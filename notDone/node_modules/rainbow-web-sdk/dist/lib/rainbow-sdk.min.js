!function(e){function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}var t={};n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(n){return e[n]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=156)}([function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @class\n * @name Call\n * @description\n *      This class represents a call. <br>\n *\t\tA call is a "short" interaction between the user and one or several contacts (Rainbow users or not) that uses either a WebRTC media (audio, video or screen sharing) or a Telephony media (PBX phone). <br>\n *\t\tNo Rainbow users such as external users can only be engaged into a Telephony call. <br>\n *\t\tA call is always attached to a conversation.\n */\nclass Call {\n    constructor(status, id, type, contact) {\n        /**\n         * @private\n         * @property {Boolean} isVm Indicates whether it is a call to user\'s own voicemail\n         * @readonly\n         */\n        this.isVm = false;\n        /**\n         * @public\n         * @property {Number} remoteMedia The media used by the recipient (e.g. audio, video, sharing, phone)\n         * @readonly\n         */\n        this.remoteMedia = 0;\n        /**\n         * @public\n         * @property {Number} localMedia The media used by the user (e.g. audio, video, sharing, phone)\n         * @readonly\n         */\n        this.localMedia = 0;\n        /**\n         * @public\n         * @property {Boolean} isEscalated True if the call has been escalated to sharing or video (only relevant for WebRTC calls)\n         * @readonly\n         */\n        this.isEscalated = false;\n        /**\n         * @public\n         * @property {Date} startDate The date when the call has been started\n         * @readonly\n         */\n        this.startDate = new Date();\n        /**\n         * @public\n         * @property {Boolean} isInitiator True if the user is the caller (false if he\'s the called)\n         * @readonly\n         */\n        this.isInitiator = false;\n        /**\n         * @public\n         * @property {Contact[]} participants The list of participants in the call (conference)\n         * @readonly\n         */\n        this.participants = null;\n        /**\n         * @public\n         * @property {Boolean} isRemoteVideoMuted True if the webRTC video has been muted by the recipient (only relevant for WebRTC calls)\n         * @readonly\n         */\n        this.isRemoteVideoMuted = false;\n        /**\n         * @public\n         * @since 1.20\n         * @property {Boolean} isConference True if the call is a conferenceCall\n         * @readonly\n         */\n        this.isConference = false;\n        /**\n         * @private\n         * @property {String} subject when receiving incoming call with subject (inside propose)\n         * @readonly\n         */\n        this.subject = undefined;\n        /**\n         * @private\n         * @property {Object}  currentCalled contains current called number and contact\n         * @readonly\n         */\n        this.currentCalled = {\n            contactPhoneNumber: "",\n            contact: null,\n            participantsPhoneNumbers: [],\n            participants: [],\n        };\n        /**\n         * @private\n         * @property {String}  fullJid the full jid of the user in the call\n         * @readonly\n         */\n        this.fullJid = "";\n        /**\n         * @private\n         * @property {object} mediaPillarCall specific media Pillar context\n         * @readonly\n         */\n        this.mediaPillarCall = null;\n        /**\n         * @private\n         * @property {object} isSecondary is nomadic secondary phone selected\n         * @readonly\n         */\n        this.isSecondary = false;\n        /**\n         * @private\n         * @property {object} relevant is this call relevant for rainbow (use in nomadic and MP multidevice cases)\n         * @readonly\n         */\n        this.relevant = true;\n        /**\n         * @private\n         * @property {string} relevantEquipmentId is this call relevant equipment identifier for rainbow (use in nomadic and MP multidevice cases)\n         * @readonly\n         */\n        this.relevantEquipmentId = "unknown";\n        /**\n         * @private\n         * @property {object}  deviceId used Only for sipWise case\n         * @readonly\n         */\n        this.deviceId = null; //sipWise+\n        /**\n         * @private\n         * @property {object} isOwner is this call owned by my device (used in calls made by makecall; may also be used later for incoming calls\n         *  taken by webclient)\n         */\n        this.isOwner = undefined;\n        /**\n         * @private\n         * @property {object} pbxConnectionDown indicates wether the telephony connection to server/pbx is down : used to handle mediapillar calls\n         * during a pbx agent shutdown\n         */\n        this.pbxConnectionDown = undefined;\n        /**\n         * @public\n         * @since 2.0.0\n         * @property {Boolean} isMuted True if the call is locally muted\n         * @readonly\n         */\n        this.isMuted = false;\n        /**\n         * @public\n         * @since 2.0.0\n         * @property {Number} duration Duration of the call in seconds\n         * @readonly\n         */\n        this.duration = 0;\n        this.unifiedPlanActivated = false;\n        this.status = status;\n        this.id = id;\n        this.type = type;\n        this.contact = contact;\n        this.avatars = (contact && contact.avatar) ? [this.contact.avatar.src] : [];\n        this.currentCalled = { contactPhoneNumber: "", contact: null, participantsPhoneNumbers: [], participants: [] };\n    }\n    // Static factories\n    static create(status, id, type, contact) {\n        return new Call(status, id, type, contact);\n    }\n    setCallId(id) { this.id = id; }\n    ;\n    setConversationId(conversationId) { this.conversationId = conversationId; }\n    ;\n    setStatus(status) { this.status = status; }\n    setType(type) { this.type = type; }\n    setIsVm(isVM) { this.isVm = isVM; }\n    setContact(contact) { this.contact = contact; this.avatars = [this.contact.avatar.src]; }\n    startDuration() { if (this.duration)\n        return; }\n    ;\n    getCurrentCalled() { return this.currentCalled; }\n    ;\n    setSubject(subject) { this.subject = subject; }\n    setCurrentCalledContactNumber(number) { this.currentCalled.contactPhoneNumber = number; }\n    setRelevantEquipmentId(relevantEquipmentId) { this.relevantEquipmentId = relevantEquipmentId; }\n    setParticipants(participants) {\n        this.participants = participants;\n        this.avatars = [];\n        var that = this;\n        this.participants.forEach((participant) => { this.avatars.push(participant.avatar.src); });\n    }\n    setConnectionId(connectionId) {\n        this.connectionId = connectionId;\n        this.id = Call.getIdFromConnectionId(connectionId);\n    }\n    isInConversationWithMobile() {\n        if (!this.fullJid) {\n            return false;\n        }\n        return (this.fullJid.indexOf("mobile_android") !== -1 || this.fullJid.indexOf("mobile_ios") !== -1);\n    }\n    setCurrentCalled(currentCalled) {\n        if (!currentCalled) {\n            this.currentCalled.contactPhoneNumber = "";\n            this.currentCalled.contact = null;\n            this.currentCalled.participantsPhoneNumbers = null;\n            this.currentCalled.participants = null;\n        }\n        else {\n            // Simple call case\n            if (this.contact && this.contact.id) {\n                this.currentCalled.contactPhoneNumber = (currentCalled.contactPhoneNumber && currentCalled.contactPhoneNumber !== "") ? currentCalled.contactPhoneNumber : "";\n                this.currentCalled.contact = currentCalled.contact ? currentCalled.contact : null;\n                this.currentCalled.participantsPhoneNumbers = null;\n                this.currentCalled.participants = null;\n            }\n            // Conference case \n            else {\n                this.currentCalled.contactPhoneNumber = "";\n                this.currentCalled.contact = null;\n                this.currentCalled.participantsPhoneNumbers = (currentCalled.participantsPhoneNumbers && currentCalled.participantsPhoneNumbers.length > 0) ? currentCalled.participantsPhoneNumbers : null;\n                this.currentCalled.participants = (currentCalled.participants && currentCalled.participants.length > 0) ? currentCalled.participants : null;\n            }\n        }\n    }\n    /*********************************************************/\n    /**                  TELEPHONY STUFF                     */\n    /*********************************************************/\n    static getIdFromConnectionId(connectionId) { return connectionId; }\n    static getCallIdFromConnectionId(connectionId) { return connectionId ? connectionId.split("#")[0] : null; }\n    static getDeviceIdFromConnectionId(connectionId) {\n        var deviceId = connectionId ? connectionId.split("#")[1] : null;\n        return deviceId ? deviceId : null;\n    }\n    /*********************************************************/\n    /**                  MEDIA PILLAR STUFF                  */\n    /*********************************************************/\n    /**\n     * Method isMediaPillarCall\n     * check if the call is linked to a media pillar context\n     * note: if it is a new call not already managed through webrtcGatewayService then not conclusive\n     * (because could be linked after)\n     */\n    isMediaPillarCall() { return (this.mediaPillarCall !== null); }\n    getMediaPillarCall() { return this.mediaPillarCall; }\n    ;\n    setMediaPillarCall(mediaPillarCallContext) { this.mediaPillarCall = (mediaPillarCallContext) ? mediaPillarCallContext : null; }\n    /*********************************************************/\n    /**                  TELEPHONY SIPWISE STUFF             */\n    /*********************************************************/\n    setDeviceIdSipWise(deviceId) {\n        this.deviceId = deviceId ? deviceId : null;\n    }\n    getDeviceIdSipWise() {\n        return this.deviceId;\n    }\n    setConnectionIdSipWise(connectionId) {\n        //this.id not equal to this.connectionId\n        this.connectionId = connectionId;\n    }\n    getDeviceIdFromConnectionIdFromCall() {\n        //for the moment only for sipWise case\n        if (this.deviceId) {\n            return this.deviceId;\n        }\n        //else former way\n        return this.connectionId ? this.connectionId.split("#")[1] : null; //not sip case\n    }\n    /********************************************************/\n    /**                  OTHERS                             */\n    /********************************************************/\n    toString() { return "(type:" + this.type.value + ", id:" + this.id + ", status:" + this.status.value; }\n    isInCallWithMediaPillar() { return (this.fullJid && this.fullJid.indexOf("mp_") !== -1); }\n}\n/**\n * @public\n * @readonly\n * @enum {Object}\n */\nCall.Status = {\n    /** Call cleared */\n    UNKNOWN: { key: 0, value: "Unknown" },\n    /** In dialing */\n    DIALING: { key: 1, value: "dialing" },\n    /** In queue (user side) */\n    QUEUED_INCOMMING: { key: 2, value: "queuedIncomming" },\n    /** In queue (recipient side) */\n    QUEUED_OUTGOING: { key: 10, value: "queuedOutGoing" },\n    /** Call in ringing (user side) */\n    RINGING_INCOMMING: { key: 3, value: "incommingCall" },\n    /** Call in ringing (recipient side */\n    RINGING_OUTGOING: { key: 4, value: "ringingOutgoing" },\n    /** Active call */\n    ACTIVE: { key: 5, value: "active" },\n    /** Call in hold */\n    HOLD: { key: 6, value: "held" },\n    /** Call put on hold */\n    PUT_ON_HOLD: { key: 7, value: "putOnHold" },\n    /** Call is clearing */\n    RELEASING: { key: 8, value: "releasing" },\n    /** call is answering */\n    ANSWERING: { key: 9, value: "answering" },\n    /** trying to reconnect */\n    CONNECTING: { key: 12, value: "connecting" },\n    /** call in error */\n    ERROR: { key: 11, value: "error" }\n};\n/**\n * @public\n * @enum {Object}\n * @readonly\n */\nCall.Type = {\n    /** WebRTC call */\n    WEBRTC: { key: 1, value: "Video" },\n    /** Telephony call (from PBX) */\n    PHONE: { key: 2, value: "Phone" }\n};\n/**\n * @public\n * @enum {Object}\n * @readonly\n */\nCall.Media = {\n    /** WebRTC audio call */\n    AUDIO: 1,\n    /** WebRTC audio and video call */\n    VIDEO: 2,\n    /** Telephony call (from pbx) */\n    PHONE: 4,\n    /** WebRTC Screen sharing call */\n    SHARING: 8\n};\nexports.Call = Call;\nangular.module("rainbow").factory("Call", () => { return Call; });\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/src/models/call.model.ts?')},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse {}\n}(this, function () {\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\t    /*\n\t     * Local polyfil of Object.create\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {};\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }())\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            var r = (function (m_w) {\n\t                var m_w = m_w;\n\t                var m_z = 0x3ade68b1;\n\t                var mask = 0xffffffff;\n\n\t                return function () {\n\t                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n\t                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n\t                    var result = ((m_z << 0x10) + m_w) & mask;\n\t                    result /= 0x100000000;\n\t                    result += 0.5;\n\t                    return result * (Math.random() > .5 ? 1 : -1);\n\t                }\n\t            });\n\n\t            for (var i = 0, rcache; i < nBytes; i += 4) {\n\t                var _r = r((rcache || Math.random()) * 0x100000000);\n\n\t                rcache = _r() * 0x3ade67b7;\n\t                words.push((_r() * 0x100000000) | 0);\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                var processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/core.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(9), __webpack_require__(40), __webpack_require__(41), __webpack_require__(5), __webpack_require__(6), __webpack_require__(10), __webpack_require__(14), __webpack_require__(42), __webpack_require__(15), __webpack_require__(43), __webpack_require__(44), __webpack_require__(45), __webpack_require__(11), __webpack_require__(46), __webpack_require__(4), __webpack_require__(3), __webpack_require__(47), __webpack_require__(48), __webpack_require__(49), __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), __webpack_require__(58), __webpack_require__(59), __webpack_require__(60), __webpack_require__(61), __webpack_require__(62));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/index.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(4));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                var block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                var block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                var modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                var modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                var finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                var finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                var wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                var salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/cipher-core.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(10), __webpack_require__(11));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var MD5 = C_algo.MD5;\n\n\t    /**\n\t     * This key derivation function is meant to conform with EVP_BytesToKey.\n\t     * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n\t     */\n\t    var EvpKDF = C_algo.EvpKDF = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: MD5,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create();\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Derives a key from a password.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init hasher\n\t            var hasher = cfg.hasher.create();\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                if (block) {\n\t                    hasher.update(block);\n\t                }\n\t                var block = hasher.update(password).finalize(salt);\n\t                hasher.reset();\n\n\t                // Iterations\n\t                for (var i = 1; i < iterations; i++) {\n\t                    block = hasher.finalize(block);\n\t                    hasher.reset();\n\t                }\n\n\t                derivedKey.concat(block);\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Derives a key from a password.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.EvpKDF(password, salt);\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.EvpKDF = function (password, salt, cfg) {\n\t        return EvpKDF.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.EvpKDF;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/evpkdf.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/enc-base64.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working varialbes\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/md5.js?")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/// <reference types="node"/>\nvar int64_buffer_1 = __webpack_require__(16);\nvar EBMLEncoder_1 = __webpack_require__(17);\nvar _Buffer = __webpack_require__(12);\nvar _tools = __webpack_require__(138);\nvar _block = __webpack_require__(139);\nexports.Buffer = _Buffer.Buffer;\nexports.readVint = _tools.readVint;\nexports.writeVint = _tools.writeVint;\nexports.ebmlBlock = _block;\nfunction readBlock(buf) {\n    return exports.ebmlBlock(new exports.Buffer(buf));\n}\nexports.readBlock = readBlock;\n/**\n  * @param end - if end === false then length is unknown\n  */\nfunction encodeTag(tagId, tagData, unknownSize) {\n    if (unknownSize === void 0) { unknownSize = false; }\n    return concat([\n        tagId,\n        unknownSize ?\n            new exports.Buffer(\'01ffffffffffffff\', \'hex\') :\n            exports.writeVint(tagData.length),\n        tagData\n    ]);\n}\nexports.encodeTag = encodeTag;\n/**\n * @return - SimpleBlock to WebP Filter\n */\nfunction WebPFrameFilter(elms) {\n    return WebPBlockFilter(elms).reduce(function (lst, elm) {\n        var o = exports.ebmlBlock(elm.data);\n        return o.frames.reduce(function (lst, frame) {\n            // https://developers.Blob.com/speed/webp/docs/riff_container\n            var webpBuf = VP8BitStreamToRiffWebPBuffer(frame);\n            var webp = new Blob([webpBuf], { type: "image/webp" });\n            return lst.concat(webp);\n        }, lst);\n    }, []);\n}\nexports.WebPFrameFilter = WebPFrameFilter;\n/**\n * WebP ファイルにできる SimpleBlock の パスフィルタ\n */\nfunction WebPBlockFilter(elms) {\n    return elms.reduce(function (lst, elm) {\n        if (elm.type !== "b") {\n            return lst;\n        }\n        if (elm.name !== "SimpleBlock") {\n            return lst;\n        }\n        var o = exports.ebmlBlock(elm.data);\n        var hasWebP = o.frames.some(function (frame) {\n            // https://tools.ietf.org/html/rfc6386#section-19.1\n            var startcode = frame.slice(3, 6).toString("hex");\n            return startcode === "9d012a";\n        });\n        if (!hasWebP) {\n            return lst;\n        }\n        return lst.concat(elm);\n    }, []);\n}\nexports.WebPBlockFilter = WebPBlockFilter;\n/**\n * @param frame - VP8 BitStream のうち startcode をもつ frame\n * @return - WebP ファイルの ArrayBuffer\n */\nfunction VP8BitStreamToRiffWebPBuffer(frame) {\n    var VP8Chunk = createRIFFChunk("VP8 ", frame);\n    var WebPChunk = concat([\n        new exports.Buffer("WEBP", "ascii"),\n        VP8Chunk\n    ]);\n    return createRIFFChunk("RIFF", WebPChunk);\n}\nexports.VP8BitStreamToRiffWebPBuffer = VP8BitStreamToRiffWebPBuffer;\n/**\n * RIFF データチャンクを作る\n */\nfunction createRIFFChunk(FourCC, chunk) {\n    var chunkSize = new exports.Buffer(4);\n    chunkSize.writeUInt32LE(chunk.byteLength, 0);\n    return concat([\n        new exports.Buffer(FourCC.substr(0, 4), "ascii"),\n        chunkSize,\n        chunk,\n        new exports.Buffer(chunk.byteLength % 2 === 0 ? 0 : 1) // padding\n    ]);\n}\nexports.createRIFFChunk = createRIFFChunk;\n/* Original Metadata\n\n m  0\tEBML\n u  1\t  EBMLVersion 1\n u  1\t  EBMLReadVersion 1\n u  1\t  EBMLMaxIDLength 4\n u  1\t  EBMLMaxSizeLength 8\n s  1\t  DocType webm\n u  1\t  DocTypeVersion 4\n u  1\t  DocTypeReadVersion 2\n m  0\tSegment\n m  1\t  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted\n u  2\t    TimecodeScale 1000000\n 8  2\t    MuxingApp Chrome\n 8  2\t    WritingApp Chrome\n m  1\t  Tracks                              tracksStartPos\n m  2\t    TrackEntry\n u  3\t      TrackNumber 1\n u  3\t      TrackUID 31790271978391090\n u  3\t      TrackType 2\n s  3\t      CodecID A_OPUS\n b  3\t      CodecPrivate <Buffer 19>\n m  3\t      Audio\n f  4\t        SamplingFrequency 48000\n u  4\t        Channels 1\n m  2\t    TrackEntry\n u  3\t      TrackNumber 2\n u  3\t      TrackUID 24051277436254136\n u  3\t      TrackType 1\n s  3\t      CodecID V_VP8\n m  3\t      Video\n u  4\t        PixelWidth 1024\n u  4\t        PixelHeight 576\n m  1\t  Cluster                             clusterStartPos\n u  2\t    Timecode 0\n b  2\t    SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/* Desired Metadata\n\n m\t0 EBML\n u\t1   EBMLVersion 1\n u\t1   EBMLReadVersion 1\n u\t1   EBMLMaxIDLength 4\n u\t1   EBMLMaxSizeLength 8\n s\t1   DocType webm\n u\t1   DocTypeVersion 4\n u\t1   DocTypeReadVersion 2\n m\t0 Segment\n m\t1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info\n u\t3       SeekPosition                    -> infoStartPos =\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks\n u\t3       SeekPosition { tracksStartPos }\n m\t2     Seek\n b\t3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues\n u\t3       SeekPosition { cuesStartPos }\n m\t1   Info\n f\t2     Duration 32480                    -> overwrite, or insert if it doesn\'t exist\n u\t2     TimecodeScale 1000000\n 8\t2     MuxingApp Chrome\n 8\t2     WritingApp Chrome\n m\t1   Tracks\n m\t2     TrackEntry\n u\t3       TrackNumber 1\n u\t3       TrackUID 31790271978391090\n u\t3       TrackType 2\n s\t3       CodecID A_OPUS\n b\t3       CodecPrivate <Buffer 19>\n m\t3       Audio\n f\t4         SamplingFrequency 48000\n u\t4         Channels 1\n m\t2     TrackEntry\n u\t3       TrackNumber 2\n u\t3       TrackUID 24051277436254136\n u\t3       TrackType 1\n s\t3       CodecID V_VP8\n m\t3       Video\n u\t4         PixelWidth 1024\n u\t4         PixelHeight 576\n m  1   Cues                                -> cuesStartPos\n m  2     CuePoint\n u  3       CueTime 0\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  2     CuePoint\n u  3       CueTime 600\n m  3       CueTrackPositions\n u  4         CueTrack 1\n u  4         CueClusterPosition 3911\n m  1   Cluster\n u  2     Timecode 0\n b  2     SimpleBlock track:2 timecode:0\tkeyframe:true\tinvisible:false\tdiscardable:false\tlacing:1\n*/\n/**\n * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues\n * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n */\nfunction makeMetadataSeekable(originalMetadata, duration, cuesInfo) {\n    // extract the header, we can reuse this as-is\n    var header = extractElement("EBML", originalMetadata);\n    var headerSize = encodedSizeOfEbml(header);\n    //console.error("Header size: " + headerSize);\n    //printElementIds(header);\n    // After the header comes the Segment open tag, which in this implementation is always 12 bytes (4 byte id, 8 byte \'unknown length\')\n    // After that the segment content starts. All SeekPositions and CueClusterPosition must be relative to segmentContentStartPos\n    var segmentContentStartPos = headerSize + 12;\n    //console.error("segmentContentStartPos: " + segmentContentStartPos);    \n    // find the original metadata size, and adjust it for header size and Segment start element so we can keep all positions relative to segmentContentStartPos\n    var originalMetadataSize = originalMetadata[originalMetadata.length - 1].dataEnd - segmentContentStartPos;\n    //console.error("Original Metadata size: " + originalMetadataSize);\n    //printElementIds(originalMetadata);\n    // extract the segment info, remove the potentially existing Duration element, and add our own one.\n    var info = extractElement("Info", originalMetadata);\n    removeElement("Duration", info);\n    info.splice(1, 0, { name: "Duration", type: "f", data: createFloatBuffer(duration, 8) });\n    var infoSize = encodedSizeOfEbml(info);\n    //console.error("Info size: " + infoSize);\n    //printElementIds(info);  \n    // extract the track info, we can re-use this as is\n    var tracks = extractElement("Tracks", originalMetadata);\n    var tracksSize = encodedSizeOfEbml(tracks);\n    //console.error("Tracks size: " + tracksSize);\n    //printElementIds(tracks);  \n    var seekHeadSize = 47; // Initial best guess, but could be slightly larger if the Cues element is huge.\n    var seekHead = [];\n    var cuesSize = 5 + cuesInfo.length * 15; // very rough initial approximation, depends a lot on file size and number of CuePoints                   \n    var cues = [];\n    var lastSizeDifference = -1; // \n    // The size of SeekHead and Cues elements depends on how many bytes the offsets values can be encoded in.\n    // The actual offsets in CueClusterPosition depend on the final size of the SeekHead and Cues elements\n    // We need to iteratively converge to a stable solution.\n    var maxIterations = 10;\n    var _loop_1 = function (i) {\n        // SeekHead starts at 0\n        var infoStart = seekHeadSize; // Info comes directly after SeekHead\n        var tracksStart = infoStart + infoSize; // Tracks comes directly after Info\n        var cuesStart = tracksStart + tracksSize; // Cues starts directly after \n        var newMetadataSize = cuesStart + cuesSize; // total size of metadata  \n        // This is the offset all CueClusterPositions should be adjusted by due to the metadata size changing.\n        var sizeDifference = newMetadataSize - originalMetadataSize;\n        // console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);\n        // console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);\n        // console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);\n        // console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`); \n        // create the SeekHead element\n        seekHead = [];\n        seekHead.push({ name: "SeekHead", type: "m", isEnd: false });\n        seekHead.push({ name: "Seek", type: "m", isEnd: false });\n        seekHead.push({ name: "SeekID", type: "b", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) }); // Info\n        seekHead.push({ name: "SeekPosition", type: "u", data: createUIntBuffer(infoStart) });\n        seekHead.push({ name: "Seek", type: "m", isEnd: true });\n        seekHead.push({ name: "Seek", type: "m", isEnd: false });\n        seekHead.push({ name: "SeekID", type: "b", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) }); // Tracks\n        seekHead.push({ name: "SeekPosition", type: "u", data: createUIntBuffer(tracksStart) });\n        seekHead.push({ name: "Seek", type: "m", isEnd: true });\n        seekHead.push({ name: "Seek", type: "m", isEnd: false });\n        seekHead.push({ name: "SeekID", type: "b", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) }); // Cues\n        seekHead.push({ name: "SeekPosition", type: "u", data: createUIntBuffer(cuesStart) });\n        seekHead.push({ name: "Seek", type: "m", isEnd: true });\n        seekHead.push({ name: "SeekHead", type: "m", isEnd: true });\n        seekHeadSize = encodedSizeOfEbml(seekHead);\n        //console.error("SeekHead size: " + seekHeadSize);\n        //printElementIds(seekHead);  \n        // create the Cues element\n        cues = [];\n        cues.push({ name: "Cues", type: "m", isEnd: false });\n        cuesInfo.forEach(function (_a) {\n            var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n            cues.push({ name: "CuePoint", type: "m", isEnd: false });\n            cues.push({ name: "CueTime", type: "u", data: createUIntBuffer(CueTime) });\n            cues.push({ name: "CueTrackPositions", type: "m", isEnd: false });\n            cues.push({ name: "CueTrack", type: "u", data: createUIntBuffer(CueTrack) });\n            //console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);\n            // EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.\n            CueClusterPosition -= segmentContentStartPos;\n            // We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.\n            CueClusterPosition += sizeDifference;\n            cues.push({ name: "CueClusterPosition", type: "u", data: createUIntBuffer(CueClusterPosition) });\n            cues.push({ name: "CueTrackPositions", type: "m", isEnd: true });\n            cues.push({ name: "CuePoint", type: "m", isEnd: true });\n        });\n        cues.push({ name: "Cues", type: "m", isEnd: true });\n        cuesSize = encodedSizeOfEbml(cues);\n        //console.error("Cues size: " + cuesSize);   \n        //console.error("Cue count: " + cuesInfo.length);\n        //printElementIds(cues);      \n        // If the new MetadataSize is not the same as the previous iteration, we need to run once more.\n        if (lastSizeDifference !== sizeDifference) {\n            lastSizeDifference = sizeDifference;\n            if (i === maxIterations - 1) {\n                throw new Error("Failed to converge to a stable metadata size");\n            }\n        }\n        else {\n            return "break";\n        }\n    };\n    for (var i = 0; i < maxIterations; i++) {\n        var state_1 = _loop_1(i);\n        if (state_1 === "break")\n            break;\n    }\n    var finalMetadata = [].concat.apply([], [\n        header,\n        { name: "Segment", type: "m", isEnd: false, unknownSize: true },\n        seekHead,\n        info,\n        tracks,\n        cues\n    ]);\n    var result = new EBMLEncoder_1.default().encode(finalMetadata);\n    //printElementIds(finalMetadata);\n    //console.error(`Final metadata buffer size: ${result.byteLength}`);\n    //console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);\n    return result;\n}\nexports.makeMetadataSeekable = makeMetadataSeekable;\n/**\n * print all element id names in a list\n\n * @param metadata - array of EBML elements to print\n *\nexport function printElementIds(metadata: EBML.EBMLElementBuffer[]) {\n\n  let result: EBML.EBMLElementBuffer[] = [];\n  let start: number = -1;\n\n  for (let i = 0; i < metadata.length; i++) {\n    console.error("\\t id: " + metadata[i].name);\n  }\n}\n*/\n/**\n * remove all occurances of an EBML element from an array of elements\n * If it\'s a MasterElement you will also remove the content. (everything between start and end)\n * @param idName - name of the EBML Element to remove.\n * @param metadata - array of EBML elements to search\n */\nfunction removeElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it\'s a Master element, extract the start and end element, and everything in between\n            if (element.type === "m") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we\'ve reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error("Detected " + idName + " closing element before finding the start");\n                    metadata.splice(start, i - start + 1);\n                    return;\n                }\n            }\n            else {\n                // not a Master element, so we\'ve found what we\'re looking for.\n                metadata.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\nexports.removeElement = removeElement;\n/**\n * extract the first occurance of an EBML tag from a flattened array of EBML data.\n * If it\'s a MasterElement you will also get the content. (everything between start and end)\n * @param idName - name of the EBML Element to extract.\n * @param metadata - array of EBML elements to search\n */\nfunction extractElement(idName, metadata) {\n    var result = [];\n    var start = -1;\n    for (var i = 0; i < metadata.length; i++) {\n        var element = metadata[i];\n        if (element.name === idName) {\n            // if it\'s a Master element, extract the start and end element, and everything in between\n            if (element.type === "m") {\n                if (!element.isEnd) {\n                    start = i;\n                }\n                else {\n                    // we\'ve reached the end, extract the whole thing\n                    if (start == -1)\n                        throw new Error("Detected " + idName + " closing element before finding the start");\n                    result = metadata.slice(start, i + 1);\n                    break;\n                }\n            }\n            else {\n                // not a Master element, so we\'ve found what we\'re looking for.\n                result.push(metadata[i]);\n                break;\n            }\n        }\n    }\n    return result;\n}\nexports.extractElement = extractElement;\n/**\n * @deprecated\n * metadata に対して duration と seekhead を追加した metadata を返す\n * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素\n * @param duration - Duration (TimecodeScale)\n * @param cues - cue points for clusters\n * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer\n * @deprecated @param cueInfos - please use cues.\n */\nfunction putRefinedMetaData(metadata, info) {\n    if (Array.isArray(info.cueInfos) && !Array.isArray(info.cues)) {\n        console.warn("putRefinedMetaData: info.cueInfos property is deprecated. please use info.cues");\n        info.cues = info.cueInfos;\n    }\n    var ebml = [];\n    var payload = [];\n    for (var i_1 = 0; i_1 < metadata.length; i_1++) {\n        var elm = metadata[i_1];\n        if (elm.type === "m" && elm.name === "Segment") {\n            ebml = metadata.slice(0, i_1);\n            payload = metadata.slice(i_1);\n            if (elm.unknownSize) {\n                payload.shift(); // remove segment tag\n                break;\n            }\n            throw new Error("this metadata is not streaming webm file");\n        }\n    }\n    // *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd\n    // |     |     |   |        |     |                              |\n    // [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]\n    // |               |        |^inf |                              |\n    // |               +segmentSiz(12)+                              |\n    // +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+\n    //                 |        |     +-newPayloadSize(??)-------------------------+\n    //                 |        |     |                                            |\n    //                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]\n    //                           ^                                                 |\n    //                           |                                                 *??=newPayloadOffsetEnd\n    //                           inf\n    if (!(payload[payload.length - 1].dataEnd > 0)) {\n        throw new Error("metadata dataEnd has wrong number");\n    }\n    var originalPayloadOffsetEnd = payload[payload.length - 1].dataEnd; // = first cluster ptr\n    var ebmlSize = ebml[ebml.length - 1].dataEnd; // = first segment ptr\n    var refinedEBMLSize = new EBMLEncoder_1.default().encode(ebml).byteLength;\n    var offsetDiff = refinedEBMLSize - ebmlSize;\n    var payloadSize = originalPayloadOffsetEnd - payload[0].tagStart;\n    var segmentSize = payload[0].tagStart - ebmlSize;\n    var segmentOffset = payload[0].tagStart;\n    var segmentTagBuf = new exports.Buffer([0x18, 0x53, 0x80, 0x67]); // Segment\n    var segmentSizeBuf = new exports.Buffer(\'01ffffffffffffff\', \'hex\'); // Segmentの最後の位置は無数の Cluster 依存なので。 writeVint(newPayloadSize).byteLength ではなく、 infinity.\n    var _segmentSize = segmentTagBuf.byteLength + segmentSizeBuf.byteLength; // == segmentSize\n    var newPayloadSize = payloadSize;\n    // We need the size to be stable between two refinements in order for our offsets to be correct\n    // Bound the number of possible refinements so we can\'t go infinate if something goes wrong\n    var i;\n    for (i = 1; i < 20; i++) {\n        var newPayloadOffsetEnd = ebmlSize + _segmentSize + newPayloadSize;\n        var offsetEndDiff = newPayloadOffsetEnd - originalPayloadOffsetEnd;\n        var sizeDiff = offsetDiff + offsetEndDiff;\n        var refined = refineMetadata(payload, sizeDiff, info);\n        var newNewRefinedSize = new EBMLEncoder_1.default().encode(refined).byteLength; // 一旦 seekhead を作って自身のサイズを調べる\n        if (newNewRefinedSize === newPayloadSize) {\n            // Size is stable\n            return new EBMLEncoder_1.default().encode([].concat(ebml, [{ type: "m", name: "Segment", isEnd: false, unknownSize: true }], refined));\n        }\n        newPayloadSize = newNewRefinedSize;\n    }\n    throw new Error("unable to refine metadata, stable size could not be found in " + i + " iterations!");\n}\nexports.putRefinedMetaData = putRefinedMetaData;\n// Given a list of EBMLElementBuffers, returns their encoded size in bytes\nfunction encodedSizeOfEbml(refinedMetaData) {\n    var encorder = new EBMLEncoder_1.default();\n    return refinedMetaData.reduce(function (lst, elm) { return lst.concat(encorder.encode([elm])); }, []).reduce(function (o, buf) { return o + buf.byteLength; }, 0);\n}\nfunction refineMetadata(mesetadata, sizeDiff, info) {\n    var duration = info.duration, clusterPtrs = info.clusterPtrs, cues = info.cues;\n    var _metadata = mesetadata.slice(0);\n    if (typeof duration === "number") {\n        // duration を追加する\n        var overwrited_1 = false;\n        _metadata.forEach(function (elm) {\n            if (elm.type === "f" && elm.name === "Duration") {\n                overwrited_1 = true;\n                elm.data = createFloatBuffer(duration, 8);\n            }\n        });\n        if (!overwrited_1) {\n            insertTag(_metadata, "Info", [{ name: "Duration", type: "f", data: createFloatBuffer(duration, 8) }]);\n        }\n    }\n    if (Array.isArray(cues)) {\n        insertTag(_metadata, "Cues", create_cue(cues, sizeDiff));\n    }\n    var seekhead_children = [];\n    if (Array.isArray(clusterPtrs)) {\n        console.warn("append cluster pointers to seekhead is deprecated. please use cues");\n        seekhead_children = create_seek_from_clusters(clusterPtrs, sizeDiff);\n    }\n    // remove seek info\n    /*\n    _metadata = _metadata.filter((elm)=> !(\n      elm.name === "Seek" ||\n      elm.name === "SeekID" ||\n      elm.name === "SeekPosition") );\n    */\n    // working on progress\n    //seekhead_children = seekhead_children.concat(create_seekhead(_metadata));\n    insertTag(_metadata, "SeekHead", seekhead_children, true);\n    return _metadata;\n}\nfunction create_seekhead(metadata, sizeDiff) {\n    var seeks = [];\n    ["Info", "Tracks", "Cues"].forEach(function (tagName) {\n        var tagStarts = metadata.filter(function (elm) { return elm.type === "m" && elm.name === tagName && elm.isEnd === false; }).map(function (elm) { return elm["tagStart"]; });\n        var tagStart = tagStarts[0];\n        if (typeof tagStart !== "number") {\n            return;\n        }\n        seeks.push({ name: "Seek", type: "m", isEnd: false });\n        switch (tagName) {\n            case "Info":\n                seeks.push({ name: "SeekID", type: "b", data: new exports.Buffer([0x15, 0x49, 0xA9, 0x66]) });\n                break;\n            case "Tracks":\n                seeks.push({ name: "SeekID", type: "b", data: new exports.Buffer([0x16, 0x54, 0xAE, 0x6B]) });\n                break;\n            case "Cues":\n                seeks.push({ name: "SeekID", type: "b", data: new exports.Buffer([0x1C, 0x53, 0xBB, 0x6B]) });\n                break;\n        }\n        seeks.push({ name: "SeekPosition", type: "u", data: createUIntBuffer(tagStart + sizeDiff) });\n        seeks.push({ name: "Seek", type: "m", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_seek_from_clusters(clusterPtrs, sizeDiff) {\n    var seeks = [];\n    clusterPtrs.forEach(function (start) {\n        seeks.push({ name: "Seek", type: "m", isEnd: false });\n        // [0x1F, 0x43, 0xB6, 0x75] で Cluster 意\n        seeks.push({ name: "SeekID", type: "b", data: new exports.Buffer([0x1F, 0x43, 0xB6, 0x75]) });\n        seeks.push({ name: "SeekPosition", type: "u", data: createUIntBuffer(start + sizeDiff) });\n        seeks.push({ name: "Seek", type: "m", isEnd: true });\n    });\n    return seeks;\n}\nfunction create_cue(cueInfos, sizeDiff) {\n    var cues = [];\n    cueInfos.forEach(function (_a) {\n        var CueTrack = _a.CueTrack, CueClusterPosition = _a.CueClusterPosition, CueTime = _a.CueTime;\n        cues.push({ name: "CuePoint", type: "m", isEnd: false });\n        cues.push({ name: "CueTime", type: "u", data: createUIntBuffer(CueTime) });\n        cues.push({ name: "CueTrackPositions", type: "m", isEnd: false });\n        cues.push({ name: "CueTrack", type: "u", data: createUIntBuffer(CueTrack) }); // video track\n        cues.push({ name: "CueClusterPosition", type: "u", data: createUIntBuffer(CueClusterPosition + sizeDiff) });\n        cues.push({ name: "CueTrackPositions", type: "m", isEnd: true });\n        cues.push({ name: "CuePoint", type: "m", isEnd: true });\n    });\n    return cues;\n}\nfunction insertTag(_metadata, tagName, children, insertHead) {\n    if (insertHead === void 0) { insertHead = false; }\n    // find the tagname from _metadata\n    var idx = -1;\n    for (var i = 0; i < _metadata.length; i++) {\n        var elm = _metadata[i];\n        if (elm.type === "m" && elm.name === tagName && elm.isEnd === false) {\n            idx = i;\n            break;\n        }\n    }\n    if (idx >= 0) {\n        // insert [<CuePoint />] to <Cues />\n        Array.prototype.splice.apply(_metadata, [idx + 1, 0].concat(children));\n    }\n    else if (insertHead) {\n        [].concat([{ name: tagName, type: "m", isEnd: false }], children, [{ name: tagName, type: "m", isEnd: true }]).reverse().forEach(function (elm) { _metadata.unshift(elm); });\n    }\n    else {\n        // metadata 末尾に <Cues /> を追加\n        // insert <Cues />\n        _metadata.push({ name: tagName, type: "m", isEnd: false });\n        children.forEach(function (elm) { _metadata.push(elm); });\n        _metadata.push({ name: tagName, type: "m", isEnd: true });\n    }\n}\n// alter Buffer.concat - https://github.com/feross/buffer/issues/154\nfunction concat(list) {\n    //return Buffer.concat.apply(Buffer, list);\n    var i = 0;\n    var length = 0;\n    for (; i < list.length; ++i) {\n        length += list[i].length;\n    }\n    var buffer = exports.Buffer.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n}\nexports.concat = concat;\nfunction encodeValueToBuffer(elm) {\n    var data = new exports.Buffer(0);\n    if (elm.type === "m") {\n        return elm;\n    }\n    switch (elm.type) {\n        case "u":\n            data = createUIntBuffer(elm.value);\n            break;\n        case "i":\n            data = createIntBuffer(elm.value);\n            break;\n        case "f":\n            data = createFloatBuffer(elm.value);\n            break;\n        case "s":\n            data = new exports.Buffer(elm.value, \'ascii\');\n            break;\n        case "8":\n            data = new exports.Buffer(elm.value, \'utf8\');\n            break;\n        case "b":\n            data = elm.value;\n            break;\n        case "d":\n            data = new int64_buffer_1.Int64BE(elm.value.getTime().toString()).toBuffer();\n            break;\n    }\n    return Object.assign({}, elm, { data: data });\n}\nexports.encodeValueToBuffer = encodeValueToBuffer;\nfunction createUIntBuffer(value) {\n    // Big-endian, any size from 1 to 8\n    // but js number is float64, so max 6 bit octets\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn("7bit or more bigger uint not supported.");\n        return new int64_buffer_1.Uint64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeUIntBE(value, 0, bytes);\n    return data;\n}\nexports.createUIntBuffer = createUIntBuffer;\nfunction createIntBuffer(value) {\n    // Big-endian, any size from 1 to 8 octets\n    // but js number is float64, so max 6 bit\n    var bytes = 1;\n    for (; value >= Math.pow(2, 8 * bytes); bytes++) { }\n    if (bytes >= 7) {\n        console.warn("7bit or more bigger uint not supported.");\n        return new int64_buffer_1.Int64BE(value).toBuffer();\n    }\n    var data = new exports.Buffer(bytes);\n    data.writeIntBE(value, 0, bytes);\n    return data;\n}\nexports.createIntBuffer = createIntBuffer;\nfunction createFloatBuffer(value, bytes) {\n    if (bytes === void 0) { bytes = 8; }\n    // Big-endian, defined for 4 and 8 octets (32, 64 bits)\n    // js number is float64 so 8 bytes.\n    if (bytes === 8) {\n        // 64bit\n        var data = new exports.Buffer(8);\n        data.writeDoubleBE(value, 0);\n        return data;\n    }\n    else if (bytes === 4) {\n        // 32bit\n        var data = new exports.Buffer(4);\n        data.writeFloatBE(value, 0);\n        return data;\n    }\n    else {\n        throw new Error("float type bits must 4bytes or 8bytes");\n    }\n}\nexports.createFloatBuffer = createFloatBuffer;\nfunction convertEBMLDateToJSDate(int64str) {\n    if (int64str instanceof Date) {\n        return int64str;\n    }\n    return new Date(new Date("2001-01-01T00:00:00.000Z").getTime() + (Number(int64str) / 1000 / 1000));\n}\nexports.convertEBMLDateToJSDate = convertEBMLDateToJSDate;\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ts-ebml/lib/tools.js?')},function(module,exports,__webpack_require__){"use strict";eval(" /* eslint-env node */\n\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n          ? '/' + headerExtension.direction\n          : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\nSDPUtils.parseSsrcGroup = function(line) {\n  var parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(function(ssrc) {\n      return parseInt(ssrc, 10);\n    })\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n      'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function(line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function(line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n          mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function(extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'cname';\n  });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n  .map(function(line) {\n    var parts = line.substr(17).split(' ');\n    return parts.map(function(part) {\n      return parseInt(part, 10);\n    });\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  // Gets the first SSRC. Note tha with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n      .map(function(line) {\n        return SDPUtils.parseSsrcMedia(line);\n      })\n      .filter(function(obj) {\n        return obj.attribute === 'cname';\n      })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(msidParts) {\n    return msidParts.attribute === 'msid';\n  });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  var user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  var lines = SDPUtils.splitLines(blob);\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n\n\n//# sourceURL=webpack:///./node_modules/sdp/sdp.js?")},function(module,exports,__webpack_require__){eval(';(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var X32WordArray = C_lib.WordArray;\n\n\t    /**\n\t     * x64 namespace.\n\t     */\n\t    var C_x64 = C.x64 = {};\n\n\t    /**\n\t     * A 64-bit word.\n\t     */\n\t    var X64Word = C_x64.Word = Base.extend({\n\t        /**\n\t         * Initializes a newly created 64-bit word.\n\t         *\n\t         * @param {number} high The high 32 bits.\n\t         * @param {number} low The low 32 bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n\t         */\n\t        init: function (high, low) {\n\t            this.high = high;\n\t            this.low = low;\n\t        }\n\n\t        /**\n\t         * Bitwise NOTs this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after negating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var negated = x64Word.not();\n\t         */\n\t        // not: function () {\n\t            // var high = ~this.high;\n\t            // var low = ~this.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ANDs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to AND with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ANDing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var anded = x64Word.and(anotherX64Word);\n\t         */\n\t        // and: function (word) {\n\t            // var high = this.high & word.high;\n\t            // var low = this.low & word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to OR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var ored = x64Word.or(anotherX64Word);\n\t         */\n\t        // or: function (word) {\n\t            // var high = this.high | word.high;\n\t            // var low = this.low | word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise XORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to XOR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after XORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var xored = x64Word.xor(anotherX64Word);\n\t         */\n\t        // xor: function (word) {\n\t            // var high = this.high ^ word.high;\n\t            // var low = this.low ^ word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftL(25);\n\t         */\n\t        // shiftL: function (n) {\n\t            // if (n < 32) {\n\t                // var high = (this.high << n) | (this.low >>> (32 - n));\n\t                // var low = this.low << n;\n\t            // } else {\n\t                // var high = this.low << (n - 32);\n\t                // var low = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftR(7);\n\t         */\n\t        // shiftR: function (n) {\n\t            // if (n < 32) {\n\t                // var low = (this.low >>> n) | (this.high << (32 - n));\n\t                // var high = this.high >>> n;\n\t            // } else {\n\t                // var low = this.high >>> (n - 32);\n\t                // var high = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotL(25);\n\t         */\n\t        // rotL: function (n) {\n\t            // return this.shiftL(n).or(this.shiftR(64 - n));\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotR(7);\n\t         */\n\t        // rotR: function (n) {\n\t            // return this.shiftR(n).or(this.shiftL(64 - n));\n\t        // },\n\n\t        /**\n\t         * Adds this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to add with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after adding.\n\t         *\n\t         * @example\n\t         *\n\t         *     var added = x64Word.add(anotherX64Word);\n\t         */\n\t        // add: function (word) {\n\t            // var low = (this.low + word.low) | 0;\n\t            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;\n\t            // var high = (this.high + word.high + carry) | 0;\n\n\t            // return X64Word.create(high, low);\n\t        // }\n\t    });\n\n\t    /**\n\t     * An array of 64-bit words.\n\t     *\n\t     * @property {Array} words The array of CryptoJS.x64.Word objects.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var X64WordArray = C_x64.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create();\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ]);\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ], 10);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 8;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this 64-bit word array to a 32-bit word array.\n\t         *\n\t         * @return {CryptoJS.lib.WordArray} This word array\'s data as a 32-bit word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x32WordArray = x64WordArray.toX32();\n\t         */\n\t        toX32: function () {\n\t            // Shortcuts\n\t            var x64Words = this.words;\n\t            var x64WordsLength = x64Words.length;\n\n\t            // Convert\n\t            var x32Words = [];\n\t            for (var i = 0; i < x64WordsLength; i++) {\n\t                var x64Word = x64Words[i];\n\t                x32Words.push(x64Word.high);\n\t                x32Words.push(x64Word.low);\n\t            }\n\n\t            return X32WordArray.create(x32Words, this.sigBytes);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {X64WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = x64WordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\n\t            // Clone "words" array\n\t            var words = clone.words = this.words.slice(0);\n\n\t            // Clone each X64Word object\n\t            var wordsLength = words.length;\n\t            for (var i = 0; i < wordsLength; i++) {\n\t                words[i] = words[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\t}());\n\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/x64-core.js?')},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-1 hash algorithm.\n\t     */\n\t    var SHA1 = C_algo.SHA1 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476,\n\t                0xc3d2e1f0\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\n\t            // Computation\n\t            for (var i = 0; i < 80; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t                    W[i] = (n << 1) | (n >>> 31);\n\t                }\n\n\t                var t = ((a << 5) | (a >>> 27)) + e + W[i];\n\t                if (i < 20) {\n\t                    t += ((b & c) | (~b & d)) + 0x5a827999;\n\t                } else if (i < 40) {\n\t                    t += (b ^ c ^ d) + 0x6ed9eba1;\n\t                } else if (i < 60) {\n\t                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n\t                } else /* if (i < 80) */ {\n\t                    t += (b ^ c ^ d) - 0x359d3e2a;\n\t                }\n\n\t                e = d;\n\t                d = c;\n\t                c = (b << 30) | (b >>> 2);\n\t                b = a;\n\t                a = t;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA1('message');\n\t     *     var hash = CryptoJS.SHA1(wordArray);\n\t     */\n\t    C.SHA1 = Hasher._createHelper(SHA1);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA1(message, key);\n\t     */\n\t    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t}());\n\n\n\treturn CryptoJS.SHA1;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/sha1.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * HMAC algorithm.\n\t     */\n\t    var HMAC = C_algo.HMAC = Base.extend({\n\t        /**\n\t         * Initializes a newly created HMAC.\n\t         *\n\t         * @param {Hasher} hasher The hash algorithm to use.\n\t         * @param {WordArray|string} key The secret key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n\t         */\n\t        init: function (hasher, key) {\n\t            // Init hasher\n\t            hasher = this._hasher = new hasher.init();\n\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof key == 'string') {\n\t                key = Utf8.parse(key);\n\t            }\n\n\t            // Shortcuts\n\t            var hasherBlockSize = hasher.blockSize;\n\t            var hasherBlockSizeBytes = hasherBlockSize * 4;\n\n\t            // Allow arbitrary length keys\n\t            if (key.sigBytes > hasherBlockSizeBytes) {\n\t                key = hasher.finalize(key);\n\t            }\n\n\t            // Clamp excess bits\n\t            key.clamp();\n\n\t            // Clone key for inner and outer pads\n\t            var oKey = this._oKey = key.clone();\n\t            var iKey = this._iKey = key.clone();\n\n\t            // Shortcuts\n\t            var oKeyWords = oKey.words;\n\t            var iKeyWords = iKey.words;\n\n\t            // XOR keys with pad constants\n\t            for (var i = 0; i < hasherBlockSize; i++) {\n\t                oKeyWords[i] ^= 0x5c5c5c5c;\n\t                iKeyWords[i] ^= 0x36363636;\n\t            }\n\t            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this HMAC to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Reset\n\t            hasher.reset();\n\t            hasher.update(this._iKey);\n\t        },\n\n\t        /**\n\t         * Updates this HMAC with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {HMAC} This HMAC instance.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.update('message');\n\t         *     hmacHasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            this._hasher.update(messageUpdate);\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the HMAC computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The HMAC.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmac = hmacHasher.finalize();\n\t         *     var hmac = hmacHasher.finalize('message');\n\t         *     var hmac = hmacHasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Compute HMAC\n\t            var innerHash = hasher.finalize(messageUpdate);\n\t            hasher.reset();\n\t            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n\t            return hmac;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/hmac.js?")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(135)\nvar ieee754 = __webpack_require__(136)\nvar isArray = __webpack_require__(137)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(134)))\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/buffer/index.js?")},function(module,exports){eval('var version = "1.64.5";\nwindow.version = version;\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/config/version.js?')},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/sha256.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(9));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\n\t    function X64Word_create() {\n\t        return X64Word.create.apply(X64Word, arguments);\n\t    }\n\n\t    // Constants\n\t    var K = [\n\t        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),\n\t        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),\n\t        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),\n\t        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),\n\t        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),\n\t        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),\n\t        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),\n\t        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),\n\t        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),\n\t        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),\n\t        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),\n\t        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),\n\t        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),\n\t        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),\n\t        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),\n\t        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),\n\t        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),\n\t        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),\n\t        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),\n\t        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),\n\t        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),\n\t        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),\n\t        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),\n\t        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),\n\t        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),\n\t        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),\n\t        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),\n\t        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),\n\t        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),\n\t        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),\n\t        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),\n\t        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),\n\t        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),\n\t        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),\n\t        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),\n\t        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),\n\t        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),\n\t        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),\n\t        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),\n\t        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)\n\t    ];\n\n\t    // Reusable objects\n\t    var W = [];\n\t    (function () {\n\t        for (var i = 0; i < 80; i++) {\n\t            W[i] = X64Word_create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-512 hash algorithm.\n\t     */\n\t    var SHA512 = C_algo.SHA512 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),\n\t                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),\n\t                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),\n\t                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var H0 = H[0];\n\t            var H1 = H[1];\n\t            var H2 = H[2];\n\t            var H3 = H[3];\n\t            var H4 = H[4];\n\t            var H5 = H[5];\n\t            var H6 = H[6];\n\t            var H7 = H[7];\n\n\t            var H0h = H0.high;\n\t            var H0l = H0.low;\n\t            var H1h = H1.high;\n\t            var H1l = H1.low;\n\t            var H2h = H2.high;\n\t            var H2l = H2.low;\n\t            var H3h = H3.high;\n\t            var H3l = H3.low;\n\t            var H4h = H4.high;\n\t            var H4l = H4.low;\n\t            var H5h = H5.high;\n\t            var H5l = H5.low;\n\t            var H6h = H6.high;\n\t            var H6l = H6.low;\n\t            var H7h = H7.high;\n\t            var H7l = H7.low;\n\n\t            // Working variables\n\t            var ah = H0h;\n\t            var al = H0l;\n\t            var bh = H1h;\n\t            var bl = H1l;\n\t            var ch = H2h;\n\t            var cl = H2l;\n\t            var dh = H3h;\n\t            var dl = H3l;\n\t            var eh = H4h;\n\t            var el = H4l;\n\t            var fh = H5h;\n\t            var fl = H5l;\n\t            var gh = H6h;\n\t            var gl = H6l;\n\t            var hh = H7h;\n\t            var hl = H7l;\n\n\t            // Rounds\n\t            for (var i = 0; i < 80; i++) {\n\t                // Shortcut\n\t                var Wi = W[i];\n\n\t                // Extend message\n\t                if (i < 16) {\n\t                    var Wih = Wi.high = M[offset + i * 2]     | 0;\n\t                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;\n\t                } else {\n\t                    // Gamma0\n\t                    var gamma0x  = W[i - 15];\n\t                    var gamma0xh = gamma0x.high;\n\t                    var gamma0xl = gamma0x.low;\n\t                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);\n\t                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n\n\t                    // Gamma1\n\t                    var gamma1x  = W[i - 2];\n\t                    var gamma1xh = gamma1x.high;\n\t                    var gamma1xl = gamma1x.low;\n\t                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\n\t                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n\n\t                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n\t                    var Wi7  = W[i - 7];\n\t                    var Wi7h = Wi7.high;\n\t                    var Wi7l = Wi7.low;\n\n\t                    var Wi16  = W[i - 16];\n\t                    var Wi16h = Wi16.high;\n\t                    var Wi16l = Wi16.low;\n\n\t                    var Wil = gamma0l + Wi7l;\n\t                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n\t                    var Wil = Wil + gamma1l;\n\t                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n\t                    var Wil = Wil + Wi16l;\n\t                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n\n\t                    Wi.high = Wih;\n\t                    Wi.low  = Wil;\n\t                }\n\n\t                var chh  = (eh & fh) ^ (~eh & gh);\n\t                var chl  = (el & fl) ^ (~el & gl);\n\t                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n\t                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n\t                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n\t                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\t                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\n\t                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\n\n\t                // t1 = h + sigma1 + ch + K[i] + W[i]\n\t                var Ki  = K[i];\n\t                var Kih = Ki.high;\n\t                var Kil = Ki.low;\n\n\t                var t1l = hl + sigma1l;\n\t                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + chl;\n\t                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Kil;\n\t                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Wil;\n\t                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n\n\t                // t2 = sigma0 + maj\n\t                var t2l = sigma0l + majl;\n\t                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n\t                // Update working variables\n\t                hh = gh;\n\t                hl = gl;\n\t                gh = fh;\n\t                gl = fl;\n\t                fh = eh;\n\t                fl = el;\n\t                el = (dl + t1l) | 0;\n\t                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n\t                dh = ch;\n\t                dl = cl;\n\t                ch = bh;\n\t                cl = bl;\n\t                bh = ah;\n\t                bl = al;\n\t                al = (t1l + t2l) | 0;\n\t                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H0l = H0.low  = (H0l + al);\n\t            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\n\t            H1l = H1.low  = (H1l + bl);\n\t            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\n\t            H2l = H2.low  = (H2l + cl);\n\t            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\n\t            H3l = H3.low  = (H3l + dl);\n\t            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\n\t            H4l = H4.low  = (H4l + el);\n\t            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\n\t            H5l = H5.low  = (H5l + fl);\n\t            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\n\t            H6l = H6.low  = (H6l + gl);\n\t            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\n\t            H7l = H7.low  = (H7l + hl);\n\t            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Convert hash to 32-bit word array before returning\n\t            var hash = this._hash.toX32();\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        },\n\n\t        blockSize: 1024/32\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA512('message');\n\t     *     var hash = CryptoJS.SHA512(wordArray);\n\t     */\n\t    C.SHA512 = Hasher._createHelper(SHA512);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA512(message, key);\n\t     */\n\t    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);\n\t}());\n\n\n\treturn CryptoJS.SHA512;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/sha512.js?")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(Buffer) {// int64-buffer.js\n\n/*jshint -W018 */ // Confusing use of \'!\'.\n/*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.\n/*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?\n\nvar Uint64BE, Int64BE, Uint64LE, Int64LE;\n\n!function(exports) {\n  // constants\n\n  var UNDEFINED = "undefined";\n  var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;\n  var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;\n  var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;\n  var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];\n  var isArray = Array.isArray || _isArray;\n  var BIT32 = 4294967296;\n  var BIT24 = 16777216;\n\n  // storage class\n\n  var storage; // Array;\n\n  // generate classes\n\n  Uint64BE = factory("Uint64BE", true, true);\n  Int64BE = factory("Int64BE", true, false);\n  Uint64LE = factory("Uint64LE", false, true);\n  Int64LE = factory("Int64LE", false, false);\n\n  // class factory\n\n  function factory(name, bigendian, unsigned) {\n    var posH = bigendian ? 0 : 4;\n    var posL = bigendian ? 4 : 0;\n    var pos0 = bigendian ? 0 : 3;\n    var pos1 = bigendian ? 1 : 2;\n    var pos2 = bigendian ? 2 : 1;\n    var pos3 = bigendian ? 3 : 0;\n    var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;\n    var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;\n    var proto = Int64.prototype;\n    var isName = "is" + name;\n    var _isInt64 = "_" + isName;\n\n    // properties\n    proto.buffer = void 0;\n    proto.offset = 0;\n    proto[_isInt64] = true;\n\n    // methods\n    proto.toNumber = toNumber;\n    proto.toString = toString;\n    proto.toJSON = toNumber;\n    proto.toArray = toArray;\n\n    // add .toBuffer() method only when Buffer available\n    if (BUFFER) proto.toBuffer = toBuffer;\n\n    // add .toArrayBuffer() method only when Uint8Array available\n    if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;\n\n    // isUint64BE, isInt64BE\n    Int64[isName] = isInt64;\n\n    // CommonJS\n    exports[name] = Int64;\n\n    return Int64;\n\n    // constructor\n    function Int64(buffer, offset, value, raddix) {\n      if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);\n      return init(this, buffer, offset, value, raddix);\n    }\n\n    // isUint64BE, isInt64BE\n    function isInt64(b) {\n      return !!(b && b[_isInt64]);\n    }\n\n    // initializer\n    function init(that, buffer, offset, value, raddix) {\n      if (UINT8ARRAY && ARRAYBUFFER) {\n        if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);\n        if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);\n      }\n\n      // Int64BE() style\n      if (!buffer && !offset && !value && !storage) {\n        // shortcut to initialize with zero\n        that.buffer = newArray(ZERO, 0);\n        return;\n      }\n\n      // Int64BE(value, raddix) style\n      if (!isValidBuffer(buffer, offset)) {\n        var _storage = storage || Array;\n        raddix = offset;\n        value = buffer;\n        offset = 0;\n        buffer = new _storage(8);\n      }\n\n      that.buffer = buffer;\n      that.offset = offset |= 0;\n\n      // Int64BE(buffer, offset) style\n      if (UNDEFINED === typeof value) return;\n\n      // Int64BE(buffer, offset, value, raddix) style\n      if ("string" === typeof value) {\n        fromString(buffer, offset, value, raddix || 10);\n      } else if (isValidBuffer(value, raddix)) {\n        fromArray(buffer, offset, value, raddix);\n      } else if ("number" === typeof raddix) {\n        writeInt32(buffer, offset + posH, value); // high\n        writeInt32(buffer, offset + posL, raddix); // low\n      } else if (value > 0) {\n        fromPositive(buffer, offset, value); // positive\n      } else if (value < 0) {\n        fromNegative(buffer, offset, value); // negative\n      } else {\n        fromArray(buffer, offset, ZERO, 0); // zero, NaN and others\n      }\n    }\n\n    function fromString(buffer, offset, str, raddix) {\n      var pos = 0;\n      var len = str.length;\n      var high = 0;\n      var low = 0;\n      if (str[0] === "-") pos++;\n      var sign = pos;\n      while (pos < len) {\n        var chr = parseInt(str[pos++], raddix);\n        if (!(chr >= 0)) break; // NaN\n        low = low * raddix + chr;\n        high = high * raddix + Math.floor(low / BIT32);\n        low %= BIT32;\n      }\n      if (sign) {\n        high = ~high;\n        if (low) {\n          low = BIT32 - low;\n        } else {\n          high++;\n        }\n      }\n      writeInt32(buffer, offset + posH, high);\n      writeInt32(buffer, offset + posL, low);\n    }\n\n    function toNumber() {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      if (!unsigned) high |= 0; // a trick to get signed\n      return high ? (high * BIT32 + low) : low;\n    }\n\n    function toString(radix) {\n      var buffer = this.buffer;\n      var offset = this.offset;\n      var high = readInt32(buffer, offset + posH);\n      var low = readInt32(buffer, offset + posL);\n      var str = "";\n      var sign = !unsigned && (high & 0x80000000);\n      if (sign) {\n        high = ~high;\n        low = BIT32 - low;\n      }\n      radix = radix || 10;\n      while (1) {\n        var mod = (high % radix) * BIT32 + low;\n        high = Math.floor(high / radix);\n        low = Math.floor(mod / radix);\n        str = (mod % radix).toString(radix) + str;\n        if (!high && !low) break;\n      }\n      if (sign) {\n        str = "-" + str;\n      }\n      return str;\n    }\n\n    function writeInt32(buffer, offset, value) {\n      buffer[offset + pos3] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos2] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos1] = value & 255;\n      value = value >> 8;\n      buffer[offset + pos0] = value & 255;\n    }\n\n    function readInt32(buffer, offset) {\n      return (buffer[offset + pos0] * BIT24) +\n        (buffer[offset + pos1] << 16) +\n        (buffer[offset + pos2] << 8) +\n        buffer[offset + pos3];\n    }\n  }\n\n  function toArray(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = null; // Array\n    if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;\n    return newArray(buffer, offset);\n  }\n\n  function toBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    storage = BUFFER;\n    if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;\n    var dest = new BUFFER(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest;\n  }\n\n  function toArrayBuffer(raw) {\n    var buffer = this.buffer;\n    var offset = this.offset;\n    var arrbuf = buffer.buffer;\n    storage = UINT8ARRAY;\n    if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;\n    var dest = new UINT8ARRAY(8);\n    fromArray(dest, 0, buffer, offset);\n    return dest.buffer;\n  }\n\n  function isValidBuffer(buffer, offset) {\n    var len = buffer && buffer.length;\n    offset |= 0;\n    return len && (offset + 8 <= len) && ("string" !== typeof buffer[offset]);\n  }\n\n  function fromArray(destbuf, destoff, srcbuf, srcoff) {\n    destoff |= 0;\n    srcoff |= 0;\n    for (var i = 0; i < 8; i++) {\n      destbuf[destoff++] = srcbuf[srcoff++] & 255;\n    }\n  }\n\n  function newArray(buffer, offset) {\n    return Array.prototype.slice.call(buffer, offset, offset + 8);\n  }\n\n  function fromPositiveBE(buffer, offset, value) {\n    var pos = offset + 8;\n    while (pos > offset) {\n      buffer[--pos] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeBE(buffer, offset, value) {\n    var pos = offset + 8;\n    value++;\n    while (pos > offset) {\n      buffer[--pos] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  function fromPositiveLE(buffer, offset, value) {\n    var end = offset + 8;\n    while (offset < end) {\n      buffer[offset++] = value & 255;\n      value /= 256;\n    }\n  }\n\n  function fromNegativeLE(buffer, offset, value) {\n    var end = offset + 8;\n    value++;\n    while (offset < end) {\n      buffer[offset++] = ((-value) & 255) ^ 255;\n      value /= 256;\n    }\n  }\n\n  // https://github.com/retrofox/is-array\n  function _isArray(val) {\n    return !!val && "[object Array]" == Object.prototype.toString.call(val);\n  }\n\n}( true && typeof exports.nodeName !== \'string\' ? exports : (this || {}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12).Buffer))\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/int64-buffer/int64-buffer.js?')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar tools = __webpack_require__(7);\nvar tools_1 = __webpack_require__(7);\nvar schema = __webpack_require__(18);\nvar byEbmlID = schema.byEbmlID;\nvar EBMLEncoder = (function () {\n    function EBMLEncoder() {\n        this._schema = byEbmlID;\n        this._buffers = [];\n        this._stack = [];\n    }\n    EBMLEncoder.prototype.encode = function (elms) {\n        var _this = this;\n        return tools.concat(elms.reduce(function (lst, elm) {\n            return lst.concat(_this.encodeChunk(elm));\n        }, [])).buffer;\n    };\n    EBMLEncoder.prototype.encodeChunk = function (elm) {\n        if (elm.type === "m") {\n            if (!elm.isEnd) {\n                this.startTag(elm);\n            }\n            else {\n                this.endTag(elm);\n            }\n        }\n        else {\n            this.writeTag(elm);\n        }\n        return this.flush();\n    };\n    EBMLEncoder.prototype.flush = function () {\n        var ret = this._buffers;\n        this._buffers = [];\n        return ret;\n    };\n    EBMLEncoder.prototype.getSchemaInfo = function (tagName) {\n        var tagNums = Object.keys(this._schema).map(Number);\n        for (var i = 0; i < tagNums.length; i++) {\n            var tagNum = tagNums[i];\n            if (this._schema[tagNum].name === tagName) {\n                return new tools_1.Buffer(tagNum.toString(16), \'hex\');\n            }\n        }\n        return null;\n    };\n    EBMLEncoder.prototype.writeTag = function (elm) {\n        var tagName = elm.name;\n        var tagId = this.getSchemaInfo(tagName);\n        var tagData = elm.data;\n        if (tagId == null) {\n            throw new Error(\'No schema entry found for \' + tagName);\n        }\n        var data = tools.encodeTag(tagId, tagData);\n        /**\n         * 親要素が閉じタグあり(isEnd)なら閉じタグが来るまで待つ(children queに入る)\n         */\n        if (this._stack.length > 0) {\n            var last = this._stack[this._stack.length - 1];\n            last.children.push({\n                tagId: tagId,\n                elm: elm,\n                children: [],\n                data: data\n            });\n            return;\n        }\n        this._buffers = this._buffers.concat(data);\n        return;\n    };\n    EBMLEncoder.prototype.startTag = function (elm) {\n        var tagName = elm.name;\n        var tagId = this.getSchemaInfo(tagName);\n        if (tagId == null) {\n            throw new Error(\'No schema entry found for \' + tagName);\n        }\n        /**\n         * 閉じタグ不定長の場合はスタックに積まずに即時バッファに書き込む\n         */\n        if (elm.unknownSize) {\n            var data = tools.encodeTag(tagId, new tools_1.Buffer(0), elm.unknownSize);\n            this._buffers = this._buffers.concat(data);\n            return;\n        }\n        var tag = {\n            tagId: tagId,\n            elm: elm,\n            children: [],\n            data: null\n        };\n        if (this._stack.length > 0) {\n            this._stack[this._stack.length - 1].children.push(tag);\n        }\n        this._stack.push(tag);\n    };\n    EBMLEncoder.prototype.endTag = function (elm) {\n        var tagName = elm.name;\n        var tag = this._stack.pop();\n        if (tag == null) {\n            throw new Error("EBML structure is broken");\n        }\n        if (tag.elm.name !== elm.name) {\n            throw new Error("EBML structure is broken");\n        }\n        var childTagDataBuffers = tag.children.reduce(function (lst, child) {\n            if (child.data === null) {\n                throw new Error("EBML structure is broken");\n            }\n            return lst.concat(child.data);\n        }, []);\n        var childTagDataBuffer = tools.concat(childTagDataBuffers);\n        if (tag.elm.type === "m") {\n            tag.data = tools.encodeTag(tag.tagId, childTagDataBuffer, tag.elm.unknownSize);\n        }\n        else {\n            tag.data = tools.encodeTag(tag.tagId, childTagDataBuffer);\n        }\n        if (this._stack.length < 1) {\n            this._buffers = this._buffers.concat(tag.data);\n        }\n    };\n    return EBMLEncoder;\n}());\nexports.default = EBMLEncoder;\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ts-ebml/lib/EBMLEncoder.js?')},function(module,exports,__webpack_require__){"use strict";eval('/*jslint node: true, vars: true, nomen: true */\r\n\r\n\r\nvar byEbmlID = {\r\n\t0x80: {\r\n\t\tname: "ChapterDisplay",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\tdescription: "Contains all possible strings to use for the chapter display."\r\n\t},\r\n\t0x83: {\r\n\t\tname: "TrackType",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\trange: "1-254",\r\n\t\tdescription: "A set of track types coded on 8 bits (1: video, 2: audio, 3: complex, 0x10: logo, 0x11: subtitle, 0x12: buttons, 0x20: control)."\r\n\t},\r\n\t0x85: {\r\n\t\tname: "ChapString",\r\n\t\tcppname: "ChapterString",\r\n\t\tlevel: 5,\r\n\t\ttype: "8",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\tdescription: "Contains the string to use as the chapter atom."\r\n\t},\r\n\t0x86: {\r\n\t\tname: "CodecID",\r\n\t\tlevel: 3,\r\n\t\ttype: "s",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "An ID corresponding to the codec, see the codec page for more info."\r\n\t},\r\n\t0x88: {\r\n\t\tname: "FlagDefault",\r\n\t\tcppname: "TrackFlagDefault",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\t"default": 1,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Set if that track (audio, video or subs) SHOULD be active if no language found matches the user preference. (1 bit)"\r\n\t},\r\n\t0x89: {\r\n\t\tname: "ChapterTrackNumber",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tdescription: "UID of the Track to apply this chapter too. In the absense of a control track, choosing this chapter will select the listed Tracks and deselect unlisted tracks. Absense of this element indicates that the Chapter should be applied to any currently used Tracks."\r\n\t},\r\n\t0x91: {\r\n\t\tname: "ChapterTimeStart",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\tdescription: "Timestamp of the start of Chapter (not scaled)."\r\n\t},\r\n\t0x92: {\r\n\t\tname: "ChapterTimeEnd",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Timestamp of the end of Chapter (timestamp excluded, not scaled)."\r\n\t},\r\n\t0x96: {\r\n\t\tname: "CueRefTime",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 2,\r\n\t\twebm: false,\r\n\t\tdescription: "Timestamp of the referenced Block."\r\n\t},\r\n\t0x97: {\r\n\t\tname: "CueRefCluster",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\twebm: false,\r\n\t\tdescription: "The Position of the Cluster containing the referenced Block."\r\n\t},\r\n\t0x98: {\r\n\t\tname: "ChapterFlagHidden",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\trange: "0-1",\r\n\t\tdescription: "If a chapter is hidden (1), it should not be available to the user interface (but still to Control Tracks; see flag notes). (1 bit)"\r\n\t},\r\n\t0x4254: {\r\n\t\tname: "ContentCompAlgo",\r\n\t\tlevel: 6,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\t// "br": [ "", "", "", "" ],\r\n\t\t// "del": [ "1 - bzlib,", "2 - lzo1x" ],\r\n\t\tdescription: "The compression algorithm used. Algorithms that have been specified so far are: 0 - zlib,   3 - Header Stripping"\r\n\t},\r\n\t0x4255: {\r\n\t\tname: "ContentCompSettings",\r\n\t\tlevel: 6,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Settings that might be needed by the decompressor. For Header Stripping (ContentCompAlgo=3), the bytes that were removed from the beggining of each frames of the track."\r\n\t},\r\n\t0x4282: {\r\n\t\tname: "DocType",\r\n\t\tlevel: 1,\r\n\t\ttype: "s",\r\n\t\tmandatory: true,\r\n\t\t"default": "matroska",\r\n\t\tminver: 1,\r\n\t\tdescription: "A string that describes the type of document that follows this EBML header. \'matroska\' in our case or \'webm\' for webm files."\r\n\t},\r\n\t0x4285: {\r\n\t\tname: "DocTypeReadVersion",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\t"default": 1,\r\n\t\tminver: 1,\r\n\t\tdescription: "The minimum DocType version an interpreter has to support to read this file."\r\n\t},\r\n\t0x4286: {\r\n\t\tname: "EBMLVersion",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\t"default": 1,\r\n\t\tminver: 1,\r\n\t\tdescription: "The version of EBML parser used to create the file."\r\n\t},\r\n\t0x4287: {\r\n\t\tname: "DocTypeVersion",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\t"default": 1,\r\n\t\tminver: 1,\r\n\t\tdescription: "The version of DocType interpreter used to create the file."\r\n\t},\r\n\t0x4444: {\r\n\t\tname: "SegmentFamily",\r\n\t\tlevel: 2,\r\n\t\ttype: "b",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tbytesize: 16,\r\n\t\tdescription: "A randomly generated unique ID that all segments related to each other must use (128 bits)."\r\n\t},\r\n\t0x4461: {\r\n\t\tname: "DateUTC",\r\n\t\tlevel: 2,\r\n\t\ttype: "d",\r\n\t\tminver: 1,\r\n\t\tdescription: "Date of the origin of timestamp (value 0), i.e. production date."\r\n\t},\r\n\t0x4484: {\r\n\t\tname: "TagDefault",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 1,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Indication to know if this is the default/original language to use for the given tag. (1 bit)"\r\n\t},\r\n\t0x4485: {\r\n\t\tname: "TagBinary",\r\n\t\tlevel: 4,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The values of the Tag if it is binary. Note that this cannot be used in the same SimpleTag as TagString."\r\n\t},\r\n\t0x4487: {\r\n\t\tname: "TagString",\r\n\t\tlevel: 4,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The value of the Element."\r\n\t},\r\n\t0x4489: {\r\n\t\tname: "Duration",\r\n\t\tlevel: 2,\r\n\t\ttype: "f",\r\n\t\tminver: 1,\r\n\t\trange: "> 0",\r\n\t\tdescription: "Duration of the segment (based on TimecodeScale)."\r\n\t},\r\n\t0x4598: {\r\n\t\tname: "ChapterFlagEnabled",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 1,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Specify wether the chapter is enabled. It can be enabled/disabled by a Control Track. When disabled, the movie should skip all the content between the TimeStart and TimeEnd of this chapter (see flag notes). (1 bit)"\r\n\t},\r\n\t0x4660: {\r\n\t\tname: "FileMimeType",\r\n\t\tlevel: 3,\r\n\t\ttype: "s",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "MIME type of the file."\r\n\t},\r\n\t0x4661: {\r\n\t\tname: "FileUsedStartTime",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tdivx: true,\r\n\t\tdescription: "DivX font extension"\r\n\t},\r\n\t0x4662: {\r\n\t\tname: "FileUsedEndTime",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tdivx: true,\r\n\t\tdescription: "DivX font extension"\r\n\t},\r\n\t0x4675: {\r\n\t\tname: "FileReferral",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\twebm: false,\r\n\t\tdescription: "A binary value that a track/codec can refer to when the attachment is needed."\r\n\t},\r\n\t0x5031: {\r\n\t\tname: "ContentEncodingOrder",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "Tells when this modification was used during encoding/muxing starting with 0 and counting upwards. The decoder/demuxer has to start with the highest order number it finds and work its way down. This value has to be unique over all ContentEncodingOrder elements in the segment."\r\n\t},\r\n\t0x5032: {\r\n\t\tname: "ContentEncodingScope",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 1,\r\n\t\trange: "not 0",\r\n\t\t// "br": [ "", "", "" ],\r\n\t\tdescription: "A bit field that describes which elements have been modified in this way. Values (big endian) can be OR\'ed. Possible values: 1 - all frame contents, 2 - the track\'s private data, 4 - the next ContentEncoding (next ContentEncodingOrder. Either the data inside ContentCompression and/or ContentEncryption)"\r\n\t},\r\n\t0x5033: {\r\n\t\tname: "ContentEncodingType",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\t// "br": [ "", "" ],\r\n\t\tdescription: "A value describing what kind of transformation has been done. Possible values: 0 - compression, 1 - encryption"\r\n\t},\r\n\t0x5034: {\r\n\t\tname: "ContentCompression",\r\n\t\tlevel: 5,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Settings describing the compression used. Must be present if the value of ContentEncodingType is 0 and absent otherwise. Each block must be decompressable even if no previous block is available in order not to prevent seeking."\r\n\t},\r\n\t0x5035: {\r\n\t\tname: "ContentEncryption",\r\n\t\tlevel: 5,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Settings describing the encryption used. Must be present if the value of ContentEncodingType is 1 and absent otherwise."\r\n\t},\r\n\t0x5378: {\r\n\t\tname: "CueBlockNumber",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Number of the Block in the specified Cluster."\r\n\t},\r\n\t0x5654: {\r\n\t\tname: "ChapterStringUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "8",\r\n\t\tmandatory: false,\r\n\t\tminver: 3,\r\n\t\twebm: true,\r\n\t\tdescription: "A unique string ID to identify the Chapter. Use for WebVTT cue identifier storage."\r\n\t},\r\n\t0x5741: {\r\n\t\tname: "WritingApp",\r\n\t\tlevel: 2,\r\n\t\ttype: "8",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Writing application (\\"mkvmerge-0.3.3\\")."\r\n\t},\r\n\t0x5854: {\r\n\t\tname: "SilentTracks",\r\n\t\tcppname: "ClusterSilentTracks",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The list of tracks that are not used in that part of the stream. It is useful when using overlay tracks on seeking. Then you should decide what track to use."\r\n\t},\r\n\t0x6240: {\r\n\t\tname: "ContentEncoding",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Settings for one content encoding like compression or encryption."\r\n\t},\r\n\t0x6264: {\r\n\t\tname: "BitDepth",\r\n\t\tcppname: "AudioBitDepth",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Bits per sample, mostly used for PCM."\r\n\t},\r\n\t0x6532: {\r\n\t\tname: "SignedElement",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tmultiple: true,\r\n\t\twebm: false,\r\n\t\tdescription: "An element ID whose data will be used to compute the signature."\r\n\t},\r\n\t0x6624: {\r\n\t\tname: "TrackTranslate",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The track identification for the given Chapter Codec."\r\n\t},\r\n\t0x6911: {\r\n\t\tname: "ChapProcessCommand",\r\n\t\tcppname: "ChapterProcessCommand",\r\n\t\tlevel: 5,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contains all the commands associated to the Atom."\r\n\t},\r\n\t0x6922: {\r\n\t\tname: "ChapProcessTime",\r\n\t\tcppname: "ChapterProcessTime",\r\n\t\tlevel: 6,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Defines when the process command should be handled (0: during the whole chapter, 1: before starting playback, 2: after playback of the chapter)."\r\n\t},\r\n\t0x6924: {\r\n\t\tname: "ChapterTranslate",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "A tuple of corresponding ID used by chapter codecs to represent this segment."\r\n\t},\r\n\t0x6933: {\r\n\t\tname: "ChapProcessData",\r\n\t\tcppname: "ChapterProcessData",\r\n\t\tlevel: 6,\r\n\t\ttype: "b",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contains the command information. The data should be interpreted depending on the ChapProcessCodecID value. For ChapProcessCodecID = 1, the data correspond to the binary DVD cell pre/post commands."\r\n\t},\r\n\t0x6944: {\r\n\t\tname: "ChapProcess",\r\n\t\tcppname: "ChapterProcess",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contains all the commands associated to the Atom."\r\n\t},\r\n\t0x6955: {\r\n\t\tname: "ChapProcessCodecID",\r\n\t\tcppname: "ChapterProcessCodecID",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "Contains the type of the codec used for the processing. A value of 0 means native Matroska processing (to be defined), a value of 1 means the DVD command set is used. More codec IDs can be added later."\r\n\t},\r\n\t0x7373: {\r\n\t\tname: "Tag",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Element containing elements specific to Tracks/Chapters."\r\n\t},\r\n\t0x7384: {\r\n\t\tname: "SegmentFilename",\r\n\t\tlevel: 2,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "A filename corresponding to this segment."\r\n\t},\r\n\t0x7446: {\r\n\t\tname: "AttachmentLink",\r\n\t\tcppname: "TrackAttachmentLink",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tdescription: "The UID of an attachment that is used by this codec."\r\n\t},\r\n\t0x258688: {\r\n\t\tname: "CodecName",\r\n\t\tlevel: 3,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\tdescription: "A human-readable string specifying the codec."\r\n\t},\r\n\t0x18538067: {\r\n\t\tname: "Segment",\r\n\t\tlevel: "0",\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "This element contains all other top-level (level 1) elements. Typically a Matroska file is composed of 1 segment."\r\n\t},\r\n\t0x447a: {\r\n\t\tname: "TagLanguage",\r\n\t\tlevel: 4,\r\n\t\ttype: "s",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": "und",\r\n\t\tdescription: "Specifies the language of the tag specified, in the Matroska languages form."\r\n\t},\r\n\t0x45a3: {\r\n\t\tname: "TagName",\r\n\t\tlevel: 4,\r\n\t\ttype: "8",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The name of the Tag that is going to be stored."\r\n\t},\r\n\t0x67c8: {\r\n\t\tname: "SimpleTag",\r\n\t\tcppname: "TagSimple",\r\n\t\tlevel: 3,\r\n\t\t"recursive": "1",\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contains general information about the target."\r\n\t},\r\n\t0x63c6: {\r\n\t\tname: "TagAttachmentUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "A unique ID to identify the Attachment(s) the tags belong to. If the value is 0 at this level, the tags apply to all the attachments in the Segment."\r\n\t},\r\n\t0x63c4: {\r\n\t\tname: "TagChapterUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "A unique ID to identify the Chapter(s) the tags belong to. If the value is 0 at this level, the tags apply to all chapters in the Segment."\r\n\t},\r\n\t0x63c9: {\r\n\t\tname: "TagEditionUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "A unique ID to identify the EditionEntry(s) the tags belong to. If the value is 0 at this level, the tags apply to all editions in the Segment."\r\n\t},\r\n\t0x63c5: {\r\n\t\tname: "TagTrackUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "A unique ID to identify the Track(s) the tags belong to. If the value is 0 at this level, the tags apply to all tracks in the Segment."\r\n\t},\r\n\t0x63ca: {\r\n\t\tname: "TargetType",\r\n\t\tcppname: "TagTargetType",\r\n\t\tlevel: 4,\r\n\t\ttype: "s",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"strong": "informational",\r\n\t\tdescription: "An  string that can be used to display the logical level of the target like \\"ALBUM\\", \\"TRACK\\", \\"MOVIE\\", \\"CHAPTER\\", etc (see TargetType)."\r\n\t},\r\n\t0x68ca: {\r\n\t\tname: "TargetTypeValue",\r\n\t\tcppname: "TagTargetTypeValue",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 50,\r\n\t\tdescription: "A number to indicate the logical level of the target (see TargetType)."\r\n\t},\r\n\t0x63c0: {\r\n\t\tname: "Targets",\r\n\t\tcppname: "TagTargets",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contain all UIDs where the specified meta data apply. It is empty to describe everything in the segment."\r\n\t},\r\n\t0x1254c367: {\r\n\t\tname: "Tags",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Element containing elements specific to Tracks/Chapters. A list of valid tags can be found here."\r\n\t},\r\n\t0x450d: {\r\n\t\tname: "ChapProcessPrivate",\r\n\t\tcppname: "ChapterProcessPrivate",\r\n\t\tlevel: 5,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Some optional data attached to the ChapProcessCodecID information. For ChapProcessCodecID = 1, it is the \\"DVD level\\" equivalent."\r\n\t},\r\n\t0x437e: {\r\n\t\tname: "ChapCountry",\r\n\t\tcppname: "ChapterCountry",\r\n\t\tlevel: 5,\r\n\t\ttype: "s",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The countries corresponding to the string, same 2 octets as in Internet domains."\r\n\t},\r\n\t0x437c: {\r\n\t\tname: "ChapLanguage",\r\n\t\tcppname: "ChapterLanguage",\r\n\t\tlevel: 5,\r\n\t\ttype: "s",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\t"default": "eng",\r\n\t\tdescription: "The languages corresponding to the string, in the bibliographic ISO-639-2 form."\r\n\t},\r\n\t0x8f: {\r\n\t\tname: "ChapterTrack",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "List of tracks on which the chapter applies. If this element is not present, all tracks apply"\r\n\t},\r\n\t0x63c3: {\r\n\t\tname: "ChapterPhysicalEquiv",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Specify the physical equivalent of this ChapterAtom like \\"DVD\\" (60) or \\"SIDE\\" (50), see complete list of values."\r\n\t},\r\n\t0x6ebc: {\r\n\t\tname: "ChapterSegmentEditionUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tdescription: "The EditionUID to play from the segment linked in ChapterSegmentUID."\r\n\t},\r\n\t0x6e67: {\r\n\t\tname: "ChapterSegmentUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\trange: ">0",\r\n\t\tbytesize: 16,\r\n\t\tdescription: "A segment to play in place of this chapter. Edition ChapterSegmentEditionUID should be used for this segment, otherwise no edition is used."\r\n\t},\r\n\t0x73c4: {\r\n\t\tname: "ChapterUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\trange: "not 0",\r\n\t\tdescription: "A unique ID to identify the Chapter."\r\n\t},\r\n\t0xb6: {\r\n\t\tname: "ChapterAtom",\r\n\t\tlevel: 3,\r\n\t\t"recursive": "1",\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\tdescription: "Contains the atom information to use as the chapter atom (apply to all tracks)."\r\n\t},\r\n\t0x45dd: {\r\n\t\tname: "EditionFlagOrdered",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Specify if the chapters can be defined multiple times and the order to play them is enforced. (1 bit)"\r\n\t},\r\n\t0x45db: {\r\n\t\tname: "EditionFlagDefault",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\trange: "0-1",\r\n\t\tdescription: "If a flag is set (1) the edition should be used as the default one. (1 bit)"\r\n\t},\r\n\t0x45bd: {\r\n\t\tname: "EditionFlagHidden",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\trange: "0-1",\r\n\t\tdescription: "If an edition is hidden (1), it should not be available to the user interface (but still to Control Tracks; see flag notes). (1 bit)"\r\n\t},\r\n\t0x45bc: {\r\n\t\tname: "EditionUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tdescription: "A unique ID to identify the edition. It\'s useful for tagging an edition."\r\n\t},\r\n\t0x45b9: {\r\n\t\tname: "EditionEntry",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\tdescription: "Contains all information about a segment edition."\r\n\t},\r\n\t0x1043a770: {\r\n\t\tname: "Chapters",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: true,\r\n\t\tdescription: "A system to define basic menus and partition data. For more detailed information, look at the Chapters Explanation."\r\n\t},\r\n\t0x46ae: {\r\n\t\tname: "FileUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Unique ID representing the file, as random as possible."\r\n\t},\r\n\t0x465c: {\r\n\t\tname: "FileData",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The data of the file."\r\n\t},\r\n\t0x466e: {\r\n\t\tname: "FileName",\r\n\t\tlevel: 3,\r\n\t\ttype: "8",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Filename of the attached file."\r\n\t},\r\n\t0x467e: {\r\n\t\tname: "FileDescription",\r\n\t\tlevel: 3,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "A human-friendly name for the attached file."\r\n\t},\r\n\t0x61a7: {\r\n\t\tname: "AttachedFile",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "An attached file."\r\n\t},\r\n\t0x1941a469: {\r\n\t\tname: "Attachments",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contain attached files."\r\n\t},\r\n\t0xeb: {\r\n\t\tname: "CueRefCodecState",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "The position of the Codec State corresponding to this referenced element. 0 means that the data is taken from the initial Track Entry."\r\n\t},\r\n\t0x535f: {\r\n\t\tname: "CueRefNumber",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\twebm: false,\r\n\t\t"default": 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Number of the referenced Block of Track X in the specified Cluster."\r\n\t},\r\n\t0xdb: {\r\n\t\tname: "CueReference",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 2,\r\n\t\twebm: false,\r\n\t\tdescription: "The Clusters containing the required referenced Blocks."\r\n\t},\r\n\t0xea: {\r\n\t\tname: "CueCodecState",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 2,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "The position of the Codec State corresponding to this Cue element. 0 means that the data is taken from the initial Track Entry."\r\n\t},\r\n\t0xb2: {\r\n\t\tname: "CueDuration",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: false,\r\n\t\tminver: 4,\r\n\t\twebm: false,\r\n\t\tdescription: "The duration of the block according to the segment time base. If missing the track\'s DefaultDuration does not apply and no duration information is available in terms of the cues."\r\n\t},\r\n\t0xf0: {\r\n\t\tname: "CueRelativePosition",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: false,\r\n\t\tminver: 4,\r\n\t\twebm: false,\r\n\t\tdescription: "The relative position of the referenced block inside the cluster with 0 being the first possible position for an element inside that cluster.",\r\n\t\tposition: "clusterRelative"\r\n\t},\r\n\t0xf1: {\r\n\t\tname: "CueClusterPosition",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "The position of the Cluster containing the required Block.",\r\n\t\tposition: "segment",\r\n\t},\r\n\t0xf7: {\r\n\t\tname: "CueTrack",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "The track for which a position is given."\r\n\t},\r\n\t0xb7: {\r\n\t\tname: "CueTrackPositions",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Contain positions for different tracks corresponding to the timestamp."\r\n\t},\r\n\t0xb3: {\r\n\t\tname: "CueTime",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Absolute timestamp according to the segment time base."\r\n\t},\r\n\t0xbb: {\r\n\t\tname: "CuePoint",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Contains all information relative to a seek point in the segment."\r\n\t},\r\n\t0x1c53bb6b: {\r\n\t\tname: "Cues",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\tdescription: "A top-level element to speed seeking access. All entries are local to the segment. Should be mandatory for non \\"live\\" streams."\r\n\t},\r\n\t0x47e6: {\r\n\t\tname: "ContentSigHashAlgo",\r\n\t\tlevel: 6,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\t// "br": [ "", "" ],\r\n\t\tdescription: "The hash algorithm used for the signature. A value of \'0\' means that the contents have not been signed but only encrypted. Predefined values: 1 - SHA1-160 2 - MD5"\r\n\t},\r\n\t0x47e5: {\r\n\t\tname: "ContentSigAlgo",\r\n\t\tlevel: 6,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\t// "br": "",\r\n\t\tdescription: "The algorithm used for the signature. A value of \'0\' means that the contents have not been signed but only encrypted. Predefined values: 1 - RSA"\r\n\t},\r\n\t0x47e4: {\r\n\t\tname: "ContentSigKeyID",\r\n\t\tlevel: 6,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "This is the ID of the private key the data was signed with."\r\n\t},\r\n\t0x47e3: {\r\n\t\tname: "ContentSignature",\r\n\t\tlevel: 6,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "A cryptographic signature of the contents."\r\n\t},\r\n\t0x47e2: {\r\n\t\tname: "ContentEncKeyID",\r\n\t\tlevel: 6,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "For public key algorithms this is the ID of the public key the the data was encrypted with."\r\n\t},\r\n\t0x47e1: {\r\n\t\tname: "ContentEncAlgo",\r\n\t\tlevel: 6,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\t// "br": "",\r\n\t\tdescription: "The encryption algorithm used. The value \'0\' means that the contents have not been encrypted but only signed. Predefined values: 1 - DES, 2 - 3DES, 3 - Twofish, 4 - Blowfish, 5 - AES"\r\n\t},\r\n\t0x6d80: {\r\n\t\tname: "ContentEncodings",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Settings for several content encoding mechanisms like compression or encryption."\r\n\t},\r\n\t0xc4: {\r\n\t\tname: "TrickMasterTrackSegmentUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tdivx: true,\r\n\t\tbytesize: 16,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xc7: {\r\n\t\tname: "TrickMasterTrackUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tdivx: true,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xc6: {\r\n\t\tname: "TrickTrackFlag",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tdivx: true,\r\n\t\t"default": 0,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xc1: {\r\n\t\tname: "TrickTrackSegmentUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tdivx: true,\r\n\t\tbytesize: 16,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xc0: {\r\n\t\tname: "TrickTrackUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tdivx: true,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xed: {\r\n\t\tname: "TrackJoinUID",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 3,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tdescription: "The trackUID number of a track whose blocks are used to create this virtual track."\r\n\t},\r\n\t0xe9: {\r\n\t\tname: "TrackJoinBlocks",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tminver: 3,\r\n\t\twebm: false,\r\n\t\tdescription: "Contains the list of all tracks whose Blocks need to be combined to create this virtual track"\r\n\t},\r\n\t0xe6: {\r\n\t\tname: "TrackPlaneType",\r\n\t\tlevel: 6,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 3,\r\n\t\twebm: false,\r\n\t\tdescription: "The kind of plane this track corresponds to (0: left eye, 1: right eye, 2: background)."\r\n\t},\r\n\t0xe5: {\r\n\t\tname: "TrackPlaneUID",\r\n\t\tlevel: 6,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 3,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tdescription: "The trackUID number of the track representing the plane."\r\n\t},\r\n\t0xe4: {\r\n\t\tname: "TrackPlane",\r\n\t\tlevel: 5,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 3,\r\n\t\twebm: false,\r\n\t\tdescription: "Contains a video plane track that need to be combined to create this 3D track"\r\n\t},\r\n\t0xe3: {\r\n\t\tname: "TrackCombinePlanes",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tminver: 3,\r\n\t\twebm: false,\r\n\t\tdescription: "Contains the list of all video plane tracks that need to be combined to create this 3D track"\r\n\t},\r\n\t0xe2: {\r\n\t\tname: "TrackOperation",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tminver: 3,\r\n\t\twebm: false,\r\n\t\tdescription: "Operation that needs to be applied on tracks to create this virtual track. For more details look at the Specification Notes on the subject."\r\n\t},\r\n\t0x7d7b: {\r\n\t\tname: "ChannelPositions",\r\n\t\tcppname: "AudioPosition",\r\n\t\tlevel: 4,\r\n\t\ttype: "b",\r\n\t\twebm: false,\r\n\t\tdescription: "Table of horizontal angles for each successive channel, see appendix."\r\n\t},\r\n\t0x9f: {\r\n\t\tname: "Channels",\r\n\t\tcppname: "AudioChannels",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\t"default": 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Numbers of channels in the track."\r\n\t},\r\n\t0x78b5: {\r\n\t\tname: "OutputSamplingFrequency",\r\n\t\tcppname: "AudioOutputSamplingFreq",\r\n\t\tlevel: 4,\r\n\t\ttype: "f",\r\n\t\tminver: 1,\r\n\t\t"default": "Sampling Frequency",\r\n\t\trange: "> 0",\r\n\t\tdescription: "Real output sampling frequency in Hz (used for SBR techniques)."\r\n\t},\r\n\t0xb5: {\r\n\t\tname: "SamplingFrequency",\r\n\t\tcppname: "AudioSamplingFreq",\r\n\t\tlevel: 4,\r\n\t\ttype: "f",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\t"default": 8000.0,\r\n\t\trange: "> 0",\r\n\t\tdescription: "Sampling frequency in Hz."\r\n\t},\r\n\t0xe1: {\r\n\t\tname: "Audio",\r\n\t\tcppname: "TrackAudio",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\tdescription: "Audio settings."\r\n\t},\r\n\t0x2383e3: {\r\n\t\tname: "FrameRate",\r\n\t\tcppname: "VideoFrameRate",\r\n\t\tlevel: 4,\r\n\t\ttype: "f",\r\n\t\trange: "> 0",\r\n\t\t"strong": "Informational",\r\n\t\tdescription: "Number of frames per second.  only."\r\n\t},\r\n\t0x2fb523: {\r\n\t\tname: "GammaValue",\r\n\t\tcppname: "VideoGamma",\r\n\t\tlevel: 4,\r\n\t\ttype: "f",\r\n\t\twebm: false,\r\n\t\trange: "> 0",\r\n\t\tdescription: "Gamma Value."\r\n\t},\r\n\t0x2eb524: {\r\n\t\tname: "ColourSpace",\r\n\t\tcppname: "VideoColourSpace",\r\n\t\tlevel: 4,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tbytesize: 4,\r\n\t\tdescription: "Same value as in AVI (32 bits)."\r\n\t},\r\n\t0x54b3: {\r\n\t\tname: "AspectRatioType",\r\n\t\tcppname: "VideoAspectRatio",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\tdescription: "Specify the possible modifications to the aspect ratio (0: free resizing, 1: keep aspect ratio, 2: fixed)."\r\n\t},\r\n\t0x54b2: {\r\n\t\tname: "DisplayUnit",\r\n\t\tcppname: "VideoDisplayUnit",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\tdescription: "How DisplayWidth & DisplayHeight should be interpreted (0: pixels, 1: centimeters, 2: inches, 3: Display Aspect Ratio)."\r\n\t},\r\n\t0x54ba: {\r\n\t\tname: "DisplayHeight",\r\n\t\tcppname: "VideoDisplayHeight",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": "PixelHeight",\r\n\t\trange: "not 0",\r\n\t\tdescription: "Height of the video frames to display. The default value is only valid when DisplayUnit is 0."\r\n\t},\r\n\t0x54b0: {\r\n\t\tname: "DisplayWidth",\r\n\t\tcppname: "VideoDisplayWidth",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": "PixelWidth",\r\n\t\trange: "not 0",\r\n\t\tdescription: "Width of the video frames to display. The default value is only valid when DisplayUnit is 0."\r\n\t},\r\n\t0x54dd: {\r\n\t\tname: "PixelCropRight",\r\n\t\tcppname: "VideoPixelCropRight",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\tdescription: "The number of video pixels to remove on the right of the image."\r\n\t},\r\n\t0x54cc: {\r\n\t\tname: "PixelCropLeft",\r\n\t\tcppname: "VideoPixelCropLeft",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\tdescription: "The number of video pixels to remove on the left of the image."\r\n\t},\r\n\t0x54bb: {\r\n\t\tname: "PixelCropTop",\r\n\t\tcppname: "VideoPixelCropTop",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\tdescription: "The number of video pixels to remove at the top of the image."\r\n\t},\r\n\t0x54aa: {\r\n\t\tname: "PixelCropBottom",\r\n\t\tcppname: "VideoPixelCropBottom",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\tdescription: "The number of video pixels to remove at the bottom of the image (for HDTV content)."\r\n\t},\r\n\t0xba: {\r\n\t\tname: "PixelHeight",\r\n\t\tcppname: "VideoPixelHeight",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Height of the encoded video frames in pixels."\r\n\t},\r\n\t0xb0: {\r\n\t\tname: "PixelWidth",\r\n\t\tcppname: "VideoPixelWidth",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Width of the encoded video frames in pixels."\r\n\t},\r\n\t0x53b9: {\r\n\t\tname: "OldStereoMode",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\t"maxver": "0",\r\n\t\twebm: false,\r\n\t\tdivx: false,\r\n\t\tdescription: "DEPRECATED, DO NOT USE. Bogus StereoMode value used in old versions of libmatroska. (0: mono, 1: right eye, 2: left eye, 3: both eyes)."\r\n\t},\r\n\t0x53c0: {\r\n\t\tname: "AlphaMode",\r\n\t\tcppname: "VideoAlphaMode",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 3,\r\n\t\twebm: true,\r\n\t\t"default": 0,\r\n\t\tdescription: "Alpha Video Mode. Presence of this element indicates that the BlockAdditional element could contain Alpha data."\r\n\t},\r\n\t0x53b8: {\r\n\t\tname: "StereoMode",\r\n\t\tcppname: "VideoStereoMode",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tminver: 3,\r\n\t\twebm: true,\r\n\t\t"default": 0,\r\n\t\tdescription: "Stereo-3D video mode (0: mono, 1: side by side (left eye is first), 2: top-bottom (right eye is first), 3: top-bottom (left eye is first), 4: checkboard (right is first), 5: checkboard (left is first), 6: row interleaved (right is first), 7: row interleaved (left is first), 8: column interleaved (right is first), 9: column interleaved (left is first), 10: anaglyph (cyan/red), 11: side by side (right eye is first), 12: anaglyph (green/magenta), 13 both eyes laced in one Block (left eye is first), 14 both eyes laced in one Block (right eye is first)) . There are some more details on 3D support in the Specification Notes."\r\n\t},\r\n\t0x9a: {\r\n\t\tname: "FlagInterlaced",\r\n\t\tcppname: "VideoFlagInterlaced",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 2,\r\n\t\twebm: true,\r\n\t\t"default": 0,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Set if the video is interlaced. (1 bit)"\r\n\t},\r\n\t0xe0: {\r\n\t\tname: "Video",\r\n\t\tcppname: "TrackVideo",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\tdescription: "Video settings."\r\n\t},\r\n\t0x66a5: {\r\n\t\tname: "TrackTranslateTrackID",\r\n\t\tlevel: 4,\r\n\t\ttype: "b",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The binary value used to represent this track in the chapter codec data. The format depends on the ChapProcessCodecID used."\r\n\t},\r\n\t0x66bf: {\r\n\t\tname: "TrackTranslateCodec",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The chapter codec using this ID (0: Matroska Script, 1: DVD-menu)."\r\n\t},\r\n\t0x66fc: {\r\n\t\tname: "TrackTranslateEditionUID",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Specify an edition UID on which this translation applies. When not specified, it means for all editions found in the segment."\r\n\t},\r\n\t0x56bb: {\r\n\t\tname: "SeekPreRoll",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tmultiple: false,\r\n\t\t"default": 0,\r\n\t\tminver: 4,\r\n\t\twebm: true,\r\n\t\tdescription: "After a discontinuity, SeekPreRoll is the duration in nanoseconds of the data the decoder must decode before the decoded data is valid."\r\n\t},\r\n\t0x56aa: {\r\n\t\tname: "CodecDelay",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmultiple: false,\r\n\t\t"default": 0,\r\n\t\tminver: 4,\r\n\t\twebm: true,\r\n\t\tdescription: "CodecDelay is The codec-built-in delay in nanoseconds. This value must be subtracted from each block timestamp in order to get the actual timestamp. The value should be small so the muxing of tracks with the same actual timestamp are in the same Cluster."\r\n\t},\r\n\t0x6fab: {\r\n\t\tname: "TrackOverlay",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Specify that this track is an overlay track for the Track specified (in the u-integer). That means when this track has a gap (see SilentTracks) the overlay track should be used instead. The order of multiple TrackOverlay matters, the first one is the one that should be used. If not found it should be the second, etc."\r\n\t},\r\n\t0xaa: {\r\n\t\tname: "CodecDecodeAll",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 2,\r\n\t\twebm: false,\r\n\t\t"default": 1,\r\n\t\trange: "0-1",\r\n\t\tdescription: "The codec can decode potentially damaged data (1 bit)."\r\n\t},\r\n\t0x26b240: {\r\n\t\tname: "CodecDownloadURL",\r\n\t\tlevel: 3,\r\n\t\ttype: "s",\r\n\t\tmultiple: true,\r\n\t\twebm: false,\r\n\t\tdescription: "A URL to download about the codec used."\r\n\t},\r\n\t0x3b4040: {\r\n\t\tname: "CodecInfoURL",\r\n\t\tlevel: 3,\r\n\t\ttype: "s",\r\n\t\tmultiple: true,\r\n\t\twebm: false,\r\n\t\tdescription: "A URL to find information about the codec used."\r\n\t},\r\n\t0x3a9697: {\r\n\t\tname: "CodecSettings",\r\n\t\tlevel: 3,\r\n\t\ttype: "8",\r\n\t\twebm: false,\r\n\t\tdescription: "A string describing the encoding setting used."\r\n\t},\r\n\t0x63a2: {\r\n\t\tname: "CodecPrivate",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\tdescription: "Private data only known to the codec."\r\n\t},\r\n\t0x22b59c: {\r\n\t\tname: "Language",\r\n\t\tcppname: "TrackLanguage",\r\n\t\tlevel: 3,\r\n\t\ttype: "s",\r\n\t\tminver: 1,\r\n\t\t"default": "eng",\r\n\t\tdescription: "Specifies the language of the track in the Matroska languages form."\r\n\t},\r\n\t0x536e: {\r\n\t\tname: "Name",\r\n\t\tcppname: "TrackName",\r\n\t\tlevel: 3,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\tdescription: "A human-readable track name."\r\n\t},\r\n\t0x55ee: {\r\n\t\tname: "MaxBlockAdditionID",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "The maximum value of BlockAdditions for this track."\r\n\t},\r\n\t0x537f: {\r\n\t\tname: "TrackOffset",\r\n\t\tlevel: 3,\r\n\t\ttype: "i",\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "A value to add to the Block\'s Timestamp. This can be used to adjust the playback offset of a track."\r\n\t},\r\n\t0x23314f: {\r\n\t\tname: "TrackTimecodeScale",\r\n\t\tlevel: 3,\r\n\t\ttype: "f",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\t"maxver": "3",\r\n\t\twebm: false,\r\n\t\t"default": 1.0,\r\n\t\trange: "> 0",\r\n\t\tdescription: "DEPRECATED, DO NOT USE. The scale to apply on this track to work at normal speed in relation with other tracks (mostly used to adjust video speed when the audio length differs)."\r\n\t},\r\n\t0x234e7a: {\r\n\t\tname: "DefaultDecodedFieldDuration",\r\n\t\tcppname: "TrackDefaultDecodedFieldDuration",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tminver: 4,\r\n\t\trange: "not 0",\r\n\t\tdescription: "The period in nanoseconds (not scaled by TimcodeScale)\\nbetween two successive fields at the output of the decoding process (see the notes)"\r\n\t},\r\n\t0x23e383: {\r\n\t\tname: "DefaultDuration",\r\n\t\tcppname: "TrackDefaultDuration",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "Number of nanoseconds (not scaled via TimecodeScale) per frame (\'frame\' in the Matroska sense -- one element put into a (Simple)Block)."\r\n\t},\r\n\t0x6df8: {\r\n\t\tname: "MaxCache",\r\n\t\tcppname: "TrackMaxCache",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The maximum cache size required to store referenced frames in and the current frame. 0 means no cache is needed."\r\n\t},\r\n\t0x6de7: {\r\n\t\tname: "MinCache",\r\n\t\tcppname: "TrackMinCache",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "The minimum number of frames a player should be able to cache during playback. If set to 0, the reference pseudo-cache system is not used."\r\n\t},\r\n\t0x9c: {\r\n\t\tname: "FlagLacing",\r\n\t\tcppname: "TrackFlagLacing",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\t"default": 1,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Set if the track may contain blocks using lacing. (1 bit)"\r\n\t},\r\n\t0x55aa: {\r\n\t\tname: "FlagForced",\r\n\t\tcppname: "TrackFlagForced",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Set if that track MUST be active during playback. There can be many forced track for a kind (audio, video or subs), the player should select the one which language matches the user preference or the default + forced track. Overlay MAY happen between a forced and non-forced track of the same kind. (1 bit)"\r\n\t},\r\n\t0xb9: {\r\n\t\tname: "FlagEnabled",\r\n\t\tcppname: "TrackFlagEnabled",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 2,\r\n\t\twebm: true,\r\n\t\t"default": 1,\r\n\t\trange: "0-1",\r\n\t\tdescription: "Set if the track is usable. (1 bit)"\r\n\t},\r\n\t0x73c5: {\r\n\t\tname: "TrackUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "A unique ID to identify the Track. This should be kept the same when making a direct stream copy of the Track to another file."\r\n\t},\r\n\t0xd7: {\r\n\t\tname: "TrackNumber",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "The track number as used in the Block Header (using more than 127 tracks is not encouraged, though the design allows an unlimited number)."\r\n\t},\r\n\t0xae: {\r\n\t\tname: "TrackEntry",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Describes a track with all elements."\r\n\t},\r\n\t0x1654ae6b: {\r\n\t\tname: "Tracks",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "A top-level block of information with many tracks described."\r\n\t},\r\n\t0xaf: {\r\n\t\tname: "EncryptedBlock",\r\n\t\tlevel: 2,\r\n\t\ttype: "b",\r\n\t\tmultiple: true,\r\n\t\twebm: false,\r\n\t\tdescription: "Similar to EncryptedBlock Structure)"\r\n\t},\r\n\t0xca: {\r\n\t\tname: "ReferenceTimeCode",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmultiple: false,\r\n\t\tmandatory: true,\r\n\t\tminver: 0,\r\n\t\twebm: false,\r\n\t\tdivx: true,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xc9: {\r\n\t\tname: "ReferenceOffset",\r\n\t\tlevel: 4,\r\n\t\ttype: "u",\r\n\t\tmultiple: false,\r\n\t\tmandatory: true,\r\n\t\tminver: 0,\r\n\t\twebm: false,\r\n\t\tdivx: true,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xc8: {\r\n\t\tname: "ReferenceFrame",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tmultiple: false,\r\n\t\tminver: 0,\r\n\t\twebm: false,\r\n\t\tdivx: true,\r\n\t\tdescription: "DivX trick track extenstions"\r\n\t},\r\n\t0xcf: {\r\n\t\tname: "SliceDuration",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\t"default": 0,\r\n\t\tdescription: "The (scaled) duration to apply to the element."\r\n\t},\r\n\t0xce: {\r\n\t\tname: "Delay",\r\n\t\tcppname: "SliceDelay",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\t"default": 0,\r\n\t\tdescription: "The (scaled) delay to apply to the element."\r\n\t},\r\n\t0xcb: {\r\n\t\tname: "BlockAdditionID",\r\n\t\tcppname: "SliceBlockAddID",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\t"default": 0,\r\n\t\tdescription: "The ID of the BlockAdditional element (0 is the main Block)."\r\n\t},\r\n\t0xcd: {\r\n\t\tname: "FrameNumber",\r\n\t\tcppname: "SliceFrameNumber",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\t"default": 0,\r\n\t\tdescription: "The number of the frame to generate from this lace with this delay (allow you to generate many frames from the same Block/Frame)."\r\n\t},\r\n\t0xcc: {\r\n\t\tname: "LaceNumber",\r\n\t\tcppname: "SliceLaceNumber",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": 0,\r\n\t\tdivx: false,\r\n\t\tdescription: "The reverse number of the frame in the lace (0 is the last frame, 1 is the next to last, etc). While there are a few files in the wild with this element, it is no longer in use and has been deprecated. Being able to interpret this element is not required for playback."\r\n\t},\r\n\t0xe8: {\r\n\t\tname: "TimeSlice",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdivx: false,\r\n\t\tdescription: "Contains extra time information about the data contained in the Block. While there are a few files in the wild with this element, it is no longer in use and has been deprecated. Being able to interpret this element is not required for playback."\r\n\t},\r\n\t0x8e: {\r\n\t\tname: "Slices",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\tdivx: false,\r\n\t\tdescription: "Contains slices description."\r\n\t},\r\n\t0x75a2: {\r\n\t\tname: "DiscardPadding",\r\n\t\tlevel: 3,\r\n\t\ttype: "i",\r\n\t\tminver: 4,\r\n\t\twebm: true,\r\n\t\tdescription: "Duration in nanoseconds of the silent data added to the Block (padding at the end of the Block for positive value, at the beginning of the Block for negative value). The duration of DiscardPadding is not calculated in the duration of the TrackEntry and should be discarded during playback."\r\n\t},\r\n\t0xa4: {\r\n\t\tname: "CodecState",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tminver: 2,\r\n\t\twebm: false,\r\n\t\tdescription: "The new codec state to use. Data interpretation is private to the codec. This information should always be referenced by a seek entry."\r\n\t},\r\n\t0xfd: {\r\n\t\tname: "ReferenceVirtual",\r\n\t\tlevel: 3,\r\n\t\ttype: "i",\r\n\t\twebm: false,\r\n\t\tdescription: "Relative position of the data that should be in position of the virtual block."\r\n\t},\r\n\t0xfb: {\r\n\t\tname: "ReferenceBlock",\r\n\t\tlevel: 3,\r\n\t\ttype: "i",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Timestamp of another frame used as a reference (ie: B or P frame). The timestamp is relative to the block it\'s attached to."\r\n\t},\r\n\t0xfa: {\r\n\t\tname: "ReferencePriority",\r\n\t\tcppname: "FlagReferenced",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 0,\r\n\t\tdescription: "This frame is referenced and has the specified cache priority. In cache only a frame of the same or higher priority can replace this frame. A value of 0 means the frame is not referenced."\r\n\t},\r\n\t0x9b: {\r\n\t\tname: "BlockDuration",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\t"default": "TrackDuration",\r\n\t\tdescription: "The duration of the Block (based on TimecodeScale). This element is mandatory when DefaultDuration is set for the track (but can be omitted as other default values). When not written and with no DefaultDuration, the value is assumed to be the difference between the timestamp of this Block and the timestamp of the next Block in \\"display\\" order (not coding order). This element can be useful at the end of a Track (as there is not other Block available), or when there is a break in a track like for subtitle tracks. When set to 0 that means the frame is not a keyframe."\r\n\t},\r\n\t0xa5: {\r\n\t\tname: "BlockAdditional",\r\n\t\tlevel: 5,\r\n\t\ttype: "b",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Interpreted by the codec as it wishes (using the BlockAddID)."\r\n\t},\r\n\t0xee: {\r\n\t\tname: "BlockAddID",\r\n\t\tlevel: 5,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\t"default": 1,\r\n\t\trange: "not 0",\r\n\t\tdescription: "An ID to identify the BlockAdditional level."\r\n\t},\r\n\t0xa6: {\r\n\t\tname: "BlockMore",\r\n\t\tlevel: 4,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contain the BlockAdditional and some parameters."\r\n\t},\r\n\t0x75a1: {\r\n\t\tname: "BlockAdditions",\r\n\t\tlevel: 3,\r\n\t\ttype: "m",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Contain additional blocks to complete the main one. An EBML parser that has no knowledge of the Block structure could still see and use/skip these data."\r\n\t},\r\n\t0xa2: {\r\n\t\tname: "BlockVirtual",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\twebm: false,\r\n\t\tdescription: "A Block with no data. It must be stored in the stream at the place the real Block should be in display order. (see Block Virtual)"\r\n\t},\r\n\t0xa1: {\r\n\t\tname: "Block",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Block containing the actual data to be rendered and a timestamp relative to the Cluster Timecode. (see Block Structure)"\r\n\t},\r\n\t0xa0: {\r\n\t\tname: "BlockGroup",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Basic container of information containing a single Block or BlockVirtual, and information specific to that Block/VirtualBlock."\r\n\t},\r\n\t0xa3: {\r\n\t\tname: "SimpleBlock",\r\n\t\tlevel: 2,\r\n\t\ttype: "b",\r\n\t\tmultiple: true,\r\n\t\tminver: 2,\r\n\t\twebm: true,\r\n\t\tdivx: true,\r\n\t\tdescription: "Similar to SimpleBlock Structure"\r\n\t},\r\n\t0xab: {\r\n\t\tname: "PrevSize",\r\n\t\tcppname: "ClusterPrevSize",\r\n\t\tlevel: 2,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\tdescription: "Size of the previous Cluster, in octets. Can be useful for backward playing.",\r\n\t\tposition: "prevCluster"\r\n\t},\r\n\t0xa7: {\r\n\t\tname: "Position",\r\n\t\tcppname: "ClusterPosition",\r\n\t\tlevel: 2,\r\n\t\ttype: "u",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The Position of the Cluster in the segment (0 in live broadcast streams). It might help to resynchronise offset on damaged streams.",\r\n\t\tposition: "segment"\r\n\t},\r\n\t0x58d7: {\r\n\t\tname: "SilentTrackNumber",\r\n\t\tcppname: "ClusterSilentTrackNumber",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "One of the track number that are not used from now on in the stream. It could change later if not specified as silent in a further Cluster."\r\n\t},\r\n\t0xe7: {\r\n\t\tname: "Timecode",\r\n\t\tcppname: "ClusterTimecode",\r\n\t\tlevel: 2,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Absolute timestamp of the cluster (based on TimecodeScale)."\r\n\t},\r\n\t0x1f43b675: {\r\n\t\tname: "Cluster",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "The lower level element containing the (monolithic) Block structure."\r\n\t},\r\n\t0x4d80: {\r\n\t\tname: "MuxingApp",\r\n\t\tlevel: 2,\r\n\t\ttype: "8",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Muxing application or library (\\"libmatroska-0.4.3\\")."\r\n\t},\r\n\t0x7ba9: {\r\n\t\tname: "Title",\r\n\t\tlevel: 2,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "General name of the segment."\r\n\t},\r\n\t0x2ad7b2: {\r\n\t\tname: "TimecodeScaleDenominator",\r\n\t\tlevel: 2,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 4,\r\n\t\t"default": "1000000000",\r\n\t\tdescription: "Timestamp scale numerator, see TimecodeScale."\r\n\t},\r\n\t0x2ad7b1: {\r\n\t\tname: "TimecodeScale",\r\n\t\tlevel: 2,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\t"default": "1000000",\r\n\t\tdescription: "Timestamp scale in nanoseconds (1.000.000 means all timestamps in the segment are expressed in milliseconds)."\r\n\t},\r\n\t0x69a5: {\r\n\t\tname: "ChapterTranslateID",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The binary value used to represent this segment in the chapter codec data. The format depends on the ChapProcessCodecID used."\r\n\t},\r\n\t0x69bf: {\r\n\t\tname: "ChapterTranslateCodec",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The chapter codec using this ID (0: Matroska Script, 1: DVD-menu)."\r\n\t},\r\n\t0x69fc: {\r\n\t\tname: "ChapterTranslateEditionUID",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "Specify an edition UID on which this correspondance applies. When not specified, it means for all editions found in the segment."\r\n\t},\r\n\t0x3e83bb: {\r\n\t\tname: "NextFilename",\r\n\t\tlevel: 2,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "An escaped filename corresponding to the next segment."\r\n\t},\r\n\t0x3eb923: {\r\n\t\tname: "NextUID",\r\n\t\tlevel: 2,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tbytesize: 16,\r\n\t\tdescription: "A unique ID to identify the next chained segment (128 bits)."\r\n\t},\r\n\t0x3c83ab: {\r\n\t\tname: "PrevFilename",\r\n\t\tlevel: 2,\r\n\t\ttype: "8",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "An escaped filename corresponding to the previous segment."\r\n\t},\r\n\t0x3cb923: {\r\n\t\tname: "PrevUID",\r\n\t\tlevel: 2,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tbytesize: 16,\r\n\t\tdescription: "A unique ID to identify the previous chained segment (128 bits)."\r\n\t},\r\n\t0x73a4: {\r\n\t\tname: "SegmentUID",\r\n\t\tlevel: 2,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\trange: "not 0",\r\n\t\tbytesize: 16,\r\n\t\tdescription: "A randomly generated unique ID to identify the current segment between many others (128 bits)."\r\n\t},\r\n\t0x1549a966: {\r\n\t\tname: "Info",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Contains miscellaneous general information and statistics on the file."\r\n\t},\r\n\t0x53ac: {\r\n\t\tname: "SeekPosition",\r\n\t\tlevel: 3,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "The position of the element in the segment in octets (0 = first level 1 element).",\r\n\t\tposition: "segment"\r\n\t},\r\n\t0x53ab: {\r\n\t\tname: "SeekID",\r\n\t\tlevel: 3,\r\n\t\ttype: "b",\r\n\t\tmandatory: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "The binary ID corresponding to the element name.",\r\n\t\ttype2: "ebmlID"\r\n\t},\r\n\t0x4dbb: {\r\n\t\tname: "Seek",\r\n\t\tcppname: "SeekPoint",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Contains a single seek entry to an EBML element."\r\n\t},\r\n\t0x114d9b74: {\r\n\t\tname: "SeekHead",\r\n\t\tcppname: "SeekHeader",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Contains the position of other level 1 elements."\r\n\t},\r\n\t0x7e7b: {\r\n\t\tname: "SignatureElementList",\r\n\t\tlevel: 2,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\twebm: false,\r\n\t\ti: "Cluster|Block|BlockAdditional",\r\n\t\tdescription: "A list consists of a number of consecutive elements that represent one case where data is used in signature. Ex:  means that the BlockAdditional of all Blocks in all Clusters is used for encryption."\r\n\t},\r\n\t0x7e5b: {\r\n\t\tname: "SignatureElements",\r\n\t\tlevel: 1,\r\n\t\ttype: "m",\r\n\t\twebm: false,\r\n\t\tdescription: "Contains elements that will be used to compute the signature."\r\n\t},\r\n\t0x7eb5: {\r\n\t\tname: "Signature",\r\n\t\tlevel: 1,\r\n\t\ttype: "b",\r\n\t\twebm: false,\r\n\t\tdescription: "The signature of the data (until a new."\r\n\t},\r\n\t0x7ea5: {\r\n\t\tname: "SignaturePublicKey",\r\n\t\tlevel: 1,\r\n\t\ttype: "b",\r\n\t\twebm: false,\r\n\t\tdescription: "The public key to use with the algorithm (in the case of a PKI-based signature)."\r\n\t},\r\n\t0x7e9a: {\r\n\t\tname: "SignatureHash",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\twebm: false,\r\n\t\tdescription: "Hash algorithm used (1=SHA1-160, 2=MD5)."\r\n\t},\r\n\t0x7e8a: {\r\n\t\tname: "SignatureAlgo",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\twebm: false,\r\n\t\tdescription: "Signature algorithm used (1=RSA, 2=elliptic)."\r\n\t},\r\n\t0x1b538667: {\r\n\t\tname: "SignatureSlot",\r\n\t\tlevel: -1,\r\n\t\ttype: "m",\r\n\t\tmultiple: true,\r\n\t\twebm: false,\r\n\t\tdescription: "Contain signature of some (coming) elements in the stream."\r\n\t},\r\n\t0xbf: {\r\n\t\tname: "CRC-32",\r\n\t\tlevel: -1,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\twebm: false,\r\n\t\tdescription: "The CRC is computed on all the data of the Master element it\'s in. The CRC element should be the first in it\'s parent master for easier reading. All level 1 elements should include a CRC-32. The CRC in use is the IEEE CRC32 Little Endian",\r\n\t\tcrc: true\r\n\t},\r\n\t0xec: {\r\n\t\tname: "Void",\r\n\t\tlevel: -1,\r\n\t\ttype: "b",\r\n\t\tminver: 1,\r\n\t\tdescription: "Used to void damaged data, to avoid unexpected behaviors when using damaged data. The content is discarded. Also used to reserve space in a sub-element for later use."\r\n\t},\r\n\t0x42f3: {\r\n\t\tname: "EBMLMaxSizeLength",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\t"default": 8,\r\n\t\tminver: 1,\r\n\t\tdescription: "The maximum length of the sizes you\'ll find in this file (8 or less in Matroska). This does not override the element size indicated at the beginning of an element. Elements that have an indicated size which is larger than what is allowed by EBMLMaxSizeLength shall be considered invalid."\r\n\t},\r\n\t0x42f2: {\r\n\t\tname: "EBMLMaxIDLength",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\t"default": 4,\r\n\t\tminver: 1,\r\n\t\tdescription: "The maximum length of the IDs you\'ll find in this file (4 or less in Matroska)."\r\n\t},\r\n\t0x42f7: {\r\n\t\tname: "EBMLReadVersion",\r\n\t\tlevel: 1,\r\n\t\ttype: "u",\r\n\t\tmandatory: true,\r\n\t\t"default": 1,\r\n\t\tminver: 1,\r\n\t\tdescription: "The minimum EBML version a parser has to support to read this file."\r\n\t},\r\n\t0x1a45dfa3: {\r\n\t\tname: "EBML",\r\n\t\tlevel: "0",\r\n\t\ttype: "m",\r\n\t\tmandatory: true,\r\n\t\tmultiple: true,\r\n\t\tminver: 1,\r\n\t\tdescription: "Set the EBML characteristics of the data to follow. Each EBML document has to start with this."\r\n\t}\r\n};\r\n\r\nvar byName = {};\r\n\r\nvar schema = {\r\n\tbyEbmlID: byEbmlID,\r\n\tbyName: byName\r\n}\r\n\r\nfor ( var ebmlID in byEbmlID) {\r\n\tvar desc = byEbmlID[ebmlID];\r\n\tbyName[desc.name.replace(\'-\', \'_\')] = parseInt(ebmlID, 10);\r\n}\r\n\r\nmodule.exports = schema;\r\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/matroska/lib/schema.js?')},function(module,exports,__webpack_require__){"use strict";eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(8);\n\nfunction fixStatsType(stat) {\n  return {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  }[stat.type] || stat.type;\n}\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all fieldѕ are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this._localDescription = null;\n    this._remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {\n    configurable: true,\n    get: function() {\n      return this._localDescription;\n    }\n  });\n  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {\n    configurable: true,\n    get: function() {\n      return this._remoteDescription;\n    }\n  });\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // ѕdpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete‥\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function() {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc._localDescription.sdp =\n          SDPUtils.getDescription(pc._localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc._localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||\n          protocol === 'UDP/DTLS/SCTP'))) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          protocol: protocol,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] &&\n          pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        // If the offer contained RTX but the answer did not,\n        // remove RTX from sendEncodingParameters.\n        var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n        var hasRtx = commonCapabilities.codecs.filter(function(c) {\n          return c.name.toLowerCase() === 'rtx';\n        }).length;\n        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n          delete transceiver.sendEncodingParameters[0].rtx;\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc._remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n      }\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      if (transceiver.iceTransport && transceiver.dtlsTransport &&\n          !transceiver.rejected) {\n        states[transceiver.iceTransport.state]++;\n        states[transceiver.dtlsTransport.state]++;\n      }\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' ||\n        pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc._remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt\n            sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n          } else {\n            sdp += 'm=application 0 ' + transceiver.protocol +\n                ' webrtc-datachannel\\r\\n';\n          }\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' +\n              'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' +\n              'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=inactive\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc._remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc._remoteDescription.sdp =\n              SDPUtils.getDescription(pc._remoteDescription.sdp) +\n              sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function(selector) {\n    if (selector && selector instanceof window.MediaStreamTrack) {\n      var senderOrReceiver = null;\n      this.transceivers.forEach(function(transceiver) {\n        if (transceiver.rtpSender &&\n            transceiver.rtpSender.track === selector) {\n          senderOrReceiver = transceiver.rtpSender;\n        } else if (transceiver.rtpReceiver &&\n            transceiver.rtpReceiver.track === selector) {\n          senderOrReceiver = transceiver.rtpReceiver;\n        }\n      });\n      if (!senderOrReceiver) {\n        throw makeError('InvalidAccessError', 'Invalid selector.');\n      }\n      return senderOrReceiver.getStats();\n    }\n\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    return Promise.all(promises).then(function(allStats) {\n      var results = new Map();\n      allStats.forEach(function(stats) {\n        stats.forEach(function(stat) {\n          results.set(stat.id, stat);\n        });\n      });\n      return results;\n    });\n  };\n\n  // fix low-level stat names and return Map instead of object.\n  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',\n    'RTCIceTransport', 'RTCDtlsTransport'];\n  ortcObjects.forEach(function(ortcObjectName) {\n    var obj = window[ortcObjectName];\n    if (obj && obj.prototype && obj.prototype.getStats) {\n      var nativeGetstats = obj.prototype.getStats;\n      obj.prototype.getStats = function() {\n        return nativeGetstats.apply(this)\n        .then(function(nativeStats) {\n          var mapStats = new Map();\n          Object.keys(nativeStats).forEach(function(id) {\n            nativeStats[id].type = fixStatsType(nativeStats[id]);\n            mapStats.set(id, nativeStats[id]);\n          });\n          return mapStats;\n        });\n      };\n    }\n  });\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n\n\n//# sourceURL=webpack:///./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js?")},function(module,exports){eval("window.sdkversion = '1.64.3';\n\n//# sourceURL=webpack:///./config/version.js?")},function(module,exports){eval('// Register core module for accessing Rainbow services\nwindow.app = angular.module("rainbow", ["angular-jwt"]);\nwindow.rainbowAdmin = angular.module("rainbowAdmin", []);\nwindow.rainbow = angular.module("rainbow", ["rainbowAdmin"]);\n\n//# sourceURL=webpack:///./src/rainbowLoader.js?')},function(module,exports,__webpack_require__){eval("__webpack_require__(13);\n\n__webpack_require__(23);\n\n__webpack_require__(24);\n\n__webpack_require__(25);\n\n__webpack_require__(26);\n\n__webpack_require__(27);\n\n__webpack_require__(28);\n\n__webpack_require__(29);\n\n__webpack_require__(30);\n\n__webpack_require__(31);\n\n__webpack_require__(32);\n\n__webpack_require__(33);\n\n__webpack_require__(34);\n\n__webpack_require__(35);\n\n__webpack_require__(36);\n\n__webpack_require__(37);\n\n__webpack_require__(38);\n\n__webpack_require__(39);\n\n__webpack_require__(63);\n\n__webpack_require__(64);\n\n__webpack_require__(65);\n\n__webpack_require__(0);\n\n__webpack_require__(66);\n\n__webpack_require__(67);\n\n__webpack_require__(68);\n\n__webpack_require__(69);\n\n__webpack_require__(70);\n\n__webpack_require__(71);\n\n__webpack_require__(72);\n\n__webpack_require__(73);\n\n__webpack_require__(74);\n\n__webpack_require__(75);\n\n__webpack_require__(76);\n\n__webpack_require__(77);\n\n__webpack_require__(78);\n\n__webpack_require__(79);\n\n__webpack_require__(80);\n\n__webpack_require__(81);\n\n__webpack_require__(82);\n\n__webpack_require__(83);\n\n__webpack_require__(84);\n\n__webpack_require__(85);\n\n__webpack_require__(86);\n\n__webpack_require__(87);\n\n__webpack_require__(88);\n\n__webpack_require__(89);\n\n__webpack_require__(90);\n\n__webpack_require__(91);\n\n__webpack_require__(92);\n\n__webpack_require__(93);\n\n__webpack_require__(94);\n\n__webpack_require__(96);\n\n__webpack_require__(97); // require('./../../dependencies_otliteclient/app/services/telephony/telephonyServiceEventHandlerSipWise');\n\n\n__webpack_require__(98);\n\n__webpack_require__(99);\n\n__webpack_require__(100);\n\n__webpack_require__(101);\n\n__webpack_require__(102);\n\n__webpack_require__(103);\n\n__webpack_require__(104);\n\n__webpack_require__(105);\n\n__webpack_require__(106);\n\n__webpack_require__(107);\n\n__webpack_require__(108);\n\n__webpack_require__(109);\n\n__webpack_require__(110);\n\n__webpack_require__(111);\n\n__webpack_require__(112);\n\n__webpack_require__(113);\n\n__webpack_require__(114);\n\n__webpack_require__(115);\n\n__webpack_require__(116);\n\n__webpack_require__(117);\n\n__webpack_require__(118);\n\n__webpack_require__(119);\n\n__webpack_require__(120);\n\n__webpack_require__(121);\n\n__webpack_require__(122);\n\n__webpack_require__(123);\n\n__webpack_require__(124);\n\n__webpack_require__(125);\n\n__webpack_require__(126);\n\n__webpack_require__(127);\n\n__webpack_require__(128);\n\n__webpack_require__(129);\n\n__webpack_require__(130);\n\n__webpack_require__(131);\n\n__webpack_require__(145);\n\n__webpack_require__(146);\n\n__webpack_require__(147);\n\n__webpack_require__(148);\n\n__webpack_require__(149);\n\n__webpack_require__(150);\n\n//# sourceURL=webpack:///./src/entrypoints/index_otLiteClient.js?")},function(module,exports){eval('/**\n * @class\n * @name AuthSettings\n * @description\n *      This class contains the authentication methods available for an identified user.<br>\n *      Depending of the user\'s Login Policy setttings, it can either login with its RAINBOW account\n *      or thru a Single Sign-On (SSO) solution (for exemple a SAML authentication system) set up \n *      in its enterprise.  \n */\nangular.module("rainbow").factory("AuthSettings", [function () {\n  "use strict";\n\n  AuthSettings.createFromData = function (data) {\n    return new AuthSettings(data);\n  }; // Constructor\n\n\n  function AuthSettings(authURLs) {\n    if (authURLs.length > 0) {\n      if (authURLs.length === 1) {\n        var authSettings = authURLs[0];\n      } else {\n        // If both SAML and RAINBOW authentication methods are available for this user, \n        // RAINBOW login url can be used as a safety url (when SSO login fails)\n        var authSettings = authURLs.reduce(function (settings, authUrl) {\n          if (authUrl.type === "RAINBOW" && settings.type !== "RAINBOW") {\n            settings.safetyUrl = authUrl.url || authUrl.loginUrl;\n            return settings;\n          }\n\n          authUrl.safetyUrl = settings.url || settings.loginUrl;\n          return authUrl;\n        });\n      }\n\n      this.type = authSettings.type;\n      this.loginUrl = authSettings.url || authSettings.loginUrl;\n      this.logoutUrl = authSettings.logoutUrl;\n      this.safetyUrl = authSettings.safetyUrl;\n    }\n    /**\n     * @public\n     * @method setRainbowAppAuth\n     * @memberof authSettings\n     * @description\n     *      Adds the fieldname as extra parameter of the login and/or logout url with the value generated by the function.\n     * @param {String} name the field name to add as parameter\n     * @param {Function} fn the generator function that generated the value.\n     */\n\n\n    this.setParameter = function (name, fn) {\n      switch (name) {\n        case "uid":\n          this.userId = fn(); // the Rainbow user unique identifier: typicaly his login email\n\n          break;\n\n        case "x-rainbow-app-auth":\n          // Extra HTTP request header must be passed in URL.\n          // If SAML authentication method is used for this user, extra login request fields must be passed in the url. \n          if (this.type !== "RAINBOW" && this.loginUrl) {\n            var url = new URL(this.loginUrl);\n            var passkey = url.searchParams.get("challenge");\n            var appAuth = fn(passkey);\n            url.searchParams.append(name, appAuth); // single URL parameter value is encoded\n\n            this.loginUrl = url.href;\n          }\n\n          break;\n\n        case "token":\n          if (this.type !== "RAINBOW" && this.logoutUrl) {\n            var url = new URL(this.logoutUrl);\n            var tkn = fn();\n            url.searchParams.append(name, tkn); // single URL parameter value is encoded\n\n            this.logoutUrl = url.href;\n          }\n\n          break;\n\n        case "safetyUrl":\n          // force a safety login url, if not already set, when SSO login is enabled for the identified user\n          if (this.type !== "RAINBOW" && !this.safetyUrl) {\n            this.safetyUrl = fn();\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    };\n  }\n\n  return AuthSettings;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/authSettings.js?')},function(module,exports){eval('function RBError(message, details, detailsCode, detailsData) {\n  this.name = "RainbowError";\n  this.message = message;\n  this.details = details;\n  this.detailsCode = detailsCode;\n  this.detailsData = detailsData;\n  this.stack = new Error().stack;\n}\n\nRBError.prototype = Object.create(Error.prototype);\nRBError.prototype.constructor = RBError;\nwindow.RBError = RBError;\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/error.js?')},function(module,exports){eval('/**\n * @class\n * @name Company\n * @description\n *      This class is used to represent a company in Rainbow.<br>\n *      A company is a set of Rainbow users grouped in that entity<br>\n *      A company is managed by one or several administrators<br>\n *      A company can be visible by users that are not inside this company of not<br>\n */\nangular.module("rainbow").factory("Company", [function () {\n  "use strict";\n  /**\n   * @private\n   */\n\n  Company.createFromData = function (data) {\n    return new Company(data);\n  };\n  /**\n   * @private\n   */\n\n\n  Company.create = function (id, name) {\n    return new Company({\n      id: id,\n      name: name\n    });\n  };\n  /**\n   * Returns a copy of the company\'s data but expurgated by the unwanted and undefined optional properties.\n   * @private\n   */\n\n\n  Company.prune = function (data, userContact) {\n    var dataCopy = Object.assign({}, data); // Remove readonly fields\n\n    delete dataCopy.dataLocation; // Note: if the property bpId is null, we send it (used when bpType changes from IR to DR or VAD)\n\n    if (!dataCopy.isBP) {\n      // these fields are only applicable if isBP is true.\n      delete dataCopy.bpType;\n      delete dataCopy.bpBusinessModel;\n      delete dataCopy.bpApplicantNumber;\n      delete dataCopy.bpCRDid;\n      delete dataCopy.bpHasRightToSell;\n      delete dataCopy.bpHasRightToConnect;\n      delete dataCopy.bpIsContractAccepted;\n    }\n\n    if (!userContact || !userContact.isSuperadmin() && !userContact.isBPAdminFinance()) {\n      // these fields can\'t be set if the user is not a "superadmin" or a "bp_finance".\n      delete dataCopy.bpType;\n      delete dataCopy.adminHasRightToUpdateSubscriptions;\n      delete dataCopy.adminAllowedUpdateSubscriptionsOps;\n    }\n\n    if (!userContact || !userContact.isSuperadmin()) {\n      // these fields can\'t be set if the user is not a "superadmin"\n      delete dataCopy.superadminComment;\n    }\n\n    if (dataCopy.economicActivityClassification === "") {\n      delete dataCopy.economicActivityClassification;\n    }\n\n    if (!userContact || !userContact.isSuperadmin() && (dataCopy.supportEmail === null || dataCopy.supportEmail === "")) {\n      delete dataCopy.supportEmail;\n    }\n\n    if (!userContact || !userContact.isSuperadmin() && (dataCopy.privateDC === null || dataCopy.privateDC === "")) {\n      delete dataCopy.privateDC;\n    }\n\n    return dataCopy;\n  };\n  /**\n   * @public\n   * @enum {string}\n   * @readonly\n   * @description\n   * Value can be:<br>\n   * - \'initializing\': When the company is initializing,<br>\n   * - \'active\': When the company is active,<br>\n   * - \'terminated\': When the company is closed\n   */\n\n\n  Company.StatusValues = ["initializing", "active", "alerting", "hold", "terminated"];\n  /**\n   * @public\n   * @enum {string}\n   * @readonly\n   * @description\n   * Value can be:\n   * - \'private\': When the users of this company are not visible from an external user,<br>\n   * - \'organization\': When the users of this company are only visible from an extenal user of the same organization,<br>\n   * - \'public\': When the users of this company are visible from an external user\n   */\n\n  Company.VisibilityValuesWithOrganization = ["public", "private", "organization", "closed", "isolated"];\n  Company.VisibilityValues = ["public", "private", "closed", "isolated"];\n  /**\n   * @public\n   * @enum {string}\n   * @readonly\n   * @description\n   * Value can be:<br>\n   * - \'self-employed\': For a single person company,<br>\n   * - \'1-10 employees\': For a company with 1 to 10 employees,<br>\n   * - "11-50 employees": For a company with 11 to 50 employees,<br>\n   * - "51-200 employees": For a company with 51 to 200 employees,<br>\n   * - "201-500 employees": For a company with 201 to 500 employees,<br>\n   * - "501-1000 employees": For a company with 501 to 1000 employees,<br>\n   * - "1001-5000 employees": For a company with 1001 to 5000 employees,<br>\n   * - "5001-10,000 employees": For a company with 5001 to 10,000 employees,<br>\n   * - "10,001+ employees": For a company with more than 10000 employees\n   */\n\n  Company.SizeValues = ["self-employed", "1-10 employees", "11-50 employees", "51-200 employees", "201-500 employees", "501-1000 employees", "1001-5000 employees", "5001-10,000 employees", "10,001+ employees"];\n  /**\n   * @private\n   * @enum {string}\n   * @readonly\n   */\n\n  Company.OfferTypes = [\n  /** Freemium company */\n  "freemium",\n  /** Premium company */\n  "premium"];\n  /**\n   * @public\n   * @enum {string}\n   * @readonly\n   * @description\n   * Value can be:<br>\n   * - \'VAD\': For Business Partner who is a  Value Added Distributor,<br>\n   * - \'DR\': For Business Partner who is a Direct Reseller,<br>\n   * - \'IR\': For Business Partner who is an Indirect Reseller\n   */\n\n  Company.BPTypes = ["VAD", "DR", "IR"];\n  /**\n   * @private\n   */\n\n  Company.BPTypeLabels = {\n    IR: "Indirect Reseller",\n    VAD: "Value Added Distributor",\n    DR: "Direct Reseller"\n  };\n  /**\n   * @public\n   * @enum {string}\n   */\n\n  Company.BPBusinessModels = [\n  /** Business Parner model is \'Resell\' */\n  "resell"]; //, "referral"];\n\n  /**\n   * @private\n   */\n\n  Company.BPBusinessModelLabels = {\n    resell: "Resell",\n    referral: "Referral"\n  };\n  /**\n   * @public\n   * @enum {string}\n   * @readonly\n   * @description\n   * Value can be:<br>\n   * - \'all\': Admin of this company is allowed to downgrade and upgrade the number of subscriptions,<br>\n   * - \'increase_only\': Admin of this company is only allowed to increase the number of subscriptions\n   */\n\n  Company.adminAllowedUpdateSubscriptionsOperations = ["all", "increase_only"];\n  /**\n   * @public\n   * @enum {Object}\n   * @readonly\n   */\n\n  Company.BPBusinessTypes = {\n    DEFAULT: "default",\n    VOICE_BY_ALE: "voice_by_ale",\n    VOICE_BY_PARTNER: "voice_by_partner",\n    CONFERENCE: "conference"\n  };\n  /**\n   * @public\n   * @enum {Object}\n   * @readonly\n   */\n\n  Company.EconomicActivityClassificationTypes = {\n    /** Not defined */\n    NONE: "notDefined-f",\n\n    /** Agriculture based activity */\n    A: "agriculture",\n\n    /** Mining based activity */\n    B: "mining",\n\n    /** Manifacturing based activity */\n    C: "manufacturing",\n\n    /** Electricity based activity */\n    D: "electricity",\n\n    /** Water supply based activity */\n    E: "water supply",\n\n    /** Construction based activity */\n    F: "construction",\n\n    /** Wholesale based activity */\n    G: "wholesale",\n\n    /** Transportation based activity */\n    H: "transportation",\n\n    /** Accomodation based activity */\n    I: "accommodation",\n\n    /** Information and communication based activity */\n    J: "information and communication",\n\n    /** Financial based activity */\n    K: "financial",\n\n    /** Real estate based activity */\n    L: "real estate activities",\n\n    /** Professional based activity */\n    M: "professional",\n\n    /** Administrative based activity */\n    N: "administrative",\n\n    /** Public administration based activity */\n    O: "public administration",\n\n    /** Education based activity */\n    P: "education",\n\n    /** Human health based activity */\n    Q: "human health",\n\n    /** Arts based activity */\n    R: "arts",\n\n    /** Other service based activity */\n    S: "other service activities",\n\n    /** Activities of households as employer based activity */\n    T: "activities of households as employer",\n\n    /** Activities of extraterritorial organisations and bodies based activity */\n    U: "activities of extraterritorial organisations and bodies"\n  }; // Private Data Center values\n\n  Company.PrivateDCValues = ["HDS"];\n  Company.attributes = [{\n    name: "id",\n    defaultValue: undefined\n  }, {\n    name: "name",\n    defaultValue: ""\n  }, {\n    name: "companyContactId",\n    defaultValue: undefined\n  }, {\n    name: "adminEmail",\n    defaultValue: ""\n  }, {\n    name: "supportEmail",\n    defaultValue: undefined\n  }, {\n    name: "status",\n    defaultValue: "active"\n  }, {\n    name: "economicActivityClassification",\n    defaultValue: "NONE"\n  }, {\n    name: "website",\n    defaultValue: undefined\n  }, {\n    name: "description",\n    defaultValue: undefined\n  }, {\n    name: "visibility",\n    defaultValue: "private"\n  }, {\n    name: "visibleBy",\n    defaultValue: []\n  }, {\n    name: "organisationId",\n    defaultValue: ""\n  }, {\n    name: "userSelfRegisterEnabled",\n    defaultValue: false\n  }, {\n    name: "userSelfRegisterAllowedDomains",\n    defaultValue: []\n  }, {\n    name: "offerType",\n    defaultValue: "freemium"\n  }, {\n    name: "country",\n    defaultValue: undefined\n  }, {\n    name: "state",\n    defaultValue: null\n  }, {\n    name: "size",\n    defaultValue: undefined\n  }, {\n    name: "slogan",\n    defaultValue: undefined\n  }, {\n    name: "isBP",\n    defaultValue: false\n  }, {\n    name: "bpType",\n    defaultValue: undefined\n  }, {\n    name: "bpBusinessModel",\n    defaultValue: undefined\n  }, {\n    name: "bpApplicantNumber",\n    defaultValue: undefined\n  }, {\n    name: "bpCRDid",\n    defaultValue: undefined\n  }, {\n    name: "bpHasRightToSell",\n    defaultValue: undefined\n  }, {\n    name: "bpId",\n    defaultValue: undefined\n  }, {\n    name: "bpHasRightToConnect",\n    defaultValue: undefined\n  }, {\n    name: "adminHasRightToUpdateSubscriptions",\n    defaultValue: false\n  }, {\n    name: "adminAllowedUpdateSubscriptionsOps",\n    defaultValue: "all"\n  }, {\n    name: "externalReference",\n    defaultValue: undefined\n  }, {\n    name: "externalReference2",\n    defaultValue: undefined\n  }, {\n    name: "lastAvatarUpdateDate",\n    defaultValue: null\n  }, {\n    name: "lastBannerUpdateDate",\n    defaultValue: null\n  }, {\n    name: "avatarShape",\n    defaultValue: "circle"\n  }, {\n    name: "catalogId",\n    defaultValue: undefined\n  }, {\n    name: "office365Tenant",\n    defaultValue: undefined\n  }, {\n    name: "isCentrex",\n    defaultValue: undefined\n  }, {\n    name: "tenantCallNumber",\n    defaultValue: undefined\n  }, {\n    name: "tenantName",\n    defaultValue: undefined\n  }, {\n    name: "numberUsers",\n    defaultValue: undefined\n  }, {\n    name: "giphyEnabled",\n    defaultValue: true\n  }, {\n    name: "dataLocation",\n    defaultValue: undefined\n  }, {\n    name: "privateDC",\n    defaultValue: undefined\n  }, {\n    name: "superadminComment",\n    defaultValue: undefined\n  }, // Free field that only superadmin can use.\n  {\n    name: "bpBusinessType",\n    defaultValue: []\n  }, {\n    name: "voIPSettings",\n    defaultValue: undefined\n  }];\n\n  Company.prototype.getNameForLogs = function () {\n    if (!this.nameForLogs && this.name) {\n      var temp = this.name.replace(/[^\\s](?=.{1,}$)/g, "*");\n      this.nameForLogs = this.name.charAt(0) + temp.substr(1);\n    }\n\n    return this.nameForLogs;\n  };\n  /**\n   * @this Company\n   */\n\n\n  function Company(data) {\n    //Generic initialization of attrbutes values from received data or default values\n    var _this = this;\n\n    Company.attributes.forEach(function (attribute) {\n      if (angular.isDefined(data[attribute.name])) {\n        // The attribute is present in the received data object : we take the value received in data object\n        _this[attribute.name] = data[attribute.name];\n      } else if (angular.isDefined(attribute.defaultValue)) {\n        // The attribute is not present in the received data object, and this attribute has a defined default value\n        // We take the defined default value\n        _this[attribute.name] = attribute.defaultValue;\n      }\n    }); //Specific initialization of some attrbutes values\n\n    /**\n     * @private\n     * @property {string} state The company US state when country is \'USA\' or \'CAN\',\n     * @readonly\n     */\n\n    this.state = data.state ? data.state : data.country === "USA" ? "AL" : data.country === "CAN" ? "AB" : null;\n    /**\n     * @public\n     * @property {string} logo The company logo\n     * @since 1.20\n     * @readonly\n     */\n\n    this.logo = null;\n    /**\n     * @public\n     * @property {string} filterName\n     * @readonly\n     */\n\n    this.filterName = this.name.toLowerCase();\n    /**\n     * @private\n     * @method\n     * @description updateFromData Allow to update an existing company with data from server\n     */\n\n    this.updateFromData = function (newData) {\n      Company.attributes.forEach(function (attribute) {\n        if (angular.isDefined(newData[attribute.name])) {\n          // The attribute is present in the received data object : we take the value received in data object\n          _this[attribute.name] = newData[attribute.name];\n        } // If the attribute is not present in the received data object, we don\'t touch the current attribute value\n\n      });\n    };\n    /**\n     * @public\n     * @property {string} nameForLogs\n     * @readonly\n     */\n\n\n    this.nameForLogs = "";\n    /**\n     * @public\n     * @method\n     * @instance\n     * @return {boolean} True if the company is active\n     * @description\n     *      Return the status of the company\n     */\n\n    this.isActive = function () {\n      return this.status === "active";\n    };\n    /**\n     * @private\n     */\n\n\n    this.isInitializing = function () {\n      return this.status === "initializing";\n    };\n\n    this.isInvited = function () {\n      return this.status === "invited";\n    };\n    /**\n     * @public\n     * @return {boolean} true if the company in the Freemium business model, otherwise false.\n     */\n\n\n    this.isFreemium = function () {\n      return this.offerType === "freemium";\n    };\n    /**\n     * @public\n     * @return {boolean} true if the company has contracted the Premium Plan, otherwise false.\n     */\n\n\n    this.isPremium = function () {\n      return this.offerType === "premium";\n    };\n    /**\n     * @public\n     * @return {boolean} true if the company is a Value Added Distributor (VAD) Business Partner company, otherwise false.\n     */\n\n\n    this.isVAD = function () {\n      return this.isBP && this.bpType === "VAD";\n    };\n    /**\n     * @public\n     * @return {boolean} true if the company is an Indirect Reseller (IR) Business Partner company, otherwise false.\n     */\n\n\n    this.isIR = function () {\n      return this.isBP && this.bpType === "IR";\n    };\n    /**\n     * @public\n     * @return {boolean} true if the company is a Direct Reseller (DR) Business Partner company, otherwise false.\n     */\n\n\n    this.isDR = function () {\n      return this.isBP && this.bpType === "DR";\n    };\n    /**\n     * @public\n     * @return {boolean} true if the company is End Customer (EC) company, otherwise false.\n     */\n\n\n    this.isEC = function () {\n      return !this.isBP;\n    };\n  }\n\n  return Company;\n}]); // Adaptation filters\n\nangular.module("rainbow").filter("companyOfferFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "freemium") {\n      return "Freemium";\n    }\n\n    if (input === "premium") {\n      return "Premium";\n    }\n\n    if (input) {\n      return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();\n    }\n\n    return input;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/company.js?')},function(module,exports){eval('/**\n * @class\n * @name CompanyInvitation\n * @private\n * @description\n *      This class is used to represent an company invitation<br/>\n */\nangular.module("rainbow").factory("CompanyInvitation", [function () {\n  "use strict";\n  /*************************************************************/\n\n  /* STATIC FACTORY                                            */\n\n  /*************************************************************/\n\n  CompanyInvitation.createFromData = function (data) {\n    var companyInvitation = new CompanyInvitation(data.id, data.companyId, data.companyName, data.invitedUserId, data.invitedUserEmail, data.invitingAdminId, data.invitingAdminLoginEmail, data.invitationDate, data.lastNotificationDate, data.requestedNotificationLanguage, data.status, data.acceptationDate, data.declinationDate, data.invitedToBeCompanyAdmin);\n    return companyInvitation;\n  };\n  /*************************************************************/\n\n  /* INVITATION CONSTRUCTOR                                    */\n\n  /*************************************************************/\n\n  /**\n   * @this CompanyInvitation\n   */\n\n\n  function CompanyInvitation(id, companyId, companyName, invitedUserId, invitedUserEmail, invitingAdminId, invitingAdminLoginEmail, invitationDate, lastNotificationDate, requestedNotificationLanguage, status, acceptationDate, declinationDate, invitedToBeCompanyAdmin) {\n    /**\n     * @public\n     * @property {string} join company invitation unique Id\n     * @readonly\n     */\n    this.id = id;\n    /**\n     * @public\n     * @property {string} Id of the company for which the join company invitation is\n     * @readonly\n     */\n\n    this.companyId = companyId;\n    /**\n     * @public\n     * @property {string} Name of the company for which the join company invitation is\n     * @readonly\n     */\n\n    this.companyName = companyName;\n    /**\n     * @public\n     * @property {string} Unique Id of the Rainbow user invited to join the company\n     * @readonly\n     */\n\n    this.invitedUserId = invitedUserId;\n    /**\n     * @private\n     * @property {string} Email of the Rainbow user invited to join the company\t\t\t \n     * @readonly\n     */\n\n    this.invitedUserEmail = invitedUserEmail;\n    /**\n     * @private\n     * @property {string} Inviting company admin unique Rainbow Id\n     * @readonly\n     */\n\n    this.invitingAdminId = invitingAdminId; // Status\n\n    /**\n     * @private\n     * @property {string} Inviting company admin loginEmail\t \n     * @readonly\n     */\n\n    this.invitingAdminLoginEmail = invitingAdminLoginEmail;\n    /**\n    * @public\n    * @property {string} Date the join company invitation was created\n    * @readonly\n    */\n\n    this.invitationDate = invitationDate;\n    /**\n     * @public\n     * @property {string} lastNotificationDate The date when the last email notification was sent.\n     * @readonly\n     */\n\n    this.lastNotificationDate = lastNotificationDate;\n    /**\n     * @public\n     * @property {string} requestedNotificationLanguage Requested notification language.\n     * @readonly\n     */\n\n    this.requestedNotificationLanguage = requestedNotificationLanguage;\n    /**\n     * @public\n     * @property {string} status Join company invitation status.\n     * @readonly\n     */\n\n    this.status = status;\n    /**\n     * @public\n     * @property {string} acceptationDate Date when the join company invitation has been accepted by the user.\n     * @readonly\n     */\n\n    this.acceptationDate = acceptationDate;\n    /**\n     * @public\n     * @property {string} declinationDate Date when the join company invitation has been declined by the user.\n     * @readonly\n     */\n\n    this.declinationDate = declinationDate;\n    /**\n     * @public\n     * @property {boolean} invitedToBeCompanyAdmin If invitedToBeCompanyAdmin is set to true, when user accepts the join company invitation he will be company_admin of this company..\n     * @since 1.24.3\n     * @readonly\n     */\n\n    this.invitedToBeCompanyAdmin = invitedToBeCompanyAdmin;\n  }\n\n  return CompanyInvitation;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/companyInvitation.js?')},function(module,exports){eval('class FileState {\n}\nFileState.DELETED = "deleted";\nFileState.UPLOADING = "uploading";\nFileState.UPLOADED = "uploaded";\nFileState.NOT_UPLOADED = "not_uploaded";\nFileState.DOWNLOADING = "downloading";\nFileState.UNKNOWN = "unknown";\nclass ThumbnailPlaceholder {\n    constructor(icon, style) {\n        this.icon = icon;\n        this.style = style;\n    }\n}\nclass Thumbnail {\n    /**\n     * @this FileDescriptor\n     */\n    constructor(data) {\n        if (data) {\n            this.availableThumbnail = data.availableThumbnail;\n            this.md5sum = data.md5sum;\n            this.size = data.size;\n            this.wantThumbnailDate = data.wantThumbnailDate;\n        }\n        else {\n            this.availableThumbnail = false;\n        }\n    }\n    isThumbnailAvailable() {\n        return this.availableThumbnail;\n    }\n    ;\n}\n/**\n * @public\n * @class\n * @name FileDescriptor\n * @description\n *      This class is used to represent a File Descriptor or a Short File Descriptor which describes a file shared in a conversation (one-to-one or bubble).\n */\nclass FileDescriptor {\n    /**\n     * @this FileDescriptor\n     */\n    constructor(id = null, url = null, ownerId = null, fileName = null, extension = null, typeMIME = null, size = null, registrationDate = null, uploadedDate = null, dateToSort = null, viewers = null, state = null, thumbnail = null, orientation = 0, tags = null, virusScanState = null, voiceMessage = false) {\n        /**\n         * @public\n         * @property {string} id The file descriptor ID (File Descriptor only)\n         * @readonly\n         */\n        this.id = id;\n        /**\n         * @public\n         * @property {string} url The file descriptor url (File Descriptor only)\n         * @readonly\n         */\n        this.url = url;\n        /**\n         * @public\n         * @property {string} ownerId The ID of the owner (File Descriptor only)\n         * @readonly\n        */\n        this.ownerId = ownerId;\n        /**\n         * @public\n         * @property {string} fileName The name of the file\n         * @readonly\n        */\n        this.fileName = fileName;\n        /**\n         * @public\n         * @property {string} extension The extension of the file\n         * @readonly\n        */\n        this.extension = extension;\n        /**\n         * @public\n         * @property {string} typeMIME The mime type of the file (\'mime\' in Short File Descriptor)\n         * @readonly\n        */\n        this.typeMIME = typeMIME;\n        /**\n        * @public\n        * @property {ThumbnailPlaceholder} thumbnailPlaceholder The thumbnail icon placeholder info\n        * @readonly\n        */\n        this.thumbnailPlaceholder = this.getThumbnailPlaceholderFromMimetype(typeMIME);\n        /**\n         * @public\n         * @property {string} size The size of the file (octets)\n         * @readonly\n        */\n        this.size = size;\n        /**\n         * @public\n         * @property {Object} registrationDate The creation date (File Descriptor only)\n         * @readonly\n        */\n        this.registrationDate = registrationDate;\n        /**\n         * @public\n         * @property {Object} uploadedDate The upload date (File Descriptor only)\n         * @readonly\n        */\n        this.uploadedDate = uploadedDate;\n        /**\n         * @private\n         * @property {Object} dateToSort The date to sort (?)\n         * @readonly\n        */\n        this.dateToSort = dateToSort;\n        /**\n         * @public\n         * @property {any[]} viewers The list of viewers (File Descriptor only)\n         * @readonly\n        */\n        this.viewers = viewers;\n        this.state = state;\n        this.thumbnail = new Thumbnail(thumbnail);\n        this.fileToSend = undefined;\n        this.previewBlob = undefined;\n        /**\n         * @private\n         * @property {Object} tags data for visual voice mails\n         * @readonly\n        */\n        this.tags = tags;\n        /**\n         * @public\n         * @property {number} orientation\n         * @description\n         *      There are four possible values for orientation and the image should be rotated acording to this value.\n         *      1 -> rotate(0deg),\n         *      3 -> rotate(180deg),\n         *      6 -> rotate(90deg),\n         *      8 -> rotate(270deg).\n        */\n        this.orientation = orientation ? orientation : undefined;\n        /**\n        * @public\n        * @property {string} virusScanState Result of virus scan\n        * @readonly\n       */\n        this.virusScanState = virusScanState;\n        /**\n        * @public\n        * @property {boolean} voiceMessage Result of virus scan\n        * @readonly\n       */\n        this.voiceMessage = voiceMessage;\n    }\n    ;\n    isMicrosoftFile() {\n        let mediaExtension = ["docx", "doc", "ppt", "pptx", "xls", "xlsx"];\n        return (mediaExtension.some((ext) => ext === this.extension));\n    }\n    ;\n    isThumbnailPossible() {\n        return (this.isImage() || this.isPDF());\n    }\n    ;\n    isPDF() {\n        return (this.typeMIME === "application/pdf");\n    }\n    ;\n    isImage() {\n        let imgType = "image/";\n        return this.typeMIME && this.typeMIME.length >= imgType.length && this.typeMIME.slice(0, imgType.length) === imgType;\n    }\n    ;\n    isAudioVideo() {\n        let mediaExtension = ["avi", "mpg", "wma", "mp3", "wmv", "mkv", "mov", "wav", "ogg", "mp4", "aac"];\n        return (mediaExtension.some((ext) => ext === this.extension));\n    }\n    ;\n    isUploaded() {\n        let imgType = "image/";\n        return this.state && this.state === FileState.UPLOADED;\n    }\n    ;\n    isAlreadyFileViewer(viewerId) {\n        if (this.ownerId && this.ownerId === viewerId) {\n            // We are owner of this file\n            return true;\n        }\n        if (this.viewers) {\n            return this.viewers.some((viewer) => viewer.viewerId === viewerId);\n        }\n        return false;\n    }\n    getDisplayName() {\n        return this.fileName.replace(/\\.[^/.]+$/, "");\n    }\n    getDisplayNameTruncated() {\n        var str = this.fileName.replace(/\\.[^/.]+$/, "");\n        return [str.substring(0, str.length - 4), str.slice(-4)];\n    }\n    getExtension() {\n        if (this.fileName.toUpperCase() === this.extension.toUpperCase()) {\n            return "";\n        }\n        else {\n            return "." + this.extension;\n        }\n    }\n    getThumbnailPlaceholderFromMimetype(mime) {\n        if (!mime) {\n            return new ThumbnailPlaceholder(\'icon_filestandard\', \'otherStyle\');\n        }\n        if (mime.indexOf("image") === 0) {\n            return new ThumbnailPlaceholder(\'icon_image\', \'imageStyle\');\n        }\n        if (mime === "application/msword" ||\n            (/^application\\/vnd.openxmlformats-officedocument.wordprocessingml.*$/.test(mime)) ||\n            mime === "application/vnd.oasis.opendocument.text") {\n            return new ThumbnailPlaceholder(\'icon_doc\', \'docStyle\');\n        }\n        if (/^application\\/vnd.ms-powerpoint.*$/.test(mime) ||\n            (/^application\\/vnd.openxmlformats-officedocument.presentationml.*$/.test(mime)) ||\n            mime === "application/vnd.oasis.opendocument.presentation") {\n            return new ThumbnailPlaceholder(\'icon_ppt\', \'pptStyle\');\n        }\n        if (mime.indexOf("application/vnd.ms-excel") === 0 ||\n            (/^application\\/vnd.openxmlformats-officedocument.spreadsheetml.*$/.test(mime))) {\n            return new ThumbnailPlaceholder(\'icon_xls\', \'xlsStyle\');\n        }\n        if (mime === "application/pdf" || mime === "application/vnd.oasis.opendocument.spreadsheet") {\n            return new ThumbnailPlaceholder(\'icon_pdf\', \'pdfStyle\');\n        }\n        if (mime.indexOf("video/") === 0 || mime.indexOf("audio/") === 0) {\n            return new ThumbnailPlaceholder(\'icon_file-video\', \'imageStyle\');\n        }\n        return new ThumbnailPlaceholder(\'icon_filestandard\', \'otherStyle\');\n    }\n    ;\n    releaseURL() {\n        this.localURL = undefined;\n    }\n}\nfunction FileDescriptorFactory() {\n    return (id, url, ownerId, fileName, extension, typeMIME, size, registrationDate, uploadedDate, dateToSort, viewers, state, thumbnail, orientation, tags, virusScanState, voiceMessage) => {\n        return new FileDescriptor(id, url, ownerId, fileName, extension, typeMIME, size, registrationDate, uploadedDate, dateToSort, viewers, state, thumbnail, orientation, tags, virusScanState, voiceMessage);\n    };\n}\nangular.module("rainbow").factory("fileDescriptorFactory", [FileDescriptorFactory]);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/fileDescriptor.ts?')},function(module,exports){eval('class FileViewerType {\n}\nFileViewerType.USER = "user";\nFileViewerType.ROOM = "room";\n/**\n * @public\n * @class\n * @name FileViewer\n * @description\n *      This class is used to represent a File Viewer who is the list of persons (individual or a bubble) that can access (download) the file.\n */\nclass FileViewer {\n    /**\n     * @this FileViewer\n     */\n    constructor(viewerId, type, contact, contactService = null, channelService = null) {\n        this.contactService = contactService;\n        this.channelService = channelService;\n        /**\n         * @public\n         * @property {String} viewerId The id of the viewer\n         * @readonly\n         */\n        this.viewerId = viewerId;\n        /**\n         * @public\n         * @property {string} type The type of viewer: \'user\' for a contact or \'room\' for a bubble\n         * @readonly\n         */\n        this.type = type;\n        /**\n         * @public\n         * @property {Contact} contact The contact\n         * @readonly\n         */\n        this.contact = contact;\n    }\n    get avatarSrc() {\n        if (this.type === "user" && this.contact) {\n            this._avatarSrc = this.contact.avatar.src;\n        }\n        else if (this.type === "channel" && this.channel) {\n            this._avatarSrc = this.channel.getAvatarSrc();\n        }\n        else {\n            this._avatarSrc = null;\n            if (this.type === "user") {\n                this.contactService.getContactByDBId(this.viewerId)\n                    .then((contact) => {\n                    this.contact = contact;\n                    this._avatarSrc = this.contact.avatar.src;\n                });\n            }\n            if (this.type === "channel") {\n                let channel = this.channelService.getChannelFromCache(this.viewerId, false);\n                if (channel) {\n                    this.channel = channel;\n                    this._avatarSrc = this.channel.getAvatarSrc();\n                }\n            }\n        }\n        return this._avatarSrc;\n    }\n}\nfunction FileViewerFactory() {\n    return (data) => {\n        let viewers = [];\n        for (let viewerData of data) {\n            viewers.push(new FileViewer(viewerData.viewerId, viewerData.type, viewerData.contact, viewerData.contactService, viewerData.channelService));\n        }\n        return viewers;\n    };\n}\nfunction FileViewerElementFactory() {\n    return (viewerId, type, contact, contactService, channelService) => {\n        return new FileViewer(viewerId, type, contact, contactService, channelService);\n    };\n}\nangular.module("rainbow").factory("fileViewerFactory", [FileViewerFactory]);\nangular.module("rainbow").factory("fileViewerElementFactory", [FileViewerElementFactory]);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/fileViewer.ts?')},function(module,exports){eval('/**\n * @class\n * @name CompanyRequest\n * @private\n * @description\n *      This class is used to represent an company request<br/>\n */\nangular.module("rainbow").factory("CompanyRequest", [function () {\n  "use strict";\n  /*************************************************************/\n\n  /* STATIC FACTORY                                            */\n\n  /*************************************************************/\n\n  CompanyRequest.createFromData = function (data) {\n    var companyRequest = new CompanyRequest(data.id, data.requestingUserId, data.requestingUserLoginEmail, data.requestedCompanyId, data.requestedCompanyName, data.status, data.requestingDate, data.requestedNotificationLanguage, data.lastNotificationDate, data.requestedToCompanyAdmin, data.requestedCompanyInvitationId);\n    return companyRequest;\n  };\n  /*************************************************************/\n\n  /* INVITATION CONSTRUCTOR                                  */\n\n  /*************************************************************/\n\n  /**\n   * @this CompanyRequest\n   */\n\n\n  function CompanyRequest(id, requestingUserId, requestingUserLoginEmail, requestedCompanyId, requestedCompanyName, status, requestingDate, requestedNotificationLanguage, lastNotificationDate, requestedToCompanyAdmin, requestedCompanyInvitationId) {\n    /**\n     * @public\n     * @property {string} join company request unique Id\n     * @readonly\n     */\n    this.id = id;\n    /**\n     * @public\n     * @property {string} Requesting user unique Rainbow Id\n     * @readonly\n     */\n\n    this.requestingUserId = requestingUserId;\n    /**\n     * @public\n     * @property {string} Requesting user email\n     * @readonly\n     */\n\n    this.requestingUserLoginEmail = requestingUserLoginEmail;\n    /**\n     * @public\n     * @property {string} Unique Id of the company the requesting user wants to join\n     * @readonly\n     */\n\n    this.requestedCompanyId = requestedCompanyId;\n    /**\n     * @private\n     * @property {string} Name of the company the requesting user wants to join\t\t\t \n     * @readonly\n     */\n\n    this.requestedCompanyName = requestedCompanyName;\n    /**\n     * @private\n     * @property {string} request status\n     * @readonly\n     */\n\n    this.status = status; // Status\n\n    /**\n     * @private\n     * @property {string} Date the request was created \n     * @readonly\n     */\n\n    this.requestingDate = requestingDate;\n    /**\n    * @public\n    * @property {string} Requested notification language to use if language of company adminis not defined\n    * @readonly\n    */\n\n    this.requestedNotificationLanguage = requestedNotificationLanguage;\n    /**\n     * @public\n     * @property {Date} Date when the last email notification was sent.\n     * @readonly\n     */\n\n    this.lastNotificationDate = lastNotificationDate;\n    /**\n     * @public\n     * @property {object} If the request was sent to a company administrator.\n     * @readonly\n     */\n\n    this.requestedToCompanyAdmin = requestedToCompanyAdmin;\n    /**\n     * @public\n     * @property {string} if the request was sent using a joinCompanyInviteId.\n     * @readonly\n     */\n\n    this.requestedCompanyInvitationId = requestedCompanyInvitationId;\n  }\n\n  return CompanyRequest;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/companyRequest.js?')},function(module,exports){eval('/**\n * @class\n * @name CompanyBpLinkInvitation\n * @private\n * @description\n *      This class is used to represent an company invitation<br/>\n */\nangular.module("rainbow").factory("CompanyBpLinkInvitation", [function () {\n  "use strict";\n  /*************************************************************/\n\n  /* STATIC FACTORY                                            */\n\n  /*************************************************************/\n\n  CompanyBpLinkInvitation.createFromData = function (data) {\n    var companyBpLinkInvitation = new CompanyBpLinkInvitation(data.id, data.invitedCompanyId, data.invitedCompanyName, data.invitedToBeBpIr, data.invitingAdminId, data.invitingAdminLoginEmail, data.invitingCompanyId, data.invitingCompanyName, data.invitationDate, data.lastNotificationDate, data.requestedNotificationLanguage, data.status, data.acceptationDate, data.cancelationDate, data.declinationDate);\n    return companyBpLinkInvitation;\n  };\n  /*************************************************************/\n\n  /* INVITATION CONSTRUCTOR                                    */\n\n  /*************************************************************/\n\n  /**\n   * @this CompanyBpLinkInvitation\n   */\n\n\n  function CompanyBpLinkInvitation(id, invitedCompanyId, invitedCompanyName, invitedToBeBpIr, invitingAdminId, invitingAdminLoginEmail, invitingCompanyId, invitingCompanyName, invitationDate, lastNotificationDate, requestedNotificationLanguage, status, acceptationDate, cancelationDate, declinationDate) {\n    /**\n     * @public\n     * @property {string} company invitation unique Id\n     * @readonly\n     */\n    this.id = id;\n    /**\n     * @public\n     * @property {string} Id of the invited company\n     * @readonly\n     */\n\n    this.invitedCompanyId = invitedCompanyId;\n    /**\n     * @public\n     * @property {string} Name of the invited company\n     * @readonly\n     */\n\n    this.invitedCompanyName = invitedCompanyName;\n    /**\n     * @public\n     * @property {boolean} true when the invited company is proposed to become IR BP\n     * @readonly\n     */\n\n    this.invitedToBeBpIr = invitedToBeBpIr;\n    /**\n     * @private\n     * @property {string} Inviting company admin unique Rainbow Id\n     * @readonly\n     */\n\n    this.invitingAdminId = invitingAdminId; // Status\n\n    /**\n     * @private\n     * @property {string} Inviting company admin loginEmail\t \n     * @readonly\n     */\n\n    this.invitingAdminLoginEmail = invitingAdminLoginEmail;\n    /**\n     * @public\n     * @property {string} Id of the inviting company\n     * @readonly\n     */\n\n    this.invitingCompanyId = invitingCompanyId;\n    /**\n     * @public\n     * @property {string} Name of the inviting company\n     * @readonly\n     */\n\n    this.invitingCompanyName = invitingCompanyName;\n    /**\n    * @public\n    * @property {string} Date the company invitation was created\n    * @readonly\n    */\n\n    this.invitationDate = invitationDate;\n    /**\n     * @public\n     * @property {string} lastNotificationDate The date when the last email notification was sent.\n     * @readonly\n     */\n\n    this.lastNotificationDate = lastNotificationDate;\n    /**\n     * @public\n     * @property {string} requestedNotificationLanguage Requested notification language.\n     * @readonly\n     */\n\n    this.requestedNotificationLanguage = requestedNotificationLanguage;\n    /**\n     * @public\n     * @property {string} status company invitation status.\n     * @readonly\n     */\n\n    this.status = status;\n    /**\n     * @public\n     * @property {string} acceptationDate Date when the company invitation has been accepted by the invited company.\n     * @readonly\n     */\n\n    this.acceptationDate = acceptationDate;\n    /**\n     * @public\n     * @property {string} cancelationDate Date when the company invitation has been cancelled by the inviting company.\n     * @readonly\n     */\n\n    this.cancelationDate = cancelationDate;\n    /**\n     * @public\n     * @property {string} declinationDate Date when the company invitation has been declined by the invited company.\n     * @readonly\n     */\n\n    this.declinationDate = declinationDate;\n  }\n\n  return CompanyBpLinkInvitation;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/companyBpLinkInvitation.js?')},function(module,exports){eval('/**\n * @class\n * @name CompanyBpLinkRequest\n * @private\n * @description\n *      This class is used to represent an company BP request<br/>\n */\nangular.module("rainbow").factory("CompanyBpLinkRequest", [function () {\n  "use strict";\n  /*************************************************************/\n\n  /* STATIC FACTORY                                            */\n\n  /*************************************************************/\n\n  CompanyBpLinkRequest.createFromData = function (data) {\n    var companyBpLinkRequest = new CompanyBpLinkRequest(data.id, data.requestingAdminId, data.requestingAdminLoginEmail, data.requestingCompanyId, data.requestingCompanyName, data.requestedCompanyId, data.requestedCompanyName, data.requestedToBeBpIr, data.requestDate, data.lastNotificationDate, data.requestedNotificationLanguage, data.status, data.acceptationDate, data.cancelationDate, data.declinationDate);\n    return companyBpLinkRequest;\n  };\n  /*************************************************************/\n\n  /* REQUEST CONSTRUCTOR                                  */\n\n  /*************************************************************/\n\n  /**\n   * @this CompanyBpLinkRequest\n   */\n\n\n  function CompanyBpLinkRequest(id, requestingAdminId, requestingAdminLoginEmail, requestingCompanyId, requestingCompanyName, requestedCompanyId, requestedCompanyName, requestedToBeBpIr, requestDate, lastNotificationDate, requestedNotificationLanguage, status, acceptationDate, cancelationDate, declinationDate) {\n    /**\n     * @public\n     * @property {string} company request unique Id\n     * @readonly\n     */\n    this.id = id;\n    /**\n     * @public\n     * @property {string} Requesting admin unique Rainbow Id\n     * @readonly\n     */\n\n    this.requestingAdminId = requestingAdminId;\n    /**\n     * @public\n     * @property {string} Requesting admin email\n     * @readonly\n     */\n\n    this.requestingAdminLoginEmail = requestingAdminLoginEmail;\n    /**\n     * @public\n     * @property {string} Unique Id of the requesting company\n     * @readonly\n     */\n\n    this.requestingCompanyId = requestingCompanyId;\n    /**\n     * @private\n     * @property {string} Name of the requesting company\t\t\t \n     * @readonly\n     */\n\n    this.requestingCompanyName = requestingCompanyName;\n    /**\n     * @public\n     * @property {string} Unique Id of the requested company\n     * @readonly\n     */\n\n    this.requestedCompanyId = requestedCompanyId;\n    /**\n     * @private\n     * @property {string} Name of the requested company\t\t\t \n     * @readonly\n     */\n\n    this.requestedCompanyName = requestedCompanyName;\n    /**\n     * @public\n     * @property {boolean} true when the requesting company wants to become IR BP\n     * @readonly\n     */\n\n    this.requestedToBeBpIr = requestedToBeBpIr;\n    /**\n     * @public\n     * @property {string} Date the company BP request was created\n     * @readonly\n     */\n\n    this.requestDate = requestDate;\n    /**\n     * @public\n     * @property {string} lastNotificationDate The date when the last email notification was sent.\n     * @readonly\n     */\n\n    this.lastNotificationDate = lastNotificationDate;\n    /**\n     * @public\n     * @property {string} requestedNotificationLanguage Requested notification language.\n     * @readonly\n     */\n\n    this.requestedNotificationLanguage = requestedNotificationLanguage;\n    /**\n     * @public\n     * @property {string} status company request status.\n     * @readonly\n     */\n\n    this.status = status;\n    /**\n     * @public\n     * @property {string} acceptationDate Date when the company request has been accepted by the requested company.\n     * @readonly\n     */\n\n    this.acceptationDate = acceptationDate;\n    /**\n     * @public\n     * @property {string} cancelationDate Date when the company request has been cancelled by the requesting company.\n     * @readonly\n     */\n\n    this.cancelationDate = cancelationDate;\n    /**\n     * @public\n     * @property {string} declinationDate Date when the company request has been declined by the requested company.\n     * @readonly\n     */\n\n    this.declinationDate = declinationDate;\n  }\n\n  return CompanyBpLinkRequest;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/companyBpLinkRequest.js?')},function(module,exports){eval('/**\n * @class\n * @private\n * @name Conference\n * @description\n *      This class is used to represent a conference\n */\nangular.module("rainbow").factory("Conference", [function () {\n  "use strict";\n\n  Conference.createFromData = function (data) {\n    var conference = new Conference(data.companyId, data.id, data.mediaType, data.name, data.passCodes, data.scheduled, data.lastUpdateDate, data.userId, data.confDialOutDisabled, data.playEntryTone, data.muteUponEntry);\n    return conference;\n  }; //\n  // Constructor\n\n  /**\n   * @this Conference\n   */\n\n\n  function Conference(companyId, // (String) Company unique identifier\n  id, // (String) unique identifier of conference\n  mediaType, // (String) mediaType of conference ("pstnAudio", "webrtc", "webrtcSharingOnly")\n  name, // (String) name of conference\n  passCodes, // (Array) list of passcodes\n  scheduled, // (Boolean) true if it is a scheduled meeting, false otherwise\n  lastUpdateDate, // (String) last update date of conference (e.g. 2018-06-20T09:08:00.000Z)\n  userId, // (String) user unique identifier\n  confDialOutDisabled, // (Boolean) true if dialOut from PGi is disabled\n  playEntryTone, // (Boolean) A tone is played when participant enters the conference.\n  muteUponEntry // (Boolean) When participant enters the conference, he is automatically muted.\n  ) {\n    /**\n    * @public\n    * @property {string} companyId\n    * @readonly\n    */\n    this.companyId = companyId;\n    /**\n     * @public\n     * @property {string} id confEndpoint unique identifier\n     * @readonly\n     */\n\n    this.id = id;\n    /**\n    * @public\n    * @property {string} mediaType\n    * @readonly\n    */\n\n    this.mediaType = mediaType;\n    /**\n    * @public\n    * @property {string} name\n    * @readonly\n    */\n\n    this.name = name;\n    /**\n    * @public\n    * @property {Array} passCodes\n    * @readonly\n    */\n\n    this.passCodes = passCodes ? passCodes : [];\n    /**\n    * @public\n    * @property {boolean} scheduled\n    * @readonly\n    */\n\n    this.scheduled = scheduled;\n    /**\n     * @public\n     * @property {string} lastUpdateDate\n     */\n\n    this.lastUpdateDate = lastUpdateDate;\n    /**\n    * @public\n    * @property {string} userId\n    * @readonly\n    */\n\n    this.userId = userId;\n    /**\n    * @public\n    * @property {string} confDialOutDisabled\n    * @readonly\n    */\n\n    this.confDialOutDisabled = confDialOutDisabled;\n    /**\n    * @public\n    * @property {boolean} playEntryTone\n    * @readonly\n    */\n\n    this.playEntryTone = playEntryTone;\n    /**\n    * @public\n    * @property {boolean} scheduled\n    * @readonly\n    */\n\n    this.muteUponEntry = muteUponEntry;\n    /**\n    * @private\n    * @property {string} updateFromData Allow to update an existing conference with data from server\n    * @readonly\n    */\n\n    this.updateFromData = function (data) {\n      this.companyId = data.companyId;\n      this.id = data.id;\n      this.mediaType = data.mediaType;\n      this.name = data.name;\n      this.passCodes = data.passCodes;\n      this.scheduled = data.scheduled;\n      this.lastUpdateDate = data.lastUpdateDate;\n      this.userId = data.userId;\n      this.confDialOutDisabled = data.confDialOutDisabled;\n      this.playEntryTone = data.playEntryTone;\n      this.muteUponEntry = data.muteUponEntry;\n    };\n  }\n\n  return Conference;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/conference.js?')},function(module,exports){eval('/**\n * @class\n * @private\n * @name ConferenceSession\n * @description\n *      This class is used to represent a conferenceSession\n */\nangular.module("rainbow").factory("ConferenceSession", ["$log", "ConferenceParticipant", "contactService", "$q", function ($log, ConferenceParticipant, contactService, $q) {\n  "use strict";\n\n  ConferenceSession.createFromData = function (id, participants, active, type) {\n    if (!type) {\n      type = "pstnAudio";\n    }\n\n    var conferenceSession = new ConferenceSession(id, participants, active, type);\n    return conferenceSession;\n  }; //\n  // Constructor\n\n  /**\n   * @this ConferenceSession\n   */\n\n\n  function ConferenceSession(_id, _participants, _active, _type) {\n    var that = this;\n    /**\n     * @public\n     * @property {string} id confEndpoint unique identifier\n     * @readonly\n     */\n\n    that.id = _id;\n    /**\n     * @public\n     * @property {Array} participants\n     * @readonly\n     */\n\n    that.participants = _participants;\n    /**\n     * @public\n     * @property {boolean} active\n     * @readonly\n     */\n\n    that.active = _active;\n    /**\n     * @public\n     * @property {boolean} talkerActive\n     * @readonly\n     */\n\n    that.talkerActive = undefined;\n    /**\n     * @public\n     * @property {boolean} recordingStarted\n     * @readonly\n     */\n\n    that.recordingStarted = undefined;\n    /**\n     * @public\n     * @property {Array} talkers\n     * @readonly\n     */\n\n    that.talkers = undefined;\n    /**\n     * @public\n     * @property {boolean} isLeaderAlreadyConnected\n     * @readonly\n     */\n\n    that.isLeaderAlreadyConnected = false;\n    /**\n     * @public\n     * @property {String} status status of the webRTC conference\n     * @readonly\n     */\n\n    that.status = null;\n    /**\n     * @public\n     * @property {MediaStream[]} localStreams local stream\n     * @readonly\n     */\n\n    that.localStreams = [];\n    /**\n     * @public\n     * @property {Object} sessions hashmap of webrtc sessions\n     * @readonly\n     */\n\n    that.sessions = {};\n    /**\n     * @public\n     * @property {Array} publishers array with list of publishers (video/sharing)\n     * @readonly\n     */\n\n    that.publishers = [];\n    /**\n     * @public\n     * @property {string} type pstn or webrtc or webrtcSharingOnly\n     * @readonly\n     */\n\n    that.type = _type;\n    /**\n     * @public\n     * @property {string} callId of call associated to the conference (if established via a 3PCC call)\n     * @readonly\n     */\n\n    that.callId = null;\n    /**\n     * @public\n     * @property {boolean} hasLocalVideo whether or not there is local video attached to conference session\n     * @readonly\n     */\n\n    that.hasLocalVideo = false;\n    /**\n     * @public\n     * @property {boolean} jingleJid jingleJid of webrtc session\n     * @readonly\n     */\n\n    that.jingleJid = null;\n    /**\n     * @public\n     * @property {boolean} localVideoSessionId sessionId for local video\n     * @readonly\n     */\n\n    that.localVideoSessionId = null;\n    /**\n     * @public\n     * @property {boolean} localSharingSessionId sessionId for local sharing\n     * @readonly\n     */\n\n    that.localSharingSessionId = null;\n    /**\n     * @public\n     * @property {boolean} haveJoined true if we have joined using this UA false otherwise\n     * @readwrite\n     */\n\n    that.haveJoined = false;\n    /**\n     * @public\n     * @property {boolean} lock true if conferenceSession is locked\n     * @readwrite\n     */\n\n    that.lock = false;\n\n    that.cleanupSessionData = function () {\n      $log.debug("[ConferenceSession] Cleanup for conferenceSession " + that.id);\n      that.participants = [];\n      that.talkerActive = undefined;\n      that.recordingStarted = undefined;\n      that.talkers = undefined;\n      that.isLeaderAlreadyConnected = false;\n      that.localStreams = [];\n      that.sessions = {};\n      that.publishers = [];\n      that.hasLocalVideo = false;\n      that.metricsState = "";\n      that.recordingStarted = false;\n      that.status = "ended";\n      that.hasLocalSharing = false;\n      that.reversedVideos = false;\n      that.jingleJid = null;\n      that.localVideoSessionId = null;\n      that.localSharingSessionId = null;\n      that.haveJoined = false;\n      that.lock = false;\n    };\n    /**\n    * @private\n    * @property {string} updateFromData Allow to update an existing conferenceSession with snapshot data from server\n    * @readonly\n    */\n\n\n    that.updateFromData = function (id, participants, active) {\n      that.id = id;\n      that.participants = participants;\n      that.active = active;\n    };\n\n    that.updateActiveState = function (active) {\n      that.active = active;\n    };\n\n    that.updateStateFromData = function (active, talkerActive, recordingStarted, lock) {\n      that.active = active;\n      that.talkerActive = talkerActive;\n      that.recordingStarted = recordingStarted;\n      that.lock = lock;\n    }; //returns a promise that resolves when participants update is finished (resolves with TRUE if participant added)\n\n\n    that.updateParticipants = function (participantsData) {\n      return $q(function (resolve) {\n        var result = false;\n\n        if (!participantsData) {\n          resolve(false);\n        }\n\n        if (!that.participants) {\n          that.participants = [];\n        }\n\n        if (participantsData.length === 0) {\n          that.participants = [];\n        }\n\n        participantsData.forEach(function (participantData) {\n          if (!participantData.participantId) {\n            return;\n          }\n\n          $log.debug("[conferenceSession] updateParticipants participantId=" + participantData.participantId);\n          var existingParticipant = that.getParticipantById(participantData.participantId) ? that.getParticipantById(participantData.participantId) : participantData.jid_im ? that.getParticipantByJid(participantData.jid_im) : null;\n\n          if (!existingParticipant) {\n            $log.debug("[conferenceSession] updateParticipants create participantId=" + participantData.participantId);\n            that.participants.push(ConferenceParticipant.createFromData(participantData));\n            result = true;\n          } else {\n            $log.debug("[conferenceSession] updateParticipants update participantId=" + participantData.participantId);\n            existingParticipant.updateFromData(participantData);\n          }\n        });\n        resolve(result);\n      });\n    };\n\n    that.removeParticipants = function (removedParticipants) {\n      if (!removedParticipants) {\n        return;\n      }\n\n      removedParticipants.forEach(function (removedParticipantId) {\n        var removedParticipantIndex = that.getParticipantIndexById(removedParticipantId);\n\n        if (removedParticipantIndex !== -1) {\n          $log.debug("[conferenceSession] removeParticipants remove participantId=" + removedParticipantId);\n          that.participants.splice(removedParticipantIndex, 1);\n        }\n      });\n    };\n\n    that.removePublisher = function (removedPublisherId) {\n      if (!removedPublisherId) {\n        return;\n      }\n\n      var removedPublisherIndex = that.getPublisherIndexById(removedPublisherId);\n\n      if (removedPublisherIndex !== -1) {\n        $log.debug("[conferenceSession] removePublisher remove participantId=" + removedPublisherId);\n        that.publishers.splice(removedPublisherIndex, 1);\n      }\n    };\n\n    that.updateTalkers = function (talkers) {\n      $log.debug("[conferenceSession] updateTalkers talkers=" + talkers);\n      that.talkers = talkers;\n    };\n\n    that.isActive = function () {\n      return that.active !== undefined ? that.active : false;\n    };\n\n    that.isTalkerActive = function () {\n      return that.talkerActive !== undefined ? that.talkerActive : false;\n    };\n\n    that.isRecordingStarted = function () {\n      return that.recordingStarted !== undefined ? that.recordingStarted : false;\n    };\n\n    that.getParticipants = function () {\n      return that.participants;\n    };\n\n    that.getConnectedParticipants = function () {\n      return that.participants ? that.participants.filter(function (participant) {\n        return participant.state !== "disconnected" && participant.state !== "watching";\n      }) : undefined;\n    };\n\n    that.getWatchingParticipants = function () {\n      return that.participants ? that.participants.filter(function (participant) {\n        return participant.state === "watching";\n      }) : undefined;\n    };\n\n    that.getConnectedParticipantsExceptLeader = function () {\n      return that.participants ? that.participants.filter(function (participant) {\n        return participant.state !== "disconnected" && participant.state !== "watching" && participant.role !== "moderator";\n      }) : undefined;\n    };\n\n    that.getConnectedLeaderParticipantsExcept = function (jid) {\n      return that.participants ? that.participants.filter(function (participant) {\n        return participant.state !== "disconnected" && participant.role === "moderator" && participant.jid_im !== jid;\n      }) : undefined;\n    };\n\n    that.getConnectedParticipantsExcept = function (jid) {\n      return that.participants ? that.participants.filter(function (participant) {\n        return participant.jid_im !== jid && participant.state !== "disconnected" && participant.state !== "watching";\n      }) : undefined;\n    };\n\n    that.getLeaderParticipant = function () {\n      return that.participants ? that.participants.find(function (participant) {\n        return participant.role === "moderator" && participant.state !== "disconnected" && participant.state !== "watching";\n      }) : undefined;\n    };\n\n    that.getLeaderParticipantById = function (jid) {\n      return that.participants ? that.participants.find(function (participant) {\n        return participant.role === "moderator" && participant.state !== "disconnected" && participant.state !== "watching" && participant.jid_im === jid;\n      }) : undefined;\n    };\n\n    that.getParticipantById = function (participantId) {\n      return that.participants ? that.participants.find(function (participant) {\n        return participant.participantId === participantId;\n      }) : undefined;\n    };\n\n    that.getParticipantByJid = function (jid) {\n      return that.participants ? that.participants.find(function (participant) {\n        return participant.jid_im === jid;\n      }) : undefined;\n    };\n\n    that.getNonDisconnectedParticipantByJid = function (jid) {\n      return that.participants ? that.participants.find(function (participant) {\n        return participant.jid_im === jid && participant.state !== "disconnected";\n      }) : undefined;\n    };\n\n    that.getConnectedParticipantByJid = function (jid) {\n      return that.participants ? that.participants.find(function (participant) {\n        return participant.jid_im === jid && participant.state === "connected";\n      }) : undefined;\n    };\n\n    that.getWatchingParticipantByJid = function (jid) {\n      return that.participants ? that.participants.find(function (participant) {\n        return participant.jid_im === jid && participant.state === "watching";\n      }) : undefined;\n    };\n\n    that.getParticipantIndexById = function (participantId) {\n      return that.participants ? that.participants.findIndex(function (participant) {\n        return participant.participantId === participantId;\n      }) : -1;\n    };\n\n    that.getPublisherIndexById = function (publisherId) {\n      return that.publishers ? that.publishers.findIndex(function (publisher) {\n        return publisher.participantId === publisherId;\n      }) : -1;\n    };\n\n    that.isParticipantConnectedByJid = function (jid) {\n      return that.participants !== undefined && that.participants.some(function (participant) {\n        return participant.jid_im === jid && participant.state === "connected";\n      });\n    };\n\n    that.isParticipantWatchingByJid = function (jid) {\n      return that.participants !== undefined && that.participants.some(function (participant) {\n        return participant.jid_im === jid && participant.state === "watching";\n      });\n    };\n\n    that.isParticipantRingingByJid = function (jid) {\n      return that.participants !== undefined && that.participants.some(function (participant) {\n        return participant.jid_im === jid && participant.state === "ringing";\n      });\n    };\n\n    that.isParticipantConnectedWithThisUAByJid = function (jid) {\n      return that.haveJoined && that.participants !== undefined && that.participants.some(function (participant) {\n        return participant.jid_im === jid && participant.state === "connected";\n      });\n    };\n\n    that.getTalkers = function () {\n      return that.talkers;\n    };\n\n    that.setCallId = function (callId) {\n      that.callId = callId;\n    };\n\n    that.getListOfRemoteVideoPublishers = function () {\n      var result = [];\n\n      if (that.publishers) {\n        for (var i = 0; i < that.publishers.length; i++) {\n          if (that.publishers[i].mediaType === "video" && that.publishers[i].jid_im !== contactService.userContact.jid) {\n            result.push(that.publishers[i]);\n          }\n        }\n      }\n\n      return result;\n    };\n  }\n\n  return ConferenceSession;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/conferenceSession.js?')},function(module,exports){eval('/**\n * @class\n * @private\n * @name ConferenceParticipant\n * @description\n *      This class is used to represent a conference participant\n */\nangular.module("rainbow").factory("ConferenceParticipant", [function () {\n  "use strict";\n\n  ConferenceParticipant.createFromData = function (data) {\n    var conferenceParticipant = new ConferenceParticipant(data.participantId, data.userId, data.jid_im, data.jid_tel, data.participantRole, data.mute, data.held, data.confStartDate, data.startDate, data.phoneNumber, data.participantState);\n    return conferenceParticipant;\n  }; //\n  // Constructor\n\n  /**\n   * @this ConferenceParticipant\n   */\n\n\n  function ConferenceParticipant(participantId, userId, jid_im, jid_tel, role, mute, held, confStartDate, startDate, phoneNumber, state) {\n    /**\n     * @public\n     * @property {string} participantId The participant Id\n     * @readonly\n     */\n    this.participantId = participantId;\n    /**\n     * @public\n     * @property {string} userId The participant\'s user Id\n     * @readonly\n     */\n\n    this.userId = userId;\n    /**\n     * @public\n     * @property {string} jid_im\n     * @readonly\n     */\n\n    this.jid_im = jid_im;\n    /**\n    * @public\n    * @property {string} jid_tel\n    * @readonly\n    */\n\n    this.jid_tel = jid_tel;\n    /**\n    * @public\n    * @property {string} role\n    * @readonly\n    */\n\n    this.role = role;\n    /**\n    * @public\n    * @property {string} mute\n    * @readonly\n    */\n\n    this.mute = mute;\n    /**\n    * @public\n    * @property {string} held\n    * @readonly\n    */\n\n    this.held = held;\n    /**\n    * @public\n    * @property {string} confStartDate\n    * @readonly\n    */\n\n    this.confStartDate = confStartDate;\n    /**\n    * @public\n    * @property {string} startDate\n    * @readonly\n    */\n\n    this.startDate = startDate;\n    /**\n    * @public\n    * @property {string} phoneNumber\n    * @readonly\n    */\n\n    this.phoneNumber = phoneNumber;\n    /**\n    * @public\n    * @property {string} state\n    * @readonly\n    */\n\n    this.state = state;\n    /**\n    * @private\n    * @property {string} updateFromData Allow to update an existing conference with data from server\n    * @readonly\n    */\n\n    this.updateFromData = function (data) {\n      //NB In case of multiple participants with the same JID, update the participant ID to the last one;\n      //Should be solved by server, but ...\n      if (data.participantId) {\n        this.participantId = data.participantId;\n      }\n\n      if (data.userId) {\n        //snapshot results contain userid but events don\'t contain userId, so don\'t remove it when updating from event\n        this.userId = data.userId;\n      }\n\n      this.jid_im = data.jid_im;\n\n      if (data.jid_tel) {\n        //snapshot results contain jid_tel but events don\'t contain jid_tel, so don\'t remove it when updating from event\n        this.jid_tel = data.jid_tel;\n      } //keep old values if no info is given\n\n\n      this.role = data.participantRole ? data.participantRole : this.role;\n      this.confStartDate = data.confStartDate ? data.confStartDate : this.confStartDate;\n      this.startDate = data.startDate ? data.startDate : this.startDate;\n      this.phoneNumber = data.phoneNumber ? data.phoneNumber : this.phoneNumber;\n      this.state = data.participantState ? data.participantState : this.state; //as true & held are booleans, we take the information from the server each time\n\n      this.mute = data.mute;\n      this.held = data.held;\n    };\n  }\n\n  return ConferenceParticipant;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/conferenceParticipant.js?')},function(module,exports){eval('/**\n * @public\n * @class\n * @name ConferenceUser\n * @description\n *      This class is used to represent a Conference User (that is a user with conference rights)\n */\nclass ConferenceUser {\n    /**\n     * @this ConferenceUser\n     */\n    constructor(id, providerUserId, providerCompanyId, confCompanyId, userId, companyId, firstName, lastName, providerType) {\n        /**\n         * @public\n         * @property {String} id confUser unique identifier\n         * @readonly\n         */\n        this.id = id;\n        /**\n         * @public\n         * @property {String} providerUserId user unique identifier on provider\n         * @readonly\n         */\n        this.providerUserId = providerUserId;\n        /**\n         * @public\n         * @property {String} providerCompanyId company unique identifier on provider\n         * @readonly\n         */\n        this.providerCompanyId = providerCompanyId;\n        /**\n         * @public\n         * @property {String} confCompanyId confCompany unique identifier\n         * @readonly\n         */\n        this.confCompanyId = confCompanyId;\n        /**\n         * @public\n         * @property {String} userId user unique identifier\n         * @readonly\n         */\n        this.userId = userId;\n        /**\n         * @public\n         * @property {String} companyId company unique identifier\n         * @readonly\n         */\n        this.companyId = companyId;\n        /**\n         * @public\n         * @property {String} firstName User firstName\n         * @readonly\n         */\n        this.firstName = firstName;\n        /**\n         * @public\n         * @property {String} lastName User lastName\n         * @readonly\n         */\n        this.lastName = lastName;\n        /**\n         * @public\n         * @property {String} providerType \tProvider used for creation of the company. e.g. "PGI"\n         * @readonly\n         */\n        this.providerType = providerType;\n    }\n}\nfunction ConferenceUserFactory() {\n    return (data) => {\n        return new ConferenceUser(data.id, data.providerUserId, data.providerCompanyId, data.confCompanyId, data.userId, data.companyId, data.firstName, data.lastName, data.providerType);\n    };\n}\nangular.module("rainbow").factory("conferenceUserFactory", ConferenceUserFactory);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/conferenceUser.ts?')},function(module,exports){eval('/**\n * @class\n * @public\n * @name Channel\n * @description\n * This class is used to represent a channel\n */\nclass Channel {\n    /**\n     * @this Channel\n     */\n    constructor(name, id, visibility, topic, creatorId, companyId, creationDate, users_count, lastAvatarUpdateDate, subscribed, type, invited, category, mode, subscribers_count) {\n        this.userRole = \'none\';\n        this.messageRetrieved = false;\n        this.messages = [];\n        this.subscribed = false;\n        this.deleted = false;\n        this.invited = false;\n        this.type = "SIMPLE";\n        this.pageIndex = 0;\n        this.isLoading = false;\n        this.complete = false;\n        this.users = [];\n        this.publishersRetreived = false;\n        this.loaded = false;\n        /**\n         * @public\n         * @property {string} name channel name\n         *\n         */\n        this.name = name;\n        /**\n         * @public\n         * @property {string} id channel unique identifier\n         *\n         */\n        this.id = id;\n        /**\n         * @public\n         * @property {string} visibility channel type/visibility<br/>\n         * \t\t"private" : a « Pub » channel, only the owner may publish messages.<br/>\n         * \t\t\t\t\tManaged by owner, the only one who can add or remove users in a private channels.<br/>\n         * \t\t\t\t\tCan\'t be found by search.<br/>\n         * \t\t"company" : « PubSub » channel (company users may join/leave)\n         * \t\t\t\t\tMay be found by search for users in the same company.<br/>\n         * \t\t"public"  : « PubSub » public channel.\n         * \t\t\t\t\tOnly allowed users may create a "public" channel.\n         * \t\t\t\t\tMay be found by search for all users.<br/>\n         *\n         */\n        this.visibility = visibility;\n        /**\n         * @public\n         * @property {string} topic channel topic\n         *\n         */\n        this.topic = topic;\n        /**\n         * @public\n         * @property {string} creatorId the creator rainbow user id\n         *\n         */\n        this.creatorId = creatorId;\n        /**\n         * @public\n         * @property {string} companyId the channel rainbow company id\n         *\n         */\n        this.companyId = companyId;\n        /**\n         * @public\n         * @property {Date} creationDate creation date of the channel (read only, set automatically during creation)\n         *\n         */\n        this.creationDate = creationDate;\n        /**\n         * @public\n         * @property {string} type type of role of the user : owner / member / publisher\n         *\n         */\n        this.type = type;\n        /**\n         * @public\n         * @property {number} users_count The number of users in the channel\n         *\n         */\n        this.users_count = users_count;\n        /**\n         * @public\n         * @property {number} subscribers_count The number of subscribers in the channel\n         *\n         */\n        this.subscribers_count = subscribers_count;\n        /**\n         @public\n         * @property {string} category the category channel\n         *\n         */\n        this.category = category;\n        /**\n        @public\n        * @property {string} mode the category mode\n        *\n        */\n        this.mode = mode;\n        this.lastAvatarUpdateDate = lastAvatarUpdateDate;\n        let timestamp = this.lastAvatarUpdateDate ? "&ts=" + new Date(this.lastAvatarUpdateDate).getTime() : "";\n        this.avatar = config.restServerUrl + "/api/channel-avatar/" + id + "?size=256" + timestamp;\n        if (subscribed !== undefined) {\n            this.subscribed = subscribed;\n        }\n        if (type !== undefined) {\n            this.userRole = type;\n        }\n        if (invited !== undefined) {\n            this.invited = invited;\n        }\n        if (!this.mode) {\n            switch (this.visibility) {\n                case "company":\n                    this.mode = "company_public";\n                    break;\n                case "public":\n                    this.mode = "all_public";\n                    break;\n                case "private":\n                    this.mode = "company_private";\n                    break;\n                default: break;\n            }\n        }\n    }\n    isNotMember() { return (this.userRole = "none"); }\n    isOwner() { return (this.userRole === "owner"); }\n    isPublisher() { return (this.subscribed && (this.userRole === "owner" || this.userRole === "publisher")); }\n    isMember() { return this.userRole === "member"; }\n    getAvatarSrc() { return (this.lastAvatarUpdateDate) ? this.avatar : "/resources/skins/rainbow/images/channels/default_channel_avatar.png"; }\n    /**\n     * @function\n     * @public\n     * @name ChannelFactory\n     * @description\n     * This class is used to create a channel from data object\n     */\n    static ChannelFactory() {\n        return (data) => {\n            return new Channel(data.name, data.id, data.visibility, data.topic, data.creatorId, data.companyId, data.creationDate, data.users_count, data.lastAvatarUpdateDate, data.subscribed, data.type, data.invited, data.category, data.mode, data.subscribers_count);\n        };\n    }\n}\nangular.module("rainbow").factory("Channel", Channel.ChannelFactory);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/channel.ts?')},function(module,exports){eval('class SearchTextMsgResult {\n    constructor() {\n        this.body = undefined;\n        this.date = undefined;\n        this.isRoom = false;\n        this.isSent = false;\n        this.messageId = undefined;\n    }\n    ;\n    static SearchTextMsgResultFactory() {\n        return () => {\n            return new SearchTextMsgResult();\n        };\n    }\n}\nclass SearchTextResult {\n    constructor(convId) {\n        this.room = null;\n        this.contact = null;\n        this.totalCount = -1;\n        this.convRes = [];\n        this.otherJid = convId;\n    }\n    ;\n    getResultFromMsgId(msgId) {\n        for (let item of this.convRes) {\n            if (item.messageId === msgId) {\n                return item;\n            }\n        }\n        return undefined;\n    }\n    addMsgItem(msgItem) {\n        this.convRes.push(msgItem);\n    }\n    isRoom() {\n        if (this.conversation) {\n            return (this.conversation.room != null);\n        }\n        return this.room !== null;\n    }\n}\nclass SearchTextConvResults {\n    constructor() {\n        this.searchedText = "";\n        this.results = [];\n        this.queryIds = [];\n        this.totalCount = 0;\n        this.searchCounter = 0;\n    }\n    ;\n    isEmpty() {\n        return this.queryIds.length === 0 || Object.keys(this.results).length === 0;\n    }\n    ;\n    searchCount() {\n        this.searchCounter++;\n    }\n    ;\n    getAvailableCount() {\n        let count = 0;\n        for (let item of this.results) {\n            count += item.convRes.length;\n        }\n        return count;\n    }\n    ;\n    getTotalCount() {\n        return this.totalCount;\n    }\n    ;\n    clearAll() {\n        this.queryIds = [];\n        this.totalCount = 0;\n        this.clearMessagesResults();\n    }\n    ;\n    clearMessagesResults() {\n        this.results.splice(0, this.results.length);\n    }\n    ;\n    isCurrentQuery(queryId) {\n        return this.queryIds.indexOf(queryId) > -1;\n    }\n    getItemForConvId(convJid) {\n        for (let item of this.results) {\n            if (item.otherJid === convJid) {\n                return item;\n            }\n        }\n        return undefined;\n    }\n    createNewResult(convJid) {\n        let currentConvResults = this.getItemForConvId(convJid);\n        if (!currentConvResults) {\n            currentConvResults = new SearchTextResult(convJid);\n            this.results.push(currentConvResults);\n        }\n        return currentConvResults;\n    }\n    addNewItemResult(convJid, searchTextItem) {\n        let currentConvResults = this.getItemForConvId(convJid);\n        if (!currentConvResults) {\n            currentConvResults = new SearchTextResult(convJid);\n            this.results.push(currentConvResults);\n        }\n        // Check if this message already exist in message store\n        if (currentConvResults.getResultFromMsgId(searchTextItem.messageId)) {\n            //this.$log.info("[searchTextConvResults] " + this.id + " try to add an already stored message with id " + message.id);\n            return;\n        }\n        currentConvResults.addMsgItem(searchTextItem);\n    }\n    splitText(text, searchFilter) {\n        var textStart = "";\n        var textColored = "";\n        var textEnd = "";\n        var textSimplified = this.cleanUpSpecialChars(text).toLowerCase();\n        var searchFilterSimplified = this.cleanUpSpecialChars(searchFilter).toLowerCase();\n        var index = textSimplified.indexOf(searchFilterSimplified);\n        if (index >= 0) {\n            if (index > 0) {\n                textStart = text.slice(0, index);\n            }\n            textColored = text.slice(index, index + searchFilter.length);\n            if (text.length > searchFilter.length + index) {\n                textEnd = text.slice(index + searchFilter.length, text.length);\n            }\n        }\n        else {\n            textStart = text;\n        }\n        return [textStart, textColored, textEnd];\n    }\n    ;\n    cleanUpSpecialChars(str) {\n        str = str.replace(/[ÀÁÂÃÄÅ]/g, "A");\n        str = str.replace(/[àáâãäå]/g, "a");\n        str = str.replace(/[ÈÉÊË]/g, "E");\n        str = str.replace(/[éèëê]/g, "e");\n        str = str.replace(/[ÎÏ]/g, "I");\n        str = str.replace(/[îï]/g, "i");\n        str = str.replace(/[ÔÖÕ]/g, "O");\n        str = str.replace(/[ôöõ]/g, "o");\n        str = str.replace(/[ùûü]/g, "u");\n        str = str.replace(/[ç]/g, "c");\n        return str;\n    }\n}\nfunction SearchTextConvResultsFactory() {\n    return () => {\n        return new SearchTextConvResults();\n    };\n}\nangular.module("rainbow").factory("SearchTextConvResultsFactory", SearchTextConvResultsFactory);\nangular.module("rainbow").factory("SearchTextMsgResultFactory", SearchTextMsgResult.SearchTextMsgResultFactory);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/searchTextConvResults.ts?')},function(module,exports){eval('angular.module("rainbowAdmin").factory("Offer", [function () {\n  "use strict";\n\n  Offer.createFromData = function (data) {\n    return new Offer(data.id, data.name, data.description, data.groupName, data.offerReference, data.profileId, data.canBeSold, data.businessModel, data.isDefault, data.isExclusive, data.isPrepaid, data.prepaidDuration, data.autoSubscribe, data.hasConference, data.hasVoice, data.isDemo, data.isBundle, data.isChinaOffer);\n  };\n\n  Offer.createFromSubscriptionData = function (subscription) {\n    return new Offer(subscription.offerId, subscription.offerName, subscription.offerDescription, subscription.groupName, subscription.offerReference, subscription.profileId, subscription.canBeSold, subscription.businessModel, subscription.isDefault, subscription.isExclusive, subscription.isPrepaid, subscription.prepaidDuration, subscription.autoSubscribe, subscription.hasConference, subscription.hasVoice, subscription.isDemo, subscription.isBundle, subscription.isChinaOffer);\n  };\n\n  Offer.createFromSubscriptionCountersData = function (subscriptionCounters) {\n    return new Offer(subscriptionCounters.offerId, subscriptionCounters.offerName, undefined, subscriptionCounters.groupName, subscriptionCounters.offerReference, undefined, subscriptionCounters.canBeSold, subscriptionCounters.businessModel, subscriptionCounters.isDefault, subscriptionCounters.isExclusive, subscriptionCounters.isPrepaid, subscriptionCounters.prepaidDuration, undefined, subscriptionCounters.hasConference, subscriptionCounters.hasVoice, subscriptionCounters.isDemo, subscriptionCounters.isBundle);\n  };\n\n  Offer.createFromProfileData = function (profile) {\n    return new Offer(profile.offerId, profile.offerName, undefined, undefined, undefined, profile.profileId, false, undefined, profile.isDefault, profile.isExclusive, profile.isPrepaid, profile.prepaidDuration, undefined, profile.hasConference, profile.hasVoice, profile.isDemo, profile.isBundle);\n  };\n\n  Offer.createFromOperationLog = function (operationLog) {\n    var data = operationLog.operationType === "delete" ? operationLog.previousData : operationLog.newData;\n    return new Offer(data.offerId, data.offerName, data.offerDescription, undefined, data.offerReference, data.profileId, data.canBeSold, data.businessModel, data.isDefault, data.isExclusive, data.isPrepaid, data.prepaidDuration, undefined, data.hasConference, data.hasVoice, data.isDemo, data.isBundle);\n  };\n\n  Offer.getLogoByName = function (offerName) {\n    var logo = "logo-offer-default.svg"; //check name in order to show the right logo\n\n    if (offerName) {\n      var name = offerName.toLowerCase();\n\n      if (name.indexOf("voice") !== -1) {\n        // Priority to voice\'s logo (when included in a bundle)\n        name = "voice";\n      } else if (name.indexOf("conference") !== -1) {\n        // Priority to conference\'s logo (when included in a bundle)\n        name = "conference";\n      } else if (name.indexOf("enterprise") !== -1) {\n        name = "enterprise";\n      } else if (name.indexOf("business") !== -1) {\n        name = "business";\n      }\n\n      logo = "logo-offer-" + name + ".svg";\n    } //TODO return "/resources/skins/rainbow/images/misc/" + logo;\n\n\n    return logo;\n  }; // Constructor\n\n\n  function Offer(id, name, description, groupName, offerReference, profileId, canBeSold, businessModel, isDefault, isExclusive, isPrepaid, prepaidDuration, autoSubscribe, hasConference, hasVoice, isDemo, isBundle, isChinaOffer) {\n    this.id = id;\n    this.name = name || "";\n    this.description = description || "Rainbow " + this.name;\n    this.groupName = hasConference ? "Conference" : groupName || name; //TODO test to be removed when server-side is ok\n\n    this.offerReference = offerReference;\n    this.profileId = profileId;\n    this.canBeSold = canBeSold ? canBeSold : false;\n    this.businessModel = businessModel;\n    this.isDefault = isDefault;\n    this.isExclusive = isExclusive;\n    this.isPrepaid = isPrepaid;\n    this.prepaidDuration = prepaidDuration;\n    this.autoSubscribe = autoSubscribe;\n    this.hasConference = hasConference;\n    this.hasVoice = hasVoice;\n    this.isDemo = isDemo === undefined ? !this.isDefault && !this.canBeSold && this.name.toLowerCase().includes("demo") : isDemo;\n    this.isBundle = isBundle;\n    this.isChinaOffer = isChinaOffer; // check name in order to show the right logo\n\n    if (this.hasVoice) {\n      // priority to voice\'s logo (when included in a bundle)\n      this.logo = "logo-offer-voice.svg";\n    } else if (this.hasConference) {\n      // priority to conference\'s logo (when included in a bundle)\n      this.logo = "logo-offer-conference.svg";\n    } else {\n      this.logo = Offer.getLogoByName(this.name);\n    }\n\n    this.isEnterprise = function () {\n      return this.name.toLowerCase().startsWith("enterprise");\n    };\n\n    this.isBusiness = function () {\n      return this.name.toLowerCase().startsWith("business");\n    };\n\n    this.isEssential = function () {\n      return this.isDefault;\n    };\n    /**\n     * Used to know if the offer is a trial license or not. \n     * Only a superadmin is allowed to subscribe to such offer.\n     * \n     * @public\n     * @function isTrial\n     * @returns {Boolean} true if the offer is a trial license\n     */\n\n\n    this.isTrial = function () {\n      return this.isDemo;\n    };\n\n    this.isUserLicense = function () {\n      return this.isDefault || this.businessModel === "nb_users" || this.businessModel === "usage";\n    };\n\n    this.isFixedLicense = function () {\n      return this.businessModel === "flat_fee";\n    };\n\n    this.isUserBasedLicense = function () {\n      return this.businessModel === "nb_users";\n    };\n\n    this.isUsageBasedLicense = function () {\n      return this.businessModel === "usage";\n    };\n  } // Comparator\n\n\n  Offer.offerComparator = function (offer1, offer2) {\n    var offerOrder = ["Essential", "Business", "Enterprise", "Voice", "Room", "Conference"]; // Handle "Essential" offer\n\n    if (offer1.isEssential()) {\n      return -1;\n    }\n\n    if (offer2.isEssential()) {\n      return 1;\n    } // Handle "demo" offers (always on top)\n\n\n    if (offer1.isTrial() && !offer2.isTrial()) {\n      return -1;\n    }\n\n    if (!offer1.isTrial() && offer2.isTrial()) {\n      return 1;\n    } // Handle "Conference" offers (always at bottom)\n\n\n    if (offer1.hasConference && !offer2.hasConference) {\n      return 1;\n    }\n\n    if (!offer1.hasConference && offer2.hasConference) {\n      return -1;\n    } // Handle offers when both are "demo" offers or other type of offers \n\n\n    var orderIndex1 = offerOrder.findIndex(function (order) {\n      return offer1.name.startsWith(order); // "Enterprise demo" and "enterprise" must have the same index\n    });\n    var orderIndex2 = offerOrder.findIndex(function (order) {\n      return offer2.name.startsWith(order); // "Enterprise demo" and "enterprise" must have the same index\n    }); // unknown offers are grouped at the bottom\n\n    orderIndex1 = orderIndex1 === -1 ? offerOrder.length : orderIndex1;\n    orderIndex2 = orderIndex2 === -1 ? offerOrder.length : orderIndex2;\n\n    if (orderIndex1 < orderIndex2) {\n      return -1;\n    }\n\n    if (orderIndex1 > orderIndex2) {\n      return 1;\n    } // offer 1 and 2 have same order index\n    // reverse sort when demo (ie. "enterprise demo" before "enterprise")\n\n\n    if (offer1.isTrial()) {\n      return -1;\n    }\n\n    if (offer2.isTrial()) {\n      return 1;\n    } // Prepaid offers placed at the bottom\n\n\n    if (offer1.isPrepaid && !offer2.isPrepaid) {\n      return 1;\n    }\n\n    if (!offer1.isPrepaid && offer2.isPrepaid) {\n      return -1;\n    } // Sort by name\n\n\n    if (offer1.name < offer2.name) {\n      return -1;\n    }\n\n    if (offer1.name > offer2.name) {\n      return 1;\n    }\n\n    return 0;\n  }; // Filters\n\n\n  Offer.isExclusive = function (offer) {\n    return offer.isDefault || offer.isExclusive; // like "Essential" (default) or "Enterprise" // nb_users (like "Beta") or undefined (like "Essential")\n  };\n\n  Offer.isOptional = function (offer) {\n    return !Offer.isExclusive(offer);\n  };\n\n  Offer.isEssential = function (offer) {\n    return offer.isDefault;\n  };\n\n  Offer.isNotEssential = function (offer) {\n    return !offer.isDefault;\n  };\n\n  Offer.isModelByNbUsers = function (offer) {\n    return offer.businessModel === "nb_users";\n  };\n\n  Offer.isPrepaid = function (offer) {\n    return offer.isPrepaid;\n  };\n\n  Offer.isNotPrepaid = function (offer) {\n    return !offer.isPrepaid;\n  };\n\n  Offer.isUserLicense = function (offer) {\n    return offer.isUserLicense();\n  };\n\n  Offer.isUsageBasedLicense = function (offer) {\n    return offer.isUsageBasedLicense();\n  };\n\n  return Offer;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/common/offer.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @class\n * @name Contact\n * @description\n *      This class is used to represent a contact or the connected user <br/>\n *      A contact is defined by a set of public information (name, firstname, avatar...) and a set of private information that are only shared with contacts that are in the user\'s network or in the same company (email, phone numbers...)\n */\n\n\nangular.module("rainbow").factory("Contact", ["$q", "$rootScope", "$interval", "$document", "$translate", "$sce", "settingsService", "Company", "$log", "xmppService", "authService", "utilService", function ($q, $rootScope, $interval, $document, $translate, $sce, settingsService, Company, $log, xmppService, authService, utilService) {\n  "use strict";\n  /*************************************************************/\n\n  /* STATIC FACTORY                                            */\n\n  /*************************************************************/\n\n  Contact.create = function (jid, firstname, lastname, company, login) {\n    var contact = new Contact(jid, null, company);\n\n    if (firstname && lastname) {\n      firstname = firstname.charAt(0).toUpperCase() + firstname.slice(1);\n      lastname = lastname.charAt(0).toUpperCase() + lastname.slice(1);\n      contact.computeCompleteDisplayName(firstname, lastname);\n    }\n\n    contact.login = login;\n    return contact;\n  };\n\n  Contact.createByPhoneNumber = function (phoneNumber) {\n    var contact = new Contact(null, phoneNumber);\n    contact.id = phoneNumber;\n    return contact;\n  };\n\n  Contact.createBotContact = function (jid, botName, id, botAvatarUrl) {\n    var contact = new Contact(jid);\n    var image = new Image();\n\n    if (window.rainbowSDK) {\n      image = null;\n    } else {\n      image.src = botAvatarUrl;\n    } //set contact info for bot\n\n\n    contact.lastname = botName;\n    contact.isBot = true;\n    contact.computeDisplayName();\n    contact.status = "online";\n    contact.imStatus = "online";\n    contact.subscription = "both";\n    contact.avatar = image;\n    contact.dbId = id;\n    return contact;\n  };\n\n  Contact.updateContactToBot = function (contact, name, id, botAvatarUrl) {\n    var image = new Image();\n\n    if (window.rainbowSDK) {\n      image = null;\n    } else {\n      image.src = botAvatarUrl;\n    } //set contact info for bot\n\n\n    contact.lastname = name;\n    contact.isBot = true;\n    contact.computeDisplayName();\n    contact.status = "online";\n    contact.imStatus = "online";\n    contact.subscription = "both";\n    contact.avatar = image;\n    contact.dbId = id;\n    return contact;\n  };\n  /*************************************************************/\n\n  /* STATIC ENUM                                               */\n\n  /*************************************************************/\n\n  /**\n   * @public\n   * @enum {string}\n   * @readonly\n   */\n\n\n  Contact.AdminType = {\n    /** Organization administrator */\n    ORGANIZATION_ADMIN: "organization_admin",\n\n    /** Company administrator */\n    COMPANY_ADMIN: "company_admin",\n\n    /** Site administrator */\n    SITE_ADMIN: "site_admin",\n\n    /** No administrator right */\n    UNDEFINED: "undefined"\n  };\n  /**\n         * @public\n         * @enum {number}\n         * @readonly\n         */\n\n  Contact.NameUpdatePrio = {\n    /* no update prio then could be updated*/\n    NO_UPDATE_PRIO: 0,\n\n    /*prio associated to outlook name resolution update*/\n    OUTLOOK_UPDATE_PRIO: 1,\n\n    /*prio associated to server name resolution (phonebook or office365AD ...) update*/\n    SERVER_UPDATE_PRIO: 2,\n\n    /*max prio : no update could overwrite*/\n    MAX_UPDATE_PRIO: 99\n  };\n  /*************************************************************/\n\n  /* CONVERSATION CONSTRUCTOR                                  */\n\n  /*************************************************************/\n\n  /**\n   * @this Contact\n   */\n\n  function Contact(jid, name, company) {\n    var that = this;\n    /**\n     * @public\n     * @property {string} id The contact ID\n     * @readonly\n     */\n\n    this.id = jid;\n    /**\n     * @public\n     * @property {string} jid The contact IM JID\n     * @readonly\n     */\n\n    this.jid = jid;\n    /**\n     * @public\n     * @property {string} fullJid The complete JID (including the resource)\n     * @readonly\n     */\n\n    this.fullJid = null;\n    /**\n     * @public\n     * @property {string} jidtel The contact TEL JID\n     * @readonly\n     */\n\n    this.jidtel = null;\n    /**\n     * @public\n     * @property {string} dbId The contact internal id\n              * @readonly\n     */\n\n    this.dbId = null;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.login = null; // Status\n\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.temp = false;\n    /**\n    * @public\n    * @property {string} status The status of the contact.\n    * @readonly\n    */\n\n    this.status = "unknown";\n    /**\n     * @public\n     * @property {string} telStatus The telephony status of the contact.\n     * @readonly\n     */\n\n    this.telStatus = "";\n    /**\n     * @public\n     * @property {string} imStatus The IM status of the contact.\n     * @readonly\n     */\n\n    this.imStatus = "offline";\n    /**\n     * @public\n     * @property {Object[]} imStatusStamp The last IM status for each resource.\n     * @readonly\n     */\n\n    this.imStatusStamp = [];\n    /**\n     * @public\n     * @property {Object} resources An object containing the list of all resources used by the connected user\n     * @readonly\n     */\n\n    this.resources = {}; // VCard fields\n\n    /**\n     * @public\n     * @deprecated\n     * @property {string} loginEmail The email account of the contact\n     * @readonly\n     */\n\n    this.loginEmail = "";\n    /**\n     * @public\n     * @property {string} lastname The lastname of the contact\n     * @readonly\n     */\n\n    this.lastname = "";\n    /**\n     * @public\n     * @property {string} fistname The firstname of the contact\n     * @readonly\n     */\n\n    this.firstname = "";\n    /**\n     * @public\n     * @property {Company} company A Company objet reprensenting the information of the company associated to the contact\n     * @readonly\n     * @link Company\n     */\n\n    this.company = company;\n    /**\n     * @public\n     * @property {string} nickname The nickname of the contact\n     * @readonly\n     */\n\n    this.nickname = "";\n    /**\n     * @public\n     * @property {string} title The title of the contact\n     * @readonly\n     */\n\n    this.title = "";\n    /**\n     * @public\n     * @property {string} jobTitle The job title of the contact\n     * @readonly\n     */\n\n    this.jobTitle = "";\n    /**\n     * @public\n     * @property {string} country The Country of the contact\n     * @readonly\n     */\n\n    this.country = "";\n    /**\n     * @private\n     * @property {Object} avatar The avatar if any\n     * @readonly\n     */\n\n    this.defaultAvatar = null;\n    this._avatar = null;\n    this._avatarLoading = false;\n    /**\n     * @public\n     * @property {string} avatarSrc The avatar URL if any, null if none\n     * @readonly\n     */\n\n    this.avatarSrc = null;\n    /**\n     * @public\n     * @property {string} timezone The timezone of the contact\n     * @readonly\n     */\n\n    this.timezone = "";\n    /**\n     * @public\n     * @property {string[]} roles (For the connected user only). The associated roles of the connected user \n     * @readonly\n     */\n\n    this.roles = null;\n    /**\n     * @public\n     * @property {string} confId\n     * @readonly\n     */\n\n    this.confId = "";\n    /**\n     * @public\n     * @property {string} phonePro The professional phone number of the contact\n     * @readonly\n     */\n\n    this.phonePro = "";\n    /**\n     * @public\n     * @property {string} phoneProCan The professional phone number of the contact (canonical format)\n     * @readonly\n     */\n\n    this.phoneProCan = "";\n    /**\n     * @public\n     * @property {string} phonePbx The phone number if exists associated to the user and monitored by Rainbow \n     * @readonly\n     */\n\n    this.phonePbx = "";\n    /**\n     * @public\n     * @property {string} phoneInternalNumber The internal number if exists associated to the user and monitored by Rainbow \n     * @readonly\n     */\n\n    this.phoneInternalNumber = "";\n    /**\n     * @public\n     * @property {string} pbxId The ID of the PBX monitored by Rainbow where the user\'s phone is associated\n     * @readonly\n     */\n\n    this.pbxId = "";\n    /**\n     * @public\n     * @property {string} mobilePro The professional mobile phone of the contact\n     * @readonly\n     */\n\n    this.mobilePro = "";\n    /**\n     * @public\n     * @property {string} mobileProCan The professional mobile phone of the contact (canonical format)\n     * @readonly\n     */\n\n    this.mobileProCan = "";\n    /**\n     * @public\n     * @property {string} phonePerso The personal phone of the contact\n     * @readonly\n     */\n\n    this.phonePerso = "";\n    /**\n     * @public\n     * @property {string} phonePersoCan The personal phone of the contact (canonical format)\n     * @readonly\n     */\n\n    this.phonePersoCan = "";\n    /**\n     * @public\n     * @property {string} mobilePerso The personal mobile phone of the contact\n     * @readonly\n     */\n\n    this.mobilePerso = "";\n    /**\n     * @public\n     * @property {string} mobilePersoCan The personal mobile phone of the contact (canonical format)\n     * @readonly\n     */\n\n    this.mobilePersoCan = "";\n    /**\n     * @public\n     * @property {string} emailPro The professional email of the contact\n     * @readonly\n     */\n\n    this.emailPro = "";\n    /**\n     * @public\n     * @property {string} emailPerso The personal email of the contact\n     * @readonly\n     */\n\n    this.emailPerso = ""; //old status before making a call\n\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.oldImStatus = null;\n    /**\n     * @public\n     * @property {boolean} roster True if the contact is part of the favorized contact\'s list of the connected user\n     * @readonly\n     */\n\n    this.roster = false;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.initialized = false;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this._displayName = name ? name : jid;\n    /**\n     * @public\n     * @property {Object} name The display name of the contact\n     * @readonly\n     */\n\n    this.name = {\n      value: this._displayName\n    };\n    /**\n     * @public\n     * @property {string} initials The initials of the contact\n     * @readonly\n     */\n\n    this.initials = "";\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.message = "";\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.cellStyle = "";\n    /**\n     * @public\n     * @property {string} ask (Contact Only) The subscription progress\n     * @readonly\n     */\n\n    this.ask = "none";\n    /**\n     * @public\n     * @property {string} subscription (Contact only) The subscription state for this contact (none or both)\n     * @readonly\n     */\n\n    this.subscription = "none";\n    /**\n     * @public\n     * @property {Conversation} conversation (Contact only) The conversation if exists with this contact\n     * @link Conversation\n     * @readonly\n     */\n\n    this.conversation = null;\n    /**\n     * @public\n     * @property {string} adminType (Connected user only) The administration type for the connected user (if user has the admin role)\n     * @readonly\n     */\n\n    this.adminType = null;\n    /**\n     * @public\n     * @property {Object} capabilities (Contact only) The communication capabilities or the contact<br/>\n     * \t\t\t(The list of communication actions that are currently supported by the contact)<br/>\n     * \t\t\tWith following members (true means, ok to try to add this media)<br/>\n     * \t\t\t\t\t{Boolean} telephony, <br/>\n     * \t\t\t\t\t{Boolean} webRTC, <br/>\n     * \t\t\t\t\t{Boolean} sharedDesktop, <br/>\n     * \t\t\t\t\t{Boolean} fileTransfert, <br/>\n     * \t\t\t\t\t{Boolean} mediaAvailable (means telephony || webRTC), <br/>\n     * \t\t\t\t\t{Boolean} addMedia (true if user is already in call and has an active fullJid)\n     * @readonly\n     */\n\n    this.capabilities = null;\n    /**\n     * @public\n     * @property {Object} groups (Contact only) The groups info associated to contact\n     * @readonly\n     */\n\n    this.groups = null;\n    /**\n     * @public\n     * @property {string} mobileResource The first mobile resource detected\n     * @readonly\n     */\n\n    this.mobileResource = null;\n    /**\n     * @public\n     * @property {string} language The contact language\n     * @since 1.20\n     * @readonly\n     */\n\n    this.language = null;\n    /**\n     * @public\n     * @property {date} lastActivityDate The contact last activity date\n     * @readonly\n     */\n\n    this.lastActivityDate = null;\n    /**\n     * @public\n     * @property {number} nameUpdatePrio Prio of the service having made an update\n     * @readonly\n     */\n\n    this.nameUpdatePrio = Contact.NameUpdatePrio.MAX_UPDATE_PRIO; //default Max prio\n\n    /**\n     * @private \n     * @readonly\n     */\n\n    this.isInDefaultCompany = false;\n    /**\n     * @private\n     * @property {Object} calendarState The object containing the calendar presence of the user (if available)\n     * @readonly\n     */\n\n    this.calendarState = {};\n    /**\n     * @private\n     * @property {Boolean} guest True is the user is authenticated as guest\n     * @readonly\n     */\n\n    this.guest = false;\n    /**\n     * @private\n     * @property {Boolean} virtual Terminal (isMonoDevice)\n     * @readonly\n     */\n\n    this.isVirtualTerm = false;\n    /**\n     * @public\n     * @property {string} nameForLogs Obscured name of user for logs\n     * @readonly\n     */\n\n    this.nameForLogs = "";\n    /**\n     * @private\n     * @property {string} systDeviceName type of set or voice subscriber\n     * \n    */\n\n    this.systDeviceName = null; //sipWise++ = RVCP when sipWise\n\n    /**\n     * @public\n     * @property {Boolean} isTv If the user is actually a Rainbow TV\n     * @readonly\n     */\n\n    this.isTv = false;\n    /**\n     * @private\n     * @property {Object} rainbowTvData The data related to the Rainbow TV\n     * @readonly\n     */\n\n    this.rainbowTvData = {};\n    /**\n     * @private\n     * @property {string[]} Tags Array of the user tags\n     * @readonly\n     */\n\n    this.tags = null;\n    $rootScope.$on("$destroy", $rootScope.$on("ON_DISPLAY_ORDER_EVENT", function () {\n      that.computeDisplayName();\n    }));\n    $rootScope.$on("$destroy", $rootScope.$on("ON_DISPLAY_ORDER_EVENT", function () {\n      that.computeDisplayName();\n    }));\n  }\n  /*************************************************************/\n\n  /** OVERIDE AVATAR ACCESSORS                                **/\n\n  /*************************************************************/\n\n\n  Object.defineProperty(Contact.prototype, "avatar", {\n    set: function set(avatar) {\n      this._avatar = avatar;\n    },\n    get: function get() {\n      var that = this;\n\n      if (that._avatar) {\n        return that._avatar;\n      }\n\n      if (!that._avatarLoading && that.avatarSrc) {\n        that._avatarLoading = true;\n        var image = new Image();\n\n        image.onload = function () {\n          var loadedImage = this;\n          $interval(function () {\n            that._avatar = loadedImage;\n            that._avatarLoading = false;\n            $log.log("[contact] Lazily load avatar for " + that.displayNameForLog() + " success");\n            $rootScope.$broadcast("ON_CONTACT_AVATAR_UPDATE", that.jid);\n          }, 0, 1, true);\n        };\n\n        image.onerror = function () {\n          $log.warn("[contact] Lazily load avatar for " + that.displayNameForLog() + " failure : use text avatar");\n          that._avatar = that.defaultAvatar;\n          that._avatarLoading = false;\n        };\n\n        image.src = that.avatarSrc;\n      }\n\n      return that.defaultAvatar;\n    }\n  });\n  /*************************************************************/\n\n  /** OVERIDE DISPLAYNAME ACCESSORS                           **/\n\n  /*************************************************************/\n\n  Object.defineProperty(Contact.prototype, "displayName", {\n    set: function set(value) {\n      this._displayName = value;\n      this.name.value = value;\n      this.displayNameMD5 = Object(crypto_js__WEBPACK_IMPORTED_MODULE_0__["MD5"])(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Latin1.parse(value)).toString(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Hex);\n    },\n    get: function get() {\n      return this._displayName;\n    }\n  });\n  /*************************************************************/\n\n  /** OVERIDE LAST ACTIVITY PROPERTIES ACCESSORS              **/\n\n  /*************************************************************/\n\n  Object.defineProperty(Contact.prototype, "lastActivityDate", {\n    set: function set(lastActivityDate) {\n      this._lastActivityDate = lastActivityDate;\n      this.updateLastActivityMessage();\n    },\n    get: function get() {\n      return this._lastActivityDate;\n    }\n  });\n  Object.defineProperty(Contact.prototype, "statusMessage", {\n    get: function get() {\n      if (this._currentStatus !== this.status || this._currentLastActivityMessage !== this.lastActivityMessage || this._currentMessage !== this.message) {\n        this._currentStatus = this.status;\n        this._currentMessage = this.message;\n        this._currentLastActivityMessage = this.lastActivityMessage;\n\n        if (this.status === "unknown") {\n          this._statusMessage = this.company && this.company.name ? this.company.name : $translate.instant("unknown");\n        } else {\n          if (this.status === "offline" && this.lastActivityMessage === "") {\n            this._statusMessage = $translate.instant("offlineFilter");\n          } else if (this.status === "away" && this.lastActivityMessage === "") {\n            this._statusMessage = $translate.instant("shortAway");\n          } else {\n            this._statusMessage = $translate.instant(this.status, {\n              "offlineDate": this.lastActivityMessage\n            });\n          }\n        }\n\n        if (this.message) {\n          var message = $translate.instant(this.message);\n\n          if (message.charAt(0) !== "(") {\n            message = "(" + message + ")";\n          }\n\n          this._statusMessage += " " + message;\n        }\n      }\n\n      return this._statusMessage;\n    }\n  });\n  Object.defineProperty(Contact.prototype, "lastActivityMessage", {\n    get: function get() {\n      var that = this;\n\n      if (!that._lastActivityMessage && !that._lastActivityInProgress) {\n        that._lastActivityInProgress = true;\n\n        try {\n          xmppService.connection.lastactivity.query(that.jid, {\n            onResponse: function onResponse(stanza) {\n              var inactivityInMSeconds = 1000 * $(stanza).find("query").attr("seconds");\n              var dateInMSeconds = new Date().getTime();\n              var lastActivityDateInMSeconds = dateInMSeconds - inactivityInMSeconds;\n              that.lastActivityDate = new Date(lastActivityDateInMSeconds);\n              that._lastActivityInProgress = false;\n            }\n          });\n        } catch (error) {\n          $log.error("[Contact] lastActivityDate getter accessor for contact " + that.jid_im + " -- failure : " + error);\n          that._lastActivityInProgress = false;\n        }\n\n        return null;\n      }\n\n      return this._lastActivityMessage;\n    }\n  });\n\n  Contact.prototype.updateLastActivityMessage = function () {\n    if (!this._lastActivityDate) {\n      this._lastActivityMessage = "";\n    } else {\n      var mdate = moment(this._lastActivityDate);\n\n      if (moment.locale().startsWith("de")) {\n        this._lastActivityMessage = mdate.fromNow(true).replace("Tage", "Tagen");\n        this._lastActivityMessage = this._lastActivityMessage.replace("eine Stunde", "einer Stunde");\n      } else {\n        this._lastActivityMessage = mdate.fromNow(true);\n      }\n    }\n  };\n\n  Contact.prototype.getLastAvailableDate = function () {\n    var lastStamp = null;\n    var stamps = this.imStatusStamp;\n    Object.keys(stamps).forEach(function (key) {\n      var stamp = stamps[key];\n\n      if (!lastStamp) {\n        lastStamp = stamp;\n      } else if (lastStamp < stamp) {\n        lastStamp = stamp;\n      }\n    });\n    return lastStamp;\n  };\n\n  Contact.prototype.updateCalendarPresenceInfo = function () {\n    var calendarState = this.calendarState;\n    var calendarParams = null;\n    var calendarMessage = null;\n    calendarState.iconId = null;\n    var calendarLabelKey = null;\n\n    if (calendarState.autoReplyOn) {\n      calendarState.iconId = "icon_outofoffice";\n      calendarMessage = "<div style=\'text-align:left\'>" + utilService.escapeHtml(calendarState.autoReplyInfos.message).replace(/\\n/g, "<br/>") + "</div>";\n      calendarParams = {\n        "meetingDate": calendarState.autoReplyInfos.until,\n        "message": calendarMessage\n      };\n\n      if (!calendarState.autoReplyInfos.until) {\n        calendarLabelKey = "calendarAutoReplySimple";\n      } else {\n        calendarLabelKey = calendarState.autoReplyInfos.untilDate ? "calendarAutoReply-date" : "calendarAutoReply";\n      }\n    } else {\n      if (calendarState.message === "busy") {\n        calendarState.iconId = "icon_inameeting";\n        calendarLabelKey = calendarState.untilDate ? "calendar-busy-date" : "calendar-busy";\n      } else if (calendarState.message === "out_of_office") {\n        calendarState.iconId = "icon_outofoffice";\n        calendarLabelKey = calendarState.untilDate ? "calendar-outofoffice-date" : "calendar-outofoffice";\n      }\n\n      calendarParams = {\n        "meetingDate": calendarState.until\n      };\n    }\n\n    if (calendarLabelKey) {\n      calendarState.tooltip = $translate.instant(calendarLabelKey, {\n        meetingDate: calendarParams.meetingDate\n      });\n\n      if (calendarParams.message) {\n        //TO DO should avoid XSS vulnerabilities with the provider, should update angular-translate\n        calendarParams.message = calendarParams.message.replace(/<script>/g, "");\n        calendarState.tooltip = $sce.trustAsHtml(calendarState.tooltip + " " + calendarParams.message);\n      }\n    }\n  };\n\n  Contact.prototype.displayNameForLog = function () {\n    if (config && config.debug) {\n      return this.displayName;\n    }\n\n    return this.displayNameMD5;\n  };\n  /**\n   * @public\n   * @method isMobileResource\n   * @memberof Contact\n   * @instance\n   * @param {string} jid the full jid of the contact\n   * @description\n   *    Return true if the resource is associated to a mobile\n   * @return {boolean} True for a mobile resource\n   */\n\n\n  Contact.prototype.isMobileResource = function (jid) {\n    return jid.indexOf("mobile_android") !== -1 || jid.indexOf("mobile_ios") !== -1;\n  };\n\n  Contact.prototype.calculateStatusFromResources = function (isMe) {\n    var presence = "offline";\n    var message = "";\n    var initStamp = "";\n    var stamp = "";\n    var fullJid = this.fullJid;\n    var desktopPresence = false;\n    var allowMobiles = config.webrtcWithMobiles;\n\n    for (var key in this.resources) {\n      if (this.resources.hasOwnProperty(key)) {\n        if (this.resources[key].show === "dnd" && this.resources[key].status === "phone") {\n          presence = "busy";\n          message = "audioPhone";\n          desktopPresence = true;\n          fullJid = key;\n          break;\n        } //if invisible or DND Manual\n        else if (this.resources[key].show === "xa" || this.resources[key].show === "dnd" && this.resources[key].status === "") {\n            var toUpdate = false;\n\n            if (this.resources[key].initStamp) {\n              if (!initStamp) {\n                initStamp = this.resources[key].initStamp;\n                toUpdate = true;\n              } else if (this.resources[key].initStamp.getTime() > initStamp.getTime()) {\n                //if this resource is newer than the other\n                initStamp = this.resources[key].initStamp;\n                toUpdate = true;\n              }\n            } else {\n              //not initial presence\n              if (!stamp) {\n                stamp = this.resources[key].stamp;\n                initStamp = this.resources[key].stamp;\n                toUpdate = true;\n              } else if (this.resources[key].stamp.getTime() > stamp.getTime()) {\n                //if this resource is newer than the other\n                stamp = this.resources[key].stamp;\n                initStamp = this.resources[key].stamp;\n                toUpdate = true;\n              }\n            }\n\n            if (toUpdate) {\n              presence = this.resources[key].show;\n              message = this.resources[key].status;\n            }\n          } else if (presence !== "xa" && (presence !== "dnd" || presence === "dnd" && message !== "") && this.resources[key].show === "dnd" && this.resources[key].status !== "") {\n            if (this.resources[key].status === "presentation") {\n              presence = this.resources[key].show;\n              message = "presentation";\n            } else {\n              presence = "busy";\n              message = this.resources[key].status;\n            }\n\n            fullJid = key;\n            desktopPresence = true;\n          } else if (isMe && this.resources[key].show === "online" && this.resources[key].status === "mode=auto" && key === this.fullJid) {\n            //we can exit manual mode\n            if (presence !== "busy" && presence !== "dnd" && message !== "presentation") {\n              presence = "online";\n              message = "";\n              this.resources[key].status = "";\n\n              if (this.isMobileResource(key)) {\n                presence = "online-mobile";\n              } else {\n                desktopPresence = true;\n              }\n            }\n          } else if (this.resources[key].show === "online" && presence !== "xa" && presence !== "dnd" && presence !== "busy") {\n            //to be devided to online mobile and online\n            message = "";\n\n            if (presence !== "online-mobile") {\n              presence = "online";\n            }\n\n            this.resources[key].status = "";\n\n            if (this.isMobileResource(key)) {\n              presence = "online-mobile";\n            } else {\n              fullJid = key;\n              desktopPresence = true;\n            } //if mobile flag is up, save the fullJid for mobiles too \n\n\n            if (allowMobiles) {\n              fullJid = key;\n            }\n          } else if (this.resources[key].show === "away" && presence === "offline") {\n            presence = "away";\n            message = "";\n            fullJid = key;\n          } //delete all statuses mode=auto\n\n\n        if (this.resources[key].status === "mode=auto") {\n          this.resources[key].status = "";\n        }\n      }\n    }\n\n    for (var key in this.resources) {\n      if (this.resources.hasOwnProperty(key) && this.resources[key].status === "mode=auto") {\n        //delete all statuses mode=auto\n        this.resources[key].status = "";\n      }\n    }\n\n    if (!isMe && !this.fullJid) {\n      this.fullJid = fullJid;\n    }\n\n    if (presence === "online-mobile" && desktopPresence) {\n      presence = "online";\n      message = "";\n    } else if (presence === "online-mobile" && !isMe && !allowMobiles) {\n      this.fullJid = null;\n      message = "";\n    }\n\n    return {\n      "presence": presence,\n      "message": message\n    };\n  };\n  /*************************************************************/\n\n  /** GUEST USER                   \t\t\t\t\t        **/\n\n  /*************************************************************/\n\n\n  Contact.prototype.isCPaaSGuest = function () {\n    return this.roles.indexOf("guest") >= 0;\n  };\n\n  Contact.prototype.isGuest = function () {\n    return this.guestMode;\n  };\n  /*************************************************************/\n\n  /** ADMIN USER\t\t\t\t\t                            **/\n\n  /*************************************************************/\n\n  /**\n   * @public\n   * @return {boolean} true if user has some administration rights, otherwise false.\n   */\n\n\n  Contact.prototype.hasAdminRights = function () {\n    return this.isSuperadmin() || this.isBusinessAdmin() || this.isAdmin() || this.isBPAdmin();\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has superadmin rights, otherwise false.\n   */\n\n\n  Contact.prototype.isSuperadmin = function () {\n    return this.roles.indexOf("superadmin") >= 0;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has business responsabilities within its company, otherwise false.\n   */\n\n\n  Contact.prototype.isBusinessAdmin = function () {\n    return this.roles.indexOf("business_admin") >= 0;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has the rights to manage its company, otherwise false.\n   */\n\n\n  Contact.prototype.isAdmin = function () {\n    if (this.roles.indexOf("admin") >= 0) {\n      if (this.isOrganizationAdmin()) {\n        // When "organization_admin" with a role "bp_admin" OR "bp_finance", the role "admin" MUST be IGNORED\n        return !this.isBPAdmin();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has the rights to manage all companies within its organization, otherwise false.\n   */\n\n\n  Contact.prototype.isOrganizationAdmin = function () {\n    return this.roles.indexOf("admin") >= 0 && this.adminType === Contact.AdminType.ORGANIZATION_ADMIN;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has the rights to manage its company, otherwise false.\n   */\n\n\n  Contact.prototype.isCompanyAdmin = function () {\n    return this.roles.indexOf("admin") >= 0 && this.adminType === Contact.AdminType.COMPANY_ADMIN;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has the rights to manage only the sites of its company, otherwise false.\n   */\n\n\n  Contact.prototype.isSiteAdmin = function () {\n    return this.roles.indexOf("admin") >= 0 && this.adminType === Contact.AdminType.SITE_ADMIN;\n  };\n  /**\n   * @public\n   * @return {string} a Contact.AdminType\n   */\n\n\n  Contact.prototype.getAdminType = function () {\n    if (this.roles.indexOf("admin") >= 0) {\n      return this.adminType;\n    }\n\n    return Contact.AdminType.UNDEFINED;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user is an administrator of a End Customer (EC) company, otherwise false.\n   */\n\n\n  Contact.prototype.isECAdmin = function () {\n    return this.company && !this.company.isBP && this.isAdmin();\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has operations or financial rights within a Business Partner (BP) company, otherwise false.\n   */\n\n\n  Contact.prototype.isBPAdmin = function () {\n    return this.isBPAdminOperations() || this.isBPAdminFinance();\n  };\n  /**\n   * @public\n   * @return {boolean} true if user is has operations rights within a Business Partner (BP) company, otherwise false.\n   */\n\n\n  Contact.prototype.isBPAdminOperations = function () {\n    return this.company && this.company.isBP && this.roles.indexOf("bp_admin") >= 0;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has financial rights within a Business Partner (BP) company, otherwise false.\n   */\n\n\n  Contact.prototype.isBPAdminFinance = function () {\n    return this.company && this.company.isBP && this.roles.indexOf("bp_finance") >= 0;\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has operations or financial rights within a Direct Reseller (DR) company, otherwise false.\n   */\n\n\n  Contact.prototype.isBPAdminDR = function () {\n    return this.isBPAdmin() && this.company.isDR();\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has operations or financial rights within a Value Added Distributor (VAD) company, otherwise false.\n   */\n\n\n  Contact.prototype.isBPAdminVAD = function () {\n    return this.isBPAdmin() && this.company.isVAD();\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has operations or financial rights within an Indirect Reseller (IR) company, otherwise false.\n   */\n\n\n  Contact.prototype.isBPAdminIR = function () {\n    return this.isBPAdmin() && this.company.isIR();\n  };\n  /**\n   * @public\n   * @return {boolean} true if user has the rights to manage the business directory of its company, otherwise false.\n   */\n\n\n  Contact.prototype.isDirectoryAdmin = function () {\n    return this.roles.indexOf("directory_admin") >= 0;\n  };\n  /*************************************************************/\n\n\n  Contact.prototype.updateIMStatus = function (attr, isMe) {\n    // Check stamp validity and ignore obsolete messages\n    if (this.imStatusStamp[attr.jid] && this.imStatusStamp[attr.jid] > attr.stamp) {\n      $log.info("[Contact] Ignore obsolete presence message for contact " + this.jid);\n      return;\n    }\n\n    $log.info("[Contact] updateIMStatus " + JSON.stringify(attr));\n    this.imStatusStamp[attr.jid] = attr.stamp;\n\n    if (attr.status) {\n      this.imStatus = attr.status;\n    }\n\n    var status = attr.message ? attr.message : "";\n\n    if (this.imStatus === "offline") {\n      if (this.fullJid === attr.jid) {\n        this.fullJid = null;\n      }\n\n      delete this.resources[attr.jid];\n      delete this.imStatusStamp[attr.jid];\n\n      if (this.resources.length === 0) {\n        this.message = "";\n      }\n    } else {\n      if (this.resources[attr.jid]) {\n        this.resources[attr.jid].show = this.imStatus;\n        this.resources[attr.jid].status = status;\n        this.resources[attr.jid].stamp = attr.stamp;\n      } else {\n        this.resources[attr.jid] = {\n          "show": this.imStatus,\n          "status": status,\n          "initStamp": attr.stamp,\n          "stamp": attr.stamp\n        };\n      }\n\n      $log.info("[Contact] updateIMStatus user resources after update " + JSON.stringify(this.resources)); // Store fullJid only if from web client (not concerning me)\n\n      if (!this.isMobileResource(attr.jid) && !isMe) {\n        this.fullJid = attr.jid;\n      } //Allow mobiles if flag is activated\n\n\n      var allowMobiles = config.webrtcWithMobiles;\n\n      if (!isMe && allowMobiles) {\n        this.fullJid = attr.jid;\n      }\n    }\n\n    this.updateRichStatus(isMe);\n\n    if (isMe && this.isMobileResource(attr.jid)) {\n      if (attr.status !== "offline" && this.mobileResource === null) {\n        this.mobileResource = attr.jid;\n        $log.info("[Contact] updateIMStatus: post event ON_MOBILE_TELEPHONY_STATUS_CHANGED_EVENT");\n        $rootScope.$broadcast("ON_MOBILE_TELEPHONY_STATUS_CHANGED_EVENT", "started");\n      }\n\n      if (attr.status === "offline") {\n        var otherMobileResource = null;\n\n        for (var key in this.resources) {\n          if (this.resources.hasOwnProperty(key)) {\n            if (this.isMobileResource(key)) {\n              otherMobileResource = key;\n              break;\n            }\n          }\n        }\n\n        this.mobileResource = otherMobileResource;\n\n        if (this.mobileResource === null) {\n          $rootScope.$broadcast("ON_MOBILE_TELEPHONY_STATUS_CHANGED_EVENT", "stopped");\n        }\n      }\n    }\n  }; //sipWise++\n\n\n  Contact.prototype.getPCGPresenceSource = function (jid) {\n    var result = "";\n\n    if (jid) {\n      var index = jid.indexOf("/");\n\n      if (index !== -1) {\n        result = jid.substr(index + 1);\n      }\n    }\n\n    return result;\n  };\n\n  Contact.prototype.transcodePCG2Presence = function (attr) {\n    var result = "";\n\n    switch (attr.status) {\n      case "offline":\n        result = "";\n        break;\n\n      case "online":\n        result = "EVT_CONNECTION_CLEARED";\n        break;\n\n      case "dnd":\n        result = "EVT_ESTABLISHED";\n        break;\n\n      default:\n        break;\n    }\n\n    return result;\n  }; //sipWise--\n  //sipWise++ From now all attr struct from xmpp eventAttr is passed instead of only status from attr.message\n  //Contact.prototype.updateTelephonyStatus = function(status, isMe) {\t\t\n\n\n  Contact.prototype.updateTelephonyStatus = function (attr, isMe) {\n    var statusOrg = this.telStatus; //this.telStatus = status;\n\n    if (this.getPCGPresenceSource(attr.jid) === "pcg2") {\n      // pcg2 sipWise presence\n      this.telStatus = this.transcodePCG2Presence(attr);\n    } else {\n      //Normal PCG1 phone presence (not sipWise)\n      this.telStatus = attr.message;\n    }\n\n    this.updateRichStatus(isMe);\n\n    if (isMe && statusOrg !== this.telStatus) {\n      $rootScope.$broadcast("ON_UPDATE_MYTELEPHONY_STATUS_EVENT");\n    }\n  }; //sipWise--\t\t\n\n\n  Contact.prototype.updatePresenceStatus = function (status) {\n    this.status = status;\n  };\n\n  Contact.prototype.updateRichStatus = function (isMe) {\n    if (this.telStatus === "EVT_SERVICE_INITIATED" || this.telStatus === "EVT_ESTABLISHED") {\n      this.status = "busy";\n      this.message = "audioPhone";\n    } else {\n      if (this.ask === "subscribe") {\n        this.status = "wait";\n      } else if (this.subscription === "none" || this.subscription === "from") {\n        this.status = "unknown";\n      } else {\n        var calculatedStatus = this.calculateStatusFromResources(isMe); //if user is not me and he is eXtended Away presence, show him as offline\n\n        if (calculatedStatus.presence === "xa") {\n          if (calculatedStatus.message === "" && !isMe) {\n            calculatedStatus.presence = "offline";\n          } else if (calculatedStatus.message === "away") {\n            calculatedStatus.presence = "away";\n            calculatedStatus.message = "";\n          }\n        }\n\n        this.status = calculatedStatus.presence;\n        this.message = calculatedStatus.message;\n\n        if (isMe) {\n          $log.info("[Contact] updateRichStatus MY PRESENCE : " + calculatedStatus.presence + " || message : " + calculatedStatus.message);\n        } else {\n          $log.info("[Contact] updateRichStatus presence : " + calculatedStatus.presence + " || message : " + calculatedStatus.message);\n        }\n\n        if (this.status !== "offline") {\n          this.lastActivityDate = null;\n        }\n      }\n    }\n\n    if (isMe) {\n      $rootScope.$broadcast("ON_UPDATE_MYCONTACT_EVENT");\n    } // Event for SDK to be updated with agregated presence for each contacts\n\n\n    $rootScope.$broadcast("ON_UPDATE_CONTACT_RICH_STATUS_EVENT", this);\n  };\n\n  Contact.prototype.updateFromUserData = function (userData) {\n    // Identification fields\n    this.dbId = userData.id;\n    this.loginEmail = userData.loginEmail;\n    this.firstname = userData.firstName;\n    this.lastname = userData.lastName;\n    this.nickname = userData.nickName ? userData.nickName : "";\n    this.title = userData.title ? userData.title : "";\n    this.jobTitle = userData.jobTitle ? userData.jobTitle : "";\n    this.organisationId = userData.organisationId;\n    this.siteId = userData.siteId;\n    this.country = userData.country ? userData.country : "FRA";\n    this.timezone = userData.timezone;\n    this.roles = userData.roles;\n    this.adminType = userData.adminType;\n    this.isBot = false;\n    this.isTerminated = userData.isTerminated;\n    this.isInDefaultCompany = userData.isInDefaultCompany;\n    this.lastAvatarUpdateDate = userData.lastAvatarUpdateDate;\n    this.initialized = userData.isInitialized;\n    this.guestMode = userData.guestMode ? userData.guestMode : false;\n    this.isTv = userData.isTv;\n    this.tags = userData.tags; // Handle jids\n\n    if (userData.jid_im) {\n      this.id = userData.jid_im;\n      this.jid = userData.jid_im;\n      this.jidtel = userData.jid_tel;\n    } // Company field\n\n\n    if (!this.company || this.company.id !== userData.companyId) {\n      this.company = Company.create(userData.companyId, userData.companyName);\n    } // Telephony fields\n\n\n    this.phonePro = this.phoneProCan = "";\n    this.phonePbx = "";\n    this.phoneInternalNumber = ""; //#29475\n\n    this.pbxId = "";\n    this.mobilePro = this.mobileProCan = "";\n    this.phonePerso = this.phonePersoCan = "";\n    this.mobilePerso = this.mobilePersoCan = "";\n    this.voicemailNumber = "";\n    this.hasPhoneNumber = false;\n    this.hasPhoneProDdiNumber = false; // Update emails\n\n    var that = this;\n\n    if (userData.emails) {\n      that.emailPerso = ""; //PR_14671\n\n      userData.emails.forEach(function (email) {\n        switch (email.type) {\n          case "work":\n            that.emailPro = email.email;\n            break;\n\n          case "home":\n            that.emailPerso = email.email;\n            break;\n\n          default:\n            break;\n        }\n      });\n    } // Update phone numbers\n\n\n    if (userData.phoneNumbers) {\n      userData.phoneNumbers.forEach(function (phoneNumber) {\n        var number = phoneNumber.number;\n        var numberCan = phoneNumber.numberE164;\n        var deviceType = phoneNumber.deviceType;\n        that.hasPhoneNumber = true;\n\n        switch (phoneNumber.type) {\n          case "work":\n            {\n              if (deviceType === "landline") {\n                if (phoneNumber.isCloudPbxDDI) {\n                  that.phonePro = phoneNumber.number;\n                  that.phoneProCan = phoneNumber.numberE164;\n                  that.hasPhoneProDdiNumber = true;\n                } else {\n                  if (!that.hasPhoneProDdiNumber) {\n                    that.phonePro = number;\n                    that.phoneProCan = numberCan;\n                  }\n                }\n\n                if (phoneNumber.isFromSystem) {\n                  that.phonePbx = phoneNumber.shortNumber;\n\n                  if (phoneNumber.internalNumber) {\n                    //#29475++\n                    that.phoneInternalNumber = phoneNumber.internalNumber;\n\n                    if (phoneNumber.deviceName === "Remote Extension" || phoneNumber.deviceName === "Any Device") {\n                      that.isVirtualTerm = true;\n                    }\n                  } //#29475--\n\n\n                  that.systDeviceName = phoneNumber.deviceName ? phoneNumber.deviceName : null; //sipWise+\t\t\t\t\t\n\n                  that.pbxId = phoneNumber.pbxId;\n                  that.voicemailNumber = phoneNumber.voiceMailNumber;\n                }\n              }\n\n              if (deviceType === "mobile") {\n                that.mobilePro = number;\n                that.mobileProCan = numberCan;\n              }\n            }\n            break;\n\n          case "home":\n            {\n              if (deviceType === "landline") {\n                that.phonePerso = number;\n                that.phonePersoCan = numberCan;\n              }\n\n              if (deviceType === "mobile") {\n                that.mobilePerso = number;\n                that.mobilePersoCan = numberCan;\n              }\n            }\n            break;\n\n          default:\n            break;\n        }\n      });\n      this.phoneNumbersInitialized = true;\n    } // Compute display name\n\n\n    this.computeDisplayName();\n  };\n\n  Contact.prototype.updateName = function (firstName, lastName) {\n    // Identification fields\n    this.firstname = firstName;\n    this.lastname = lastName; // Compute display name\n\n    this.computeDisplayName(); //update avatar too\n\n    this.getAvatar();\n  };\n\n  Contact.prototype.getNameUpdatePrio = function () {\n    return this.nameUpdatePrio;\n  };\n\n  Contact.prototype.setNameUpdatePrio = function (prio) {\n    switch (prio) {\n      case Contact.NameUpdatePrio.NO_UPDATE_PRIO:\n      case Contact.NameUpdatePrio.OUTLOOK_UPDATE_PRIO:\n      case Contact.NameUpdatePrio.SERVER_UPDATE_PRIO:\n      case Contact.NameUpdatePrio.MAX_UPDATE_PRIO:\n        this.nameUpdatePrio = prio;\n        break;\n\n      default: //no change\t\t\t\t\t\t\t\n\n    }\n  };\n\n  Contact.prototype.containsEmail = function (email) {\n    var lowerCaseEmail = email.toLowerCase();\n\n    if (this.loginEmail && this.loginEmail.toLowerCase() === lowerCaseEmail) {\n      return true;\n    }\n\n    if (this.emailPro && this.emailPro.toLowerCase() === lowerCaseEmail) {\n      return true;\n    }\n\n    if (this.emailPerso && this.emailPerso.toLowerCase() === lowerCaseEmail) {\n      return true;\n    }\n\n    return false;\n  };\n  /* PRIVATE METHODS */\n\n\n  Contact.prototype.computeDisplayName = function () {\n    var firstName = this.firstname ? this.firstname.charAt(0).toUpperCase() + this.firstname.slice(1) : null;\n    var lastName = this.lastname ? this.lastname.charAt(0).toUpperCase() + this.lastname.slice(1) : null;\n    var nickName = this.nickname ? this.nickname.charAt(0).toUpperCase() + this.nickname.slice(1) : null;\n\n    if (this.isTv) {\n      this.displayName = firstName ? firstName : lastName;\n      this.initials = this.displayName.charAt(0);\n    } else if (lastName && firstName) {\n      this.computeCompleteDisplayName(firstName, lastName);\n    } else if (lastName && !firstName) {\n      this.displayName = lastName;\n      this.initials = lastName.charAt(0);\n    } else if (nickName) {\n      this.displayName = nickName;\n      this.initials = nickName.charAt(0);\n    } else if (this.loginEmail) {\n      this.displayName = this.loginEmail;\n      this.initials = this.loginEmail.substring(0, 2).toUpperCase();\n    } else if (firstName) {\n      this.displayName = firstName;\n      this.initials = firstName.charAt(0);\n    } else {\n      this.displayName = "Anonymous";\n      this.initials = "A";\n    }\n  };\n\n  Contact.prototype.computeCompleteDisplayName = function (firstName, lastName) {\n    var displayName = "";\n    var initials = "";\n\n    if (lastName.length !== 1 && firstName.length !== 2) {\n      if (settingsService.getSetting("displayOrder") === "FL") {\n        displayName = firstName + " " + lastName;\n        initials = firstName.charAt(0) + lastName.charAt(0);\n      } else {\n        displayName = lastName + " " + firstName;\n        initials = lastName.charAt(0) + firstName.charAt(0);\n      }\n    } else {\n      if (settingsService.getSetting("displayOrder") === "FL") {\n        displayName = firstName + " " + lastName;\n      } else {\n        displayName = lastName + " " + firstName;\n      }\n\n      initials = firstName.charAt(0) + firstName.charAt(1);\n    }\n\n    this.displayName = displayName;\n    this.initials = initials; // Compute contact color\n\n    var upperCaseDisplayName = this.displayName.toUpperCase();\n    var sum = 0;\n\n    for (var i = 0; i < upperCaseDisplayName.length; i++) {\n      sum += upperCaseDisplayName.charCodeAt(i);\n    }\n\n    this.colorIndex = sum % 12;\n    this.color = Contact.textAvatarColor[this.colorIndex];\n  };\n  /*************************************************************/\n\n  /* AVATAR STUFF                                              */\n\n  /*************************************************************/\n\n\n  Contact.prototype.getAvatarInBase64 = function () {\n    var contact = this;\n    var that = this;\n    return $q(function (resolve) {\n      try {\n        if (!contact || !contact.avatar || !contact.avatar.src) {\n          resolve();\n        }\n\n        if (contact.avatar.src && !contact.avatar.src.startsWith("data:image/png")) {\n          var img = new Image();\n          var canvas = $document[0].createElement("canvas");\n          canvas.width = 120;\n          canvas.height = 120;\n          var ctx = canvas.getContext("2d");\n          ctx.rect(0, 0, 120, 120);\n          ctx.fillStyle = that.color;\n          ctx.fill();\n\n          img.onload = function () {\n            ctx.drawImage(this, 0, 0, 120, 120);\n            var dataURL = canvas.toDataURL("image/png");\n            resolve(dataURL);\n          };\n\n          img.src = contact.avatar.src;\n        } else {\n          resolve(contact.avatar.src);\n        }\n      } catch (error) {\n        $log.warn("[contactService] getAvatarInBase64 error " + error);\n        resolve();\n      }\n    });\n  };\n\n  Contact.prototype.getAvatar = function (size, forced) {\n    var contact = this; // Building url for SDK stored in avatarSrc\n\n    if (contact.dbId && contact.lastAvatarUpdateDate) {\n      var serverURL = config.webservices.protocol + "://" + config.webservices.currentServer;\n\n      if ($rootScope.cdn) {\n        serverURL = $rootScope.cdnServer;\n      }\n\n      var imgSrc = serverURL + "/api/avatar/" + contact.dbId + "?size=" + (size ? size : 256);\n      imgSrc += "&update=" + Object(crypto_js__WEBPACK_IMPORTED_MODULE_0__["MD5"])(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Latin1.parse(contact.lastAvatarUpdateDate)).toString(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Hex);\n      contact.avatarSrc = imgSrc;\n    }\n\n    if (authService.fromSDK) {\n      // Always create the text image\n      contact.createTextAvatarImage();\n      return $q.when();\n    } //if this is a Rainbow TV, get the avatar from local sources\n\n\n    if (contact.isTv) {\n      var image = new Image();\n      image.src = "/resources/skins/rainbow/images/misc/androidtv.svg";\n      contact.defaultAvatar = image;\n      return $q.when();\n    }\n\n    return $q(function (resolve) {\n      contact.createTextAvatarImage();\n\n      if (forced || !contact.lastAvatarUpdateDate) {\n        contact.avatar = null;\n      }\n\n      resolve(contact);\n    });\n  };\n\n  Contact.prototype.createTextAvatarImage = function () {\n    var that = this;\n    var image = new Image();\n    var canvas = $document[0].createElement("canvas");\n    canvas.width = image.width = 225;\n    canvas.height = image.height = 225;\n    var ctx = canvas.getContext("2d");\n    ctx.rect(0, 0, 225, 225);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n    ctx.font = "bold 100px Helvetica";\n    ctx.textAlign = "center";\n    ctx.fillStyle = "white";\n    ctx.fillText(this.initials, 110, 150);\n    image.src = canvas.toDataURL("image/png");\n    that.defaultAvatar = image;\n  };\n\n  Contact.prototype.getGroups = function () {\n    return this.groups;\n  };\n\n  Contact.prototype.setGroups = function (groups) {\n    this.groups = groups;\n  };\n\n  Contact.prototype.getNameForLogs = function () {\n    if (!this.nameForLogs && this.displayName) {\n      var temp = this.displayName.replace(/[^\\s](?=.{1,}$)/g, "*");\n      this.nameForLogs = this.displayName.charAt(0) + temp.substr(1);\n    }\n\n    return this.nameForLogs;\n  };\n  /*************************************************************/\n\n  /* INTERNAL AVATAR LIST                                      */\n\n  /*************************************************************/\n\n\n  Contact.textAvatarColor = ["#ff4500", "#d38700", "#348833", "#007356", "#00b2a9", "#00b0e5", "#0085ca", "#6639b7", "#91278a", "#cf0072", "#a50034", "#d20000"];\n  return Contact;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/contact.js?')},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Check if typed arrays are supported\n\t    if (typeof ArrayBuffer != 'function') {\n\t        return;\n\t    }\n\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\n\t    // Reference original init\n\t    var superInit = WordArray.init;\n\n\t    // Augment WordArray.init to handle typed arrays\n\t    var subInit = WordArray.init = function (typedArray) {\n\t        // Convert buffers to uint8\n\t        if (typedArray instanceof ArrayBuffer) {\n\t            typedArray = new Uint8Array(typedArray);\n\t        }\n\n\t        // Convert other array views to uint8\n\t        if (\n\t            typedArray instanceof Int8Array ||\n\t            (typeof Uint8ClampedArray !== \"undefined\" && typedArray instanceof Uint8ClampedArray) ||\n\t            typedArray instanceof Int16Array ||\n\t            typedArray instanceof Uint16Array ||\n\t            typedArray instanceof Int32Array ||\n\t            typedArray instanceof Uint32Array ||\n\t            typedArray instanceof Float32Array ||\n\t            typedArray instanceof Float64Array\n\t        ) {\n\t            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t        }\n\n\t        // Handle Uint8Array\n\t        if (typedArray instanceof Uint8Array) {\n\t            // Shortcut\n\t            var typedArrayByteLength = typedArray.byteLength;\n\n\t            // Extract bytes\n\t            var words = [];\n\t            for (var i = 0; i < typedArrayByteLength; i++) {\n\t                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n\t            }\n\n\t            // Initialize this word array\n\t            superInit.call(this, words, typedArrayByteLength);\n\t        } else {\n\t            // Else call normal init\n\t            superInit.apply(this, arguments);\n\t        }\n\t    };\n\n\t    subInit.prototype = WordArray;\n\t}());\n\n\n\treturn CryptoJS.lib.WordArray;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/lib-typedarrays.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * UTF-16 BE encoding strategy.\n\t     */\n\t    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 BE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 BE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 BE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 BE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-16 LE encoding strategy.\n\t     */\n\t    C_enc.Utf16LE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 LE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 LE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 LE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 LE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    function swapEndian(word) {\n\t        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Utf16;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/enc-utf16.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(14));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\n\t    /**\n\t     * SHA-224 hash algorithm.\n\t     */\n\t    var SHA224 = C_algo.SHA224 = SHA256.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA256._doFinalize.call(this);\n\n\t            hash.sigBytes -= 4;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA224('message');\n\t     *     var hash = CryptoJS.SHA224(wordArray);\n\t     */\n\t    C.SHA224 = SHA256._createHelper(SHA224);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA224(message, key);\n\t     */\n\t    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);\n\t}());\n\n\n\treturn CryptoJS.SHA224;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/sha224.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(9), __webpack_require__(15));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA512 = C_algo.SHA512;\n\n\t    /**\n\t     * SHA-384 hash algorithm.\n\t     */\n\t    var SHA384 = C_algo.SHA384 = SHA512.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),\n\t                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),\n\t                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),\n\t                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA512._doFinalize.call(this);\n\n\t            hash.sigBytes -= 16;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA384('message');\n\t     *     var hash = CryptoJS.SHA384(wordArray);\n\t     */\n\t    C.SHA384 = SHA512._createHelper(SHA384);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA384(message, key);\n\t     */\n\t    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);\n\t}());\n\n\n\treturn CryptoJS.SHA384;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/sha384.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(9));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var C_algo = C.algo;\n\n\t    // Constants tables\n\t    var RHO_OFFSETS = [];\n\t    var PI_INDEXES  = [];\n\t    var ROUND_CONSTANTS = [];\n\n\t    // Compute Constants\n\t    (function () {\n\t        // Compute rho offset constants\n\t        var x = 1, y = 0;\n\t        for (var t = 0; t < 24; t++) {\n\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t            var newX = y % 5;\n\t            var newY = (2 * x + 3 * y) % 5;\n\t            x = newX;\n\t            y = newY;\n\t        }\n\n\t        // Compute pi index constants\n\t        for (var x = 0; x < 5; x++) {\n\t            for (var y = 0; y < 5; y++) {\n\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t            }\n\t        }\n\n\t        // Compute round constants\n\t        var LFSR = 0x01;\n\t        for (var i = 0; i < 24; i++) {\n\t            var roundConstantMsw = 0;\n\t            var roundConstantLsw = 0;\n\n\t            for (var j = 0; j < 7; j++) {\n\t                if (LFSR & 0x01) {\n\t                    var bitPosition = (1 << j) - 1;\n\t                    if (bitPosition < 32) {\n\t                        roundConstantLsw ^= 1 << bitPosition;\n\t                    } else /* if (bitPosition >= 32) */ {\n\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t                    }\n\t                }\n\n\t                // Compute next LFSR\n\t                if (LFSR & 0x80) {\n\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t                } else {\n\t                    LFSR <<= 1;\n\t                }\n\t            }\n\n\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t        }\n\t    }());\n\n\t    // Reusable objects for temporary values\n\t    var T = [];\n\t    (function () {\n\t        for (var i = 0; i < 25; i++) {\n\t            T[i] = X64Word.create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-3 hash algorithm.\n\t     */\n\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} outputLength\n\t         *   The desired number of bits in the output hash.\n\t         *   Only values permitted are: 224, 256, 384, 512.\n\t         *   Default: 512\n\t         */\n\t        cfg: Hasher.cfg.extend({\n\t            outputLength: 512\n\t        }),\n\n\t        _doReset: function () {\n\t            var state = this._state = []\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = new X64Word.init();\n\t            }\n\n\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t            // Absorb\n\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t                // Shortcuts\n\t                var M2i  = M[offset + 2 * i];\n\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t                // Swap endian\n\t                M2i = (\n\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t                );\n\t                M2i1 = (\n\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Absorb message into state\n\t                var lane = state[i];\n\t                lane.high ^= M2i1;\n\t                lane.low  ^= M2i;\n\t            }\n\n\t            // Rounds\n\t            for (var round = 0; round < 24; round++) {\n\t                // Theta\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Mix column lanes\n\t                    var tMsw = 0, tLsw = 0;\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        tMsw ^= lane.high;\n\t                        tLsw ^= lane.low;\n\t                    }\n\n\t                    // Temporary values\n\t                    var Tx = T[x];\n\t                    Tx.high = tMsw;\n\t                    Tx.low  = tLsw;\n\t                }\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Shortcuts\n\t                    var Tx4 = T[(x + 4) % 5];\n\t                    var Tx1 = T[(x + 1) % 5];\n\t                    var Tx1Msw = Tx1.high;\n\t                    var Tx1Lsw = Tx1.low;\n\n\t                    // Mix surrounding columns\n\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        lane.high ^= tMsw;\n\t                        lane.low  ^= tLsw;\n\t                    }\n\t                }\n\n\t                // Rho Pi\n\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t                    // Shortcuts\n\t                    var lane = state[laneIndex];\n\t                    var laneMsw = lane.high;\n\t                    var laneLsw = lane.low;\n\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t                    // Rotate lanes\n\t                    if (rhoOffset < 32) {\n\t                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t                    } else /* if (rhoOffset >= 32) */ {\n\t                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t                    }\n\n\t                    // Transpose lanes\n\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t                    TPiLane.high = tMsw;\n\t                    TPiLane.low  = tLsw;\n\t                }\n\n\t                // Rho pi at x = y = 0\n\t                var T0 = T[0];\n\t                var state0 = state[0];\n\t                T0.high = state0.high;\n\t                T0.low  = state0.low;\n\n\t                // Chi\n\t                for (var x = 0; x < 5; x++) {\n\t                    for (var y = 0; y < 5; y++) {\n\t                        // Shortcuts\n\t                        var laneIndex = x + 5 * y;\n\t                        var lane = state[laneIndex];\n\t                        var TLane = T[laneIndex];\n\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t                        // Mix rows\n\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t                    }\n\t                }\n\n\t                // Iota\n\t                var lane = state[0];\n\t                var roundConstant = ROUND_CONSTANTS[round];\n\t                lane.high ^= roundConstant.high;\n\t                lane.low  ^= roundConstant.low;;\n\t            }\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t            var blockSizeBits = this.blockSize * 32;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t            // Squeeze\n\t            var hashWords = [];\n\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t                // Shortcuts\n\t                var lane = state[i];\n\t                var laneMsw = lane.high;\n\t                var laneLsw = lane.low;\n\n\t                // Swap endian\n\t                laneMsw = (\n\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t                );\n\t                laneLsw = (\n\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Squeeze state to retrieve hash\n\t                hashWords.push(laneLsw);\n\t                hashWords.push(laneMsw);\n\t            }\n\n\t            // Return final computed hash\n\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\n\t            var state = clone._state = this._state.slice(0);\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = state[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA3('message');\n\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t     */\n\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t     */\n\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA3;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/sha3.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t(c) 2012 by Cédric Mesnil. All rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\t    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\t    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t*/\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var _zl = WordArray.create([\n\t        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n\t        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n\t        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n\t        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);\n\t    var _zr = WordArray.create([\n\t        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n\t        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n\t        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n\t        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n\t        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);\n\t    var _sl = WordArray.create([\n\t         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,\n\t        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n\t        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n\t          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n\t        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);\n\t    var _sr = WordArray.create([\n\t        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n\t        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n\t        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n\t        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n\t        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);\n\n\t    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n\t    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\n\t    /**\n\t     * RIPEMD160 hash algorithm.\n\t     */\n\t    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                // Swap\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\t            // Shortcut\n\t            var H  = this._hash.words;\n\t            var hl = _hl.words;\n\t            var hr = _hr.words;\n\t            var zl = _zl.words;\n\t            var zr = _zr.words;\n\t            var sl = _sl.words;\n\t            var sr = _sr.words;\n\n\t            // Working variables\n\t            var al, bl, cl, dl, el;\n\t            var ar, br, cr, dr, er;\n\n\t            ar = al = H[0];\n\t            br = bl = H[1];\n\t            cr = cl = H[2];\n\t            dr = dl = H[3];\n\t            er = el = H[4];\n\t            // Computation\n\t            var t;\n\t            for (var i = 0; i < 80; i += 1) {\n\t                t = (al +  M[offset+zl[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f1(bl,cl,dl) + hl[0];\n\t                } else if (i<32) {\n\t\t            t +=  f2(bl,cl,dl) + hl[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(bl,cl,dl) + hl[2];\n\t                } else if (i<64) {\n\t\t            t +=  f4(bl,cl,dl) + hl[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f5(bl,cl,dl) + hl[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sl[i]);\n\t                t = (t+el)|0;\n\t                al = el;\n\t                el = dl;\n\t                dl = rotl(cl, 10);\n\t                cl = bl;\n\t                bl = t;\n\n\t                t = (ar + M[offset+zr[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f5(br,cr,dr) + hr[0];\n\t                } else if (i<32) {\n\t\t            t +=  f4(br,cr,dr) + hr[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(br,cr,dr) + hr[2];\n\t                } else if (i<64) {\n\t\t            t +=  f2(br,cr,dr) + hr[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f1(br,cr,dr) + hr[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sr[i]) ;\n\t                t = (t+er)|0;\n\t                ar = er;\n\t                er = dr;\n\t                dr = rotl(cr, 10);\n\t                cr = br;\n\t                br = t;\n\t            }\n\t            // Intermediate hash value\n\t            t    = (H[1] + cl + dr)|0;\n\t            H[1] = (H[2] + dl + er)|0;\n\t            H[2] = (H[3] + el + ar)|0;\n\t            H[3] = (H[4] + al + br)|0;\n\t            H[4] = (H[0] + bl + cr)|0;\n\t            H[0] =  t;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)\n\t            );\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 5; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                // Swap\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\n\t    function f1(x, y, z) {\n\t        return ((x) ^ (y) ^ (z));\n\n\t    }\n\n\t    function f2(x, y, z) {\n\t        return (((x)&(y)) | ((~x)&(z)));\n\t    }\n\n\t    function f3(x, y, z) {\n\t        return (((x) | (~(y))) ^ (z));\n\t    }\n\n\t    function f4(x, y, z) {\n\t        return (((x) & (z)) | ((y)&(~(z))));\n\t    }\n\n\t    function f5(x, y, z) {\n\t        return ((x) ^ ((y) |(~(z))));\n\n\t    }\n\n\t    function rotl(x,n) {\n\t        return (x<<n) | (x>>>(32-n));\n\t    }\n\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.RIPEMD160('message');\n\t     *     var hash = CryptoJS.RIPEMD160(wordArray);\n\t     */\n\t    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n\t     */\n\t    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);\n\t}(Math));\n\n\n\treturn CryptoJS.RIPEMD160;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/ripemd160.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(10), __webpack_require__(11));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA1 = C_algo.SHA1;\n\t    var HMAC = C_algo.HMAC;\n\n\t    /**\n\t     * Password-Based Key Derivation Function 2 algorithm.\n\t     */\n\t    var PBKDF2 = C_algo.PBKDF2 = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hasher to use. Default: SHA1\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: SHA1,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create();\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Computes the Password-Based Key Derivation Function 2.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init HMAC\n\t            var hmac = HMAC.create(cfg.hasher, password);\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\t            var blockIndex = WordArray.create([0x00000001]);\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var blockIndexWords = blockIndex.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                var block = hmac.update(salt).finalize(blockIndex);\n\t                hmac.reset();\n\n\t                // Shortcuts\n\t                var blockWords = block.words;\n\t                var blockWordsLength = blockWords.length;\n\n\t                // Iterations\n\t                var intermediate = block;\n\t                for (var i = 1; i < iterations; i++) {\n\t                    intermediate = hmac.finalize(intermediate);\n\t                    hmac.reset();\n\n\t                    // Shortcut\n\t                    var intermediateWords = intermediate.words;\n\n\t                    // XOR intermediate with block\n\t                    for (var j = 0; j < blockWordsLength; j++) {\n\t                        blockWords[j] ^= intermediateWords[j];\n\t                    }\n\t                }\n\n\t                derivedKey.concat(block);\n\t                blockIndexWords[0]++;\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Computes the Password-Based Key Derivation Function 2.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.PBKDF2(password, salt);\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.PBKDF2 = function (password, salt, cfg) {\n\t        return PBKDF2.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.PBKDF2;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/pbkdf2.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher Feedback block mode.\n\t */\n\tCryptoJS.mode.CFB = (function () {\n\t    var CFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    CFB.Encryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // Remember this block to use with next block\n\t            this._prevBlock = words.slice(offset, offset + blockSize);\n\t        }\n\t    });\n\n\t    CFB.Decryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            // Remember this block to use with next block\n\t            var thisBlock = words.slice(offset, offset + blockSize);\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // This block becomes the previous block\n\t            this._prevBlock = thisBlock;\n\t        }\n\t    });\n\n\t    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n\t        // Shortcut\n\t        var iv = this._iv;\n\n\t        // Generate keystream\n\t        if (iv) {\n\t            var keystream = iv.slice(0);\n\n\t            // Remove IV for subsequent blocks\n\t            this._iv = undefined;\n\t        } else {\n\t            var keystream = this._prevBlock;\n\t        }\n\t        cipher.encryptBlock(keystream, 0);\n\n\t        // Encrypt\n\t        for (var i = 0; i < blockSize; i++) {\n\t            words[offset + i] ^= keystream[i];\n\t        }\n\t    }\n\n\t    return CFB;\n\t}());\n\n\n\treturn CryptoJS.mode.CFB;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/mode-cfb.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Counter block mode.\n\t */\n\tCryptoJS.mode.CTR = (function () {\n\t    var CTR = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = CTR.Encryptor = CTR.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            var keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Increment counter\n\t            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTR.Decryptor = Encryptor;\n\n\t    return CTR;\n\t}());\n\n\n\treturn CryptoJS.mode.CTR;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/mode-ctr.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n\t * derived from CryptoJS.mode.CTR\n\t * Jan Hruby jhruby.web@gmail.com\n\t */\n\tCryptoJS.mode.CTRGladman = (function () {\n\t    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tfunction incWord(word)\n\t\t{\n\t\t\tif (((word >> 24) & 0xff) === 0xff) { //overflow\n\t\t\tvar b1 = (word >> 16)&0xff;\n\t\t\tvar b2 = (word >> 8)&0xff;\n\t\t\tvar b3 = word & 0xff;\n\n\t\t\tif (b1 === 0xff) // overflow b1\n\t\t\t{\n\t\t\tb1 = 0;\n\t\t\tif (b2 === 0xff)\n\t\t\t{\n\t\t\t\tb2 = 0;\n\t\t\t\tif (b3 === 0xff)\n\t\t\t\t{\n\t\t\t\t\tb3 = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++b3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++b2;\n\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t++b1;\n\t\t\t}\n\n\t\t\tword = 0;\n\t\t\tword += (b1 << 16);\n\t\t\tword += (b2 << 8);\n\t\t\tword += b3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tword += (0x01 << 24);\n\t\t\t}\n\t\t\treturn word;\n\t\t}\n\n\t\tfunction incCounter(counter)\n\t\t{\n\t\t\tif ((counter[0] = incWord(counter[0])) === 0)\n\t\t\t{\n\t\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n\t\t\t\tcounter[1] = incWord(counter[1]);\n\t\t\t}\n\t\t\treturn counter;\n\t\t}\n\n\t    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\n\t\t\t\tincCounter(counter);\n\n\t\t\t\tvar keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTRGladman.Decryptor = Encryptor;\n\n\t    return CTRGladman;\n\t}());\n\n\n\n\n\treturn CryptoJS.mode.CTRGladman;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/mode-ctr-gladman.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Output Feedback block mode.\n\t */\n\tCryptoJS.mode.OFB = (function () {\n\t    var OFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = OFB.Encryptor = OFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var keystream = this._keystream;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                keystream = this._keystream = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    OFB.Decryptor = Encryptor;\n\n\t    return OFB;\n\t}());\n\n\n\treturn CryptoJS.mode.OFB;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/mode-ofb.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Electronic Codebook block mode.\n\t */\n\tCryptoJS.mode.ECB = (function () {\n\t    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    ECB.Encryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.encryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    ECB.Decryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.decryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    return ECB;\n\t}());\n\n\n\treturn CryptoJS.mode.ECB;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/mode-ecb.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ANSI X.923 padding strategy.\n\t */\n\tCryptoJS.pad.AnsiX923 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcuts\n\t        var dataSigBytes = data.sigBytes;\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;\n\n\t        // Compute last byte position\n\t        var lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\n\t        data.sigBytes += nPaddingBytes;\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Ansix923;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/pad-ansix923.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO 10126 padding strategy.\n\t */\n\tCryptoJS.pad.Iso10126 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t        // Pad\n\t        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).\n\t             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso10126;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/pad-iso10126.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO/IEC 9797-1 Padding Method 2.\n\t */\n\tCryptoJS.pad.Iso97971 = {\n\t    pad: function (data, blockSize) {\n\t        // Add 0x80 byte\n\t        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));\n\n\t        // Zero pad the rest\n\t        CryptoJS.pad.ZeroPadding.pad(data, blockSize);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Remove zero padding\n\t        CryptoJS.pad.ZeroPadding.unpad(data);\n\n\t        // Remove one more byte -- the 0x80 byte\n\t        data.sigBytes--;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso97971;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/pad-iso97971.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Zero padding strategy.\n\t */\n\tCryptoJS.pad.ZeroPadding = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Shortcut\n\t        var dataWords = data.words;\n\n\t        // Unpad\n\t        var i = data.sigBytes - 1;\n\t        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {\n\t            i--;\n\t        }\n\t        data.sigBytes = i + 1;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.ZeroPadding;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/pad-zeropadding.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * A noop padding strategy.\n\t */\n\tCryptoJS.pad.NoPadding = {\n\t    pad: function () {\n\t    },\n\n\t    unpad: function () {\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.NoPadding;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/pad-nopadding.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var CipherParams = C_lib.CipherParams;\n\t    var C_enc = C.enc;\n\t    var Hex = C_enc.Hex;\n\t    var C_format = C.format;\n\n\t    var HexFormatter = C_format.Hex = {\n\t        /**\n\t         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The hexadecimally encoded string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            return cipherParams.ciphertext.toString(Hex);\n\t        },\n\n\t        /**\n\t         * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n\t         *\n\t         * @param {string} input The hexadecimally encoded string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n\t         */\n\t        parse: function (input) {\n\t            var ciphertext = Hex.parse(input);\n\t            return CipherParams.create({ ciphertext: ciphertext });\n\t        }\n\t    };\n\t}());\n\n\n\treturn CryptoJS.format.Hex;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/format-hex.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(5), __webpack_require__(6), __webpack_require__(4), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Lookup tables\n\t    var SBOX = [];\n\t    var INV_SBOX = [];\n\t    var SUB_MIX_0 = [];\n\t    var SUB_MIX_1 = [];\n\t    var SUB_MIX_2 = [];\n\t    var SUB_MIX_3 = [];\n\t    var INV_SUB_MIX_0 = [];\n\t    var INV_SUB_MIX_1 = [];\n\t    var INV_SUB_MIX_2 = [];\n\t    var INV_SUB_MIX_3 = [];\n\n\t    // Compute lookup tables\n\t    (function () {\n\t        // Compute double table\n\t        var d = [];\n\t        for (var i = 0; i < 256; i++) {\n\t            if (i < 128) {\n\t                d[i] = i << 1;\n\t            } else {\n\t                d[i] = (i << 1) ^ 0x11b;\n\t            }\n\t        }\n\n\t        // Walk GF(2^8)\n\t        var x = 0;\n\t        var xi = 0;\n\t        for (var i = 0; i < 256; i++) {\n\t            // Compute sbox\n\t            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n\t            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n\t            SBOX[x] = sx;\n\t            INV_SBOX[sx] = x;\n\n\t            // Compute multiplication\n\t            var x2 = d[x];\n\t            var x4 = d[x2];\n\t            var x8 = d[x4];\n\n\t            // Compute sub bytes, mix columns tables\n\t            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n\t            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n\t            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n\t            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n\t            SUB_MIX_3[x] = t;\n\n\t            // Compute inv sub bytes, inv mix columns tables\n\t            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n\t            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n\t            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n\t            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n\t            INV_SUB_MIX_3[sx] = t;\n\n\t            // Compute next counter\n\t            if (!x) {\n\t                x = xi = 1;\n\t            } else {\n\t                x = x2 ^ d[d[d[x8 ^ x2]]];\n\t                xi ^= d[d[xi]];\n\t            }\n\t        }\n\t    }());\n\n\t    // Precomputed Rcon lookup\n\t    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n\t    /**\n\t     * AES block cipher algorithm.\n\t     */\n\t    var AES = C_algo.AES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._nRounds && this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            // Compute number of rounds\n\t            var nRounds = this._nRounds = keySize + 6;\n\n\t            // Compute number of key schedule rows\n\t            var ksRows = (nRounds + 1) * 4;\n\n\t            // Compute key schedule\n\t            var keySchedule = this._keySchedule = [];\n\t            for (var ksRow = 0; ksRow < ksRows; ksRow++) {\n\t                if (ksRow < keySize) {\n\t                    keySchedule[ksRow] = keyWords[ksRow];\n\t                } else {\n\t                    var t = keySchedule[ksRow - 1];\n\n\t                    if (!(ksRow % keySize)) {\n\t                        // Rot word\n\t                        t = (t << 8) | (t >>> 24);\n\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n\t                        // Mix Rcon\n\t                        t ^= RCON[(ksRow / keySize) | 0] << 24;\n\t                    } else if (keySize > 6 && ksRow % keySize == 4) {\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\t                    }\n\n\t                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n\t                }\n\t            }\n\n\t            // Compute inv key schedule\n\t            var invKeySchedule = this._invKeySchedule = [];\n\t            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n\t                var ksRow = ksRows - invKsRow;\n\n\t                if (invKsRow % 4) {\n\t                    var t = keySchedule[ksRow];\n\t                } else {\n\t                    var t = keySchedule[ksRow - 4];\n\t                }\n\n\t                if (invKsRow < 4 || ksRow <= 4) {\n\t                    invKeySchedule[invKsRow] = t;\n\t                } else {\n\t                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n\t                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n\t                }\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            // Swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\n\t            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n\t            // Inv swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\t        },\n\n\t        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n\t            // Shortcut\n\t            var nRounds = this._nRounds;\n\n\t            // Get input, add round key\n\t            var s0 = M[offset]     ^ keySchedule[0];\n\t            var s1 = M[offset + 1] ^ keySchedule[1];\n\t            var s2 = M[offset + 2] ^ keySchedule[2];\n\t            var s3 = M[offset + 3] ^ keySchedule[3];\n\n\t            // Key schedule row counter\n\t            var ksRow = 4;\n\n\t            // Rounds\n\t            for (var round = 1; round < nRounds; round++) {\n\t                // Shift rows, sub bytes, mix columns, add round key\n\t                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\n\t                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\n\t                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\n\t                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\n\n\t                // Update state\n\t                s0 = t0;\n\t                s1 = t1;\n\t                s2 = t2;\n\t                s3 = t3;\n\t            }\n\n\t            // Shift rows, sub bytes, add round key\n\t            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n\n\t            // Set output\n\t            M[offset]     = t0;\n\t            M[offset + 1] = t1;\n\t            M[offset + 2] = t2;\n\t            M[offset + 3] = t3;\n\t        },\n\n\t        keySize: 256/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.AES = BlockCipher._createHelper(AES);\n\t}());\n\n\n\treturn CryptoJS.AES;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/aes.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(5), __webpack_require__(6), __webpack_require__(4), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Permuted Choice 1 constants\n\t    var PC1 = [\n\t        57, 49, 41, 33, 25, 17, 9,  1,\n\t        58, 50, 42, 34, 26, 18, 10, 2,\n\t        59, 51, 43, 35, 27, 19, 11, 3,\n\t        60, 52, 44, 36, 63, 55, 47, 39,\n\t        31, 23, 15, 7,  62, 54, 46, 38,\n\t        30, 22, 14, 6,  61, 53, 45, 37,\n\t        29, 21, 13, 5,  28, 20, 12, 4\n\t    ];\n\n\t    // Permuted Choice 2 constants\n\t    var PC2 = [\n\t        14, 17, 11, 24, 1,  5,\n\t        3,  28, 15, 6,  21, 10,\n\t        23, 19, 12, 4,  26, 8,\n\t        16, 7,  27, 20, 13, 2,\n\t        41, 52, 31, 37, 47, 55,\n\t        30, 40, 51, 45, 33, 48,\n\t        44, 49, 39, 56, 34, 53,\n\t        46, 42, 50, 36, 29, 32\n\t    ];\n\n\t    // Cumulative bit shift constants\n\t    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n\t    // SBOXes and round permutation constants\n\t    var SBOX_P = [\n\t        {\n\t            0x0: 0x808200,\n\t            0x10000000: 0x8000,\n\t            0x20000000: 0x808002,\n\t            0x30000000: 0x2,\n\t            0x40000000: 0x200,\n\t            0x50000000: 0x808202,\n\t            0x60000000: 0x800202,\n\t            0x70000000: 0x800000,\n\t            0x80000000: 0x202,\n\t            0x90000000: 0x800200,\n\t            0xa0000000: 0x8200,\n\t            0xb0000000: 0x808000,\n\t            0xc0000000: 0x8002,\n\t            0xd0000000: 0x800002,\n\t            0xe0000000: 0x0,\n\t            0xf0000000: 0x8202,\n\t            0x8000000: 0x0,\n\t            0x18000000: 0x808202,\n\t            0x28000000: 0x8202,\n\t            0x38000000: 0x8000,\n\t            0x48000000: 0x808200,\n\t            0x58000000: 0x200,\n\t            0x68000000: 0x808002,\n\t            0x78000000: 0x2,\n\t            0x88000000: 0x800200,\n\t            0x98000000: 0x8200,\n\t            0xa8000000: 0x808000,\n\t            0xb8000000: 0x800202,\n\t            0xc8000000: 0x800002,\n\t            0xd8000000: 0x8002,\n\t            0xe8000000: 0x202,\n\t            0xf8000000: 0x800000,\n\t            0x1: 0x8000,\n\t            0x10000001: 0x2,\n\t            0x20000001: 0x808200,\n\t            0x30000001: 0x800000,\n\t            0x40000001: 0x808002,\n\t            0x50000001: 0x8200,\n\t            0x60000001: 0x200,\n\t            0x70000001: 0x800202,\n\t            0x80000001: 0x808202,\n\t            0x90000001: 0x808000,\n\t            0xa0000001: 0x800002,\n\t            0xb0000001: 0x8202,\n\t            0xc0000001: 0x202,\n\t            0xd0000001: 0x800200,\n\t            0xe0000001: 0x8002,\n\t            0xf0000001: 0x0,\n\t            0x8000001: 0x808202,\n\t            0x18000001: 0x808000,\n\t            0x28000001: 0x800000,\n\t            0x38000001: 0x200,\n\t            0x48000001: 0x8000,\n\t            0x58000001: 0x800002,\n\t            0x68000001: 0x2,\n\t            0x78000001: 0x8202,\n\t            0x88000001: 0x8002,\n\t            0x98000001: 0x800202,\n\t            0xa8000001: 0x202,\n\t            0xb8000001: 0x808200,\n\t            0xc8000001: 0x800200,\n\t            0xd8000001: 0x0,\n\t            0xe8000001: 0x8200,\n\t            0xf8000001: 0x808002\n\t        },\n\t        {\n\t            0x0: 0x40084010,\n\t            0x1000000: 0x4000,\n\t            0x2000000: 0x80000,\n\t            0x3000000: 0x40080010,\n\t            0x4000000: 0x40000010,\n\t            0x5000000: 0x40084000,\n\t            0x6000000: 0x40004000,\n\t            0x7000000: 0x10,\n\t            0x8000000: 0x84000,\n\t            0x9000000: 0x40004010,\n\t            0xa000000: 0x40000000,\n\t            0xb000000: 0x84010,\n\t            0xc000000: 0x80010,\n\t            0xd000000: 0x0,\n\t            0xe000000: 0x4010,\n\t            0xf000000: 0x40080000,\n\t            0x800000: 0x40004000,\n\t            0x1800000: 0x84010,\n\t            0x2800000: 0x10,\n\t            0x3800000: 0x40004010,\n\t            0x4800000: 0x40084010,\n\t            0x5800000: 0x40000000,\n\t            0x6800000: 0x80000,\n\t            0x7800000: 0x40080010,\n\t            0x8800000: 0x80010,\n\t            0x9800000: 0x0,\n\t            0xa800000: 0x4000,\n\t            0xb800000: 0x40080000,\n\t            0xc800000: 0x40000010,\n\t            0xd800000: 0x84000,\n\t            0xe800000: 0x40084000,\n\t            0xf800000: 0x4010,\n\t            0x10000000: 0x0,\n\t            0x11000000: 0x40080010,\n\t            0x12000000: 0x40004010,\n\t            0x13000000: 0x40084000,\n\t            0x14000000: 0x40080000,\n\t            0x15000000: 0x10,\n\t            0x16000000: 0x84010,\n\t            0x17000000: 0x4000,\n\t            0x18000000: 0x4010,\n\t            0x19000000: 0x80000,\n\t            0x1a000000: 0x80010,\n\t            0x1b000000: 0x40000010,\n\t            0x1c000000: 0x84000,\n\t            0x1d000000: 0x40004000,\n\t            0x1e000000: 0x40000000,\n\t            0x1f000000: 0x40084010,\n\t            0x10800000: 0x84010,\n\t            0x11800000: 0x80000,\n\t            0x12800000: 0x40080000,\n\t            0x13800000: 0x4000,\n\t            0x14800000: 0x40004000,\n\t            0x15800000: 0x40084010,\n\t            0x16800000: 0x10,\n\t            0x17800000: 0x40000000,\n\t            0x18800000: 0x40084000,\n\t            0x19800000: 0x40000010,\n\t            0x1a800000: 0x40004010,\n\t            0x1b800000: 0x80010,\n\t            0x1c800000: 0x0,\n\t            0x1d800000: 0x4010,\n\t            0x1e800000: 0x40080010,\n\t            0x1f800000: 0x84000\n\t        },\n\t        {\n\t            0x0: 0x104,\n\t            0x100000: 0x0,\n\t            0x200000: 0x4000100,\n\t            0x300000: 0x10104,\n\t            0x400000: 0x10004,\n\t            0x500000: 0x4000004,\n\t            0x600000: 0x4010104,\n\t            0x700000: 0x4010000,\n\t            0x800000: 0x4000000,\n\t            0x900000: 0x4010100,\n\t            0xa00000: 0x10100,\n\t            0xb00000: 0x4010004,\n\t            0xc00000: 0x4000104,\n\t            0xd00000: 0x10000,\n\t            0xe00000: 0x4,\n\t            0xf00000: 0x100,\n\t            0x80000: 0x4010100,\n\t            0x180000: 0x4010004,\n\t            0x280000: 0x0,\n\t            0x380000: 0x4000100,\n\t            0x480000: 0x4000004,\n\t            0x580000: 0x10000,\n\t            0x680000: 0x10004,\n\t            0x780000: 0x104,\n\t            0x880000: 0x4,\n\t            0x980000: 0x100,\n\t            0xa80000: 0x4010000,\n\t            0xb80000: 0x10104,\n\t            0xc80000: 0x10100,\n\t            0xd80000: 0x4000104,\n\t            0xe80000: 0x4010104,\n\t            0xf80000: 0x4000000,\n\t            0x1000000: 0x4010100,\n\t            0x1100000: 0x10004,\n\t            0x1200000: 0x10000,\n\t            0x1300000: 0x4000100,\n\t            0x1400000: 0x100,\n\t            0x1500000: 0x4010104,\n\t            0x1600000: 0x4000004,\n\t            0x1700000: 0x0,\n\t            0x1800000: 0x4000104,\n\t            0x1900000: 0x4000000,\n\t            0x1a00000: 0x4,\n\t            0x1b00000: 0x10100,\n\t            0x1c00000: 0x4010000,\n\t            0x1d00000: 0x104,\n\t            0x1e00000: 0x10104,\n\t            0x1f00000: 0x4010004,\n\t            0x1080000: 0x4000000,\n\t            0x1180000: 0x104,\n\t            0x1280000: 0x4010100,\n\t            0x1380000: 0x0,\n\t            0x1480000: 0x10004,\n\t            0x1580000: 0x4000100,\n\t            0x1680000: 0x100,\n\t            0x1780000: 0x4010004,\n\t            0x1880000: 0x10000,\n\t            0x1980000: 0x4010104,\n\t            0x1a80000: 0x10104,\n\t            0x1b80000: 0x4000004,\n\t            0x1c80000: 0x4000104,\n\t            0x1d80000: 0x4010000,\n\t            0x1e80000: 0x4,\n\t            0x1f80000: 0x10100\n\t        },\n\t        {\n\t            0x0: 0x80401000,\n\t            0x10000: 0x80001040,\n\t            0x20000: 0x401040,\n\t            0x30000: 0x80400000,\n\t            0x40000: 0x0,\n\t            0x50000: 0x401000,\n\t            0x60000: 0x80000040,\n\t            0x70000: 0x400040,\n\t            0x80000: 0x80000000,\n\t            0x90000: 0x400000,\n\t            0xa0000: 0x40,\n\t            0xb0000: 0x80001000,\n\t            0xc0000: 0x80400040,\n\t            0xd0000: 0x1040,\n\t            0xe0000: 0x1000,\n\t            0xf0000: 0x80401040,\n\t            0x8000: 0x80001040,\n\t            0x18000: 0x40,\n\t            0x28000: 0x80400040,\n\t            0x38000: 0x80001000,\n\t            0x48000: 0x401000,\n\t            0x58000: 0x80401040,\n\t            0x68000: 0x0,\n\t            0x78000: 0x80400000,\n\t            0x88000: 0x1000,\n\t            0x98000: 0x80401000,\n\t            0xa8000: 0x400000,\n\t            0xb8000: 0x1040,\n\t            0xc8000: 0x80000000,\n\t            0xd8000: 0x400040,\n\t            0xe8000: 0x401040,\n\t            0xf8000: 0x80000040,\n\t            0x100000: 0x400040,\n\t            0x110000: 0x401000,\n\t            0x120000: 0x80000040,\n\t            0x130000: 0x0,\n\t            0x140000: 0x1040,\n\t            0x150000: 0x80400040,\n\t            0x160000: 0x80401000,\n\t            0x170000: 0x80001040,\n\t            0x180000: 0x80401040,\n\t            0x190000: 0x80000000,\n\t            0x1a0000: 0x80400000,\n\t            0x1b0000: 0x401040,\n\t            0x1c0000: 0x80001000,\n\t            0x1d0000: 0x400000,\n\t            0x1e0000: 0x40,\n\t            0x1f0000: 0x1000,\n\t            0x108000: 0x80400000,\n\t            0x118000: 0x80401040,\n\t            0x128000: 0x0,\n\t            0x138000: 0x401000,\n\t            0x148000: 0x400040,\n\t            0x158000: 0x80000000,\n\t            0x168000: 0x80001040,\n\t            0x178000: 0x40,\n\t            0x188000: 0x80000040,\n\t            0x198000: 0x1000,\n\t            0x1a8000: 0x80001000,\n\t            0x1b8000: 0x80400040,\n\t            0x1c8000: 0x1040,\n\t            0x1d8000: 0x80401000,\n\t            0x1e8000: 0x400000,\n\t            0x1f8000: 0x401040\n\t        },\n\t        {\n\t            0x0: 0x80,\n\t            0x1000: 0x1040000,\n\t            0x2000: 0x40000,\n\t            0x3000: 0x20000000,\n\t            0x4000: 0x20040080,\n\t            0x5000: 0x1000080,\n\t            0x6000: 0x21000080,\n\t            0x7000: 0x40080,\n\t            0x8000: 0x1000000,\n\t            0x9000: 0x20040000,\n\t            0xa000: 0x20000080,\n\t            0xb000: 0x21040080,\n\t            0xc000: 0x21040000,\n\t            0xd000: 0x0,\n\t            0xe000: 0x1040080,\n\t            0xf000: 0x21000000,\n\t            0x800: 0x1040080,\n\t            0x1800: 0x21000080,\n\t            0x2800: 0x80,\n\t            0x3800: 0x1040000,\n\t            0x4800: 0x40000,\n\t            0x5800: 0x20040080,\n\t            0x6800: 0x21040000,\n\t            0x7800: 0x20000000,\n\t            0x8800: 0x20040000,\n\t            0x9800: 0x0,\n\t            0xa800: 0x21040080,\n\t            0xb800: 0x1000080,\n\t            0xc800: 0x20000080,\n\t            0xd800: 0x21000000,\n\t            0xe800: 0x1000000,\n\t            0xf800: 0x40080,\n\t            0x10000: 0x40000,\n\t            0x11000: 0x80,\n\t            0x12000: 0x20000000,\n\t            0x13000: 0x21000080,\n\t            0x14000: 0x1000080,\n\t            0x15000: 0x21040000,\n\t            0x16000: 0x20040080,\n\t            0x17000: 0x1000000,\n\t            0x18000: 0x21040080,\n\t            0x19000: 0x21000000,\n\t            0x1a000: 0x1040000,\n\t            0x1b000: 0x20040000,\n\t            0x1c000: 0x40080,\n\t            0x1d000: 0x20000080,\n\t            0x1e000: 0x0,\n\t            0x1f000: 0x1040080,\n\t            0x10800: 0x21000080,\n\t            0x11800: 0x1000000,\n\t            0x12800: 0x1040000,\n\t            0x13800: 0x20040080,\n\t            0x14800: 0x20000000,\n\t            0x15800: 0x1040080,\n\t            0x16800: 0x80,\n\t            0x17800: 0x21040000,\n\t            0x18800: 0x40080,\n\t            0x19800: 0x21040080,\n\t            0x1a800: 0x0,\n\t            0x1b800: 0x21000000,\n\t            0x1c800: 0x1000080,\n\t            0x1d800: 0x40000,\n\t            0x1e800: 0x20040000,\n\t            0x1f800: 0x20000080\n\t        },\n\t        {\n\t            0x0: 0x10000008,\n\t            0x100: 0x2000,\n\t            0x200: 0x10200000,\n\t            0x300: 0x10202008,\n\t            0x400: 0x10002000,\n\t            0x500: 0x200000,\n\t            0x600: 0x200008,\n\t            0x700: 0x10000000,\n\t            0x800: 0x0,\n\t            0x900: 0x10002008,\n\t            0xa00: 0x202000,\n\t            0xb00: 0x8,\n\t            0xc00: 0x10200008,\n\t            0xd00: 0x202008,\n\t            0xe00: 0x2008,\n\t            0xf00: 0x10202000,\n\t            0x80: 0x10200000,\n\t            0x180: 0x10202008,\n\t            0x280: 0x8,\n\t            0x380: 0x200000,\n\t            0x480: 0x202008,\n\t            0x580: 0x10000008,\n\t            0x680: 0x10002000,\n\t            0x780: 0x2008,\n\t            0x880: 0x200008,\n\t            0x980: 0x2000,\n\t            0xa80: 0x10002008,\n\t            0xb80: 0x10200008,\n\t            0xc80: 0x0,\n\t            0xd80: 0x10202000,\n\t            0xe80: 0x202000,\n\t            0xf80: 0x10000000,\n\t            0x1000: 0x10002000,\n\t            0x1100: 0x10200008,\n\t            0x1200: 0x10202008,\n\t            0x1300: 0x2008,\n\t            0x1400: 0x200000,\n\t            0x1500: 0x10000000,\n\t            0x1600: 0x10000008,\n\t            0x1700: 0x202000,\n\t            0x1800: 0x202008,\n\t            0x1900: 0x0,\n\t            0x1a00: 0x8,\n\t            0x1b00: 0x10200000,\n\t            0x1c00: 0x2000,\n\t            0x1d00: 0x10002008,\n\t            0x1e00: 0x10202000,\n\t            0x1f00: 0x200008,\n\t            0x1080: 0x8,\n\t            0x1180: 0x202000,\n\t            0x1280: 0x200000,\n\t            0x1380: 0x10000008,\n\t            0x1480: 0x10002000,\n\t            0x1580: 0x2008,\n\t            0x1680: 0x10202008,\n\t            0x1780: 0x10200000,\n\t            0x1880: 0x10202000,\n\t            0x1980: 0x10200008,\n\t            0x1a80: 0x2000,\n\t            0x1b80: 0x202008,\n\t            0x1c80: 0x200008,\n\t            0x1d80: 0x0,\n\t            0x1e80: 0x10000000,\n\t            0x1f80: 0x10002008\n\t        },\n\t        {\n\t            0x0: 0x100000,\n\t            0x10: 0x2000401,\n\t            0x20: 0x400,\n\t            0x30: 0x100401,\n\t            0x40: 0x2100401,\n\t            0x50: 0x0,\n\t            0x60: 0x1,\n\t            0x70: 0x2100001,\n\t            0x80: 0x2000400,\n\t            0x90: 0x100001,\n\t            0xa0: 0x2000001,\n\t            0xb0: 0x2100400,\n\t            0xc0: 0x2100000,\n\t            0xd0: 0x401,\n\t            0xe0: 0x100400,\n\t            0xf0: 0x2000000,\n\t            0x8: 0x2100001,\n\t            0x18: 0x0,\n\t            0x28: 0x2000401,\n\t            0x38: 0x2100400,\n\t            0x48: 0x100000,\n\t            0x58: 0x2000001,\n\t            0x68: 0x2000000,\n\t            0x78: 0x401,\n\t            0x88: 0x100401,\n\t            0x98: 0x2000400,\n\t            0xa8: 0x2100000,\n\t            0xb8: 0x100001,\n\t            0xc8: 0x400,\n\t            0xd8: 0x2100401,\n\t            0xe8: 0x1,\n\t            0xf8: 0x100400,\n\t            0x100: 0x2000000,\n\t            0x110: 0x100000,\n\t            0x120: 0x2000401,\n\t            0x130: 0x2100001,\n\t            0x140: 0x100001,\n\t            0x150: 0x2000400,\n\t            0x160: 0x2100400,\n\t            0x170: 0x100401,\n\t            0x180: 0x401,\n\t            0x190: 0x2100401,\n\t            0x1a0: 0x100400,\n\t            0x1b0: 0x1,\n\t            0x1c0: 0x0,\n\t            0x1d0: 0x2100000,\n\t            0x1e0: 0x2000001,\n\t            0x1f0: 0x400,\n\t            0x108: 0x100400,\n\t            0x118: 0x2000401,\n\t            0x128: 0x2100001,\n\t            0x138: 0x1,\n\t            0x148: 0x2000000,\n\t            0x158: 0x100000,\n\t            0x168: 0x401,\n\t            0x178: 0x2100400,\n\t            0x188: 0x2000001,\n\t            0x198: 0x2100000,\n\t            0x1a8: 0x0,\n\t            0x1b8: 0x2100401,\n\t            0x1c8: 0x100401,\n\t            0x1d8: 0x400,\n\t            0x1e8: 0x2000400,\n\t            0x1f8: 0x100001\n\t        },\n\t        {\n\t            0x0: 0x8000820,\n\t            0x1: 0x20000,\n\t            0x2: 0x8000000,\n\t            0x3: 0x20,\n\t            0x4: 0x20020,\n\t            0x5: 0x8020820,\n\t            0x6: 0x8020800,\n\t            0x7: 0x800,\n\t            0x8: 0x8020000,\n\t            0x9: 0x8000800,\n\t            0xa: 0x20800,\n\t            0xb: 0x8020020,\n\t            0xc: 0x820,\n\t            0xd: 0x0,\n\t            0xe: 0x8000020,\n\t            0xf: 0x20820,\n\t            0x80000000: 0x800,\n\t            0x80000001: 0x8020820,\n\t            0x80000002: 0x8000820,\n\t            0x80000003: 0x8000000,\n\t            0x80000004: 0x8020000,\n\t            0x80000005: 0x20800,\n\t            0x80000006: 0x20820,\n\t            0x80000007: 0x20,\n\t            0x80000008: 0x8000020,\n\t            0x80000009: 0x820,\n\t            0x8000000a: 0x20020,\n\t            0x8000000b: 0x8020800,\n\t            0x8000000c: 0x0,\n\t            0x8000000d: 0x8020020,\n\t            0x8000000e: 0x8000800,\n\t            0x8000000f: 0x20000,\n\t            0x10: 0x20820,\n\t            0x11: 0x8020800,\n\t            0x12: 0x20,\n\t            0x13: 0x800,\n\t            0x14: 0x8000800,\n\t            0x15: 0x8000020,\n\t            0x16: 0x8020020,\n\t            0x17: 0x20000,\n\t            0x18: 0x0,\n\t            0x19: 0x20020,\n\t            0x1a: 0x8020000,\n\t            0x1b: 0x8000820,\n\t            0x1c: 0x8020820,\n\t            0x1d: 0x20800,\n\t            0x1e: 0x820,\n\t            0x1f: 0x8000000,\n\t            0x80000010: 0x20000,\n\t            0x80000011: 0x800,\n\t            0x80000012: 0x8020020,\n\t            0x80000013: 0x20820,\n\t            0x80000014: 0x20,\n\t            0x80000015: 0x8020000,\n\t            0x80000016: 0x8000000,\n\t            0x80000017: 0x8000820,\n\t            0x80000018: 0x8020820,\n\t            0x80000019: 0x8000020,\n\t            0x8000001a: 0x8000800,\n\t            0x8000001b: 0x0,\n\t            0x8000001c: 0x20800,\n\t            0x8000001d: 0x820,\n\t            0x8000001e: 0x20020,\n\t            0x8000001f: 0x8020800\n\t        }\n\t    ];\n\n\t    // Masks that select the SBOX input\n\t    var SBOX_MASK = [\n\t        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\n\t        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f\n\t    ];\n\n\t    /**\n\t     * DES block cipher algorithm.\n\t     */\n\t    var DES = C_algo.DES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\n\t            // Select 56 bits according to PC1\n\t            var keyBits = [];\n\t            for (var i = 0; i < 56; i++) {\n\t                var keyBitPos = PC1[i] - 1;\n\t                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;\n\t            }\n\n\t            // Assemble 16 subkeys\n\t            var subKeys = this._subKeys = [];\n\t            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {\n\t                // Create subkey\n\t                var subKey = subKeys[nSubKey] = [];\n\n\t                // Shortcut\n\t                var bitShift = BIT_SHIFTS[nSubKey];\n\n\t                // Select 48 bits according to PC2\n\t                for (var i = 0; i < 24; i++) {\n\t                    // Select from the left 28 key bits\n\t                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);\n\n\t                    // Select from the right 28 key bits\n\t                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);\n\t                }\n\n\t                // Since each subkey is applied to an expanded 32-bit input,\n\t                // the subkey can be broken into 8 values scaled to 32-bits,\n\t                // which allows the key to be used without expansion\n\t                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\n\t                for (var i = 1; i < 7; i++) {\n\t                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);\n\t                }\n\t                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\n\t            }\n\n\t            // Compute inverse subkeys\n\t            var invSubKeys = this._invSubKeys = [];\n\t            for (var i = 0; i < 16; i++) {\n\t                invSubKeys[i] = subKeys[15 - i];\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._subKeys);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._invSubKeys);\n\t        },\n\n\t        _doCryptBlock: function (M, offset, subKeys) {\n\t            // Get input\n\t            this._lBlock = M[offset];\n\t            this._rBlock = M[offset + 1];\n\n\t            // Initial permutation\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeLR.call(this, 1,  0x55555555);\n\n\t            // Rounds\n\t            for (var round = 0; round < 16; round++) {\n\t                // Shortcuts\n\t                var subKey = subKeys[round];\n\t                var lBlock = this._lBlock;\n\t                var rBlock = this._rBlock;\n\n\t                // Feistel function\n\t                var f = 0;\n\t                for (var i = 0; i < 8; i++) {\n\t                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n\t                }\n\t                this._lBlock = rBlock;\n\t                this._rBlock = lBlock ^ f;\n\t            }\n\n\t            // Undo swap from last round\n\t            var t = this._lBlock;\n\t            this._lBlock = this._rBlock;\n\t            this._rBlock = t;\n\n\t            // Final permutation\n\t            exchangeLR.call(this, 1,  0x55555555);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\n\t            // Set output\n\t            M[offset] = this._lBlock;\n\t            M[offset + 1] = this._rBlock;\n\t        },\n\n\t        keySize: 64/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    // Swap bits across the left and right words\n\t    function exchangeLR(offset, mask) {\n\t        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\n\t        this._rBlock ^= t;\n\t        this._lBlock ^= t << offset;\n\t    }\n\n\t    function exchangeRL(offset, mask) {\n\t        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\n\t        this._lBlock ^= t;\n\t        this._rBlock ^= t << offset;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.DES = BlockCipher._createHelper(DES);\n\n\t    /**\n\t     * Triple-DES block cipher algorithm.\n\t     */\n\t    var TripleDES = C_algo.TripleDES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\n\t            // Create DES instances\n\t            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));\n\t            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));\n\t            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._des1.encryptBlock(M, offset);\n\t            this._des2.decryptBlock(M, offset);\n\t            this._des3.encryptBlock(M, offset);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._des3.decryptBlock(M, offset);\n\t            this._des2.encryptBlock(M, offset);\n\t            this._des1.decryptBlock(M, offset);\n\t        },\n\n\t        keySize: 192/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.TripleDES = BlockCipher._createHelper(TripleDES);\n\t}());\n\n\n\treturn CryptoJS.TripleDES;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/tripledes.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(5), __webpack_require__(6), __webpack_require__(4), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * RC4 stream cipher algorithm.\n\t     */\n\t    var RC4 = C_algo.RC4 = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            var keySigBytes = key.sigBytes;\n\n\t            // Init sbox\n\t            var S = this._S = [];\n\t            for (var i = 0; i < 256; i++) {\n\t                S[i] = i;\n\t            }\n\n\t            // Key setup\n\t            for (var i = 0, j = 0; i < 256; i++) {\n\t                var keyByteIndex = i % keySigBytes;\n\t                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\n\n\t                j = (j + S[i] + keyByte) % 256;\n\n\t                // Swap\n\t                var t = S[i];\n\t                S[i] = S[j];\n\t                S[j] = t;\n\t            }\n\n\t            // Counters\n\t            this._i = this._j = 0;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            M[offset] ^= generateKeystreamWord.call(this);\n\t        },\n\n\t        keySize: 256/32,\n\n\t        ivSize: 0\n\t    });\n\n\t    function generateKeystreamWord() {\n\t        // Shortcuts\n\t        var S = this._S;\n\t        var i = this._i;\n\t        var j = this._j;\n\n\t        // Generate keystream word\n\t        var keystreamWord = 0;\n\t        for (var n = 0; n < 4; n++) {\n\t            i = (i + 1) % 256;\n\t            j = (j + S[i]) % 256;\n\n\t            // Swap\n\t            var t = S[i];\n\t            S[i] = S[j];\n\t            S[j] = t;\n\n\t            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\n\t        }\n\n\t        // Update counters\n\t        this._i = i;\n\t        this._j = j;\n\n\t        return keystreamWord;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4 = StreamCipher._createHelper(RC4);\n\n\t    /**\n\t     * Modified RC4 stream cipher algorithm.\n\t     */\n\t    var RC4Drop = C_algo.RC4Drop = RC4.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} drop The number of keystream words to drop. Default 192\n\t         */\n\t        cfg: RC4.cfg.extend({\n\t            drop: 192\n\t        }),\n\n\t        _doReset: function () {\n\t            RC4._doReset.call(this);\n\n\t            // Drop\n\t            for (var i = this.cfg.drop; i > 0; i--) {\n\t                generateKeystreamWord.call(this);\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4Drop = StreamCipher._createHelper(RC4Drop);\n\t}());\n\n\n\treturn CryptoJS.RC4;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/rc4.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(5), __webpack_require__(6), __webpack_require__(4), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm\n\t     */\n\t    var Rabbit = C_algo.Rabbit = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.Rabbit = StreamCipher._createHelper(Rabbit);\n\t}());\n\n\n\treturn CryptoJS.Rabbit;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/rabbit.js?")},function(module,exports,__webpack_require__){eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(1), __webpack_require__(5), __webpack_require__(6), __webpack_require__(4), __webpack_require__(3));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm.\n\t     *\n\t     * This is a legacy version that neglected to convert the key to little-endian.\n\t     * This error doesn't affect the cipher's security,\n\t     * but it does affect its compatibility with other implementations.\n\t     */\n\t    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);\n\t}());\n\n\n\treturn CryptoJS.RabbitLegacy;\n\n}));\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/crypto-js/rabbit-legacy.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n\n/**\n * @class\n * @name Conversation\n * @description\n *      This class represents a conversation <br>\n *\t\tA conversation is a "long" interaction (aka the "long tail") between the user ane one or several contacts (Rainbow users or not) based on the IM media if the recipients are Rainbow users. <br>\n *\t\tA conversation never ends and all interactions done can be retrieved. <br>\n */\n\nangular.module("rainbow").factory("Conversation", ["$log", "$rootScope", "$interval", "$filter", "contactService", "xmppService", "Message", "uuid4", "utilService", "fileStorageService", "fileServerService", "$q", "fileViewerFactory", "roomService", "pstnConferenceService", function ($log, $rootScope, $interval, $filter, contactService, xmppService, Message, uuid4, utilService, fileStorageService, fileServerService, $q, fileViewerFactory, roomService, pstnConferenceService) {\n  "use strict";\n  /*************************************************************/\n\n  /* PUBLIC STUFF                                              */\n\n  /*************************************************************/\n\n  Conversation.ChatstatesNS = "http://jabber.org/protocol/chatstates";\n  Conversation.ReceiptNS = "urn:xmpp:receipts";\n  /**\n   * @public\n   * @enum {number}\n         * @readonly\n   */\n\n  Conversation.Type = {\n    /** One-to-one conversation */\n    ONE_TO_ONE: 0,\n\n    /** Room conversation with multiple participants */\n    ROOM: 1,\n\n    /** Conversation with a Bot */\n    BOT: 2\n  };\n  /**\n   * @public\n   * @enum {number}\n         * @readonly\n   */\n\n  Conversation.EventType = {\n    /** New conversation */\n    NEW: 0,\n\n    /** New IM in conversation */\n    IM: 1,\n\n    /** Capability change in conversation */\n    CAPABILITIES: 2,\n\n    /** File event in conversation */\n    FILE: 3\n  };\n  /**\n   * @public\n   * @enum {Object}\n         * @readonly\n   */\n\n  Conversation.Status = {\n    /** Active conversation */\n    ACTIVE: {\n      key: 0,\n      value: "active"\n    },\n\n    /** Inactive conversation */\n    INACTIVE: {\n      key: 1,\n      value: "inactive"\n    },\n\n    /** When composing a message */\n    COMPOSING: {\n      key: 2,\n      value: "composing"\n    },\n\n    /** When a message is written but not sent */\n    PAUSED: {\n      key: 3,\n      value: "paused"\n    }\n  };\n  /*************************************************************/\n\n  /* STATIC FACTORIES                                          */\n\n  /*************************************************************/\n\n  Conversation.createOneToOneConversation = function (participant) {\n    $log.info("[Conversation] Create one to one conversation (" + participant.id + ")"); // Create the conversation object\n\n    var conversation = new Conversation(participant.id); // Attach it to contact\n\n    conversation.contact = participant;\n    participant.conversation = conversation; // Fill display information\n\n    if (participant.isBot) {\n      conversation.avatar = "";\n      conversation.type = Conversation.Type.BOT;\n    } else {\n      conversation.avatar = participant.avatar ? participant.avatar.src : null;\n      conversation.type = Conversation.Type.ONE_TO_ONE;\n    }\n\n    conversation.name = participant.name;\n\n    if (participant.displayName) {\n      conversation.filterName = utilService.removeDiacritis(participant.displayName.toLowerCase());\n    }\n\n    return conversation;\n  };\n\n  Conversation.createRoomConversation = function (room) {\n    $log.info("[Conversation] Create room conversation (" + room.jid + ")"); // Create the conversation object\n\n    var conversation = new Conversation(room.jid);\n    conversation.type = Conversation.Type.ROOM;\n    conversation.room = room;\n    conversation.filterName = utilService.removeDiacritis(room.name.toLowerCase());\n    conversation.infoVisible = true;\n    return conversation;\n  };\n  /*************************************************************/\n\n  /* CONVERSATION CONSTRUCTOR                                  */\n\n  /*************************************************************/\n\n  /**\n   * @this Conversation\n   */\n\n\n  function Conversation(conversationId) {\n    /**\n     * @public\n     * @property {string} id The conversation ID\n     * @readonly\n     */\n    this.id = conversationId;\n    /**\n     * @public\n     * @property {string} dbId The database ID\n     * @readonly\n     */\n\n    this.dbId = null;\n    /**\n     * @public\n     * @property {Conversation.Type} type The type of the conversation. Can be ONE_TO_ONE (0), ROOM (1) or BOT (2)\n     * @readonly\n     */\n\n    this.type = null;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.owner = null;\n    /**\n     * @public\n     * @property {Contact} contact (ONE_TO_ONE conversation only) The recipient of the conversation\n     * @link Contact\n     * @readonly\n     */\n\n    this.contact = null;\n    /**\n     * @public\n     * @property {Room} room (ROOM conversation only) The conversation room if any\n     * @link Room\n     * @readonly\n     */\n\n    this.room = null;\n    /**\n     * @public\n     * @property {Object} capabilities The capabilities of the conversation<br/>\n     * \t\t\tWith following members (true means, ok to try to add this media)<br/>\n     * \t\t\t\t\t{Boolean} telephony, <br/>\n     * \t\t\t\t\t{Boolean} webRTC, <br/>\n     * \t\t\t\t\t{Boolean} sharedDesktop, <br/>\n     * \t\t\t\t\t{Boolean} fileTransfert, <br/>\n     * \t\t\t\t\t{Boolean} mediaAvailable (means telephony || webRTC), <br/>\n     * \t\t\t\t\t{Boolean} addMedia (true if user is already in call and has an active fullJid)\n     * @readonly\n     */\n\n    this.capabilities = null; // Display information\n\n    /**\n     * @public\n     * @property {Object} avatar (ONE_TO_ONE conversation only) The avatar of the conversation\n     * @readonly\n     */\n\n    this.avatar = null;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.presenceStatus = null;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.name = function () {\n      return {};\n    };\n    /**\n     * @public\n     * @property {string} filterName The name of the conversation (the display name of the recipient for ONE_TO_ONE conversation or the room name for a ROOM conversation)\n     * @readonly\n     */\n\n\n    this.filterName = "";\n    /**\n     * @public\n     * @property {number} missedCounter The number of instant messages not read\n     * @readonly\n     */\n\n    this.missedCounter = 0;\n    /**\n     * @public\n     * @property {number} missedCalls (ONE_TO_ONE conversation only) The number of call missed with this recipient (only WebRTC call)\n     * @readonly\n     */\n\n    this.missedCalls = 0;\n    /**\n     * @public\n     * @property {Message[]} messages The list of messages downloaded for this conversation\n     * @link Message\n     * @readonly\n     */\n\n    this.messages = [];\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.participantStatuses = {};\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.draft = "";\n    /**\n     * @public\n     * @property {Conversation.Status} status The status of the conversation\n     * @readonly\n     */\n\n    this.status = Conversation.Status.ACTIVE; // History stuff\n\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.historyIndex = -1;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.historyMessages = [];\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.historyDefered = null;\n    /**\n     * @public\n              * @property {Boolean} True if the history has been completely loaded\n     * @readonly\n     */\n\n    this.historyComplete = false; // LastModification\n\n    /**\n     * @public\n     * @property {Date} lastModification The date of the last modification of the conversation\n     * @readonly\n     */\n\n    this.lastModification = undefined; // CreationDate\n\n    /**\n     * @public\n     * @property {Date} creationDate The date of the creation of the conversation\n     * @since 1.21\n     * @readonly\n     */\n\n    this.creationDate = new Date(); // LastMessageText\n\n    /**\n     * @public\n     * @property {string} lastMessageText The text of the last message received of the conversation\n     * @readonly\n     */\n\n    this.lastMessageText = ""; // LastMessageSenderID\n\n    /**\n     * @public\n     * @property {string} lastMessageSender The ID of the user for the last message\n     * @readonly\n     */\n\n    this.lastMessageSender = ""; // Picture in picture\n\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.pip = true; // Call references\n\n    /**\n     * @public\n     * @property {Call} videoCall Link to a WebRTC call (audio/video/sharing) if exists\n     * @readonly\n     */\n\n    this.videoCall = {\n      status: _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN\n    };\n    /**\n     * @public\n     * @property {Call} audioCall Link to a telephony call (from a PBX) if exists\n     * @readonly\n     */\n\n    this.audioCall = null;\n    /**\n     * @public\n     * @property {ConferenceSession} pstnConferenceSession Link to a pstn conference session if exists\n     * @readonly\n     * @since 1.30\n     */\n\n    this.pstnConferenceSession = null;\n    /**\n     * @public\n     * @property {ConferenceSession} webConferenceSession Link to a webrtc conference session if exists\n     * @readonly\n     * @since 1.30\n     */\n\n    this.webConferenceSession = null; //is muted\n\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.isMutedAudio = false;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.isMutedVideo = false;\n    /**\n     * @public\n     * @property {boolean} infoVisible Determines whether the right area is shown when opening the conversation. Default value: false\n     */\n\n    this.infoVisible = false; //is conversation muted\n\n    this.muted = false; //is conversation favorite\n\n    this.isFavorite = false;\n    this.lastEditableMsg = null;\n    /**\n     * @public\n     * @property {Array} cacheMessages Cache messages never displayed\n     */\n\n    this.cacheMessages = [];\n  }\n\n  var generateRandomID = function generateRandomID() {\n    return uuid4.generate();\n  }; //message ID\n\n\n  var randomBase = generateRandomID();\n  var messageId = 0;\n\n  Conversation.getUniqueMessageId = function () {\n    var messageToSendID = "web_" + randomBase + messageId;\n    messageId++;\n    return messageToSendID;\n  };\n  /*************************************************************/\n\n  /* PUBLIC STATIC METHODS                                     */\n\n  /*************************************************************/\n\n\n  Conversation.stringToStatus = function (status) {\n    switch (status) {\n      case "composing":\n        return Conversation.Status.COMPOSING;\n\n      case "paused":\n        return Conversation.Status.PAUSED;\n\n      default:\n        return Conversation.Status.ACTIVE;\n    }\n  };\n  /*************************************************************/\n\n  /* PUBLIC METHODS                                            */\n\n  /*************************************************************/\n\n\n  Conversation.prototype.reset = function () {\n    this.messages = [];\n    this.historyIndex = -1;\n    this.historyMessages = [];\n    this.historyComplete = false;\n    this.currentHistoryId = null;\n    this.lastMessageText = null;\n\n    if (this.chatRenderer) {\n      this.chatRenderer.removeAllMessages();\n    }\n  };\n  /**\n         * @public\n         * @method isInCall\n         * @memberof Conversation\n         * @instance\n         * @description\n         *    Return true if the conversation is engaged in a call (webRTC or Telephony)\n         * @return {Boolean} True if a call is active\n         */\n\n\n  Conversation.prototype.isInCall = function () {\n    if (this.pstnConferenceSession) {\n      return this.pstnConferenceSession.isParticipantConnectedByJid(contactService.userContact.jid);\n    }\n\n    if (this.webConferenceSession) {\n      return this.webConferenceSession.isParticipantConnectedByJid(contactService.userContact.jid);\n    }\n\n    return this.videoCall && this.videoCall.status && this.videoCall.status.value !== "Unknown" || this.audioCall && this.audioCall.status && this.audioCall.status.value !== "Unknown" && this.audioCall.status.value !== "incommingCall" && this.audioCall.status.value !== "queued";\n  };\n  /**\n         * @public\n         * @method isNotInCall\n         * @memberof Conversation\n         * @instance\n         * @description\n         *    Return true if the conversation is not engaged in a call (webRTC of Telephony)\n         * @return {Boolean} True if no call is active\n         */\n\n\n  Conversation.prototype.isNotInCall = function () {\n    return (!this.videoCall || !this.videoCall.status || this.videoCall.status.value === "Unknown") && (!this.audioCall || !this.audioCall.status || this.audioCall.status.value === "Unknown") && (contactService.userContact.status !== "busy" || contactService.userContact.message === "");\n  };\n\n  Conversation.prototype.isActive = function () {\n    return this.videoCall && this.videoCall.status && this.videoCall.status.value === "active" || this.audioCall && this.audioCall.status && this.audioCall.status.value === "active";\n  };\n\n  Conversation.prototype.isHeld = function () {\n    return this.videoCall && this.videoCall.status && this.videoCall.status.value === "held" || this.audioCall && this.audioCall.status && this.audioCall.status.value === "held";\n  };\n\n  Conversation.prototype.getMessageById = function (messId, searchInCache) {\n    if (searchInCache) {\n      var foundMsg = this.cacheMessages.find(function (item) {\n        return item.id === messId;\n      });\n\n      if (foundMsg) {\n        return foundMsg;\n      }\n    }\n\n    return this.messages.find(function (item) {\n      if (item.id === messId) return true;\n\n      if (item.replaceMsgs.length > 0) {\n        return item.replaceMsgs.find(function (replaceItem) {\n          return replaceItem.id === messId;\n        });\n      }\n\n      return false;\n    });\n  };\n\n  Conversation.prototype.getMessageByIdInHistory = function (messId) {\n    return this.historyMessages.find(function (item) {\n      return item.id === messId;\n    });\n  };\n  /**\n         * @public\n         * @method sendChatMessage\n         * @memberof Conversation\n         * @instance\n         * @param {string} data The text message to send\n         * @description\n         *    Send a message to this conversation\n         * @return {Message} The message sent\n         */\n\n\n  Conversation.prototype.sendChatMessage = function (data, answeredMsg, alternativeContent) {\n    var unicodeData = $filter("emojiShortToUnicode")(data);\n    var xmppMessage = null;\n    var that = this; // Build the message ID\n\n    var messageToSendID = Conversation.getUniqueMessageId(); // Handle One to one conversation message\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      var to = this.contact.jid;\n      xmppMessage = $msg({\n        to: to,\n        type: "chat",\n        id: messageToSendID,\n        "xml:lang": contactService.currentLanguage\n      }).c("body", {\n        "xml:lang": contactService.currentLanguage\n      }).t(unicodeData).up().c("request", {\n        "xmlns": Conversation.ReceiptNS\n      }).up().c("active", {\n        "xmlns": Conversation.ChatstatesNS\n      }).up();\n    } // Handle Room conversation message\n    else {\n        xmppMessage = $msg({\n          to: this.room.jid,\n          type: "groupchat",\n          id: messageToSendID\n        }).c("body", {\n          "xml:lang": contactService.currentLanguage\n        }).t(unicodeData).up().c("request", {\n          "xmlns": Conversation.ReceiptNS\n        }).up().c("active", {\n          "xmlns": Conversation.ChatstatesNS\n        }).up();\n      }\n\n    var answeredMsgId = null;\n    var answeredMsgDate = null;\n\n    if (answeredMsg) {\n      xmppMessage = xmppMessage.c("answeredMsg", {\n        "stamp": answeredMsg.date.getTime()\n      }).t(answeredMsg.id).up();\n      answeredMsgId = answeredMsg.id;\n      answeredMsgDate = answeredMsg.date;\n    }\n\n    if (alternativeContent) {\n      xmppMessage = xmppMessage.c("content", {\n        "type": alternativeContent.type\n      }).t(alternativeContent.message).up();\n    } // Add message in messages array\n\n\n    var message = null;\n    message = this.addChatMessage(contactService.userContact, new Date(), unicodeData, messageToSendID, true, null, null, answeredMsgId, answeredMsgDate, null, alternativeContent);\n\n    if (!message) {\n      return null;\n    }\n\n    message.serverAckTimer = $interval(function () {\n      message.receiptStatus = Message.ReceiptStatus.ERROR;\n      that.updateMessage(message);\n    }, 10000); // Create and send message\n\n    xmppService.send(xmppMessage);\n    return message;\n  };\n  /**\n         * @public\n         * @method sendChatMessage\n         * @memberof Conversation\n         * @instance\n         * @param {string} data The correctedtext message to send\n         * @param {string} origMsgId The initial message Id to correct\n         * @description\n         *    Send a message to this conversation\n         * @return {Message} The message sent\n         */\n\n\n  Conversation.prototype.sendCorrectedChatMessage = function (originalMessage, data, origMsgId) {\n    $log.info("[Conversation] >sendCorrectedChatMessage: origMsgId=" + origMsgId);\n    /* <message to=\'juliet@capulet.net/balcony\' id=\'good1\'>\n    <body>But soft, what light through yonder window breaks?</body>\n    <replace id=\'bad1\' xmlns=\'urn:xmpp:message-correct:0\'/>\n    <store xmlns=\'urn:xmpp:hints\'/>\n    </message> */\n\n    this.sendAckReadMessages();\n    var unicodeData = $filter("emojiShortToUnicode")(data);\n    var xmppMessage = null;\n    var that = this; // Build the message ID\n\n    var messageToSendID = Conversation.getUniqueMessageId();\n    $log.info("[Conversation] >sendCorrectedChatMessage: messageToSendID=" + messageToSendID); // Handle One to one conversation message\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      var to = this.contact.jid;\n      xmppMessage = $msg({\n        to: to,\n        type: "chat",\n        id: messageToSendID,\n        "xml:lang": contactService.currentLanguage\n      }).c("body", {\n        "xml:lang": contactService.currentLanguage\n      }).t(unicodeData).up().c("replace", {\n        id: origMsgId,\n        "xmlns": "urn:xmpp:message-correct:0"\n      }).up().c("store", {\n        "xmlns": "urn:xmpp:hints"\n      }).up().c("request", {\n        "xmlns": Conversation.ReceiptNS\n      }).up().c("active", {\n        "xmlns": Conversation.ChatstatesNS\n      }).up();\n    } // Handle Room conversation message\n    else {\n        xmppMessage = $msg({\n          to: this.room.jid,\n          type: "groupchat",\n          id: messageToSendID\n        }).c("body", {\n          "xml:lang": contactService.currentLanguage\n        }).t(unicodeData).up().c("replace", {\n          id: origMsgId,\n          "xmlns": "urn:xmpp:message-correct:0"\n        }).t(unicodeData).up().c("store", {\n          "xmlns": "urn:xmpp:hints"\n        }).up().c("request", {\n          "xmlns": Conversation.ReceiptNS\n        }).up().c("active", {\n          "xmlns": Conversation.ChatstatesNS\n        }).up();\n      } // message = this.addChatReplaceMessage(contactService.userContact, new Date(), unicodeData, messageToSendID, true);\n\n\n    if (!originalMessage) {\n      return null;\n    }\n\n    originalMessage.serverAckTimer = $interval(function () {\n      originalMessage.receiptStatus = Message.ReceiptStatus.ERROR;\n      that.updateMessage(originalMessage);\n    }, 10000); // Add message in messages array\n\n    originalMessage.addReplaceMsg(messageToSendID, data); // Create and send message\n\n    xmppService.send(xmppMessage);\n    return messageToSendID;\n  };\n  /**\n         * @public\n         * @method sendIsTypingState\n         * @memberof Conversation\n         * @instance\n         * @param {string} isTypingState The typing State\n         * @description\n         *    Send only the typing state\n         */\n\n\n  Conversation.prototype.sendIsTypingState = function (isTypingState) {\n    var xmppMessage = null; // Build the message ID\n\n    var messageToSendID = Conversation.getUniqueMessageId();\n    var state = isTypingState ? "composing" : "active"; // Handle One to one conversation message\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      var to = this.contact.jid;\n      xmppMessage = $msg({\n        to: to,\n        type: "chat",\n        id: messageToSendID,\n        "xml:lang": contactService.currentLanguage\n      }).c(state, {\n        "xmlns": Conversation.ChatstatesNS\n      }).up();\n    } // Handle Room conversation message\n    else {\n        xmppMessage = $msg({\n          to: this.room.jid,\n          type: "groupchat",\n          id: messageToSendID\n        }).c(state, {\n          "xmlns": Conversation.ChatstatesNS\n        }).up();\n      } // Create and send message\n\n\n    xmppService.send(xmppMessage);\n  };\n\n  Conversation.prototype.sendRecordingMessage = function (message) {\n    var unicodeData = $filter("emojiShortToUnicode")(message);\n    var xmppMessage = null;\n    var that = this; // Build the message ID\n\n    var messageToSendID = Conversation.getUniqueMessageId(); // Handle One to one conversation message\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      var to = this.contact.jid;\n      xmppMessage = $msg({\n        to: to,\n        type: "chat",\n        id: messageToSendID,\n        "xml:lang": contactService.currentLanguage\n      }).c("body", {\n        "xml:lang": contactService.currentLanguage\n      }).up().c("recording", {\n        "xmlns": "jabber:iq:recordingP2P"\n      }).t(unicodeData).up().c("request", {\n        "xmlns": Conversation.ReceiptNS\n      }).up().c("active", {\n        "xmlns": Conversation.ChatstatesNS\n      }).up();\n      /*xmppMessage = $msg({ to: to, type: "recording", id: messageToSendID, "xml:lang": contactService.currentLanguage })\n      \t.c("body", { "xml:lang": contactService.currentLanguage }).t(unicodeData).up()\n      \t.c("request", { "xmlns": Conversation.ReceiptNS }).up()\n      \t.c("active", { "xmlns": Conversation.ChatstatesNS }).up(); */\n    } // Add message in messages array\n\n\n    var message = null;\n    message = this.addRecordingMessage(contactService.userContact, new Date(), unicodeData, messageToSendID);\n\n    if (!message) {\n      return null;\n    }\n\n    message.serverAckTimer = $interval(function () {\n      message.receiptStatus = Message.ReceiptStatus.ERROR;\n      that.updateMessage(message);\n    }, 10000); // Create and send message\n\n    xmppService.send(xmppMessage);\n    return message;\n  };\n  /**\n         * @public\n         * @method sendExistingMessage\n         * @memberof Conversation\n         * @instance\n         * @param {string} data The text message to send\n         * @description\n         *    Send a message to this conversation\n         * @return {Message} The message sent\n         */\n\n\n  Conversation.prototype.sendExistingFSMessage = function (message, fileDescriptor) {\n    if (!message) {\n      return null;\n    }\n\n    var unicodeData = $filter("emojiShortToUnicode")(message.data);\n    var xmppMessage = null;\n    var that = this; // Build the message ID\n\n    var messageToSendID = message.id; // Handle One to one conversation message\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      var to = this.contact.jid;\n      xmppMessage = $msg({\n        to: to,\n        type: "chat",\n        id: messageToSendID,\n        "xml:lang": contactService.currentLanguage\n      }).c("body", {\n        "xml:lang": contactService.currentLanguage\n      }).t(unicodeData).up().c("request", {\n        "xmlns": Conversation.ReceiptNS\n      }).up().c("active", {\n        "xmlns": Conversation.ChatstatesNS\n      }).up();\n    } // Handle Room conversation message\n    else {\n        xmppMessage = $msg({\n          to: this.room.jid,\n          type: "groupchat",\n          id: messageToSendID\n        }).c("body", {\n          "xml:lang": contactService.currentLanguage\n        }).t(unicodeData).up().c("request", {\n          "xmlns": Conversation.ReceiptNS\n        }).up().c("active", {\n          "xmlns": Conversation.ChatstatesNS\n        }).up();\n      }\n\n    var url = config.restServerUrl + "/api/rainbow/fileserver/v1.0/files/" + fileDescriptor.id;\n    xmppMessage.c("x", {\n      "xmlns": "jabber:x:oob"\n    }).c("url", {}, url).c("mime", {}, fileDescriptor.typeMIME).c("filename", {}, fileDescriptor.fileName).c("size", {}, fileDescriptor.size).up();\n\n    if (fileDescriptor.tags && fileDescriptor.tags.purpose === "voicemail") {\n      xmppMessage.c("voicemessage", {\n        "xmlns": "http://jabber.org/protocol/voicemessage"\n      }).up();\n    }\n\n    xmppMessage.c("store", {\n      "xmlns": "urn:xmpp:hints"\n    });\n    message.fileId = fileDescriptor.id;\n    message.setReceiptStatus(Message.ReceiptStatus.SENT);\n    that.updateMessage(message); // Create and send message\n\n    xmppService.send(xmppMessage);\n    return message;\n  };\n  /**\n         * @private\n         * @method sendAckReadOrReceivedMessage\n         * @memberof Conversation\n         * @instance\n         * @param {String} messageId The messageId to ack\n         * @param {String} status Received or Read status for this message (values : received or read)\n         * @description\n         *    When receiving a message, it has to be acknowledged in order to inform the recipient that the message has been successfully received. This acknoledgement is automatically done by the SDK.\n         */\n\n\n  Conversation.prototype.sendAckReadOrReceivedMessage = function (messageId, status) {\n    $log.info("[Conversation] " + this.id + " send " + status + " status for message " + messageId);\n    var to = this.type === Conversation.Type.ONE_TO_ONE ? this.contact.jid : this.room.jid;\n    var from = contactService.userContact.jid;\n    var msg = $msg({\n      "to": to,\n      "from": from,\n      "type": "chat"\n    }).c("received", {\n      "xmlns": Conversation.ReceiptNS,\n      "event": status,\n      "entity": "client",\n      "type": "im",\n      "id": messageId\n    });\n\n    if (this.type !== Conversation.Type.ONE_TO_ONE) {\n      msg = $msg({\n        "to": to,\n        "from": from,\n        "type": "groupchat"\n      }).c("received", {\n        "xmlns": Conversation.ReceiptNS,\n        "event": status,\n        "entity": "client",\n        "type": "muc",\n        "id": messageId\n      });\n    }\n\n    xmppService.send(msg);\n  };\n  /**\n         * @private\n         * @method sendAckReceivedMessage\n         * @memberof Conversation\n         * @instance\n         * @param {Message} message The message to ack\n         * @description\n         *    When receiving a message, it has to be acknowledged in order to inform the recipient that the message has been successfully received. This acknoledgement is automatically done by the SDK.\n         */\n\n\n  Conversation.prototype.sendAckReceivedMessage = function (message) {\n    //no need to send RECV for messages we\'ve already received or read\n    if (message.receiptStatus >= Message.ReceiptStatus.UNREAD) {\n      return;\n    }\n\n    $log.info("[Conversation] " + this.id + " send received ack for message " + message.id);\n    var to = this.type === Conversation.Type.ONE_TO_ONE ? this.contact.jid : this.room.jid;\n    var from = contactService.userContact.jid;\n    var msg = null;\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      msg = $msg({\n        "to": to,\n        "from": from,\n        "type": "chat"\n      }).c("received", {\n        "xmlns": Conversation.ReceiptNS,\n        "event": "received",\n        "entity": "client",\n        "type": "im",\n        "id": message.id\n      });\n    } else {\n      msg = $msg({\n        "to": to,\n        "from": from,\n        "type": "groupchat"\n      }).c("received", {\n        "xmlns": Conversation.ReceiptNS,\n        "event": "received",\n        "entity": "client",\n        "type": "muc",\n        "id": message.id\n      });\n    }\n\n    xmppService.send(msg);\n    message.setReceiptStatus(Message.ReceiptStatus.UNREAD);\n  };\n  /**\n         * @public\n         * @method sendAckReadMessage\n         * @memberof Conversation\n         * @instance\n         * @param {Message} message The message to acknowledge\n   * @return {Message} The updated message or undefined if the message has been already acknowledged\n         * @description\n         *    When reading a message, it has to be acknowledged in order to inform the recipient that the message has been read\n         */\n\n\n  Conversation.prototype.sendAckReadMessage = function (message) {\n    //no need to send ACK for messages we\'ve already read\n    if (message.receiptStatus === Message.ReceiptStatus.READ) {\n      return;\n    }\n\n    $log.info("[Conversation] " + this.id + " send read ack for message " + message.id);\n    var to = this.type === Conversation.Type.ONE_TO_ONE ? this.contact.jid : this.room.jid;\n    var from = contactService.userContact.jid;\n    var msg = $msg({\n      "to": to,\n      "from": from,\n      "type": "chat"\n    }).c("received", {\n      "xmlns": Conversation.ReceiptNS,\n      "event": "read",\n      "entity": "client",\n      "type": "im",\n      "id": message.id\n    });\n\n    if (this.type !== Conversation.Type.ONE_TO_ONE) {\n      msg = $msg({\n        "to": to,\n        "from": from,\n        "type": "groupchat"\n      }).c("received", {\n        "xmlns": Conversation.ReceiptNS,\n        "event": "read",\n        "entity": "client",\n        "type": "muc",\n        "id": message.id\n      });\n    }\n\n    xmppService.send(msg);\n    message.setReceiptStatus(Message.ReceiptStatus.READ); //ack all replaced/updated msg\n\n    if (message.replaceMsgs && message.replaceMsgs.length) {\n      var that = this;\n      message.replaceMsgs.forEach(function (message) {\n        that.sendAckReadOrReceivedMessage(message.id, "read");\n      });\n    }\n  };\n  /**\n         * @public\n         * @method sendAckReadMessages\n         * @memberof Conversation\n         * @instance\n   * @return {Boolean} true if any message has been ACK, false by default\n         * @description\n         *    Acknowledge all messages of this conversation (read)\n         */\n\n\n  Conversation.prototype.sendAckReadMessages = function () {\n    $log.info("[Conversation] " + this.id + " sendAckReadMessages");\n    var result = false;\n    var that = this;\n    this.messages.forEach(function (message) {\n      if ((message.receiptStatus === Message.ReceiptStatus.SENT || message.receiptStatus === Message.ReceiptStatus.UNREAD) && (message.side === Message.Side.LEFT || message.side === Message.Side.ADMIN)) {\n        that.sendAckReadMessage(message);\n        result = true;\n      }\n    });\n    return result;\n  };\n  /**\n   * @private\n   * @method sendFSMessage\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.sendFSMessage = function (file, data, voiceMessage) {\n    $log.debug("[conversation] >sendFSMessage");\n    var defered = $q.defer();\n    var that = this; // Add message in messages array\n\n    var fileExtension = file.name.split(".").pop();\n    var fileMimeType = file.type;\n    var viewers = [];\n    var voiceMessageData = false;\n    var message = _typeof(data) === "object" ? data : undefined;\n    var currentFileDescriptor;\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      viewers = fileViewerFactory([{\n        "viewerId": this.contact.dbId,\n        "type": "user"\n      }]);\n    } else {\n      viewers = fileViewerFactory([{\n        "viewerId": this.room.dbId,\n        "type": "room"\n      }]);\n    }\n\n    if (voiceMessage) {\n      voiceMessageData = true;\n    }\n\n    fileStorageService.createFileDescriptor(file.name, fileExtension, file.size, viewers, voiceMessageData).then(function (fileDescriptor) {\n      currentFileDescriptor = fileDescriptor;\n      fileDescriptor.fileToSend = file;\n\n      if (fileDescriptor.isImage()) {\n        // var URLObj = $window.URL || $window.webkitURL;\n        // fileDescriptor.previewBlob = URLObj.createObjectURL(file);\n        if (file.preview) {\n          fileDescriptor.previewBlob = file.preview;\n        }\n      }\n\n      if (!message) {\n        message = that.addFSMessage(fileDescriptor.id, fileMimeType, data, "uploading", voiceMessageData);\n      }\n\n      message.fileId = fileDescriptor.id;\n      message.fileName = fileDescriptor.fileName; // Upload file\n\n      fileDescriptor.state = "uploading";\n      $rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n        fileDesc: fileDescriptor,\n        cancelable: true\n      });\n      return fileServerService.uploadAFileByChunk(fileDescriptor, file, message, null).then(function successCallback(fileDesc) {\n        $log.debug("uploadAFileByChunk success");\n        return $q.resolve(fileDescriptor);\n      }, function errorCallback(error) {\n        $log.debug("uploadAFileByChunk error"); //do we need to delete the file descriptor from the server if error ??\n\n        fileStorageService.deleteFileDescriptor(currentFileDescriptor.id); // .then(function() {\n        // var msgKey = error.translatedMessage ? error.translatedMessage : "Unable to share file";\n        // $rootScope.$broadcast("ON_SHOW_INFO_MESSAGE", { type: "error", messageKey: msgKey });\n        // currentFileDescriptor.state = "uploadError";\n        // message.receiptStatus = Message.ReceiptStatus.ERROR;\n        // message.fileErrorMsg = msgKey;\n        // that.updateMessage(message);\n        // });\n\n        var msgKey = error.translatedMessage ? error.translatedMessage : "Unable to share file";\n        $rootScope.$broadcast("ON_SHOW_INFO_MESSAGE", {\n          type: "error",\n          messageKey: msgKey\n        });\n        currentFileDescriptor.state = "uploadError";\n        message.receiptStatus = Message.ReceiptStatus.ERROR;\n        message.fileErrorMsg = msgKey;\n        that.updateMessage(message);\n        return $q.reject(error);\n      });\n    }).then(function successCallback(fileDescriptor) {\n      fileDescriptor.state = "uploaded";\n      fileDescriptor.chunkPerformed = 0;\n      fileDescriptor.chunkTotalNumber = 0;\n      $rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n        fileDesc: fileDescriptor\n      });\n      that.sendExistingFSMessage(message, fileDescriptor);\n      defered.resolve(message);\n    }, function errorCallback(error) {\n      $log.debug("createFileDescriptor error");\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n  /**\n   * @private\n   * @method sendEFSMessage\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.sendEFSMessage = function (fileDescriptor, data, voiceMessage) {\n    var that = this; // Add message in messages array\n\n    var fileExtension = fileDescriptor.extension;\n    var viewerType = "";\n    var viewerOrRoomId = null;\n    var message = this.addFSMessage(fileDescriptor.id, fileExtension, data, fileDescriptor.state, voiceMessage);\n\n    if (this.type === Conversation.Type.ONE_TO_ONE) {\n      viewerType = "user";\n      viewerOrRoomId = this.contact.dbId;\n    } else {\n      viewerType = "room";\n      viewerOrRoomId = this.room.dbId;\n    }\n\n    fileStorageService.addFileViewer(fileDescriptor.id, viewerOrRoomId, viewerType).then(function () {\n      that.sendExistingFSMessage(message, fileDescriptor);\n    })["catch"](function (error) {\n      var msgKey = error.translatedMessage ? error.translatedMessage : "Unable to share file";\n      $rootScope.$broadcast("ON_SHOW_INFO_MESSAGE", {\n        type: "error",\n        messageKey: msgKey\n      });\n      message.receiptStatus = Message.ReceiptStatus.ERROR;\n      that.updateMessage(message);\n    });\n    return message;\n  };\n  /**\n         * @private\n         * @method addAdminBubbleMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.addAdminBubbleMessage = function (from, date, type, messageID) {\n    var existingMsg = this.getMessageById(messageID);\n\n    if (existingMsg) {\n      $log.info("[Conversation] " + this.id + " add addAdminBubbleMessage message (" + messageID + ") already exists.");\n      return null;\n    }\n\n    $log.info("[Conversation] " + this.id + " add addAdminBubbleMessage from " + from.jid + " : " + type);\n    var data = type + "MsgRoom";\n    var side = Message.Side.ADMIN;\n    var message = Message.create(messageID, date, from, side, data, false);\n    message.setReceiptStatus(Message.ReceiptStatus.SENT);\n    return this.addMessage(message);\n  };\n  /**\n         * @private\n         * @method addFTMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.addFTMessage = function (from, date, fileTransfert, messageID) {\n    $log.info("[Conversation] " + this.id + " add FT message from " + from.jid + " : " + fileTransfert.message);\n    var side = contactService.isUserContact(from) ? "R" : "L";\n    var message = Message.createFTMessage(messageID, date, from, side, fileTransfert.message, false, fileTransfert);\n    return this.addMessage(message);\n  };\n  /**\n   * @private\n   * @method addFSMessage\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.addFSMessage = function (fileId, mime, data, status, voiceMessage) {\n    $log.info("[Conversation] " + this.id + " add FS message from me");\n    var messageToSendID = Conversation.getUniqueMessageId();\n    var unicodeData = $filter("emojiShortToUnicode")(data);\n    var date = new Date();\n    var side = "R";\n    $log.info("[Conversation] " + this.id + " add FILE SHARING message from me");\n\n    if (voiceMessage) {\n      var message = Message.createVoiceMessage(messageToSendID, date, contactService.userContact, side, unicodeData, status, fileId, voiceMessage);\n    } else {\n      var message = Message.createFileSharingMessage(messageToSendID, date, contactService.userContact, side, unicodeData, status, fileId);\n    }\n\n    message.setReceiptStatus(Message.ReceiptStatus.IN_PROGRESS);\n    return this.addMessage(message);\n  };\n  /**\n         * @private\n         * @method addChatMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.addChatMessage = function (from, date, data, messageID, isSender, isMarkdown, subject, answeredMsgId, answeredMsgDate, additionalContent, alternativeContent) {\n    var existingMsg = this.getMessageById(messageID);\n\n    if (existingMsg) {\n      $log.info("[Conversation] " + this.id + " add CHAT message (" + messageID + ") already exists.");\n      return null;\n    }\n\n    $log.info("[Conversation] " + this.id + " add CHAT message (" + messageID + ") from " + from.jid);\n    var side = contactService.isUserContact(from) ? "R" : "L";\n    var message = Message.create(messageID, date, from, side, data, false, isMarkdown, subject, answeredMsgId, answeredMsgDate, additionalContent, alternativeContent);\n\n    if (isSender) {\n      message.setReceiptStatus(Message.ReceiptStatus.IN_PROGRESS);\n    } else {\n      message.setReceiptStatus(Message.ReceiptStatus.SENT);\n    }\n\n    return this.addMessage(message);\n  };\n  /**\n   * @private\n   * @method addRecordingMessage\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.addRecordingMessage = function (from, date, data, messageID) {\n    var side = "ADMIN";\n    var message = Message.createRecordingAdminMessage(messageID, date, from, side, data);\n    return this.addMessage(message);\n  };\n  /**\n         * @private\n         * @method addFileMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.addFileMessage = function (from, date, data, messageID) {\n    $log.info("[Conversation] " + this.id + " add FILE message from " + from.jid + " : " + data);\n    var side = contactService.isUserContact(from) ? "R" : "L";\n    var message = Message.createFileMessage(messageID, date, from, side, data, false);\n    return this.addMessage(message);\n  };\n  /**\n   * @private\n   * @method addFileSharingMessage\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.addFileSharingMessage = function (from, date, data, messageID, fileId, fileName, geoloc, voiceMessage) {\n    $log.info("[Conversation] " + this.id + " add FILE SHARING message from " + from.jid + " message ID " + messageID);\n    var side = contactService.isUserContact(from) ? "R" : "L";\n\n    if (voiceMessage) {\n      var message = Message.createVoiceMessage(messageID, date, from, side, data, false, fileId, fileName, voiceMessage);\n    } else {\n      var message = Message.createFileSharingMessage(messageID, date, from, side, data, false, fileId, fileName, geoloc);\n    }\n\n    return this.addMessage(message);\n  };\n  /**\n   * @private\n   * @method addConferenceMessage\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.addConferenceMessage = function (from, date, messageID, conferenceDescriptor) {\n    if (conferenceDescriptor.type === "reminder") {\n      var room = roomService.getRoomByJid(conferenceDescriptor.roomjid);\n      var confSession = pstnConferenceService.conferenceSessions[room.getPstnConfEndpointId()];\n\n      if (confSession && confSession.isActive() && confSession.isParticipantConnectedByJid(contactService.userContact.jid)) {\n        // Ignore the reminder if we are already in it\n        return;\n      }\n    }\n\n    $log.info("[Conversation] " + this.id + " add CONFERENCE message from " + from.jid);\n    var side = "ADMIN";\n    var message = Message.createConferenceMessage(messageID, date, from, side, false, conferenceDescriptor);\n    return this.addMessage(message);\n  };\n  /**\n         * @private\n         * @method addWebRTCMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.addWebRTCMessage = function (from, date, data, messageID) {\n    var existingMsg = this.getMessageById(messageID);\n\n    if (existingMsg) {\n      $log.info("[Conversation] " + this.id + " add addWebRTCMessage message (" + messageID + ") already exists.");\n      return null;\n    }\n\n    $log.info("[Conversation] " + this.id + " add WebRTC message from " + from.jid + " : " + data);\n    var side = contactService.isUserContact(from) ? Message.Side.RIGHT : Message.Side.LEFT;\n    var message = Message.createWebRTCMessage(messageID, date, from, side, data, false);\n    return this.addMessage(message);\n  };\n  /**\n         * @private\n         * @method updateMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.updateMessage = function (message) {\n    if (this.chatRenderer) {\n      this.chatRenderer.updateMessage(message, this.room);\n    }\n  };\n  /**\n         * @private\n         * @method addMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.addMessage = function (message) {\n    // Check if this message already exist in message store\n    if (this.messages.find(function (item) {\n      return item.id === message.id;\n    })) {\n      $log.info("[Conversation] " + this.id + " try to add an already stored message with id " + message.id);\n      return message;\n    } // Increment unreadEvent counter\n\n\n    if (message.side === Message.Side.LEFT) {\n      if (message.type === Message.Type.WEBRTC) {\n        this.missedCalls += 1;\n      }\n\n      this.setStatusMessage(message.from, Conversation.Status.ACTIVE);\n    } else {\n      // TODO check date\n      var oldEditableMsg = this.lastEditableMsg;\n      this.lastEditableMsg = message;\n      this.updateMessage(oldEditableMsg);\n    } // Store the message\n\n\n    this.messages.push(message); // Inform the renderer (if any)\n\n    if (this.chatRenderer) {\n      this.chatRenderer.appendMessages([message], this.room); // Calculate time in days between now and last activity\n\n      if (this.contact && this.contact._lastActivityDate) {\n        var daysOffline = Math.abs(new Date() - this.contact._lastActivityDate) / 1000 / 3600 / 24;\n\n        if (this.contact.roster && this.contact.status === "offline" && daysOffline >= 14) {\n          var chatRenderer = this.chatRenderer;\n          chatRenderer.displayInfoMessage($filter("translate")("offlineSendMail"), $filter("translate")("warningOfflineSendMail"), function (action, contact) {\n            if (!action) {\n              chatRenderer.hideInfoMessage();\n            } else {\n              chatRenderer.sendingInfoMessage($filter("translate")("sendingMail")); // Send email\n\n              contactService.notifyImByEmail(contact).then(function () {\n                chatRenderer.displayInfoMessage($filter("translate")("sendMailSuccess"));\n                $interval(function () {\n                  chatRenderer.hideInfoMessage();\n                }, 3000, 1);\n              })["catch"](function (error) {\n                chatRenderer.displayErrorMessage(error);\n                $interval(function () {\n                  chatRenderer.hideInfoMessage();\n                }, 5000, 1);\n              });\n            }\n          });\n        }\n      }\n    } // Update lastModification\n\n\n    this.lastModification = new Date(); //update last activity date for rooms when we receive/sent messages\n\n    if (this.room) {\n      this.room.lastActivityDate = this.lastModification;\n    } // Update lastMessageText\n\n\n    this.lastMessageText = message.data; // Send event\n\n    $rootScope.$broadcast("ON_CONVERSATION_UPDATED_EVENT", this.id);\n    return message;\n  };\n  /**\n   * @public\n   * @method addMessageInHistoryMessages\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.addMessageInHistoryMessages = function (message) {\n    if (!message) {\n      return;\n    }\n\n    this.historyMessages.push(message);\n\n    if (message.side === Message.Side.RIGHT) {\n      // TODO check date\n      if (!this.lastEditableMsg || message.date.getTime() > this.lastEditableMsg.date.getTime()) {\n        var oldEditableMsg = this.lastEditableMsg;\n        this.lastEditableMsg = message;\n        this.updateMessage(oldEditableMsg);\n      }\n    }\n  };\n\n  Conversation.prototype.addMessageInCacheMessages = function (message) {\n    if (!message) {\n      return;\n    }\n\n    this.cacheMessages.push(message);\n  };\n  /**\n   * @private\n   * @method removeMessage\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.removeMessage = function (message) {\n    var index = this.messages.lastIndexOf(message);\n\n    if (index !== -1) {\n      this.messages.splice(index, 1);\n    }\n  };\n  /**\n   * @private\n   * @method sendChatStatus\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.sendChatStatus = function (status) {\n    $log.info("[Conversation] " + this.id + " setStatus " + status.value);\n\n    if (this.status === status) {\n      return;\n    }\n\n    this.status = status;\n\n    if (status !== Conversation.Status.IDLE) {\n      var xmppMessage = null;\n      var to = ""; // Handle One to one conversation message\n\n      if (this.type === Conversation.Type.ONE_TO_ONE) {\n        to = this.contact.jid;\n        xmppMessage = $msg({\n          to: to,\n          type: "chat"\n        }).c(status.value, {\n          "xmlns": Conversation.ChatstatesNS\n        });\n      } // Handle Room conversation message\n      else {\n          to = this.room.jid;\n          xmppMessage = $msg({\n            to: to,\n            type: "groupchat"\n          }).c(status.value, {\n            "xmlns": Conversation.ChatstatesNS\n          });\n        }\n\n      try {\n        // Send message\n        xmppService.connection.send(xmppMessage);\n      } catch (error) {\n        $log.error("[Conversation] sendChatStatus error " + error);\n      }\n    }\n  };\n  /**\n         * @private\n         * @method setStatusMessage\n         * @memberof Conversation\n         * @instance\n         */\n\n\n  Conversation.prototype.setStatusMessage = function (from, status) {\n    $log.info("[Conversation] " + this.id + " add status message from " + from.jid + " : " + status.value); // Store participant status\n\n    this.participantStatuses[from.jid] = status;\n\n    if (this.chatRenderer && this.chatRenderer.updateStatuses) {\n      this.chatRenderer.updateStatuses();\n    }\n  };\n  /**\n   * @private\n   * @method sendInvitation\n   * @memberof Conversation\n   * @instance\n   */\n\n\n  Conversation.prototype.sendInvitation = function (participant) {\n    try {\n      var to = participant.jid;\n      var attrs = {\n        xmlns: "jabber:x:conference",\n        jid: this.id\n      };\n      var invitation = $msg({\n        from: xmppService.connection.jid,\n        to: to\n      }).c("x", attrs);\n      xmppService.connection.send(invitation);\n    } catch (error) {\n      $log.error("[Conversation] sendInvitation error " + error);\n    }\n  };\n  /**\n         * @private\n         * @method ackReadAllMessages\n         * @memberof Conversation\n         * @instance\n   * Marks all messages as READ\n         */\n\n\n  Conversation.prototype.ackReadAllMessages = function () {\n    var that = this;\n    this.messages.forEach(function (message) {\n      if (message.receiptStatus === Message.ReceiptStatus.SENT || message.receiptStatus === Message.ReceiptStatus.UNREAD) {\n        message.setReceiptStatus(Message.ReceiptStatus.READ);\n\n        if (that.chatRenderer) {\n          that.chatRenderer.updateMessage(message, that.room);\n        }\n      }\n    });\n  };\n\n  return Conversation;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/conversation.js?')},function(module,exports){eval('/**\n * @class\n * @name Message\n * @description\n *      This class is used to represent a message in a conversation\n */\nangular.module("rainbow").factory("Message", ["$log", "$filter", "$interval", "ReplaceMsg", "roomService", function ($log, $filter, $interval, ReplaceMsg, roomService) {\n  "use strict"; // Static constants\n\n  /**\n   * @public\n   * @enum {number}\n         * @readonly\n   */\n\n  Message.Type = {\n    /** A chat message */\n    CHAT: {\n      key: 0,\n      value: "Chat"\n    },\n\n    /** A file message */\n    FILE: {\n      key: 1,\n      value: "File"\n    },\n\n    /** A file message */\n    FS: {\n      key: 2,\n      value: "FileSharing"\n    },\n\n    /** A file transfert message */\n    FT: {\n      key: 3,\n      value: "FileTransfert"\n    },\n\n    /** A WebRTC message */\n    WEBRTC: {\n      key: 4,\n      value: "WebRTC CAll"\n    },\n\n    /** A Recording message */\n    RECORDING: {\n      key: 5,\n      value: "Recording"\n    },\n\n    /** A Voice message */\n    VM: {\n      key: 6,\n      value: "VoiceMessage"\n    }\n  };\n  /**\n   * @public\n   * @enum {number}\n         * @readonly\n   */\n\n  Message.ReceiptStatus = {\n    /** No receipt received yet */\n    NONE: 0,\n\n    /** No receipt received after a while (The server doesn\'t answer) */\n    ERROR: 1,\n\n    /** Receipt in progress */\n    IN_PROGRESS: 2,\n\n    /** The server has confirmed the reception of the message */\n    SENT: 3,\n\n    /** The message has been received but not read */\n    UNREAD: 4,\n\n    /** The message has been read */\n    READ: 5\n  };\n  /**\n   * @public\n   * @enum {string}\n         * @readonly\n   */\n\n  Message.Side = {\n    /** Message is from a recipient */\n    LEFT: "L",\n\n    /** Message is from me */\n    RIGHT: "R",\n\n    /** Specific admin message */\n    ADMIN: "ADMIN"\n  };\n  /**\n   * @private\n   */\n\n  Message.ReceiptStatusText = ["none", "ko", "inProgress", "sent", "received", "read"];\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n  Message.create = function (id, date, from, side, data, status, isMarkdown, subject, answeredMsgId, answeredMsgDate, additionalContent, alternativeContent) {\n    // convert emojione from unicode to short\n    var message = $filter("emojiUnicodeToShort")(data);\n    return new Message(id, Message.Type.CHAT, date, from, side, message, status, null, isMarkdown, subject, null, answeredMsgId, answeredMsgDate, null, additionalContent, alternativeContent);\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.createFileSharingMessage = function (id, date, from, side, data, status, fileId, fileName, geoloc) {\n    // convert emojione from unicode to short\n    var message = $filter("emojiUnicodeToShort")(data);\n    return new Message(id, Message.Type.FS, date, from, side, message, status, fileId, null, null, fileName, null, null, geoloc);\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.createVoiceMessage = function (id, date, from, side, data, status, fileId, fileName, voiceMessage) {\n    // convert emojione from unicode to short\n    var message = $filter("emojiUnicodeToShort")(data);\n    return new Message(id, Message.Type.VM, date, from, side, message, status, fileId, null, null, fileName, null, null, null, null, voiceMessage);\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.createConferenceMessage = function (id, date, from, side, status, conferenceDescriptor) {\n    var room = roomService.getRoomByJid(conferenceDescriptor.roomjid);\n    var headerConferenceMessage = "";\n\n    switch (conferenceDescriptor.type) {\n      case "invite":\n        headerConferenceMessage = $filter("translate")("headerConferenceMessage", {\n          sender: from._displayName,\n          firstname: from.firstname,\n          bubblename: room.name\n        });\n        break;\n\n      case "reminder":\n        if (room && room.owner) {\n          headerConferenceMessage = $filter("translate")("conferenceReminderMessageforOwner", {\n            sender: from._displayName\n          });\n        } else {\n          headerConferenceMessage = $filter("translate")("conferenceReminderMessage", {\n            sender: from._displayName\n          });\n        }\n\n        break;\n\n      default:\n        headerConferenceMessage = $filter("translate")("headerConferenceMessage", {\n          sender: from._displayName,\n          firstname: from.firstname,\n          bubblename: room.name\n        });\n        break;\n    }\n\n    if (room.desc) {\n      headerConferenceMessage += "<br>" + $filter("translate")("conferenceSuject") + room.desc;\n    }\n\n    var message = headerConferenceMessage;\n    return new Message(id, Message.Type.CHAT, date, from, side, message, status);\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.createFileMessage = function (id, date, from, side, data, status) {\n    return new Message(id, Message.Type.FILE, date, from, side, data, status);\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.createWebRTCMessage = function (id, date, from, side, data, status) {\n    return new Message(id, Message.Type.WEBRTC, date, from, side, data, status);\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.createFTMessage = function (id, date, from, side, data, status, fileTransfert) {\n    var message = new Message(id, Message.Type.FT, date, from, side, data, status);\n    message.fileTransfert = fileTransfert;\n    return message;\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.createBubbleAdminMessage = function (id, date, from, type) {\n    var data = type + "MsgRoom";\n    var side = Message.Side.ADMIN;\n    var message = Message.create(id, date, from, side, data, false);\n    return message;\n  };\n  /**\n   * @private\n   * @method\n   * @instance\n   */\n\n\n  Message.createRecordingAdminMessage = function (id, date, from, type, cmd) {\n    var data = type + "Recording";\n\n    if (cmd) {\n      data = data + cmd;\n    }\n\n    var side = Message.Side.ADMIN;\n    var message = new Message(id, Message.Type.RECORDING, date, from, side, data, false);\n    return message;\n  }; // Constructor\n\n  /**\n  \t * @this Message\n  \t */\n\n\n  function Message(id, type, date, from, side, data, status, fileId, isMarkdown, subject, fileName, answeredMsgId, answeredMsgDate, geoloc, additionalContent, alternativeContent, voiceMessage) {\n    /**\n     * @public\n     * @property {string} id The message ID\n     * @readonly\n     */\n    this.id = id;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.index = null;\n    /**\n     * @public\n     * @property {Type} type The type of the message (could be CHAT, FILE, FT or WEBRTC)\n     * @link Type\n     * @readonly\n     */\n\n    this.type = type;\n    /**\n     * @public\n     * @property {Date} date The creation date of the message\n     * @readonly\n     */\n\n    this.date = date;\n    /**\n     * @public\n     * @property {Contact} from The initiator of the message\n     * @link Contact\n     * @readonly\n     */\n\n    this.from = from;\n    /**\n     * @public\n     * @property {Side} side The message originator\n     * @link Side\n     * @since 1.21\n     * @readonly\n     */\n\n    this.side = side;\n    /**\n     * @public\n     * @property {string} data The content of the message\n     * @readonly\n     */\n\n    this.data = data;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.status = status;\n    /**\n     * @public\n     * @property {ReceiptStatus} receiptStatus The state of the receipt\n     * @readonly\n     */\n\n    this.receiptStatus = Message.ReceiptStatus.NONE;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.serverAckTimer = null;\n    /**\n     * @public\n     * @property {string} fileId An attached file Id (if exists)\n     * @readonly\n     */\n\n    this.fileId = fileId;\n    /**\n     * @public\n     * @property {string} fileName An attached file Name (if exists)\n     * @readonly\n     */\n\n    this.fileName = fileName;\n    /**\n     * @public\n     * @property {boolean} isMarkdown If the message is a markdown type message\n     * @readonly\n     */\n\n    this.isMarkdown = isMarkdown;\n    /**\n     * @public\n     * @property {string} subject The subject of the message displayed in notifs\n     * @readonly\n     */\n\n    this.subject = subject;\n    /**\n     * @public\n     * @property {string} answeredMsgId The Id of the message answered\n     * @readonly\n     */\n\n    this.answeredMsgId = answeredMsgId;\n    /**\n     * @public\n     * @property {string} answeredMsgDate The Date of the message answered\n     * @readonly\n     */\n\n    this.answeredMsgDate = answeredMsgDate;\n    /** \n     * @public\n     * @property {geoloc} geoloc\n     * @readonly\n     */\n\n    this.geoloc = geoloc;\n    /** \n     * @public\n     * @property {object} additionalContent\n     * @readonly\n     */\n\n    this.additionalContent = additionalContent;\n    /** \n     * @public\n     * @property {object} alternativeContent\n     * @readonly\n     */\n\n    this.alternativeContent = alternativeContent;\n    /** \n     * @public\n     * @property {voiceMessage} voiceMessage\n     * @readonly\n     */\n\n    this.voiceMessage = voiceMessage;\n    this.replaceMsgs = [];\n  }\n\n  Message.prototype.addReplaceMsg = function (messageId, replacedMsgBody) {\n    var replacedMsg = ReplaceMsg.create(messageId, replacedMsgBody);\n    this.replaceMsgs.push(replacedMsg);\n  };\n\n  Message.prototype.isTextModified = function () {\n    return this.replaceMsgs.length > 0;\n  };\n\n  Message.prototype.getLastTextModified = function () {\n    if (this.replaceMsgs.length > 0) {\n      return this.replaceMsgs[this.replaceMsgs.length - 1].body;\n    }\n\n    return this.data;\n  };\n\n  Message.prototype.isDeleted = function () {\n    return this.getLastTextModified().length === 0;\n  };\n  /**\n         * @private\n         * @method\n         * @instance\n         */\n\n\n  Message.prototype.setReceiptStatus = function (receiptStatus) {\n    if (this.serverAckTimer && receiptStatus > Message.ReceiptStatus.IN_PROGRESS) {\n      $interval.cancel(this.serverAckTimer);\n      this.serverAckTimer = null;\n    }\n\n    if (receiptStatus > this.receiptStatus) {\n      this.receiptStatus = receiptStatus;\n      $log.info("[Message] " + this.id + " : " + Message.ReceiptStatusText[receiptStatus]);\n    }\n\n    return this;\n  };\n\n  return Message;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/message.js?')},function(module,exports){eval('/**\n * @class\n * @name Room\n * @description\n *      This class represents a bubble (old name was a \'room\') <br>\n *\t\tA bubble is an interaction between several participants based on IM media. A bubble is described by a name and a description.<br>\n *\t\tLike for P2P conversation, A conversation within a bubble never ends and all interactions done can be retrieved. <br>\n */\nangular.module("rainbow").factory("Room", [function () {\n  "use strict";\n  /**\n   * @private\n         * @readonly\n   * @enum {number}\n   */\n\n  Room.Type = {\n    "PRIVATE": 0,\n    "PUBLIC": 1\n  };\n  /**\n   * @public\n         * @readonly\n   * @enum {String}\n   */\n\n  Room.Privilege = {\n    /** User level */\n    "USER": "user",\n\n    /** Moderator level */\n    "MODERATOR": "moderator",\n\n    /** Guest level */\n    "GUEST": "guest"\n  };\n  /**\n   * @public\n   * @readonly\n   * @enum {String}\n   */\n\n  Room.History = {\n    /** Full bubble history is accessible for newcomers */\n    "ALL": "all",\n\n    /** No history is accessible for newcomers, only new messages posted */\n    "NONE": "none"\n  };\n\n  Room.create = function (dbId, jid, name, topic, date, conferenceEndpoints, history, customdata, conference, avatar, isActive, lastActivityDate, autoRegister) {\n    var room = new Room(dbId, jid, name, topic, date, conferenceEndpoints, history, customdata, conference, avatar, isActive, lastActivityDate, autoRegister);\n    return room;\n  };\n  /**\n   * @this Room\n   */\n\n\n  function Room(dbId, jid, name, topic, date, conferenceEndpoints, history, customdata, conference, avatar, isActive, lastActivityDate, autoRegister) {\n    /**\n     * @public\n     * @property {string} dbId The bubble ID\n     * @readonly\n     */\n    this.dbId = dbId;\n    /**\n     * @public\n     * @property {string} jid The jid associated to this bubble\n     * @readonly\n     */\n\n    this.jid = jid;\n    /**\n     * @public\n     * @property {string} name The name of the bubble\n     * @readonly\n     */\n\n    this.name = name;\n    /**\n     * @public\n     * @property {string} name The name of the bubble\n     * @readonly\n     */\n\n    this.nameForLogs = "";\n    /**\n     * @public\n     * @property {string} description The description of the bubble\n     * @readonly\n     */\n\n    this.desc = topic;\n    /**\n     * @private\n     * @property {string} type The type of the bubble\n     * @readonly\n     */\n\n    this.type = Room.Type.PRIVATE;\n    /**\n     * @public\n     * @property {Contact[]} users The list of users of the bubble (invited, joined and removed)\n     * @readonly\n     */\n\n    this.users = [];\n    /**\n    * @public\n    * @property {string} history Allow newcomers to access or not messages history. If the value is "all", a newcomer can retrieve the full bubble messages history\n    * @readonly\n    */\n\n    this.history = history || Room.History.NONE;\n    /**\n    * @public\n    * @property {Object} customData Custom data associated to the Room\n    * @readonly\n    */\n\n    this.customData = customdata || {};\n    /**\n     * @public\n     * @property {Contact} ownerContact The owner of the bubble\n     * @readonly\n     */\n\n    this.ownerContact = null;\n    /**\n     * @public\n     * @property {Contact[]} organizers The organizers of the bubble\n     * @readonly\n     */\n\n    this.organizers = [];\n    /**\n     * @public\n     * @property {Contact[]} members The members of the bubble\n     * @readonly\n     */\n\n    this.members = [];\n    /**\n     * @public\n     * @property {Object[]} avatarContacts The avatar of each participants of the bubble\n     * @readonly\n     */\n\n    this.avatarContacts = [];\n    /**\n     * @public\n     * @property {boolean} owner True if the bubble is owned by the connected user\n     * @readonly\n     */\n\n    this.owner = false;\n    /**\n     * @public\n     * @property {boolean} isModerator True if the bubble is moderated by the connected user\n     * @readonly\n     */\n\n    this.isModerator = false;\n    /**\n     * @public\n     * @property {Object[]} confEndpoints\n     * @readonly\n     */\n\n    this.confEndpoints = conferenceEndpoints ? conferenceEndpoints : [];\n    /**\n     * @public\n     * @property {Object} conference\n     * @readonly\n     */\n\n    this.conference = conference !== undefined ? conference : null;\n    /**\n     * @public\n     * @property {string} status The status of the connected user in the bubble (\'invited\', \'accepted\', \'unsubscribed\', \'rejected\' or \'deleted\')\n     * @readonly\n     */\n\n    this.status = "none";\n    /**\n     * @private\n     * @property {string} creationDate The creation date of the bubble\n     * @readonly\n     */\n\n    this.creationDate = date;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.initPresPromise = null;\n    /**\n     * @private\n     * @readonly\n     */\n\n    this.avatar = avatar;\n    /**\n     * @private\n     * @property {array} guestEmails List of guest emails\n     */\n\n    this.guestEmails = [];\n    /**\n     * @private\n     * @property {boolean} isActive True if the bubble is actived\n     * @readonly\n     */\n\n    this.isActive = isActive;\n    /**\n     * @private\n     * @property {string} lastActivityDate The date of the last activity in this bubble\n     * @readonly\n     */\n\n    this.lastActivityDate = lastActivityDate;\n    /**\n     * @private\n     * @property {string} autoRegister A user can create a room and not have to register users. He can share instead a public link also called \'public URL\'\n     * @readonly\n     */\n\n    this.autoRegister = autoRegister;\n    /**\n     * @private\n     */\n\n    Room.prototype.toString = function () {\n      return "Room " + this.dbId + " " + this.name + " " + this.jid;\n    };\n    /**\n     * @private\n     */\n\n\n    Room.prototype.updateAvatarInfo = function () {\n      var avatarContacts = [];\n      var orderedContacts = this.users.slice(); //ignore if we\'ve already an avatar set\n\n      if (this.avatar) {\n        return;\n      }\n\n      orderedContacts.sort(function (aa, bb) {\n        return new Date(aa.date) - new Date(bb.date);\n      });\n\n      for (var index = 0; index < orderedContacts.length; index++) {\n        var contact = orderedContacts[index].contact;\n        var status = orderedContacts[index].status;\n\n        if (contact && contact.dbId !== this.ownerContact.dbId && contact.initials !== "A" && contact.displayName !== "Anonymous") {\n          if (status === "accepted" || status === "invited") {\n            avatarContacts.push(contact);\n          }\n\n          if (avatarContacts.length === 2) {\n            break;\n          }\n        }\n      }\n\n      this.avatarContacts = avatarContacts;\n    };\n\n    Room.prototype.isUserOwner = function (contact) {\n      if (contact) {\n        return this.ownerContact.jid === contact.jid;\n      }\n\n      return false;\n    };\n\n    Room.prototype.isUserModerator = function (contact) {\n      var user = this.getOrganizerFromContactJid(contact.jid);\n      return user !== undefined;\n    };\n\n    Room.prototype.isUserStatusAccepted = function (contact) {\n      var user = this.getUserByJid(contact.jid);\n      return user !== undefined && user.status === "accepted";\n    };\n\n    Room.prototype.isUserStillBelongToRoom = function (userJid) {\n      var ownUser = this.getUserByJid(userJid);\n\n      if (ownUser && (ownUser.status === "unsubscribed" || ownUser.status === "deleted")) {\n        // User does no more belong to this Bubble\n        return false;\n      }\n\n      return true;\n    };\n\n    Room.prototype.getOrganizerFromContactJid = function (contactJid) {\n      var user;\n      this.organizers.forEach(function (organizer) {\n        if (organizer.contact.jid === contactJid) {\n          user = organizer;\n        }\n      });\n      return user;\n    };\n    /**\n     * @private\n     */\n\n\n    Room.prototype.getUserByJid = function (userJid) {\n      for (var i = 0; i < this.users.length; i++) {\n        if (userJid === this.users[i].contact.jid) {\n          return this.users[i];\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Method helper to get the first PGI conference Endpoint Identifier (if any)\n     * @public\n     */\n\n\n    Room.prototype.getPstnConfEndpointId = function () {\n      if (this.confEndpoints && this.confEndpoints.length) {\n        for (var i = 0; i < this.confEndpoints.length; i++) {\n          if (this.confEndpoints[i].mediaType === "pstnAudio") {\n            return this.confEndpoints[i].confEndpointId;\n          }\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Method helper to get SFU conference Endpoint Identifier (if any)\n     * @public\n     */\n\n\n    Room.prototype.getSFUConfEndpointId = function () {\n      if (this.confEndpoints && this.confEndpoints.length) {\n        for (var i = 0; i < this.confEndpoints.length; i++) {\n          if (this.confEndpoints[i].mediaType === "webrtc") {\n            return this.confEndpoints[i].confEndpointId;\n          }\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Method helper to get SFU sharing only conference Endpoint Identifier (if any)\n     * @public\n     */\n\n\n    Room.prototype.getSFUSharingConfEndpointId = function () {\n      if (this.confEndpoints && this.confEndpoints.length) {\n        for (var i = 0; i < this.confEndpoints.length; i++) {\n          if (this.confEndpoints[i].mediaType === "webrtcSharingOnly") {\n            return this.confEndpoints[i].confEndpointId;\n          }\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Method helper to know if room is a meeting\n     * @public\n     */\n\n\n    Room.prototype.isMeetingRoom = function () {\n      return this.conference && this.conference.mediaType === "pstnAudio";\n    };\n    /**\n     * Method helper to know if room is a web conference room (SFU)\n     * @public\n    */\n\n\n    Room.prototype.isWebConferenceRoom = function () {\n      return this.conference && this.conference.mediaType !== "pstnAudio" && this.getSFUConfEndpointId();\n    };\n    /**\n     * Method helper to know if room is a Meeting or SFU conference\n     * @public\n     */\n\n\n    Room.prototype.isMeetingOrWebConferenceRoom = function () {\n      return this.isMeetingRoom() || this.getSFUConfEndpointId();\n    };\n\n    Room.prototype.getNameForLogs = function () {\n      if (!this.nameForLogs && this.name) {\n        var temp = this.name.replace(/[^\\s](?=.{1,}$)/g, "*");\n        this.nameForLogs = this.name.charAt(0) + temp.substr(1);\n      }\n\n      return this.nameForLogs;\n    };\n\n    Room.prototype.getInvitedUsers = function (audioUserJids) {\n      var audioUserJidsList = [];\n      if (audioUserJids) audioUserJidsList = audioUserJids;\n      var ctrl = this;\n      return this.members.filter(function (user) {\n        return !user.contact.displayName.startsWith("__guest__") && !user.contact.displayName.startsWith("__##__guest__##__") && !user.contact.displayName.startsWith("Anonymous") && !audioUserJidsList.contains(user.contact.jid) && !ctrl.isUserModerator(user.contact) && !user.contact.isTerminated && (user.status === "accepted" || user.status === "invited");\n      });\n    };\n\n    Room.prototype.getAutoRegister = function () {\n      return this.autoRegister ? this.autoRegister : "unlock";\n    };\n\n    Room.prototype.setAutoRegister = function (value) {\n      this.autoRegister = value;\n    };\n  }\n\n  return Room;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/room.js?')},function(module,exports){eval('(function () {\n  "use strict";\n\n  angular.module("rainbow").factory("RBNotification", ["$log", "$rootScope", "$notification", "$filter", "notify", function ($log, $rootScope, $notification, $filter, notify) {\n    /*************************************************************/\n\n    /* PUBLIC STUFF                                              */\n\n    /*************************************************************/\n    var defaultDelay = 800000;\n    var that = this;\n    var notificationSaver = null;\n    /*************************************************************/\n\n    /* STATIC METHODS                                            */\n\n    /*************************************************************/\n\n    RBNotification.notifs = [];\n\n    RBNotification.create = function (attr) {\n      var notification = RBNotification.notifs[attr.id];\n\n      if (notification) {\n        notification.update(attr);\n        return notification;\n      }\n\n      notification = new RBNotification(attr);\n      RBNotification.notifs[attr.id] = notification;\n      return notification;\n    };\n\n    RBNotification.hide = function (notificationId) {\n      $log.info("[RBNotification] Hide notification");\n      var notification = RBNotification.notifs[notificationId];\n\n      if (notification) {\n        notification.handler.close();\n      }\n\n      delete RBNotification.notifs[notificationId];\n\n      if (Object.keys(RBNotification.notifs).length === 0) {\n        $rootScope.$broadcast("NOTIFICATION_HIDE_EVENT", this);\n      }\n    };\n\n    RBNotification.createNotificationListener = function (scope) {\n      $rootScope.$on("$destroy", $rootScope.$on("NOTIFICATION_SHOW_EVENT", function (__event, notification) {\n        notification.display(scope);\n      }));\n    };\n    /*************************************************************/\n\n    /* PRIVATE CONSTRUCTOR                                       */\n\n    /*************************************************************/\n\n\n    function RBNotification(attr) {\n      $log.info("[RBNotification] Create notification"); // Fill properties\n\n      this.icon = attr.icon; //this.contact = attr.contact;\n\n      this.displayName = attr.displayName;\n      this.message = attr.body;\n      this.type = attr.type;\n      this.tag = attr.tag;\n      this.title = attr.title;\n      this.tooltip = attr.tooltip;\n      this.delay = attr.delay ? attr.delay : defaultDelay;\n      this.focusAction = attr.focusAction;\n      this.sound = null;\n      this.answerAudioButton = null;\n      this.answerVideoButton = null;\n      this.answerSharingButton = null;\n      this.answerAudioButtonDisabled = null;\n      this.answerClick = false;\n      this.declineClick = false;\n      this.declineButton = null;\n      this.answerWithIMButton = null;\n      this.answerWithTemplateIMClick = false;\n      this.bottomRightButton = null;\n      this.handler = null;\n      this.ascope = null;\n      this.isSent = false;\n    }\n\n    RBNotification.prototype.update = function (attr) {\n      $log.info("[RBNotification] >update"); // Fill properties\n\n      this.icon = attr.icon; //this.contact = attr.contact;\n\n      this.displayName = attr.displayName;\n      this.message = attr.body;\n      this.type = attr.type;\n      this.tag = attr.tag;\n      this.delay = attr.delay ? attr.delay : defaultDelay;\n      this.focusAction = attr.focusAction;\n    };\n    /*************************************************************/\n\n    /* PUBLIC METHODS                                            */\n\n    /*************************************************************/\n\n\n    RBNotification.prototype.send = function () {\n      if (!this.isSent) {\n        this.isSent = true;\n        $rootScope.$broadcast("NOTIFICATION_SHOW_EVENT", this);\n      }\n    };\n\n    RBNotification.prototype.addAnswerAudioButton = function (attr) {\n      this.answerAudioButton = attr;\n    };\n\n    RBNotification.prototype.addDivertedCallButton = function (attr) {\n      this.divertedCallButton = attr;\n    };\n\n    RBNotification.prototype.addAnswerVideoButton = function (attr) {\n      this.answerVideoButton = attr;\n    };\n\n    RBNotification.prototype.addAnswerSharingButton = function (attr) {\n      this.answerSharingButton = attr;\n    };\n\n    RBNotification.prototype.addAnswerAudioButtonDisabled = function (attr) {\n      this.answerAudioButtonDisabled = attr;\n    };\n\n    RBNotification.prototype.addDeclineButton = function (attr) {\n      this.declineButton = attr;\n    };\n\n    RBNotification.prototype.addAnswerWithIMButton = function (attr) {\n      this.answerWithIMButton = attr;\n    };\n\n    RBNotification.prototype.addBottomRightButton = function (attr) {\n      this.bottomRightButton = attr;\n    };\n    /*************************************************************/\n\n    /* PRIVATE METHODS                                           */\n\n    /*************************************************************/\n\n\n    RBNotification.prototype.display = function (scope) {\n      // Create HTML5 notification if application is not visible\n      if (!$rootScope.appVisible) {\n        var _notif = $notification(this.displayName, {\n          tag: this.tag,\n          body: this.message,\n          icon: this.icon,\n          delay: 4000\n        });\n\n        if (this.focusAction) {\n          _notif.$on("click", this.focusAction);\n        }\n      } // Create an isolated scope object\n\n\n      if (!this.ascope) {\n        this.ascope = scope.$new(true);\n        this.ascope.notification = this;\n        this.ascope.showIMTemplates = false;\n        this.ascope.showPhoneTemplates = false;\n\n        this.ascope.answerAudioButtonClick = function (notif) {\n          if (!notif.answerClick) {\n            notif.answerAudioButton.action();\n            notif.answerClick = true;\n          }\n        };\n\n        this.ascope.divertedCallButtonClick = function (notif) {\n          // Save the notification\n          if (notif.ascope.showPhoneTemplates) {\n            notif.ascope.showPhoneTemplates = false;\n            notif.ascope.templatesPhone = [];\n          } else {\n            notificationSaver = notif; //create template entries\n\n            var templatesPhone = [];\n\n            if (notif.divertedCallButton && Array.isArray(notif.divertedCallButton.choice)) {\n              notif.divertedCallButton.choice.forEach(function (item) {\n                templatesPhone.push(item);\n              });\n            }\n\n            notif.ascope.templatesPhone = templatesPhone; //open menu with predefined texts\n\n            notif.ascope.showPhoneTemplates = true;\n          }\n        };\n\n        this.ascope.divertedCallWithTemplatePhone = function (template) {\n          notificationSaver.divertedCallButton.action(template.phonenumber);\n        };\n\n        this.ascope.answerVideoButtonClick = function (notif) {\n          if (!notif.answerClick) {\n            notif.answerVideoButton.action();\n            notif.answerClick = true;\n          }\n        };\n\n        this.ascope.answerSharingButtonClick = function (notif) {\n          if (!notif.answerClick) {\n            notif.answerSharingButton.action();\n            notif.answerClick = true;\n          }\n        };\n\n        this.ascope.declineButtonClick = function (notif) {\n          if (!notif.declineClick) {\n            notif.declineButton.action();\n            notif.declineClick = true;\n          }\n        };\n\n        this.ascope.answerWithIMButtonClick = function (notif) {\n          // Save the notification\n          if (notif.ascope.showIMTemplates) {\n            notif.ascope.showIMTemplates = false;\n            notif.ascope.templatesIM = [];\n          } else {\n            notificationSaver = notif; //create template entries\n\n            var templatesIM = [];\n\n            if (notif.answerWithIMButton && Array.isArray(notif.answerWithIMButton.choice)) {\n              notif.answerWithIMButton.choice.forEach(function (item) {\n                templatesIM.push(item);\n              });\n            }\n\n            notif.ascope.templatesIM = templatesIM; //open menu with predefined texts\n\n            notif.ascope.showIMTemplates = true;\n          }\n        };\n\n        this.ascope.answerWithTemplateIM = function (template) {\n          if (!notificationSaver.answerWithTemplateIMClick) {\n            if (notificationSaver) {\n              var message = "";\n\n              if (notificationSaver.answerWithIMButton.label !== template.label) {\n                message = $filter("translate")(template.label);\n              }\n\n              notificationSaver.answerWithIMButton.action(message);\n            }\n\n            notificationSaver.answerWithTemplateIMClick = true;\n          }\n        };\n\n        this.ascope.addBottomRightButtonClick = function (notif) {\n          notif.bottomRightButton.action();\n        };\n      } // Create notification with this isolated scope\n\n\n      if (!this.handler) {\n        this.handler = notify({\n          container: document.getElementById("leftArea"),\n          position: "left",\n          templateUrl: "notificationCallTemplate.html",\n          message: this.title,\n          duration: this.delay,\n          startTop: 80,\n          scope: this.ascope\n        });\n      }\n    };\n\n    return RBNotification;\n  }]);\n})();\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/notification.js?')},function(module,exports){eval('angular.module("rainbow").factory("CallLog", [function () {\n  "use strict";\n\n  CallLog.create = function (id, contact, state, duration, type, read, date, direction, callSubject, isLatestCall) {\n    var callLog = new CallLog(id, contact, state, duration, type, read, date, direction, callSubject, isLatestCall);\n    return callLog;\n  };\n\n  CallLog.getNames = function (callLog) {\n    var result = {\n      firstname: "",\n      lastname: ""\n    };\n\n    if (callLog && callLog.contact) {\n      result.firstname = callLog.contact.firstname ? callLog.contact.firstname.toUpperCase() : "";\n      result.lastname = callLog.contact.lastname ? callLog.contact.lastname.toUpperCase() : "";\n\n      if (callLog && callLog.date) {\n        result.date = callLog.date.getTime();\n      }\n    }\n\n    return result;\n  };\n\n  CallLog.getDate = function (callLog) {\n    if (callLog && callLog.date) {\n      return callLog.date.getTime();\n    }\n\n    return 0;\n  };\n\n  CallLog.sortByContact = function (callLogA, callLogB) {\n    var res = -1;\n\n    if (callLogA && callLogA.value.lastname && callLogB && callLogB.value.lastname) {\n      var str1 = callLogA.value.lastname;\n      var str2 = callLogB.value.lastname;\n      res = str1.localeCompare(str2);\n\n      if (res === 0) {\n        str1 = callLogA.value.firstname;\n        str2 = callLogB.value.firstname;\n        res = str1.localeCompare(str2);\n\n        if (res === 0 && callLogB.value.date && callLogA.value.date) {\n          //order by date\n          res = callLogB.value.date - callLogA.value.date;\n        }\n      }\n    }\n\n    return res;\n  };\n\n  CallLog.sortByDate = function (callLogA, callLogB) {\n    var res = 1;\n\n    if (callLogA && callLogB) {\n      res = callLogB.value - callLogA.value;\n    }\n\n    return res;\n  };\n\n  CallLog.Type = {\n    /** WebRTC call */\n    WEBRTC: "webrtc",\n\n    /** Telephony call (from PBX) */\n    TELEPHONE: "telephone",\n\n    /** Conference call (from PBX) */\n    CONFERENCE: "conference"\n  };\n\n  function CallLog(id, contact, state, duration, type, read, date, direction, callSubject, isLatestCall) {\n    /**\n    * @public\n    * @property {string} id The CallLog ID\n    * @readonly\n    */\n    this.id = id;\n    /**\n    * @public\n    * @property {Contact} contact The Contact related to the call log\n    * @link Contact\n    * @readonly\n    */\n\n    this.contact = contact;\n    this.state = state;\n    this.duration = duration;\n    this.direction = direction;\n    this.callSubject = callSubject;\n    this.isLatestCall = isLatestCall;\n\n    if (type === "unknown" || type === "audio" || type === "webrtc") {\n      type = CallLog.Type.WEBRTC;\n    } else if (type === "telephone") {\n      type = CallLog.Type.TELEPHONE;\n    } else {\n      type = CallLog.Type.CONFERENCE;\n    }\n\n    this.type = type;\n    this.read = read;\n    this.date = date; // this.startDate = startDate;\n    // this.endDate = endDate;\n    // this.contactId = contactId;\n    // this.contact = null;\n    // this.direction = direction;\n    // this.isTelephony = false;\n    // this.isMissed = false;\n    // this.isNotAnswered = false;\n    // this.isWebRTCAudioCall = false;\n  }\n\n  return CallLog;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/callLog.js?')},function(module,exports){eval('(function () {\n  "use strict";\n\n  angular.module("rainbow").factory("Document", ["$log", "$filter", function ($log, $filter) {\n    // Static factories\n    Document.create = function (publisher, data) {\n      return new Document(publisher, data, Date.now(), publisher.jid);\n    };\n\n    Document.createForSharing = function (publisher, document) {\n      console.log(document.item_id);\n\n      if (document.item_id === "") {\n        return new Document(publisher, "Repost", Date.now(), document.authorjid, document.pub_id);\n      } else {\n        return new Document(publisher, "Repost", Date.now(), document.authorjid, document.item_id);\n      }\n    };\n\n    Document.createFromXML = function (publisher, data) {\n      return new Document(publisher, data.childNodes[0].childNodes[0].nodeValue, //data\n      parseInt(data.childNodes[1].childNodes[0].nodeValue, 10), //timestamp\n      data.childNodes[2].childNodes[0].nodeValue, //publisherjid\n      data.childNodes[3].childNodes.length !== 1 ? "" : data.childNodes[3].childNodes[0].nodeValue, //"","","","",\n      //"",\n      data.parentNode.attributes.getNamedItem("id").nodeValue //id\n      );\n    }; // Constructor\n\n\n    function Document(publisher, data, timestamp, authorjid, item_id, pub_id) {\n      this.publisher = publisher; // publisher\n\n      this.item_id = item_id; //orginal publication id if sharing\n\n      this.data = data; //content of publication\n\n      this.timestamp = timestamp; //publish time\n\n      this.authorjid = authorjid; // who write this publication,\n      //two cases: 1. publish: publisher.jid = authorjid\n      //           2. sharing: publisher.jid is the one who published, and authorjid is\n      //              the one who writed the orginal publication\n\n      this.pub_id = pub_id; // id of publication\n\n      $log.debug("[Document] createActu : " + this);\n    }\n\n    Document.prototype.messageFilter = function (message) {\n      return $filter("quoteFilter")($filter("emojione")($filter("linky")($filter("emojiUnicodeToShort")(message, "_blank"))));\n    };\n\n    Document.prototype.setPubId = function (pub_id) {\n      this.pub_id = pub_id;\n    };\n\n    Document.prototype.setItemId = function (item_id) {\n      this.item_id = item_id;\n    };\n\n    Document.prototype.getXML = function () {\n      return [{\n        data: $build("entry").c("data", this.data).up().c("timestamp", this.timestamp).up().c("jidauthor", this.authorjid).up().c("item_id", this.item_id).tree()\n      }];\n    };\n\n    Document.prototype.getTime = function (format) {\n      return moment(this.timestamp).format(format);\n    }; // Override toString method\n\n\n    Document.prototype.toString = function () {\n      return "(jid:" + this.contact + ", id:" + this.pub_id + ", data:" + this.data + ", tsmp:" + this.timestamp + " )";\n    };\n\n    return Document;\n  }]);\n})();\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/document.js?')},function(module,exports){eval('/**\n * @class\n * @name Group\n * @description\n *\t  This class represents a user\'s contact Group <br>\n *\t\tA group is a list of one or more user\'s contact(s).<br>\n *\t\tOne contact may be in several groups. <br>\n */\nangular.module("rainbow").factory("Group", [function () {\n  "use strict"; // Static factories\n\n  Group.createFromData = function (data) {\n    return new Group(data.id, data.name, data.comment, data.isFavorite);\n  };\n  /**\n   * @this Group\n   */\n\n\n  function Group(id, name, comment, isFavorite) {\n    /**\n     * @public\n     * @property {string} id The group ID\n     * @readonly\n     */\n    this.id = id;\n    /**\n     * @public\n     * @property {String} name The group name\n     */\n\n    this.name = name;\n    /**\n     * @public\n     * @property {String} comment The group comment\n     */\n\n    this.comment = comment ? comment : "";\n    /**\n     * @public\n     * @property {Boolean} isFavorite True if the group was marked as "Favorite"\n     */\n\n    this.isFavorite = isFavorite ? isFavorite : false;\n    /**\n     * @public\n     * @property {Contact[]} users The list of users of the group.\n     */\n\n    this.users = [];\n    /**\n     * @public\n     * @property {Contact[]} sortedUserList The list of users of the group (sorted)\n     */\n\n    this.sortedUserList = [];\n  }\n\n  return Group;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/group.js?')},function(module,exports){eval('/**\n * @class\n * @name Invitation\n * @public\n * @description\n *      This class is used to represent an invitation received or sent by/to user <br/>\n */\nangular.module("rainbow").factory("Invitation", ["userInfoService", function (userInfoService) {\n  "use strict";\n  /*************************************************************/\n\n  /* STATIC FACTORIES                                          */\n\n  /*************************************************************/\n\n  Invitation.create = function (id, invitedUserId, invitedUserEmail, invitingUserId, invitingUserEmail, requestNotificationLanguage, invitingDate, lastNotificationDate, status, type, inviteToJoinMeeting) {\n    return new Invitation(id, invitedUserId, invitedUserEmail, invitingUserId, invitingUserEmail, requestNotificationLanguage, invitingDate, lastNotificationDate, status, type, inviteToJoinMeeting);\n  };\n\n  Invitation.createFromData = function (invitationData) {\n    var invitation = new Invitation(invitationData.id, invitationData.invitedUserId, invitationData.invitedUserEmail, invitationData.invitingUserId, invitationData.invitingUserEmail, invitationData.requestNotificationLanguage, invitationData.invitingDate, invitationData.lastNotificationDate, invitationData.status, invitationData.type, invitationData.inviteToJoinMeeting, invitationData.invitedPhoneNumber);\n    invitation.createDefaultAvatar();\n    return invitation;\n  };\n  /*************************************************************/\n\n  /* INVITATION CONSTRUCTOR                                  */\n\n  /*************************************************************/\n\n  /**\n   * @this Invitation\n   */\n\n\n  function Invitation(id, invitedUserId, invitedUserEmail, invitingUserId, invitingUserEmail, requestNotificationLanguage, invitingDate, lastNotificationDate, status, type, inviteToJoinMeeting, invitedPhoneNumber) {\n    /**\n     * @public\n     * @property {string} id The invitation ID\n     * @readonly\n     */\n    this.id = id;\n    /**\n     * @public\n     * @property {string} invitedUserId The invited user unique Rainbow id\n     * @readonly\n     */\n\n    this.invitedUserId = invitedUserId;\n    /**\n     * @public\n     * @property {string} invitedUserEmail The invited user email\n     * @readonly\n     */\n\n    this.invitedUserEmail = invitedUserEmail;\n    /**\n     * @public\n     * @property {string} invitedPhoneNumber The invited user Phone Number\n     * @readonly\n     */\n\n    this.invitedPhoneNumber = invitedPhoneNumber;\n    /**\n     * @private\n     * @property {string} invitingUserId The inviting user unique Rainbow Id\t\t\t \n     * @readonly\n     */\n\n    this.invitingUserId = invitingUserId;\n    /**\n     * @private\n     * @property {string} invitingUserEmail The inviting user loginEmail\n     * @readonly\n     */\n\n    this.invitingUserEmail = invitingUserEmail; // Status\n\n    /**\n     * @private\n     * @property {string} requestNotificationLanguage The request notification language\t\t \n     * @readonly\n     */\n\n    this.requestNotificationLanguage = requestNotificationLanguage;\n    /**\n    * @public\n    * @property {string} invitingDate The date the invitation was created.\n    * @readonly\n    */\n\n    this.invitingDate = invitingDate;\n    /**\n     * @public\n     * @property {string} lastnotificationDate The date when the last email notification was sent.\n     * @readonly\n     */\n\n    this.lastNotificationDate = lastNotificationDate; //fix #24157\n\n    /**\n     * @public\n     * @property {string} status The invitation status.\n     * @readonly\n     */\n\n    this.status = status;\n    /**\n     * @public\n     * @property {string} type The invitation type.\n     * @readonly\n     */\n\n    this.type = type;\n    /**\n     * @public\n     * @property {string} defaultAvatar The invitation defaultAvatar.\n     * @readonly\n     */\n\n    this.defaultAvatar = null;\n    /**\n     * @public\n     * @property {boolean} inviteToJoinMeeting True if joinRoom invitation.\n     * @readonly\n     */\n\n    this.inviteToJoinMeeting = inviteToJoinMeeting;\n\n    this.createDefaultAvatar = function () {\n      if (!this.defaultAvatar && this.invitedUserEmail) {\n        var color = userInfoService.computeUserColor(this.invitedUserEmail);\n        var initials = this.invitedUserEmail.substring(0, 2).toUpperCase();\n        this.defaultAvatar = userInfoService.createDefaultAvatarImage(initials, color);\n      }\n    };\n  }\n\n  return Invitation;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/invitation.js?')},function(module,exports){eval('/**\n * @ngdoc factory\n * @module rainbow\n * @private\n * @name VoiceMail\n * @restrict E\n * @description VoiceMail model\n */\n\n/**\n * @class\n * @name VoiceMail\n * @private\n * @description\n *      This class is used to represent a VoiceMail <br/>\n */\nangular.module("rainbow").factory("VoiceMail", ["profileService", function (profileService) {\n  "use strict";\n  /*************************************************************/\n\n  /* STATIC FACTORIES                                          */\n\n  /*************************************************************/\n\n  /**\n   * @ngdoc method\n   * @name VoiceMail#create\n   * @returns {VoiceMail} VoiceMail object.\n         * @description Creates new VoiceMail object\n   */\n\n  VoiceMail.create = function () {\n    return new VoiceMail();\n  };\n  /*************************************************************/\n\n  /* INVITATION CONSTRUCTOR                                  */\n\n  /*************************************************************/\n\n  /**\n   * @this VoiceMail\n   */\n\n\n  function VoiceMail() {\n    /**\n     * @public\n     * @property {boolean} VMFlag Allow vm msg notification without knowing nu of msg\n     * @readonly\n     */\n    this.VMFlag = false;\n    /**\n     * @public\n     * @property {int} VMCounter nb of vm msg (if 0 nothing to display)\n     * @readonly\n     */\n\n    this.VMCounter = 0;\n    /**\n     * @public\n     * @property {string} infoMsg service warning deduced from handler/callservice feedback\n     * @readonly\n     */\n\n    this.infoMsg = "";\n    /**\n     * @public\n     * @property {string} infoMsg service warning deduced from handler/callservice feedback\n     * @readonly\n     */\n\n    this.voiceMailFeatureEnabled = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_VOICE_MAIL);\n    /**\n     * @public\n     * @method\n     * @instance\n     */\n\n    this.setVMFlag = function (flag) {\n      this.VMFlag = flag;\n    };\n    /**\n     * @public\n     * @method\n     * @instance\n     */\n\n\n    this.getVMFlag = function () {\n      return this.VMFlag;\n    };\n    /**\n     * @public\n     * @method\n     * @instance\n     */\n\n\n    this.setVMCounter = function (ct) {\n      if (ct > 0) {\n        this.VMFlag = true;\n        this.VMCounter = ct;\n      } else {\n        this.VMCounter = 0;\n      }\n    };\n    /**\n     * @public\n     * @method\n     * @instance\n     */\n\n\n    this.getVMCounter = function () {\n      return this.VMCounter;\n    };\n    /**\n     * @public\n     * @method\n     * @instance\n     */\n\n\n    this.setInfoMsg = function (msg) {\n      this.infoMsg = msg;\n    };\n    /**\n     * @public\n     * @method\n     * @instance\n     */\n\n\n    this.getInfoMsg = function () {\n      return this.infoMsg;\n    };\n    /**\n     * @public\n     * @method\n     * @instance\n     */\n\n\n    this.getDisplayState = function () {\n      return this.voiceMailFeatureEnabled;\n    };\n  }\n\n  return VoiceMail;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/voiceMail.js?')},function(module,exports){eval('/**\n * @class\n * @name Message\n * @description\n *      This class is used to represent a message in a conversation\n */\nangular.module("rainbow").factory("ReplaceMsg", ["$filter", function ($filter) {\n  "use strict";\n  /**\n   * @private\n   * @method\n   * @instance\n   */\n\n  ReplaceMsg.create = function (id, body) {\n    // convert emojione from unicode to short\n    var messageBody = $filter("emojiUnicodeToShort")(body);\n    return new ReplaceMsg(id, messageBody);\n  }; // Constructor\n\n  /**\n    * @this Message\n    */\n\n\n  function ReplaceMsg(id, body) {\n    this.id = id;\n    this.body = body;\n  }\n\n  return ReplaceMsg;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/replaceMsg.js?')},function(module,exports){eval('angular.module("rainbow").factory("Organisation", [function () {\n  "use strict"; // Static factories\n\n  Organisation.createFromData = function (data) {\n    return new Organisation(data.id, data.name, data.visibility);\n  }; // Constructor\n\n\n  function Organisation(id, name, visibility) {\n    this.id = id;\n    this.name = name;\n    this.visibility = visibility;\n    this.companies = [];\n  }\n\n  return Organisation;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/organisation.js?')},function(module,exports){eval('/**\n * @class\n * @name Bot\n * @public\n * @description\n *      This class is used to represent a bot service.\n */\nangular.module("rainbowAdmin").factory("Bot", [function () {\n  "use strict";\n  /**\n   * A Bot service.\n   */\n\n  Bot.create = function (data) {\n    return new Bot(data.jid, data.name, data.id, data.avatarId, data.lastAvatarUpdateDate, data.isBotAvatarCustomized);\n  }; // Constructor\n\n\n  function Bot(jid, name, id, avatarId, lastAvatarUpdateDate, isBotAvatarCustomized) {\n    /**\n     * @public\n     * @property {string} jid Bot service jid id, should be a domain name (for example \'emily.rb.com\').\n     */\n    this.jid = jid;\n    /**\n    * @public\n    * @property {string} name Bot name, like \'Emily\'.\n    */\n\n    this.name = name;\n    /**\n      \t * @public\n         \t * @property {string} id Unique identifier that represents the bot service.\n      \t */\n\n    this.id = id;\n    /**\n      \t * @public\n         \t * @property {string} id Current avatar entity identifier.\n      \t */\n\n    this.avatarId = avatarId || id;\n    /**\n    * @public\n    * @property {string} lastAvatarUpdateDate Last create/update date of the current bot avatar.\n    */\n\n    this.lastAvatarUpdateDate = lastAvatarUpdateDate;\n    /**\n    * @public\n    * @property {boolean} isAvatarCustomized True if the default avatar has been replaced, otherwise false.\n    */\n\n    this.isAvatarCustomized = isBotAvatarCustomized;\n  }\n\n  return Bot;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/bot.js?')},function(module,exports){eval('angular.module("rainbow").factory("Site", [function () {\n  "use strict";\n\n  Site.createFromData = function (data) {\n    return new Site(data.id, data.name, data.status, data.companyId, data.settings, data.isCentrex);\n  };\n\n  Site.create = function (id, name, status, companyId) {\n    return new Site(id, name, status, companyId);\n  };\n  /**\n   * AUTHORIZED VALUES\n   */\n\n\n  Site.StatusValues = ["active", "alerting", "hold", "terminated"]; // Constructor\n\n  function Site(id, name, status, companyId, settings, isCentrex) {\n    this.id = id;\n    this.name = name ? name : "";\n    this.status = status ? status : "";\n    this.companyId = companyId ? companyId : "";\n    this.settings = settings ? settings : "";\n\n    if (angular.isDefined(isCentrex)) {\n      this.isCentrex = isCentrex;\n    }\n  }\n\n  return Site;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/site.js?')},function(module,exports){eval('angular.module("rainbow").factory("System", [function () {\n  "use strict";\n\n  System.createFromData = function (data) {\n    return new System(data.id, data.pbxId, data.jid_pbxagent, data.jid_password, data.pbxMainBundlePrefix, data.serverPingTimeout, data.type, data.status, data.version, data.siteId, data.country, data.name, data.jid_pbxagent_password, data.jid_pbxagent_password_activating, data.usePbxMainBundlePrefix, data.pbxNumberingTranslator, data.isCentrex, data.isShared, data.bpId, data.cloudpbx, data.hasMediaPillar, data.isOxoManaged);\n  };\n\n  System.create = function () {\n    return new System();\n  };\n  /**\n   * AUTHORIZED VALUES\n   */\n\n\n  System.TypeValues = ["oxe", "oxo", "third_party", "cloud_pbx", "oxo_managed"];\n  System.TypeEnum = {\n    OXE: "oxe",\n    OXO: "oxo",\n    THIRD_PARTY: "third_party",\n    CLOUD_PBX: "cloud_pbx",\n    OXO_MANAGED: "oxo_managed"\n  };\n  System.StatusValues = ["created", "activating", "activated"]; // Constructor\n\n  function System(id, pbxId, jid_pbxagent, jid_password, pbxMainBundlePrefix, serverPingTimeout, type, status, version, siteId, country, name, jid_pbxagent_password, jid_pbxagent_password_activating, usePbxMainBundlePrefix, pbxNumberingTranslator, isCentrex, isShared, bpId, cloudpbx, hasMediaPillar, isOxoManaged) {\n    this.id = id || null;\n    this.type = type || null;\n\n    if (this.type !== System.TypeEnum.CLOUD_PBX) {\n      this.jid_pbxagent = jid_pbxagent || "";\n      this.jid_password = jid_password || "";\n      this.jid_pbxagent_password = jid_pbxagent_password || "";\n      this.jid_pbxagent_password_activating = jid_pbxagent_password_activating || "";\n      this.pbxMainBundlePrefix = pbxMainBundlePrefix || ["0"];\n      this.usePbxMainBundlePrefix = angular.isDefined(usePbxMainBundlePrefix) ? usePbxMainBundlePrefix : true;\n      this.pbxNumberingTranslator = pbxNumberingTranslator || [];\n    }\n\n    this.country = country || "FRA";\n    this.name = name || ""; // Optionnal parameters\n\n    if (siteId) {\n      this.siteId = siteId;\n    }\n\n    if (pbxId) {\n      this.pbxId = pbxId;\n    }\n\n    if (serverPingTimeout) {\n      this.serverPingTimeout = serverPingTimeout;\n    }\n\n    if (status) {\n      this.status = status;\n    }\n\n    if (version) {\n      this.version = version;\n    }\n\n    if (angular.isDefined(isCentrex)) {\n      this.isCentrex = isCentrex;\n    }\n\n    if (angular.isDefined(isShared)) {\n      this.isShared = isShared;\n    }\n\n    if (bpId) {\n      this.bpId = bpId;\n    }\n\n    if (angular.isDefined(hasMediaPillar)) {\n      this.hasMediaPillar = hasMediaPillar;\n    }\n\n    if (angular.isDefined(isOxoManaged)) {\n      this.isOxoManaged = isOxoManaged;\n    }\n\n    if (cloudpbx) {\n      if (cloudpbx.domainName) {\n        this.domainName = cloudpbx.domainName;\n      }\n\n      if (cloudpbx.numberingDigits) {\n        this.numberingDigits = cloudpbx.numberingDigits;\n      }\n\n      if (cloudpbx.numberingPrefix) {\n        this.numberingPrefix = cloudpbx.numberingPrefix;\n      }\n\n      if (cloudpbx.outgoingPrefix) {\n        this.outgoingPrefix = cloudpbx.outgoingPrefix;\n      }\n\n      if (cloudpbx.externalTrunkId) {\n        this.externalTrunkId = cloudpbx.externalTrunkId;\n      }\n\n      if (cloudpbx.installationNumber) {\n        this.installationNumber = cloudpbx.installationNumber;\n      }\n\n      if (cloudpbx.installationNumberId) {\n        this.installationNumberId = cloudpbx.installationNumberId;\n      }\n    } else {\n      this.numberingDigits = 3;\n      this.numberingPrefix = "1";\n    }\n  }\n\n  return System;\n}]); // Adaptation filters\n\nangular.module("rainbow").filter("serverTypeFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "oxo") {\n      return "OXO Connect";\n    }\n\n    if (input === "oxe") {\n      return "OmniPCX Enterprise";\n    }\n\n    if (input === "third_party") {\n      return "Third party PBX";\n    }\n\n    if (input === "cloud_pbx") {\n      return "Cloud PBX";\n    }\n\n    if (input === "oxo_managed") {\n      return "Managed OXO Connect";\n    }\n\n    return input; // OTEC-S value is returned as is\n  };\n}]);\nangular.module("rainbow").filter("systemStateFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "created") {\n      return "pending";\n    }\n\n    if (input === "activating") {\n      return "pending";\n    }\n\n    if (input === "activated") {\n      return "systemStatusActivated";\n    } // detailed connection state (available for OXE and OXO systems)\n\n\n    if (input === "connected") {\n      return "systemStatusConnected";\n    }\n\n    if (input === "disconnected") {\n      return "systemStatusDisonnected";\n    }\n\n    if (input === "degraded") {\n      return "systemStatusDegraded";\n    }\n  };\n}]);\nangular.module("rainbow").filter("systemStateColorFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "created") {\n      return "color_blue";\n    }\n\n    if (input === "activating") {\n      return "color_blue";\n    }\n\n    if (input === "activated") {\n      return "color_blue";\n    } // detailed connection state (available for OXE and OXO systems)\n\n\n    if (input === "connected") {\n      return "color_green";\n    }\n\n    if (input === "disconnected") {\n      return "color_error";\n    }\n\n    if (input === "degraded") {\n      return "color_warning";\n    }\n  };\n}]);\nangular.module("rainbow").filter("thirdPartySystemStateFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "created") {\n      return "pending";\n    }\n\n    if (input === "activating") {\n      return "pending";\n    }\n\n    if (input === "activated") {\n      return "systemStatusConnected";\n    }\n  };\n}]);\nangular.module("rainbow").filter("thirdPartySystemStateColorFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "created") {\n      return "color_blue";\n    }\n\n    if (input === "activating") {\n      return "color_blue";\n    }\n\n    if (input === "activated") {\n      return "color_green";\n    }\n  };\n}]);\nangular.module("rainbow").filter("cloudPbxStateFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "created") {\n      return "systemStatusConnected";\n    }\n\n    if (input === "disconnected") {\n      return "systemStatusDisonnected";\n    }\n  };\n}]);\nangular.module("rainbow").filter("cloudPbxStateColorFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "created") {\n      return "color_green";\n    }\n\n    if (input === "disconnected") {\n      return "color_error";\n    }\n  };\n}]);\nangular.module("rainbow").filter("gatewayStateFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "true") {\n      return "systemStatusConnected";\n    }\n\n    if (input === "false") {\n      return "systemStatusDisonnected";\n    }\n  };\n}]);\nangular.module("rainbow").filter("gatewayStateColorFilter", [function () {\n  "use strict";\n\n  return function (input) {\n    if (input === "true") {\n      return "color_green";\n    }\n\n    if (input === "false") {\n      return "color_error";\n    }\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/system.js?')},function(module,exports){eval('angular.module("rainbow").factory("SystemsGroup", [function () {\n  "use strict";\n\n  SystemsGroup.createFromData = function (data) {\n    return new SystemsGroup(data.id, data.name, data.companies, data.systems);\n  };\n\n  SystemsGroup.create = function (id, name, companies, systems) {\n    return new SystemsGroup(id, name, companies, systems);\n  }; // Constructor\n\n\n  function SystemsGroup(id, name, companies, systems) {\n    this.id = id || null;\n    this.name = name;\n    this.companies = companies || [];\n    this.systems = systems;\n\n    this.containsSystem = function (systemId) {\n      if (this.systems) {\n        return this.systems.some(function (system) {\n          return system.systemId === systemId;\n        });\n      }\n\n      return false;\n    };\n  }\n\n  return SystemsGroup;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/systemsGroup.js?')},function(module,exports){eval('angular.module("rainbow").factory("User", ["Subscription", "userInfoService", function (Subscription, userInfoService) {\n  "use strict";\n\n  User.createFromData = function (data, noDefaultValues) {\n    //replace deprecated roles values in received data:\n    if (data && data.roles && data.roles.includes("private_channels_admin")) {\n      data.roles.splice(data.roles.indexOf("private_channels_admin"), 1, User.RoleValues.ALL_COMPANY_CHANNELS_ADMIN);\n    }\n\n    var user = new User(data, noDefaultValues);\n\n    if (data.profiles) {\n      data.profiles.forEach(function (subscriptionData) {\n        var subscription = Subscription.createFromData(subscriptionData);\n\n        if (!subscription.isTerminated()) {\n          user.subscriptions.push(subscription);\n        }\n      });\n      user.fillMainSubscriptionField();\n    }\n\n    user.computeDisplayName();\n    return user;\n  };\n\n  User.create = function () {\n    return new User();\n  };\n  /**\n   * Returns a copy of the user\'s data but expurgated by the unwanted and undefined optional properties.\n   * @private\n   */\n\n\n  User.prune = function (data, userContact) {\n    var dataCopy = Object.assign({}, data); // if (userContact && (userContact.isSuperadmin() || userContact.isAdmin() || userContact.isBPAdminOperations() || userContact.isBPAdminFinance())) {\n    // \tif (userContact.dbId === data.id) {\n    // \t\t// these fields can\'t be set for himself if the user is a "superadmin" or "admin" or "bp_admin" or "bp_finance".\n    // \t\tdelete dataCopy.roles; // An admin or superadmin can\'t upgrade or downgrade himself\n    // \t}\n    // }\n\n    return dataCopy;\n  };\n  /**\n         * @public\n         * @enum {string}\n         * @readonly\n         * @description\n         * Value can be:\n         * - \'private\': When the user is not visible from an external user,<br>\n         * - \'public\': When the user is visible from an external user\n         */\n\n\n  User.VisibilityValues = ["same_than_company", "public", "private"];\n  User.RoleValues = {\n    USER: "user",\n    GUEST: "guest",\n    SUPERADMIN: "superadmin",\n    SUPPORT: "support",\n    BUSINESS_ADMIN: "business_admin",\n    ADMIN: "admin",\n    BP_ADMIN_OPERATIONS: "bp_admin",\n    BP_ADMIN_FINANCE: "bp_finance",\n    DIRECTORY_ADMIN: "directory_admin",\n    PUBLIC_CHANNELS_ADMIN: "public_channels_admin",\n    ALL_COMPANY_CHANNELS_ADMIN: "all_company_channels_admin",\n    CLOSED_CHANNELS_ADMIN: "closed_channels_admin",\n    TV: "tv"\n  };\n  User.LoginPolicies = [{\n    value: "RAINBOW",\n    label: "rainbowLoginCredentials"\n  }, {\n    value: "SAML",\n    label: "ssoLoginCredentialsSAML",\n    isSSO: true\n  }, {\n    value: "OIDC",\n    label: "ssoLoginCredentialsOIDC",\n    isSSO: true\n  }, {\n    value: "DEFAULT",\n    label: "defaultLogin"\n  }];\n  User.attributes = [{\n    name: "id",\n    defaultValue: null\n  }, {\n    name: "loginEmail",\n    defaultValue: ""\n  }, {\n    name: "firstName",\n    defaultValue: ""\n  }, {\n    name: "lastName",\n    defaultValue: ""\n  }, {\n    name: "displayName",\n    defaultValue: ""\n  }, {\n    name: "nickName",\n    defaultValue: ""\n  }, {\n    name: "title",\n    defaultValue: ""\n  }, {\n    name: "jobTitle",\n    defaultValue: ""\n  }, {\n    name: "companyId",\n    defaultValue: ""\n  }, {\n    name: "companyName",\n    defaultValue: ""\n  }, {\n    name: "siteId",\n    defaultValue: ""\n  }, {\n    name: "systemId",\n    defaultValue: ""\n  }, {\n    name: "accountType",\n    defaultValue: "free"\n  }, {\n    name: "country",\n    defaultValue: "FRA"\n  }, {\n    name: "timezone",\n    defaultValue: "Europe/Paris"\n  }, {\n    name: "emails",\n    defaultValue: []\n  }, {\n    name: "phoneNumbers",\n    defaultValue: []\n  }, {\n    name: "roles",\n    defaultValue: ["user"]\n  }, {\n    name: "adminType",\n    defaultValue: "company_admin"\n  }, {\n    name: "isActive",\n    defaultValue: false\n  }, {\n    name: "isInitialized",\n    defaultValue: false\n  }, {\n    name: "isTv",\n    defaultValue: undefined\n  }, {\n    name: "password",\n    defaultValue: undefined\n  }, {\n    name: "jid_im",\n    defaultValue: ""\n  }, {\n    name: "jid_tel",\n    defaultValue: ""\n  }, {\n    name: "language",\n    defaultValue: "en"\n  }, {\n    name: "lastAvatarUpdateDate",\n    defaultValue: null\n  }, {\n    name: "visibility",\n    defaultValue: undefined\n  }, {\n    name: "authenticationType",\n    defaultValue: undefined\n  }, {\n    name: "tags",\n    defaultValue: undefined\n  }, {\n    name: "userInfo1",\n    defaultValue: undefined\n  }, {\n    name: "userInfo2",\n    defaultValue: undefined\n  }]; // Constructor\n\n  function User(data, noDefaultValues) {\n    //Generic initialization of attrbutes values from received data or default values\n    var _this = this;\n\n    User.attributes.forEach(function (attribute) {\n      if (data && angular.isDefined(data[attribute.name])) {\n        // The attribute is present in the received data object : we take the value received in data object\n        _this[attribute.name] = data[attribute.name];\n      } else if (!noDefaultValues && angular.isDefined(attribute.defaultValue)) {\n        // The attribute is not present in the received data object, and this attribute has a defined default value \n        // We take the defined default value\n        _this[attribute.name] = attribute.defaultValue;\n      }\n    });\n    this.subscriptions = [];\n    /**\n     * @private\n     * @method\n     * @description updateFromData Allow to update an existing user with data from server\n     */\n\n    this.updateFromData = function (newData) {\n      User.attributes.forEach(function (attribute) {\n        if (angular.isDefined(newData[attribute.name])) {\n          // The attribute is present in the received data object : we take the value received in data object\n          _this[attribute.name] = newData[attribute.name];\n        } // If the attribute is not present in the received data object, we don\'t touch the current attribute value\n\n      });\n    };\n\n    this.fillSubscriptionMap = function () {\n      var subscriptionMap = {};\n      this.subscriptions.forEach(function (subscription) {\n        subscriptionMap[subscription.id] = subscription;\n      });\n      this.subscriptionMap = subscriptionMap;\n    };\n\n    this.fillMainSubscriptionField = function () {\n      //main subscription\n      var exclusiveSubscriptions = this.subscriptions.filter(Subscription.isExclusive).sort(Subscription.subscriptionComparator);\n\n      if (exclusiveSubscriptions.length > 0) {\n        this.mainSubscription = exclusiveSubscriptions[exclusiveSubscriptions.length - 1];\n        this.mainSubscriptionName = this.mainSubscription.offerName;\n      } //optional subscriptions\n\n\n      var optionalSubscriptions = this.subscriptions.filter(Subscription.isOptional);\n\n      if (optionalSubscriptions.length > 0) {\n        this.optionalSubscriptionNames = optionalSubscriptions.map(function (optionalSubscription) {\n          return optionalSubscription.offerName;\n        }).join(", ");\n      } //complete (main + options) subscriptions names\n\n\n      this.subscriptionNames = this.mainSubscriptionName + (this.optionalSubscriptionNames ? ", " + this.optionalSubscriptionNames : "");\n    };\n\n    this.getMainSubscription = function () {\n      if (!this.mainSubscription) {\n        this.fillMainSubscriptionField();\n      }\n\n      return this.mainSubscription;\n    };\n\n    this.getOptionalSubscriptions = function () {\n      return this.subscriptions.filter(Subscription.isOptional);\n    };\n\n    this.getMainSubscriptionName = function () {\n      if (!this.mainSubscriptionName) {\n        this.fillMainSubscriptionField();\n      }\n\n      return this.mainSubscriptionName;\n    };\n\n    this.getOptionalSubscriptionNames = function () {\n      if (!this.mainSubscriptionName) {\n        this.fillMainSubscriptionField();\n      }\n\n      return this.optionalSubscriptionNames;\n    };\n\n    this.hasUserRoleOnly = function () {\n      return this.roles.length === 1 && this.roles.indexOf(User.RoleValues.USER) !== -1;\n    };\n\n    this.isAdmin = function () {\n      return this.roles.indexOf(User.RoleValues.ADMIN) !== -1;\n    };\n\n    this.isOrganizationAdmin = function () {\n      if (this.isAdmin()) {\n        return this.adminType === "organization_admin";\n      }\n\n      return false;\n    };\n\n    this.isSiteAdmin = function () {\n      if (this.isAdmin()) {\n        return this.adminType === "site_admin";\n      }\n\n      return false;\n    };\n\n    this.isCompanyAdmin = function () {\n      if (this.isAdmin()) {\n        return this.adminType === "company_admin";\n      }\n\n      return false;\n    }; //TODO Temporary. BPAdmin must be split in "operations" and "finance" roles.\n\n\n    this.isBPAdmin = function () {\n      return this.isBPAdminOperations() || this.isBPAdminFinance();\n    };\n\n    this.isBPAdminOperations = function () {\n      return this.roles.indexOf(User.RoleValues.BP_ADMIN_OPERATIONS) !== -1;\n    };\n\n    this.isBPAdminFinance = function () {\n      return this.roles.indexOf(User.RoleValues.BP_ADMIN_FINANCE) !== -1;\n    };\n\n    this.isSuperadmin = function () {\n      return this.roles.indexOf(User.RoleValues.SUPERADMIN) !== -1;\n    };\n\n    this.isBusinessAdmin = function () {\n      return this.roles.indexOf(User.RoleValues.BUSINESS_ADMIN) !== -1;\n    };\n\n    this.isPublicChannelsAdmin = function () {\n      return this.roles.indexOf(User.RoleValues.PUBLIC_CHANNELS_ADMIN) !== -1;\n    };\n\n    this.isAllCompanyChannelsAdmin = function () {\n      return this.roles.indexOf(User.RoleValues.ALL_COMPANY_CHANNELS_ADMIN) !== -1;\n    };\n\n    this.isClosedChannelsAdmin = function () {\n      return this.roles.indexOf(User.RoleValues.CLOSED_CHANNELS_ADMIN) !== -1;\n    };\n\n    this.isDirectoryAdmin = function () {\n      return this.roles.indexOf(User.RoleValues.DIRECTORY_ADMIN) !== -1;\n    };\n    /**\n     * Indicates if the user is associated to a TV equipment or a person.\n     * \n     * @return {boolean} true if this user is associated to a TV equipment, otherwise false.\n     */\n\n\n    this.isRainbowTv = function () {\n      return this.isTv || this.roles.indexOf(User.RoleValues.TV) !== -1;\n    };\n\n    this.computeDisplayName = function () {\n      var nameInfo = userInfoService.getNameInformation(this.firstName, this.lastName);\n      this.displayName = nameInfo.displayName;\n      this.initials = nameInfo.initials;\n    };\n\n    this.getPhoneNumbers = function (type, deviceType) {\n      return this.phoneNumbers ? this.phoneNumbers.filter(function (phoneNumber) {\n        return phoneNumber.type === type && phoneNumber.deviceType === deviceType;\n      }) : [];\n    };\n\n    this.getSystemPhoneNumber = function () {\n      return this.phoneNumbers ? this.phoneNumbers.find(function (phoneNumber) {\n        return angular.isDefined(phoneNumber.systemId) && phoneNumber.isFromSystem;\n      }) : undefined;\n    };\n\n    this.getActivePhoneNumber = function (type, deviceType) {\n      var filteredPhoneNumbers = this.getPhoneNumbers(type, deviceType);\n\n      if (filteredPhoneNumbers.length > 1) {\n        //if several phonenumbers are found, keep only the phonenumber linked to a system\n        var systemPhoneNumber = filteredPhoneNumbers.find(function (phoneNumber) {\n          return angular.isDefined(phoneNumber.systemId);\n        });\n\n        if (systemPhoneNumber) {\n          return systemPhoneNumber;\n        }\n      }\n\n      return filteredPhoneNumbers[0];\n    };\n\n    this.getDdiPhoneNumber = function (type, deviceType) {\n      var filteredPhoneNumbers = this.getPhoneNumbers(type, deviceType);\n\n      if (filteredPhoneNumbers.length > 1) {\n        //first search for a cloudpbx ddi\n        var ddiPhoneNumber = filteredPhoneNumbers.find(function (phoneNumber) {\n          return phoneNumber.isCloudPbxDDI;\n        });\n\n        if (!ddiPhoneNumber) {\n          //if several phonenumbers are found (without ddi cloudpbx ddi number), keep only the phonenumber linked to a system\n          ddiPhoneNumber = filteredPhoneNumbers.find(function (phoneNumber) {\n            return phoneNumber.isFromSystem;\n          });\n        }\n\n        if (ddiPhoneNumber) {\n          return ddiPhoneNumber;\n        }\n      }\n\n      return filteredPhoneNumbers[0];\n    };\n  }\n\n  return User;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/user.js?')},function(module,exports){eval('angular.module("rainbow").factory("Subscription", ["Offer", function (Offer) {\n  "use strict";\n\n  Subscription.createFromData = function (data) {\n    var id = data.id ? data.id : data.subscriptionId;\n    return new Subscription(id, data.offerId, data.offerName, data.offerDescription, data.groupName, data.offerReference, data.profileId, data.profileName, data.maxNumberUsers, data.numberAssignedUsers, data.status, data.syncOngoing, data.updatingMaxNumberUsers, data.nbBPLicences, data.nbAssignedBPUsers, data.nbLicencesAssignedToECs, data.nbLicencesUsed, data.nbFreeLicences, data.businessModel, data.canBeSold, data.isDefault, data.isExclusive, data.isPrepaid, data.prepaidDuration, data.expirationDate, data.autoRenew, data.hasConference, data.hasVoice, data.isDemo, data.isChinaOffer);\n  }; // Constructor\n\n\n  function Subscription(id, offerId, offerName, offerDescription, groupName, offerReference, profileId, profileName, maxNumberUsers, numberAssignedUsers, status, syncOngoing, updatingMaxNumberUsers, nbBPLicences, nbAssignedBPUsers, nbLicencesAssignedToECs, nbLicencesUsed, nbFreeLicences, businessModel, canBeSold, isDefault, isExclusive, isPrepaid, prepaidDuration, expirationDate, autoRenew, hasConference, hasVoice, isDemo, isChinaOffer) {\n    this.id = id;\n    this.offerId = offerId;\n    this.offerName = offerName || "";\n    this.offerDescription = offerDescription || "Rainbow " + this.offerName;\n    this.groupName = groupName || offerName;\n    this.offerReference = offerReference;\n    this.profileId = profileId;\n    this.profileName = profileName;\n    this.maxNumberUsers = maxNumberUsers;\n    this.numberAssignedUsers = numberAssignedUsers;\n    this.status = status;\n    this.syncOngoing = syncOngoing ? syncOngoing : false;\n    this.updatingMaxNumberUsers = updatingMaxNumberUsers;\n\n    if (nbBPLicences !== undefined) {\n      this.nbBPLicences = nbBPLicences;\n    }\n\n    if (nbAssignedBPUsers !== undefined) {\n      this.nbAssignedBPUsers = nbAssignedBPUsers;\n    }\n\n    if (nbLicencesAssignedToECs !== undefined) {\n      this.nbLicencesAssignedToECs = nbLicencesAssignedToECs;\n    }\n\n    if (nbLicencesUsed !== undefined) {\n      this.nbLicencesUsed = nbLicencesUsed;\n    }\n\n    if (nbFreeLicences !== undefined) {\n      this.nbFreeLicences = nbFreeLicences;\n    }\n\n    this.businessModel = businessModel;\n    this.canBeSold = canBeSold;\n    this.isDefault = isDefault;\n    this.isExclusive = isExclusive;\n    this.isPrepaid = isPrepaid;\n    this.prepaidDuration = prepaidDuration;\n    this.expirationDate = expirationDate;\n    this.autoRenew = autoRenew;\n    this.hasConference = hasConference;\n    this.hasVoice = hasVoice;\n    this.isDemo = isDemo === undefined ? !this.isDefault && !this.canBeSold && this.offerName.toLowerCase().includes("demo") : isDemo;\n    this.isChinaOffer = isChinaOffer;\n\n    this.isEnterprise = function () {\n      return this.offerName.toLowerCase().startsWith("enterprise");\n    };\n\n    this.isBusiness = function () {\n      return this.offerName.toLowerCase().startsWith("business");\n    };\n\n    this.isEssential = function () {\n      return this.offerName.toLowerCase().startsWith("essential");\n    };\n    /**\n     * Used to know if the subscription is a trial license or not. \n     * Only a superadmin is allowed to subscribe to such offer for a company.\n     * \n     * @public\n     * @function isTrial\n     * @returns {Boolean} true if the subscription is a trial license\n     */\n\n\n    this.isTrial = function () {\n      return this.isDemo;\n    };\n\n    this.isTerminated = function () {\n      return this.status === "terminated";\n    };\n\n    this.isTerminating = function () {\n      return this.status === "terminating";\n    };\n\n    this.isUserLicense = function () {\n      return this.isDefault || this.businessModel === "nb_users" || this.businessModel === "usage";\n    };\n  } // Comparator\n\n\n  Subscription.subscriptionComparator = function (subscription1, subscription2) {\n    var offer1 = new Offer(subscription1.offerId, subscription1.offerName, subscription1.offerDescription, subscription1.groupName, subscription1.offerReference, subscription1.profileId, subscription1.canBeSold, subscription1.businessModel, subscription1.isDefault, subscription1.isExclusive, subscription1.isPrepaid, subscription1.prepaidDuration, subscription1.autoSubscribe, subscription1.hasConference, subscription1.hasVoice, subscription1.isDemo, subscription1.isBundle, subscription1.isChinaOffer);\n    var offer2 = new Offer(subscription2.offerId, subscription2.offerName, subscription2.offerDescription, subscription2.groupName, subscription2.offerReference, subscription2.profileId, subscription2.canBeSold, subscription2.businessModel, subscription2.isDefault, subscription2.isExclusive, subscription2.isPrepaid, subscription2.prepaidDuration, subscription2.autoSubscribe, subscription2.hasConference, subscription2.hasVoice, subscription2.isDemo, subscription2.isBundle, subscription2.isChinaOffer);\n    return Offer.offerComparator(offer1, offer2);\n  }; // Filters\n\n\n  Subscription.isUserLicense = function (subscription) {\n    return subscription.isDefault || subscription.businessModel === "nb_users" || subscription.businessModel === "usage";\n  };\n\n  Subscription.isTvLicense = function (subscription) {\n    return subscription.groupName === "Room";\n  };\n\n  Subscription.excludeTvLicense = function (subscription) {\n    return !Subscription.isTvLicense(subscription);\n  };\n\n  Subscription.isExclusive = function (subscription) {\n    return subscription.isDefault || subscription.isExclusive; // nb_users (like "Beta") or undefined (like "Essential")\n  };\n\n  Subscription.isOptional = function (subscription) {\n    return !Subscription.isExclusive(subscription);\n  };\n\n  Subscription.isConference = function (subscription) {\n    return Subscription.isOptional(subscription) && (subscription.hasConference || subscription.businessModel === "usage");\n  };\n\n  Subscription.isNotConference = function (subscription) {\n    return Subscription.isOptional(subscription) && !(subscription.hasConference || subscription.businessModel === "usage");\n  };\n\n  Subscription.withLicenses = function (subscription) {\n    return subscription.isDefault || subscription.businessModel === "usage" || subscription.businessModel === "nb_users" && subscription.maxNumberUsers > 0;\n  };\n\n  Subscription.isPrepaid = function (subscription) {\n    return subscription.isPrepaid;\n  };\n\n  Subscription.isMonthly = function (subscription) {\n    return !subscription.isPrepaid;\n  };\n\n  return Subscription;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/subscription.js?')},function(module,exports){eval('/**\n * @class\n * @name IceServer\n * @private\n * @description\n *      This class is used to represent a IceServer\n */\nangular.module("rainbow").factory("IceServer", [function () {\n  "use strict"; // Static factories\n\n  IceServer.createFromData = function (data) {\n    return new IceServer(data.id, data.urls, data.username, data.credential);\n  }; // Constructor\n\n\n  function IceServer(id, urls, username, credential) {\n    this.id = id;\n    this.urls = urls;\n    this.username = username;\n    this.credential = credential;\n  }\n\n  return IceServer;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/iceServer.js?')},function(module,exports){eval('angular.module("rainbow").factory("PhoneNumber", [function () {\n  "use strict";\n\n  PhoneNumber.SelectTypeEnum = {\n    EXTENSION: "extension",\n    EXTENSION_CLOUD: "extension-cloud",\n    DDI_CLOUD: "ddi-cloud",\n    FREE_DDI_CLOUD: "free-ddi-cloud"\n  };\n\n  PhoneNumber.createFromData = function (data) {\n    return new PhoneNumber(data.id ? data.id : data.phoneNumberId, data.shortNumber, data.number, data.numberE164, data.pbxUserId, data.userId, data.type, data.deviceType, data.pbxId, data.isFromSystem, data.isMonitored, data.systemId, data.country, data.voiceMailNumber, data.deviceName, data.firstName, data.lastName, data.internalNumber, data.isCloudPbxDDI, data.isCloudPbxDefault, data.password);\n  }; // Constructor\n\n\n  function PhoneNumber(id, shortNumber, number, numberE164, pbxUserId, userId, type, deviceType, pbxId, isFromSystem, isMonitored, systemId, country, voiceMailNumber, deviceName, firstName, lastName, internalNumber, isCloudPbxDDI, isCloudPbxDefault, password) {\n    this.id = id;\n    this.shortNumber = shortNumber;\n    this.number = number;\n    this.numberE164 = numberE164;\n    this.pbxUserId = pbxUserId;\n    this.userId = userId;\n    this.type = type;\n    this.deviceType = deviceType;\n    this.pbxId = pbxId;\n    this.isFromSystem = isFromSystem;\n    this.isMonitored = isMonitored;\n    this.systemId = systemId;\n    this.country = country;\n    this.voiceMailNumber = voiceMailNumber;\n    this.deviceName = deviceName;\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.internalNumber = internalNumber;\n\n    if (angular.isDefined(isCloudPbxDDI)) {\n      this.isCloudPbxDDI = isCloudPbxDDI;\n    }\n\n    if (angular.isDefined(isCloudPbxDefault)) {\n      this.isCloudPbxDefault = isCloudPbxDefault;\n    }\n\n    if (password) {\n      this.password = password;\n    }\n  }\n\n  return PhoneNumber;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/admin/phoneNumber.js?')},function(module,exports){eval('angular.module("rainbow").service("helpersService", [function () {\n  "use strict";\n\n  this.chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\n\n  this.findIndex = function (array, predicate) {\n    return array.findIndex(predicate);\n  };\n  /** This function is used to check the current browser \n   * @param {String} browser - current browser to check\n  */\n\n\n  this.checkBrowser = function (browser) {\n    return navigator.userAgent.indexOf(browser) !== -1;\n  };\n\n  this.randomString = function (length) {\n    length = length || 10;\n    var string = "";\n    var rnd;\n\n    while (length > 0) {\n      rnd = Math.floor(Math.random() * this.chars.length);\n      string += this.chars.charAt(rnd);\n      length--;\n    }\n\n    return string;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/helpers/helpersService.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\nangular.module("rainbow").service("userInfoService", ["$q", "$log", "$interval", "$rootScope", "settingsService", function ($q, $log, $interval, $rootScope, settingsService) {\n  "use strict";\n\n  var service = this;\n  service.userColors = ["#ff4500", "#d38700", "#348833", "#007356", "#00b2a9", "#00b0e5", "#0085ca", "#6639b7", "#91278a", "#cf0072", "#a50034", "#d20000"];\n\n  service.getAvatarImage = function (objId, initials, color, size, lastAvatarUpdate) {\n    return $q(function (resolve) {\n      // Handle default attribute values\n      lastAvatarUpdate = typeof lastAvatarUpdate === "undefined" ? false : lastAvatarUpdate; // Create the default avatar image\n\n      var defaultAvatarImage = initials ? service.createDefaultAvatarImage(initials, color) : null;\n\n      if (!lastAvatarUpdate) {\n        resolve(defaultAvatarImage);\n      } else {\n        // Build the image URL\n        var serverURL = config.webservices.protocol + "://" + config.webservices.currentServer;\n\n        if ($rootScope.cdn) {\n          serverURL = $rootScope.cdnServer;\n        }\n\n        var imgSrc = serverURL + "/api/avatar/" + objId + "?size=" + (size ? size : 256);\n\n        if (lastAvatarUpdate) {\n          imgSrc += "&update=" + Object(crypto_js__WEBPACK_IMPORTED_MODULE_0__["MD5"])(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Latin1.parse(lastAvatarUpdate)).toString(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Hex);\n        } // Create the image\n\n\n        var image = new Image();\n\n        image.onload = function () {\n          var loadedImage = this;\n          $interval(function () {\n            $log.log("[avatarService] Load avatar for " + objId + " success");\n            resolve(loadedImage);\n          }, 1, 1);\n        };\n\n        image.onerror = function () {\n          $interval(function () {\n            $log.warn("[avatarService] Load avatar for " + objId + " failure : use text avatar");\n            resolve(defaultAvatarImage);\n          }, 1, 1);\n        }; // Load the image\n\n\n        image.src = imgSrc;\n      }\n    });\n  };\n\n  service.getNameInformation = function (firstName, lastName) {\n    var result = {\n      displayName: "",\n      initials: ""\n    };\n\n    if (lastName.length !== 1 && firstName.length !== 2) {\n      if (settingsService.getSetting("displayOrder") === "FL") {\n        result.displayName = firstName + " " + lastName;\n        result.initials = firstName.charAt(0).toUpperCase() + lastName.charAt(0).toUpperCase();\n      } else {\n        result.displayName = lastName + " " + firstName;\n        result.initials = lastName.charAt(0).toUpperCase() + firstName.charAt(0).toUpperCase();\n      }\n    } else {\n      if (settingsService.getSetting("displayOrder") === "FL") {\n        result.displayName = firstName + " " + lastName;\n      } else {\n        result.displayName = lastName + " " + firstName;\n      }\n\n      result.initials = firstName.charAt(0).toUpperCase() + firstName.charAt(1).toUpperCase();\n    }\n\n    return result;\n  };\n\n  service.createDefaultAvatarImage = function (initials, color) {\n    var image = new Image();\n    var canvas = document.createElement("canvas");\n    canvas.width = image.width = 225;\n    canvas.height = image.height = 225;\n    var ctx = canvas.getContext("2d");\n    ctx.rect(0, 0, 225, 225);\n    ctx.fillStyle = color;\n    ctx.fill();\n    ctx.font = "bold 100px Helvetica";\n    ctx.textAlign = "center";\n    ctx.fillStyle = "white";\n    ctx.fillText(initials, 110, 150);\n    image.src = canvas.toDataURL("image/png");\n    return image;\n  };\n\n  service.computeUserColor = function (displayName) {\n    try {\n      var result = {\n        colorIndex: 0,\n        color: service.userColors[0]\n      };\n      var upperCaseDisplayName = displayName.toUpperCase();\n      var sum = 0;\n\n      for (var i = 0; i < upperCaseDisplayName.length; i++) {\n        sum += upperCaseDisplayName.charCodeAt(i);\n      }\n\n      result.colorIndex = sum % 12;\n      result.color = service.userColors[result.colorIndex];\n    } catch (error) {\n      $log.error("[UserInfoService] computeUserColor failure");\n      result.colorIndex = 1;\n      result.color = service.userColors[result.colorIndex];\n    }\n\n    return result;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/helpers/userInfoService.js?')},function(module,exports){eval('angular.module("rainbow").service("errorHelperService", ["$filter", function ($filter) {\n  "use strict";\n\n  var service = this;\n  service.ErrorCodeLabels = {\n    "-1": "unknownError",\n    "0": "errorNoServerResponse",\n    "400": "Bad request",\n    "400000": "Bad request",\n    "400210": "invalidPhoneNumber",\n    "400400": "errorWrongPassword",\n    "400500": "invalidFile",\n    "400504": "companyNameAlreadyExist",\n    "400505": "BPCompanyWithoutPaymentConfigurationData",\n    "400506": "NoActiveSubscriptionToOffer",\n    "400511": "ActiveDirectoryDomainAlreadyUsed",\n    "400552": "BPCompanyAndECCompanyMustNotBeSame",\n    "400973": "noCreateUserPermission",\n    "400975": "userAlreadyExistsInOtherCompany",\n    "400983": "userAlreadyExistsInOtherCompany",\n    "400990": "noUserFound",\n    "400993": "noUserFound",\n    "401": "Authorization failure",\n    "401102": "Authorization failure",\n    "401202": "errorInvalidToken",\n    "401500": "errorUnauthorized",\n    "401501": "errorLoginForbidden",\n    "401510": "errorUnauthorized",\n    "401520": "errorUserNotActive",\n    "401521": "errorUserNotActive",\n    "403": "Forbidden",\n    "403000": "accessDeniedNotRequiredRole",\n    "403001": "accessDeniedNotOwner",\n    "403034": "cantDeselectDefaultWebRTCGateway",\n    "403035": "cantDeleteDefaultWebRTCGateway",\n    "403060": "confLockMsg",\n    "403200": "notAllowedToChangeRole",\n    "403203": "notAllowedToChangeRole",\n    "403204": "notAllowedToMoveExistingUserToThisCompany",\n    "403205": "notAllowedToManageUser",\n    "403301": "notAllowedToManageCompany",\n    "403304": "notAllowedToAddAnotherAdmin",\n    "403311": "errorRemoveSyncOngoingSubscriptionForbidden",\n    "403315": "errorRemoveSubscriptionForbidden",\n    "403316": "errorRemoveAdminAllocatedSubscriptionForbidden",\n    "403317": "errorRemoveClientAllocatedSubscriptionForbidden",\n    "403500": "notAllowedBlacklistedEmail",\n    "403501": "notAllowedBlacklistedEmail",\n    "403503": "NotAllowedSelfRegistrationEmail",\n    "403504": "notAllowedLoggedInUserEmail",\n    "403507": "notAllowedSupportEmail",\n    "403513": "companyNotABpCompany",\n    "403516": "companyNotABpCompany",\n    "403517": "companySeenAsTerminated",\n    "403518": "companyBpTypeIncompatible",\n    "403519": "companyAlreadyLinkedToBp",\n    "403520": "companyNotVadBp",\n    "403531": "resetPasswordBlocked",\n    "403532": "resetPasswordForbidden",\n    "403608": "errorAssignSubscriptionSyncOngoing",\n    "403609": "errorAssignSubscriptionSyncOngoing",\n    "403610": "maxSubscriptionAllocationReached",\n    "403611": "notAllowedToCreateAnEquipment",\n    "403615": "maximumNumberConferenceParticipantsReach",\n    "403616": "subscriptionCompanyAdminEssentialAlreadyExists",\n    "403617": "roleCompanyAdminEssentialAlreadyExists",\n    "403620": "MaximumNumberRoomUsersReach",\n    "403621": "MaximumNumberConvUsersReach",\n    "403624": "notAllowedRemoveService",\n    "403626": "restrictedConvAccess",\n    "403630": "uploadErrorMaxQuotaReached",\n    "403655": "userAlreadyCompanyMember",\n    "403700": "errorDeleteSiteWithSystems",\n    "403701": "errorDeleteOrganisationLinkedCompany",\n    "403702": "errorDeleteCompanyWithSubscriptions",\n    "403703": "errorDeleteCompanyWithSites",\n    "403704": "errorDeleteCompanyWithUsers",\n    "403705": "errorDeleteCompanyStillTerminated",\n    "403706": "errorRemoveBusinessPartnerRole",\n    "403719": "externalTrunkChangeForbidden",\n    "403721": "numberingPlanCantBeUpdated",\n    "403722": "outgoingPrefixChangeForbidden",\n    "403723": "cannotRemoveCompanyPublicNumber",\n    "403724": "notAllowedDeleteCloudPbxWithPublicNumbers",\n    "403725": "notAllowedDeleteCloudPbxWithUsedExtensions",\n    "404": "resourceNotFound",\n    "404000": "resourceNotFound",\n    "404001": "resourceNotFoundUpdateImpossible",\n    "404002": "resourceNotFoundDeleteImpossible",\n    "404116": "archivedOrDeletedConversation",\n    "404300": "noValidOfferReferenceInACTISFile",\n    "404301": "offerNotFound",\n    "409000": "userAlreadyCreated",\n    "409011": "noMessagesToExport",\n    "409552": "internalNumberAlreadyUsed",\n    "409557": "notAllowedDeleteUserAssociatedToCloudPbx",\n    "409600": "userAlreadyExist",\n    "409601": "invitationReSentConflict",\n    "409602": "userAlreadyNetworkMember",\n    "409603": "invitationReSentConflict",\n    "409620": "offerAlreadySubscribed",\n    "409623": "conferenceOfferAlreadySubscribed",\n    "409625": "errorUpdateSyncOngoingSubscriptionForbidden",\n    "409800": "companyNotIrBp",\n    "409801": "companyNotLinkedToBp",\n    "409802": "actisCompanyAdminMismatch",\n    "409803": "actisCompanyNameMismatch",\n    "413000": "uploadErrorTooLarge",\n    "500": "errorInternalServerError",\n    "1001": "extensionNotLinkedToEquipment",\n    "1002": "extensionHasNoIdentifier",\n    "1003": "extensionDoesNotExist",\n    "1004": "extensionLookupFailure",\n    "1005": "extensionConflict",\n    "1006": "nonUniqueEquipmentForExtension",\n    "1007": "userAlreadyAssociatedToExtension",\n    "1008": "extensionAssociatedToAnotherUser",\n    "1009": "failedToAttachExtension",\n    "1010": "userHasNoExtension",\n    "1011": "userHasTooManyExtensions",\n    "1012": "failedToDetachExtension"\n  };\n  service.portalErrorCodeLabels = {\n    "massprovisioning": {\n      "400000": "invalidValue",\n      "400501": "invalidFile",\n      "400502": "invalidColumnName",\n      "400504": "invalidFile",\n      "400506": "invalidValueInActionColumn",\n      "400600": "deviceTypeCannotBeUpdated",\n      "400601": "duplicateDeviceIds",\n      "400602": "duplicateMacAdresses",\n      "400603": "invalidDeviceTypes",\n      "400604": "missingDeviceTypeInLines",\n      "400605": "invalidEquipment",\n      "403610": "errorMaxSubscriptionReached",\n      "404600": "deviceDoesNotExist",\n      "404601": "noCloudPbxInCompany",\n      "409555": "sipDeviceAlreadyExistsWithMacAddress"\n    },\n    "rvcpprovisioning": {\n      "403622": "noVoiceLicenceAllocatedToUser",\n      "409556": "companyHasAlreadyACloudPbx"\n    },\n    "authentication": {\n      "401102": "Authorization failure",\n      "401103": "Authorization failure",\n      "401500": "Authorization failure",\n      "401520": "Forbidden",\n      "401521": "Forbidden",\n      "401522": "Forbidden",\n      "401523": "Forbidden",\n      "401530": "Authorization failure",\n      "401600": "Authorization failure",\n      "401700": "Authorization failure",\n      "403000": "Authorization failure",\n      "500000": "errorInternalServerError",\n      "503000": "resourceNotFound"\n    }\n  };\n\n  service.handleErrorMessage = function (response, context) {\n    service.getErrorFullMessage(response, context);\n  };\n\n  service.handleError = function (response, params) {\n    //api portal determination\n    var portal = service.getPortal(response); // Handle error details code\n\n    var errorDetailsCode = response.status;\n\n    if (response.data && response.data.errorDetailsCode) {\n      errorDetailsCode = response.data.errorDetailsCode;\n    }\n\n    var error = new Error(service.getDetailedErrorMessage(response));\n    error.status = response.status;\n    error.fieldErrors = service.getBadRequestFieldErrors(response);\n    error.errorDetailsCode = errorDetailsCode;\n    error.errorDetailsLabel = service.getErrorCodeLabel(errorDetailsCode, portal);\n    error.translatedMessage = service.getTranslatedErrorMessage(response, params, portal);\n    error.portal = portal;\n    return error;\n  };\n\n  service.getPortal = function (response) {\n    var url = response.config ? response.config.url : undefined;\n    var res = url ? url.match(/api\\/rainbow\\/(\\w+)\\//) : undefined;\n    var portal = res ? res[1] : undefined;\n    return portal;\n  };\n\n  service.getBadRequestFieldErrors = function (response) {\n    var fieldErrors = {};\n\n    if (response.status === 400) {\n      if (response.data && response.data.errorDetails instanceof Array) {\n        response.data.errorDetails.forEach(function (details) {\n          if (!fieldErrors[details.param]) {\n            fieldErrors[details.param] = {\n              ok: false,\n              message: details.msg,\n              value: details.value\n            };\n          }\n        });\n      } else if (response.data && response.data.errorDetails && response.data.errorDetails.param) {\n        var details = response.data.errorDetails;\n        fieldErrors[details.param] = {\n          ok: false,\n          message: details.msg,\n          value: details.value\n        };\n      }\n\n      if (response.data && response.data.errorDetailsCode === 400511) {\n        fieldErrors.office365Tenant = {\n          ok: false,\n          message: service.ErrorCodeLabels["400511"]\n        };\n      }\n    }\n\n    return fieldErrors;\n  };\n\n  service.getErrorMessage = function (response) {\n    var errorMessage = service.getStatusErrorMessage(response);\n\n    if (response.data && response.data.errorMsg) {\n      errorMessage = "";\n\n      if (response.data.errorDetails) {\n        if (response.data.errorDetails instanceof Array) {\n          errorMessage += "one or more fields are invalid";\n        } else {\n          if (response.data.errorDetails.msg) {\n            errorMessage += response.data.errorDetails.msg;\n          } else {\n            errorMessage += response.data.errorDetails;\n          }\n        }\n      } else {\n        errorMessage += response.data.errorMsg;\n      }\n    }\n\n    return errorMessage;\n  };\n\n  service.getStatusErrorMessage = function (response) {\n    var errorMessage;\n\n    if (response.status === 500) {\n      errorMessage = "Internal server error";\n    } else if (response.status === 415) {\n      errorMessage = "Unsupported Media Type";\n    } else if (response.status === 413) {\n      errorMessage = "Request Entity Too Large";\n    } else if (response.status === 404) {\n      errorMessage = "Resource not found";\n    } else if (response.status === 403) {\n      errorMessage = "Access is forbidden";\n    } else if (response.status === 401) {\n      errorMessage = "Authorization failure";\n    } else if (response.status === 400) {\n      errorMessage = "Bad request";\n    } else {\n      errorMessage = response.statusText ? response.statusText : "Unknown error";\n    }\n\n    return errorMessage;\n  };\n\n  service.getDetailedErrorMessage = function (response) {\n    var errorMessage = service.getErrorMessage(response);\n\n    if (response.data && response.data.errorDetails && response.data.errorDetails instanceof Array) {\n      if (response.data.errorDetails.length > 0) {\n        errorMessage += " : " + response.data.errorDetails[0].msg;\n      }\n    }\n\n    return errorMessage;\n  };\n\n  service.getTranslatedErrorMessage = function (response, params, portal) {\n    // Filter the case of 500 response code for which the error message is not to be translated for the user\n    if (response.status === 500) {\n      return service.getLocalizedError("500");\n    }\n\n    var errorDetailsCode = null;\n\n    if (response.data && response.data.errorDetailsCode) {\n      errorDetailsCode = response.data.errorDetailsCode;\n    }\n\n    var errorDetailsData = null;\n\n    if (response.data && response.data.errorDetailsData) {\n      errorDetailsData = Object.assign(response.data.errorDetailsData, params);\n    } else {\n      errorDetailsData = params;\n    }\n\n    return service.getTranslatedErrorMessageByDetailsCode(errorDetailsCode, errorDetailsData, service.getErrorMessage(response), portal);\n  };\n\n  service.getTranslatedErrorMessageByDetailsCode = function (errorDetailsCode, errorDetailsParams, errorInfoMessage, portal) {\n    var errorMessage; // Try to get translation from error code \n\n    if (errorDetailsCode) {\n      errorMessage = service.getLocalizedError(errorDetailsCode, errorDetailsParams, portal);\n    }\n\n    if (!errorMessage) {\n      // Last chance to get the error localized\n      if (errorDetailsCode) {\n        errorMessage = $filter("translate")("anErrorOccurred", {\n          errorcode: errorDetailsCode\n        });\n      } else {\n        errorMessage = $filter("translate")("anErrorOccurred");\n      }\n\n      if (errorInfoMessage) {\n        errorMessage += " (" + $filter("translate")(errorInfoMessage) + ")";\n      }\n    }\n\n    return errorMessage;\n  };\n\n  service.getLocalizedError = function (errorCode, params, portal) {\n    var errorMessage;\n\n    if (errorCode) {\n      var errorLabel = service.getErrorCodeLabel(errorCode, portal);\n\n      if (errorLabel) {\n        var translation = $filter("translate")(errorLabel, params);\n\n        if (translation !== errorLabel) {\n          errorMessage = translation;\n        }\n      }\n    }\n\n    return errorMessage;\n  };\n\n  service.getErrorCodeLabel = function (errorCode, portal) {\n    if (portal && service.portalErrorCodeLabels[portal] && service.portalErrorCodeLabels[portal][errorCode]) {\n      return service.portalErrorCodeLabels[portal][errorCode];\n    }\n\n    return service.ErrorCodeLabels[errorCode];\n  };\n\n  service.getErrorFullMessage = function (response, context) {\n    var errorMessage = context ? context + " failure : " : "";\n\n    if (response && response.data) {\n      errorMessage += response.data.errorMsg; // Handle error details\n\n      if (response.data.errorDetails) {\n        errorMessage += " - ";\n\n        if (response.data.errorDetails instanceof Array) {\n          response.data.errorDetails.forEach(function (details) {\n            errorMessage += details.msg;\n          });\n        } else {\n          if (response.data.errorDetails.msg) {\n            // normally \'msg\' is a string, but sometimes it can be an detailed error object\n            errorMessage += JSON.stringify(response.data.errorDetails.msg);\n          } else {\n            errorMessage += response.data.errorDetails;\n          }\n        }\n      }\n    } else {\n      errorMessage += "Unknow error - Something goes really wrong";\n    }\n\n    return errorMessage;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/helpers/errorHelperService.js?')},function(module,exports){eval('angular.module("rainbow").service("pushImageHelperService", ["$log", "$q", "$http", "authService", "errorHelperService", function ($log, $q, $http, authService, errorHelperService) {\n  "use strict";\n\n  var service = this;\n  /*****************************************************************/\n\n  /** PUBLIC METHODS                                              **/\n\n  /*****************************************************************/\n\n  service.pushImage = function (pushServiceURL, avatarImg, params) {\n    return $q(function (resolve, reject) {\n      var resizePromise = null;\n\n      if (params && params.nosize) {\n        resizePromise = function resizePromise() {\n          var image = new Image();\n          image.src = avatarImg;\n          return $q.when(image);\n        };\n      } else {\n        // Extract parameters\n        var width = params && params.width ? params.width : 512;\n        var height = params && params.height ? params.height : 512;\n\n        resizePromise = function resizePromise() {\n          return service.resizeImage(avatarImg, width, height);\n        };\n      } // Resize image\n\n\n      resizePromise().then(function (resizedImage) {\n        // Extract image type and binary buffer\n        var binaryData = service.getBinaryData(resizedImage); // Send image to push image service url  \n\n        $http({\n          method: "POST",\n          url: pushServiceURL,\n          headers: authService.getPostHeader("image/" + binaryData.type),\n          data: binaryData.data,\n          transformRequest: []\n        }).then(function () {\n          $log.info("[pushImageHelperService] pushImage : success");\n          resolve();\n        }, function (response) {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[pushImageHelperService] " + errorHelperService.getErrorFullMessage(response, "pushImage"));\n        });\n      });\n    });\n  };\n  /******************************************************************/\n\n  /** PRIVATE METHODS                                              **/\n\n  /******************************************************************/\n\n\n  service.resizeImage = function (avatarImg, maxWidth, maxHeight) {\n    return $q(function (resolve) {\n      var image = new Image();\n      image.src = avatarImg;\n\n      image.onload = function () {\n        var imageWidth = image.width;\n        var imageHeight = image.height;\n\n        if (imageWidth > imageHeight) {\n          if (imageWidth > maxWidth) {\n            imageHeight *= maxWidth / imageWidth;\n            imageWidth = maxWidth;\n          }\n        } else {\n          if (imageHeight > maxHeight) {\n            imageWidth *= maxHeight / imageHeight;\n            imageHeight = maxHeight;\n          }\n        }\n\n        var canvas = document.createElement("canvas");\n        canvas.width = imageWidth;\n        canvas.height = imageHeight;\n        image.width = imageWidth;\n        image.height = imageHeight;\n        var ctx = canvas.getContext("2d");\n        ctx.drawImage(this, 0, 0, imageWidth, imageHeight);\n        var resizedImage = new Image();\n        resizedImage.src = canvas.toDataURL("image/png");\n        resolve(resizedImage);\n      };\n    });\n  };\n\n  service.getBinaryData = function (image) {\n    var typeIndex = image.src.indexOf("image/") + 6;\n    var binaryIndex = image.src.indexOf(";base64,");\n    var binaryData = image.src.slice(binaryIndex + 8);\n    var imageType = image.src.slice(typeIndex, binaryIndex);\n    var binary_string = window.atob(binaryData);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      bytes[i] = binary_string.charCodeAt(i);\n    }\n\n    return {\n      type: imageType,\n      data: bytes\n    };\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/helpers/pushImageHelperService.js?')},function(module,exports){eval('angular.module("rainbow").service("$localStorage", ["$q", function ($q) {\n  "use strict";\n\n  this.get = function (keys) {\n    var result = {};\n\n    for (var i = 0; i < keys.length; i++) {\n      result[keys[i]] = localStorage.getItem(keys[i]);\n    }\n\n    return $q.when(result);\n  };\n\n  this.set = function (object) {\n    var keys = Object.keys(object);\n\n    for (var i = 0; i < keys.length; i++) {\n      localStorage.setItem(keys[i], object[keys[i]]);\n    }\n\n    return $q.when();\n  };\n\n  this.remove = function (keys) {\n    for (var i = 0; i < keys.length; i++) {\n      localStorage.removeItem(keys[i]);\n    }\n\n    return $q.when();\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/localStorageService.js?')},function(module,exports){eval('//import { SHA256 } from "crypto-js";\nangular.module("rainbow").service("authService", ["$http", "$q", "$window", "$log", "$localStorage", "$interval", "$rootScope", "$translate", "jwtHelper", "settingsService", "AuthSettings", function ($http, $q, $window, $log, $localStorage, $interval, $rootScope, $translate, jwtHelper, settingsService, AuthSettings) {\n  "use strict";\n  /********************************************************************/\n\n  /** LYFECYCLE STUFF                                                 */\n\n  /********************************************************************/\n\n  var service = this;\n\n  try {\n    window[\'SHA256\'] = CryptoJS.SHA256;\n  } catch (e) {}\n\n  service.onInit = function () {\n    $log.info("[authService] === INITIALIZATION ==="); // Constants\n\n    service.SSO_LOGIN_POPUP_WINDOW_NAME = "Single Sign-On Login"; // Private\n\n    service.login = null;\n    service.token = null;\n    service.jidIm = null;\n    service.jidTel = null;\n    service.jidPwd = null;\n    service.initialized = null;\n    service.renewAppTokenInterval = null;\n    service.renewTokenInterval = null;\n    service.userData = null;\n    service.firstUse = localStorage.getItem("firstUse") === null;\n    service.browserFingerprint = null;\n    service.isGuest = false;\n    service.logingItself = false;\n    service.trueLoging = false;\n\n    if (!config.appModuleKey) {\n      config.appModuleKey = angular.module("rainbow").moduleIds ? angular.module("rainbow").moduleIds.join("") : "default";\n    } // SDK stuff\n\n\n    service.sdkHostForced = null;\n    service.appToken = null;\n    service.fromSDK = false; // Detect new version\n\n    service.firstUseNewVersion = false;\n    var storedVersion = localStorage.getItem("version");\n    var storedMajorVersion = service.getMajorVersion(storedVersion);\n    var currentMajorVersion = service.getMajorVersion(version);\n\n    if (storedMajorVersion !== currentMajorVersion) {\n      service.firstUseNewVersion = true;\n    }\n\n    $localStorage.set({\n      "version": version\n    });\n  };\n\n  service.getMajorVersion = function (version) {\n    if (!version) {\n      return null;\n    }\n\n    var regExp = /\\d+\\.\\d+/g;\n    var result = regExp.exec(version);\n\n    if (result && result.length > 0) {\n      return result[0];\n    }\n\n    return null;\n  };\n\n  service.registerEventsHandler = function () {\n    if (service.visibilityHandlerRemoval) {\n      service.visibilityHandlerRemoval();\n    }\n\n    service.visibilityHandlerRemoval = $rootScope.$on("ON_APP_VISIBLE_CHANGE_EVENT", function (__event, visible) {\n      if (visible) {\n        service.startTokenSurvey();\n      }\n    });\n  };\n  /********************************************************************/\n\n  /** PUBLIC TOOLBOX METHODS                                          */\n\n  /********************************************************************/\n\n\n  service.isInitialized = function () {\n    return service.initialized;\n  };\n\n  service.isFirstUse = function () {\n    return service.firstUse;\n  };\n\n  service.getRequestHeader = function () {\n    var headers = {\n      "Authorization": "Bearer " + service.token,\n      "Accept": "application/json"\n    };\n\n    if (service.fromSDK && service.appToken) {//headers["x-rainbow-app-token"] = "Bearer " + service.appToken; // TODO force token presence when token become mandatory\n      // To also add header to other REST requests (than login) uncomment this\n      //service.setInformationHeaders(headers);\n    }\n\n    return headers;\n  };\n\n  service.getRequestHeaderWithRange = function (range) {\n    var header = service.getRequestHeader();\n    header.Range = range;\n    return header;\n  };\n\n  service.getPostHeader = function (contentType) {\n    var header = service.getRequestHeader();\n    var type = contentType || "application/json";\n    header["Content-Type"] = type;\n    return header;\n  };\n\n  service.getPostHeaderWithRange = function (range, contentType) {\n    var header = service.getPostHeader(contentType);\n    header["Content-Range"] = range;\n    return header;\n  };\n  /********************************************************************/\n\n  /** LOGIN/PWD AUTHENTICATION METHOD                                 */\n\n  /********************************************************************/\n\n  /**\n   * AUTHENTICATE ON A HOST\n    * Used by SDK (public)\n    * Warning when modifying this method\n   */\n\n\n  service.authenticateOnHost = function (login, password, host, appToken, token) {\n    service.sdkHostForced = host;\n    service.appToken = appToken;\n    service.fromSDK = true;\n\n    if (token) {\n      config.xmpp.currentServer = service.sdkHostForced;\n      config.webservices.currentServer = service.sdkHostForced; // Compute REST server URL\n\n      config.restServerUrl = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port;\n      return service.authenticateWithToken(token);\n    }\n\n    return service.authenticate(login, password, false);\n  };\n\n  service.authenticate = function (login, password, rememberMe, authSettings) {\n    return $q(function (resolve, reject) {\n      $log.info(\'[authService] authenticate with "\' + login + \'"\');\n\n      if (service.validateLogin(login)) {\n        service.getLocalStorageAuthInfo(false).then(function () {\n          return service.logon(login, password, rememberMe, authSettings);\n        }).then(function () {\n          service.registerEventsHandler();\n          resolve();\n        })["catch"](function (error) {\n          $log.error("[authService] authenticate failure -- " + error.message);\n          reject(error);\n        });\n      } else {\n        var errorMessage = \'authenticate for login "\' + login + \'" failure : \';\n        var errorStatus = "errorUnauthorized";\n        var errorCode = 401500;\n        var errorData = null;\n        reject(new RBError(errorMessage, errorStatus, errorCode, errorData));\n      }\n    });\n  };\n\n  service.getUserEnvironments = function (login) {\n    if (!config.multiEnvServer) {\n      return Promise.resolve([{\n        environmentApiUrl: "https://" + config.xmpp.server\n      }]);\n    }\n\n    return new Promise(function (resolve) {\n      if (!config.defaultEnvironment) {\n        config.defaultEnvironment = config.xmpp.server;\n      }\n\n      var url = config.webservices.protocol + "://" + config.multiEnvServer + ":" + config.webservices.port + "/api/rainbow/multienvironments/v1.0/environments?loginEmail=" + encodeURIComponent(login);\n      $http({\n        method: "GET",\n        url: url,\n        timeout: 15000\n      }).then(function (response) {\n        if (response && response.data && response.data.data) {\n          resolve(response.data.data);\n        }\n      })["catch"](function (error) {\n        var errorMessage = \'getUserEnvironments for login "\' + login + \'" failure : \';\n        var errorStatus = "errorUltimateUnknownError"; // Handle complete failure (no result info)\n\n        if (!error) {\n          errorMessage += "Ultimate unknown error";\n        }\n\n        if (error.status === 0 || error.status === -1) {\n          errorMessage += "No server response";\n          errorStatus = "errorNoServerResponse";\n        } else if (error.status === 500) {\n          errorMessage += error.data.errorDetails;\n          errorStatus = "errorInternalServerError";\n        } // Log pb information\n\n\n        $log.info("[authService] " + errorMessage);\n        $log.info("[authService] getUserEnvironment -- continue with default environment"); // resolve the promise\n\n        resolve();\n      });\n    });\n  };\n  /*service.getUserEnvironment = function(login) {\n  \treturn $q(function(resolve) {\n  \t\t//check if environment is already saved in the local storage and use it\n  \t\tvar userEnvironment = settingsService.getSetting("userEnvironment");\n  \t\tif (userEnvironment) {\n  \t\t\tif (!config.defaultEnvironment) { config.defaultEnvironment = config.xmpp.server; }\n  \t\t\t$log.info("[authService] getUserEnvironment from local storage -- " + userEnvironment);\n  \t\t\tconfig.xmpp.currentServer = userEnvironment;\n  \t\t\tconfig.xmpp.server = userEnvironment;\n  \t\t\tconfig.webservices.currentServer = userEnvironment;\n  \t\t\tconfig.webservices.server = userEnvironment;\n  \t\t\tresolve();\n  \t\t\treturn;\n  \t\t}\n  \t\t\tvar headers = {};\n  \t\t\t$http({\n  \t\t\tmethod: "GET",\n  \t\t\turl: config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/multienvironments/v1.0/environments?loginEmail=" + encodeURIComponent(login),\n  \t\t\theaders: headers,\n  \t\t\ttimeout: 15000\n  \t\t}).then(\n  \t\t\tfunction success(response) {\n  \t\t\t\tif (response && response.data && response.data.data) {\n  \t\t\t\t\tvar data = response.data.data[0];\n  \t\t\t\t\tif (data) {\n  \t\t\t\t\t\tif (!config.defaultEnvironment) { config.defaultEnvironment = config.xmpp.server; }\n  \t\t\t\t\t\tvar environmentName = data.environmentApiUrl;\n  \t\t\t\t\t\tenvironmentName = environmentName.replace("https://", "");\n  \t\t\t\t\t\t$log.info("[authService] getUserEnvironment -- success -- " + environmentName);\n  \t\t\t\t\t\tconfig.xmpp.currentServer = environmentName;\n  \t\t\t\t\t\tconfig.xmpp.server = environmentName;\n  \t\t\t\t\t\tconfig.webservices.currentServer = environmentName;\n  \t\t\t\t\t\tconfig.webservices.server = environmentName;\n  \t\t\t\t\t\tsettingsService.setSetting("userEnvironment", environmentName);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tresolve();\n  \t\t\t},\n  \t\t\t\tfunction error(response) {\n  \t\t\t\tvar errorMessage = \'getUserEnvironment for login "\' + login + \'" failure : \';\n  \t\t\t\tvar errorStatus = "errorUltimateUnknownError";\n  \t\t\t\t\t// Handle complete failure (no result info)\n  \t\t\t\tif (!response) {\n  \t\t\t\t\terrorMessage += "Ultimate unknown error";\n  \t\t\t\t}\n  \t\t\t\t\tif (response.status === 0 || response.status === -1) {\n  \t\t\t\t\terrorMessage += "No server response";\n  \t\t\t\t\terrorStatus = "errorNoServerResponse";\n  \t\t\t\t}\n  \t\t\t\telse if (response.status === 500) {\n  \t\t\t\t\terrorMessage += response.data.errorDetails;\n  \t\t\t\t\terrorStatus = "errorInternalServerError";\n  \t\t\t\t}\n  \t\t\t\t\t// Log pb information\n  \t\t\t\t$log.info("[authService] " + errorMessage);\n  \t\t\t\t\t$log.info("[authService] getUserEnvironment -- continue with default environment");\n  \t\t\t\t// resolve the promise\n  \t\t\t\tresolve();\n  \t\t\t}\n  \t\t);\n  \t});\n  }*/\n\n\n  service.getUserAuthenticationSettings = function (login, inAppAuth) {\n    return $q(function (resolve, reject) {\n      var defaultLoginUrl = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/authentication/v1.0/login"; // force rainbow authentication ?\n\n      if (inAppAuth) {\n        // default authentication URL (Rainbow authentication)\n        var authSettings = AuthSettings.createFromData([{\n          type: "RAINBOW",\n          loginUrl: defaultLoginUrl\n        }]);\n        resolve(authSettings);\n      } else {\n        var headers = {};\n        service.setInformationHeaders(headers);\n        $http({\n          method: "GET",\n          url: config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/authentication/v1.0/urls?uid=" + encodeURIComponent(login),\n          headers: headers,\n          timeout: 15000\n        }).then(function success(response) {\n          var authSettings = AuthSettings.createFromData(response.data.data); // The user unique identifier: typicaly his login email\n\n          authSettings.setParameter("uid", function () {\n            return login;\n          }); // The HTTP header custom field "x-rainbow-app-auth" is used to authenticate an application\n\n          authSettings.setParameter("x-rainbow-app-auth", service.getRainbowAppAuth.bind(this, config.rainbowApiClientKey, config.appModuleKey)); // Development mode\n\n          if ($window && $window.location.href.indexOf("localhost") !== -1) {\n            // force a safety login url, if not already set, when SSO login is enabled for the identified user\n            authSettings.setParameter("safetyUrl", function () {\n              return defaultLoginUrl;\n            });\n          }\n\n          resolve(authSettings);\n        }, function error(response) {\n          var errorMessage = \'authenticate for login "\' + login + \'" failure : \';\n          var errorStatus = "errorUltimateUnknownError"; // Handle complete failure (no result info)\n\n          if (!response) {\n            errorMessage += "Ultimate unknown error";\n          }\n\n          if (response.status === 0 || response.status === -1) {\n            errorMessage += "No server response";\n            errorStatus = "errorNoServerResponse";\n          } else if (response.status === 400 || response.status === 404) {\n            errorMessage += response.data.errorDetails;\n            errorStatus = "noMatchingAccount";\n          } else if (response.status === 500) {\n            errorMessage += response.data.errorDetails;\n            errorStatus = "errorInternalServerError";\n          } // Log pb information\n\n\n          $log.info("[authService] " + errorMessage); // Reject the promise\n\n          reject(new RBError(errorMessage, errorStatus));\n        });\n      }\n    });\n  };\n  /**\n   * @public\n   * @method getBasicAuthorizationCredentials\n   * @memberof authService\n   * @description\n   * \t\tReturns the base64 encoding value of login and password joined by a colon.\n   * \t\tIn basic HTTP authentication, a request contains a header field of the form Authorization: Basic <credentials>, \n   * \t\twhere credentials is the base64 encoding of login and password joined by a colon.\n   * @param {String} login the user\'s identifier\n   * @param {String} password the user\'s password\n   * @return {String} the base64 encoding value of login and password joined by a colon\n   */\n\n\n  service.getBasicAuthorizationCredentials = function (login, password) {\n    return $window.btoa(unescape(encodeURIComponent((login || "") + ":" + (password || ""))));\n  };\n  /**\n   * @public\n   * @method getXRainbowAppAuth\n   * @memberof authService\n   * @description\n   * \t\tReturns the base64 encoding value of application identifier and passkey joined by a colon.\n   * \t\tThe HTTP header custom field "x-rainbow-app-auth" is used to authenticate an application.\n   * @param {String} appId the unique identifier of the application\n   * @param {String} appSecret the application secret key\n   * @param {String} password a password\n   * @return {String} the base64 encoding value of the application identifier and a passkey joined by a colon\n   */\n\n\n  service.getRainbowAppAuth = function (appId, appSecret, password) {\n    return $window.btoa(unescape(encodeURIComponent((appId || "") + ":" + SHA256((appSecret || "") + (password || "")))));\n  };\n\n  service.logon = function (login, password, rememberMe, authSettings) {\n    return $q(function (resolve, reject) {\n      var headers = {\n        "Authorization": "Basic " + $window.btoa(unescape(encodeURIComponent(login + ":" + password))),\n        "Accept": "application/json"\n      };\n      service.setInformationHeaders(headers);\n\n      if (config.rainbowApiClientKey) {\n        headers["x-rainbow-app-auth"] = "Basic " + $window.btoa(unescape(encodeURIComponent(config.rainbowApiClientKey + ":" + SHA256(config.appModuleKey + password))));\n      }\n\n      if (service.fromSDK) {\n        if (service.appToken && service.appToken.appID) {\n          //headers["x-rainbow-app-token"] = "Bearer " + service.appToken; // TODO force token presence when token become mandatory\n          headers["x-rainbow-app-auth"] = "Basic " + $window.btoa(unescape(encodeURIComponent(service.appToken.appID + ":" + SHA256(service.appToken.appSecret + password))));\n        }\n      } // Default Rainbow login url\n\n\n      var url = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/authentication/v1.0/login";\n\n      if (authSettings) {\n        // Rainbow login url was given by the server (otherwise use the default url)\n        switch (authSettings.type) {\n          case "RAINBOW":\n            url = authSettings.loginUrl;\n            break;\n\n          case "SAML":\n          case "OIDC":\n          default:\n            // if provided, use alternative Rainbow login url\n            if (authSettings.safetyUrl) {\n              url = authSettings.safetyUrl;\n            } //if not provided, user should not be authorized to login with its Rainbow account \n            //TODO reject, or may be it is rejected by the server ?\n            // else { reject(new RBError("Forbidden", "Forbidden")); }\n\n\n            break;\n        }\n      }\n\n      $http({\n        method: "GET",\n        withCredentials: true,\n        url: url,\n        headers: headers,\n        timeout: 15000\n      }).then(function success(response) {\n        $log.info(\'[authService] authenticate with "\' + login + \'" success\');\n        $rootScope.disconnected = false;\n        service.userData = response.data.loggedInUser;\n        service.token = response.data.token;\n        service.userId = response.data.loggedInUser.id;\n        service.login = response.data.loggedInUser.loginEmail;\n        service.jidIm = response.data.loggedInUser.jid_im;\n        service.jidTel = response.data.loggedInUser.jid_tel;\n        service.jidPwd = response.data.loggedInUser.jid_password;\n        service.initialized = response.data.loggedInUser.isInitialized;\n        service.companyId = response.data.loggedInUser.companyId; //service.firstUse = false; // Commented to use it for popupService, we need to know if it\'s the user first time after connection\n\n        service.logingItself = true;\n        service.trueLoging = true;\n        service.isGuest = response.data.loggedInUser.guestMode;\n        service.creationDate = response.data.loggedInUser.creationDate;\n        service.xmppDomain = service.jidIm.split("@")[1];\n        service.handleUserLanguage(); // When user doesn\'t refresh the application but reconnect, it correctly detect that it\'s not his first time connecting\n\n        $localStorage.get([\'firstUse\']).then(function (result) {\n          if (result.firstUse === "false" || result.firstUse === false) {\n            service.firstUse = false;\n          }\n        }); // In all case set the firstUse flag to false in localStorage\n\n        $localStorage.set({\n          "firstUse": "false"\n        }); // Update credentials local storage storing policy\n\n        service.rememberMe = rememberMe; // Store token in sessionStore or localStore\n\n        if (rememberMe) {\n          $log.info("[authService] store credentials");\n          $localStorage.set({\n            "token": service.token,\n            "login": service.login,\n            "id": service.userId\n          });\n        } else {\n          service.removeCredentials();\n        }\n\n        service.startTokenSurvey();\n        resolve();\n      }, function error(response) {\n        var errorMessage = \'authenticate for login "\' + login + \'" failure : \';\n        var errorStatus = "errorUltimateUnknownError";\n        var errorCode;\n        var errorData; // Handle complete failure (no result info)\n\n        if (!response) {\n          errorMessage += "Ultimate unknown error";\n        }\n\n        if (response.status === 0 || response.status === -1) {\n          errorMessage += "No server response";\n          errorStatus = "errorNoServerResponse";\n        } else if (response.status === 401) {\n          service.removeCredentials();\n          errorMessage += response.data.errorDetails;\n          errorCode = response.data.errorDetailsCode;\n\n          if (response.data.errorDetailsCode === 401500) {\n            errorStatus = $translate.instant("errorUnauthorized");\n          } else if (response.data.errorDetailsCode === 401501) {\n            errorStatus = "errorLoginForbidden";\n\n            if (response.data.errorDetailsData) {\n              errorData = {\n                delay: response.data.errorDetailsData.forbiddenDelay\n              };\n            }\n          }\n        } else if (response.status === 500) {\n          errorMessage += response.data.errorDetails;\n          errorStatus = "errorInternalServerError";\n        } // Log pb information\n\n\n        $log.info("[authService] " + errorMessage); // Reject the promise\n\n        reject(new RBError(errorMessage, errorStatus, errorCode, errorData));\n      });\n    });\n  };\n\n  service.logout = function () {\n    return $q(function (resolve, reject) {\n      var authType = localStorage.getItem("authType");\n      service.removeCredentials(); // was the token gotten from SSO authentication ?\n\n      if (service.authSettings && service.authSettings.logoutUrl && authType && authType !== "RAINBOW") {\n        $log.info("[authService] logout " + authType); // the token must be passed as extra parameter of the logout url\n\n        service.authSettings.setParameter("token", function () {\n          return service.token;\n        }); // redirec to SAML logout url\n\n        resolve(service.authSettings.logoutUrl);\n      } else {\n        $log.info("[authService] logout");\n        resolve();\n      }\n    });\n  };\n\n  service.setInformationHeaders = function (headers) {\n    // Used by SDK Web !!!\n    headers["x-rainbow-client"] = service.getInformationHeadersApp();\n    headers["x-rainbow-client-version"] = service.getInformationHeadersAppVersion();\n  };\n\n  service.getInformationHeadersApp = function () {\n    // Overload by centralizedService for Rainbow\n    return "web_sdk";\n  };\n\n  service.getInformationHeadersAppVersion = function () {\n    // Overload by centralizedService for Rainbow\n    return window.sdkversion ? window.sdkversion : "9.9.99";\n  };\n  /********************************************************************/\n\n  /** LOGIN WITH A GIVEN TOKEN                                        */\n\n  /********************************************************************/\n\n\n  service.authenticateWithToken = function (strToken, rememberMe) {\n    return $q(function (resolve, reject) {\n      if (strToken) {\n        var decodedToken = jwtHelper.decodeToken(strToken);\n        service.token = strToken;\n        service.login = decodedToken.user.loginEmail;\n        service.userId = decodedToken.user.id;\n\n        if (decodedToken.saml) {\n          var authType = "SAML";\n        }\n\n        if (decodedToken.oidc) {\n          var authType = "OIDC";\n        } // Store credentials in local storage ?\n\n\n        if (rememberMe || authType && authType !== "RAINBOW") {\n          $log.info("[authService] store credentials");\n          $localStorage.set({\n            "token": service.token,\n            "login": service.login,\n            "id": service.userId,\n            "authType": authType\n          });\n        } else {\n          service.removeCredentials();\n        }\n\n        service.startTokenSurvey().then(function () {\n          return service.getUserData();\n        }).then(function () {\n          return service.getUserAuthenticationSettings(service.login);\n        }).then(function (authSettings) {\n          service.authSettings = authSettings;\n        }).then(function () {\n          service.registerEventsHandler();\n          resolve();\n        })["catch"](function (error) {\n          var errorMessage = error ? error.message : "unknown error";\n          $log.error("[authService] authenticateWithToken failure -- " + errorMessage);\n          reject(new Error(errorMessage));\n        });\n      } else {\n        reject(new Error("No token provided"));\n      }\n    });\n  };\n  /********************************************************************/\n\n  /** PROVIDED CREDENTIALS AUTHENTICATION METHOD                      */\n\n  /********************************************************************/\n\n\n  service.authenticateWithProvidedCredentials = function (token) {\n    if (token) {\n      return service.getLocalStorageAuthInfo(false).then(function () {\n        return service.authenticateWithToken(token, service.rememberMe);\n      });\n    }\n\n    return service.authenticateWithLocalCredentials();\n  };\n  /********************************************************************/\n\n  /** STORED CREDENTIALS AUTHENTICATION METHOD                        */\n\n  /********************************************************************/\n\n\n  service.authenticateWithLocalCredentials = function (email) {\n    return $q(function (resolve, reject) {\n      service.getLocalStorageAuthInfo(true).then(function () {\n        if (email && service.login !== email) {\n          return $q.reject(new Error("Login account mismatch"));\n        }\n\n        return $q.resolve();\n      }).then(function () {\n        return service.startTokenSurvey();\n      }).then(function () {\n        return service.getUserData();\n      }).then(function () {\n        return service.getUserAuthenticationSettings(service.login);\n      }).then(function (authSettings) {\n        service.authSettings = authSettings;\n      }).then(function () {\n        service.registerEventsHandler();\n        resolve();\n      })["catch"](function (error) {\n        $log.error("[authService] authenticateWithLocalCredentials failure -- " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  service.getLocalStorageAuthInfo = function (getToken) {\n    return $q(function (resolve, reject) {\n      $localStorage.get(["token", "appToken", "login", "server", "support", "id", "rememberMe", "userEnvironment"]).then(function (result) {\n        $log.info("[authService] get authentication token"); // Update config object\n\n        if (result.server && result.server !== "null" && result.server !== "undefined") {\n          config.xmpp.currentServer = result.server;\n          config.webservices.currentServer = result.server;\n\n          if (result.server === "openrainbow.net") {\n            config.appModuleKey = config.dotNetAppModuleKey;\n            config.rainbowApiClientKey = config.dotNetRainbowApiClientKey;\n            config.multiEnvServer = "openrainbow.net";\n          }\n\n          if (result.server === "openrainbow.com") {\n            config.appModuleKey = config.dotComAppModuleKey;\n            config.rainbowApiClientKey = config.dotComRainbowApiClientKey;\n            config.multiEnvServer = "openrainbow.com";\n          }\n\n          if (!config.defaultEnvironment) {\n            config.defaultEnvironment = config.xmpp.currentServer;\n          }\n        } else if (service.sdkHostForced) {\n          config.xmpp.currentServer = service.sdkHostForced;\n          config.webservices.currentServer = service.sdkHostForced;\n        } else {\n          config.xmpp.currentServer = config.xmpp.server;\n          config.webservices.currentServer = config.webservices.server;\n        } //get user environment if saved\n        //check if environment is already saved in the local storage and use it\n\n\n        if (result.userEnvironment) {\n          if (!config.defaultEnvironment) {\n            config.defaultEnvironment = config.xmpp.server;\n          }\n\n          $log.info("[authService] getUserEnvironment from local storage -- " + result.userEnvironment);\n          config.xmpp.currentServer = result.userEnvironment;\n          config.xmpp.server = result.userEnvironment;\n          config.webservices.currentServer = result.userEnvironment;\n          config.webservices.server = result.userEnvironment;\n        } // Compute REST server URL\n\n\n        config.restServerUrl = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port; // Update credentials local storage storing policy\n\n        service.rememberMe = result.rememberMe;\n        service.logingItself = true; // Reject if no token\n\n        if (getToken) {\n          service.token = result.token;\n          service.appToken = result.appToken;\n          service.login = result.login;\n          service.userId = result.id;\n\n          if (!service.token || !service.login) {\n            reject(new Error("No existing token"));\n          } else {\n            resolve();\n          }\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n\n  service.startTokenSurvey = function () {\n    return $q(function (resolve, reject) {\n      service.startAppTokenSurvey().then(function () {\n        return service.startUserTokenSurvey();\n      }).then(function () {\n        $log.debug("[authService] startTokenSurvey success");\n        resolve();\n      })["catch"](function (error) {\n        if (!error || !error.message) {\n          error = new Error("Unknown error");\n        }\n\n        $log.error("[authService] startTokenSurvey failure -- " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  service.startUserTokenSurvey = function (first) {\n    var decodedToken = jwtHelper.decodeToken(service.token);\n    var tokenExpirationTimestamp = decodedToken.exp * 1000;\n    var tokenIssueAtTimestamp = decodedToken.iat * 1000;\n    var halfTokenDuration = (tokenExpirationTimestamp - tokenIssueAtTimestamp) / 2;\n    var expirationDate = new Date(tokenExpirationTimestamp);\n    var currentDate = new Date();\n    var currentTimestamp = currentDate.valueOf();\n    var tokenExpirationDuration = tokenExpirationTimestamp - currentTimestamp;\n\n    if (first) {\n      $log.info("[authService] on logon");\n    }\n\n    $log.info("[authService] Extract auth token info (countRenewed: " + decodedToken.countRenewed + ", maxTokenRenew: " + decodedToken.maxTokenRenew + ", tokenExpirationDuration: " + tokenExpirationDuration + ")");\n\n    if (tokenExpirationDuration < 0) {\n      $log.info("[authService] auth token has already expired, display login page");\n\n      if (service.renewTokenInterval) {\n        $interval.cancel(service.renewTokenInterval);\n      }\n\n      service.token = null;\n      $rootScope.$broadcast("ON_AUTH_TOKEN_EXPIRE");\n      return $q.reject(new Error("Token expired"));\n    }\n\n    if (tokenExpirationDuration < halfTokenDuration) {\n      $log.info("[authService] auth token will expire in less " + halfTokenDuration / 1000 + " seconds, re-new it immediately");\n      return service.renewAuthToken();\n    }\n\n    var usedExpirationDuration = tokenExpirationDuration - halfTokenDuration;\n    $log.info("[authService] start auth token survey (expirationDate: " + expirationDate + " tokenExpirationDuration: " + tokenExpirationDuration + "ms usedExpirationDuration: " + usedExpirationDuration + "ms)");\n\n    if (service.renewTokenInterval) {\n      $interval.cancel(service.renewTokenInterval);\n    }\n\n    service.renewTokenInterval = $interval(function () {\n      service.renewAuthToken();\n    }, usedExpirationDuration);\n    return $q.resolve();\n  };\n\n  service.renewAuthToken = function () {\n    return $q(function (resolve, reject) {\n      $log.info("[authService] re-new authentication token");\n      $http({\n        method: "GET",\n        url: config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/authentication/v1.0/renew",\n        headers: service.getRequestHeader()\n      }).then(function success(response) {\n        $log.info("[authService] renew authentication token success");\n        service.token = response.data.token;\n        $localStorage.set({\n          "token": service.token\n        });\n        $rootScope.$broadcast("ON_AUTH_TOKEN_RENEW");\n        service.startTokenSurvey();\n        resolve();\n      }, function failure(response) {\n        var errorDetails = response.data && response.data.errorDetails ? response.data.errorDetails : "no details";\n        var errorMessage = "renew authentication token failure -- " + errorDetails;\n        var error = new Error(errorMessage);\n        error.details = "AUTH_TOKEN_EXPIRED";\n        $log.error("[authService] " + errorMessage);\n        $interval.cancel(service.renewTokenInterval);\n        $rootScope.$broadcast("ON_AUTH_TOKEN_EXPIRE");\n        reject(error);\n      });\n    });\n  };\n\n  service.startAppTokenSurvey = function () {\n    if (!service.appToken || typeof service.appToken !== "string" || !service.appToken.length) {\n      // No application token ...\n      $log.info("[authService] No application token.");\n      return $q.resolve();\n    }\n\n    var decodedToken = jwtHelper.decodeToken(service.appToken);\n    var tokenExpirationTimestamp = decodedToken.exp * 1000;\n    var expirationDate = new Date(tokenExpirationTimestamp);\n    var currentDate = new Date();\n    var currentTimestamp = currentDate.valueOf();\n    var tokenExpirationDuration = tokenExpirationTimestamp - currentTimestamp;\n    $log.info("[authService] Extract application token info (countRenewed: " + decodedToken.countRenewed + ", maxTokenRenew: " + decodedToken.maxTokenRenew + ")");\n\n    if (tokenExpirationDuration < 0) {\n      $log.info("[authService] application token has already expired, re-new it immediately");\n      return service.renewAppToken();\n    }\n\n    if (tokenExpirationDuration < 30000) {\n      $log.info("[authService] application token will expire in less 5 minutes, re-new it immediately");\n      return service.renewAppToken();\n    }\n\n    var usedExpirationDuration = tokenExpirationDuration - 24000; // Refresh 4 minute before the token expiration\n\n    $log.info("[authService] start application token survey (expirationDate: " + expirationDate + " tokenExpirationDuration: " + tokenExpirationDuration + "ms usedExpirationDuration: " + usedExpirationDuration + "ms)");\n\n    if (service.renewAppTokenInterval) {\n      $interval.cancel(service.renewAppTokenInterval);\n    }\n\n    service.renewAppTokenInterval = $interval(function () {\n      service.renewAppToken();\n    }, usedExpirationDuration);\n    return $q.when();\n  };\n\n  service.renewAppToken = function () {\n    return $q(function (resolve, reject) {\n      $log.info("[authService] re-new application token");\n      $http({\n        method: "GET",\n        url: config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/applications/v1.0/authentication/renew",\n        headers: service.getRequestHeader()\n      }).then(function success(response) {\n        $log.info("[authService] renew application token success");\n        service.appToken = response.data.token;\n        $localStorage.set({\n          "appToken": service.appToken\n        });\n        $rootScope.$broadcast("ON_APP_TOKEN_RENEW");\n        service.startAppTokenSurvey();\n        resolve();\n      }, function failure(response) {\n        var errorDetails = response.data && response.data.errorDetails ? response.data.errorDetails : "no details";\n        var errorMessage = "renew application token failure -- " + errorDetails;\n        var error = new Error(errorMessage);\n        error.details = "APP_TOKEN_EXPIRED";\n        $log.error("[authService] " + errorMessage);\n        $interval.cancel(service.renewAppTokenInterval);\n        $rootScope.$broadcast("ON_APP_TOKEN_EXPIRE");\n        reject(error);\n      });\n    });\n  };\n\n  service.getUserData = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + service.userId,\n        headers: service.getRequestHeader()\n      }).then(function (response) {\n        service.userData = response.data.data;\n        service.login = response.data.data.loginEmail;\n        service.jidIm = response.data.data.jid_im;\n        service.jidTel = response.data.data.jid_tel;\n        service.jidPwd = response.data.data.jid_password;\n        service.initialized = response.data.data.isInitialized;\n        service.companyId = response.data.data.companyId;\n        service.isGuest = response.data.data.guestMode;\n        service.xmppDomain = service.jidIm.split("@")[1];\n        service.handleUserLanguage();\n        resolve(service.userData);\n      }, // Handle WS failure\n      function (error) {\n        service.removeCredentials();\n        reject(new Error("Wrong token -- " + error.message));\n      });\n    });\n  };\n  /********************************************************************/\n\n  /** SAML CONFIGURATION STUFF                   \t\t\t\t\t    */\n\n  /********************************************************************/\n\n\n  service.getCompanySAMLConfiguration = function (companyId) {\n    return $q(function (resolve, reject) {\n      $log.debug("[authService] Get assertion configuration for a company");\n      $http({\n        method: "GET",\n        url: config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/authentication/v1.0/saml/" + companyId + "/metadata.xml",\n        headers: service.getRequestHeader()\n      }).then(function success(response) {\n        $log.debug("[authService] getCompanySAMLConfiguration success");\n        resolve(response.data);\n      }, function failure(response) {\n        // Log pb information\n        $log.error("[authService] getCompanySAMLConfiguration failure -- " + JSON.stringify(response)); // Reject the promise\n\n        reject(response);\n      });\n    });\n  };\n  /********************************************************************/\n\n  /** GET BROWSER FINGERPRINT                                        **/\n\n  /********************************************************************/\n\n\n  service.getFingerPrint = function () {\n    return $q(function (resolve) {\n      if (service.browserFingerprint) {\n        resolve(service.browserFingerprint);\n      } else {\n        var browserTests = ["audio", "availableScreenResolution", "canvas", "colorDepth", "cookies", "cpuClass", "deviceDpi", "doNotTrack", "indexedDb", "installedFonts", "language", "localStorage", "pixelRatio", "platform", "plugins", "processorCores", "screenResolution", "sessionStorage", "timezoneOffset", "touchSupport", "userAgent", "webGl"];\n        imprint.test(browserTests).then(function (browserFingerprint) {\n          service.browserFingerprint = browserFingerprint;\n          resolve(browserFingerprint);\n        });\n      }\n    });\n  };\n  /********************************************************************/\n\n  /** PRIVATE COMMON METHODS                                          */\n\n  /********************************************************************/\n\n\n  service.handleUserLanguage = function () {\n    var userServerLanguage = service.userData.language;\n\n    if (userServerLanguage) {\n      settingsService.setAppliLangageCodeFromServer(userServerLanguage);\n    }\n  };\n\n  service.removeCredentials = function () {\n    $log.info("[authService] remove credentials");\n    var dataToRemove = ["token", "id", "authType", "userEnvironment"];\n\n    if (service.isGuest) {\n      dataToRemove.push("login");\n    }\n\n    $localStorage.remove(dataToRemove);\n    $localStorage.set({\n      "token": null\n    });\n    service.isGuest = false;\n    service.resetUserEnvironment();\n  };\n\n  service.resetUserEnvironment = function () {\n    //reset the user environment\n    settingsService.setSetting("userEnvironment", "");\n\n    if (config.defaultEnvironment) {\n      $log.info("[authService] resetUserEnvironment");\n      config.xmpp.currentServer = config.defaultEnvironment;\n      config.xmpp.server = config.defaultEnvironment;\n      config.webservices.currentServer = config.defaultEnvironment;\n      config.webservices.server = config.defaultEnvironment;\n    }\n  };\n\n  service.validateLogin = function (login) {\n    return login.indexOf("@") !== -1;\n  };\n\n  service.onInit();\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/authService.js?')},function(module,exports){eval('var REQUEST_TIMEOUT = 10000;\nangular.module("rainbow").service("xmppService", ["$rootScope", "$log", "$q", "$interval", "authService", "helpersService", "settingsService", "utilService", function ($rootScope, $log, $q, $interval, authService, helpersService, settingsService, utilService) {\n  "use strict";\n\n  var service = this; // Disconnection handler\n\n  service.disconnectionHandler = null;\n  /*********************************************************/\n\n  /** STROPHE CONFIGURATION                               **/\n\n  /*********************************************************/\n\n  Strophe.log = function (level, msg) {\n    switch (level) {\n      case Strophe.LogLevel.WARN:\n        $log.warn(msg);\n        break;\n\n      case Strophe.LogLevel.ERROR:\n        $log.error(msg);\n        break;\n\n      case Strophe.LogLevel.FATAL:\n        $log.error(msg);\n        break;\n\n      default:\n        $log.debug(msg);\n        break;\n    }\n  };\n  /*********************************************************/\n\n  /** LIFECYCLE STUFF                                     **/\n\n  /*********************************************************/\n\n\n  service.start = function (stats) {\n    $log.info("");\n    $log.info("[xmppService] === STARTING ===");\n    var startDate = performance.now(); // Read config\n\n    service.showBodyMessage = settingsService.getSetting("showBodyMessage") === "true"; // Service statuses\n\n    service.started = false;\n    service.connected = false;\n    service.stropheStatus = null;\n    service.presenceStatus = "offline"; // Handle pingTimeout\n\n    var pingInterval = config.xmpp.pingInterval ? config.xmpp.pingInterval : 60000;\n    this.pingTimeout = 2 * pingInterval; // Compute serverURL\n\n    service.serverURL = config.xmpp.protocol + "://" + config.xmpp.currentServer + ":" + config.xmpp.port + "/websocket"; // Init private params\n\n    service.presenceWaitingList = [];\n    service.jidsToRemove = [];\n    service.fullJid = null; // Retrieve and check credentials\n\n    if (!authService.jidIm || !authService.jidPwd) {\n      $log.info("Starting failure : No valid XMPP credentials");\n      return $q.reject(new Error("No valid XMPP credentials"));\n    } // Initial connection to XMPP service\n\n\n    return this.connect().then(function () {\n      service.started = true;\n      var startDuration = Math.round(performance.now() - startDate);\n      stats.push({\n        service: "xmppService",\n        startDuration: startDuration\n      });\n      $log.info("[xmppService] === STARTED (" + startDuration + " ms) ===");\n    })["catch"](function (error) {\n      $log.error("[xmppService] === STARTING FAILURE (" + error.message + ") === ");\n      return $q.reject(new Error("Starting failure : " + error.message));\n    });\n  };\n\n  service.stop = function () {\n    try {\n      return this.disconnect("Stop service")["finally"](function () {\n        service.connection = null;\n        service.started = false;\n        service.stropheStatus = null;\n        service.presenceWaitingList = [];\n        service.deferDisconnect = null;\n        service.fullJid = null;\n      });\n    } catch (error) {\n      $log.error("XMPP disconnect error : " + error);\n      service.connection = null;\n      service.started = false;\n      service.stropheStatus = null;\n      service.presenceWaitingList = [];\n      service.deferDisconnect = null;\n      service.fullJid = null; //unblock in case of error\n\n      return $q.when();\n    }\n  };\n  /*********************************************************/\n\n  /** CONNECTION STUFF                                    **/\n\n  /*********************************************************/\n\n\n  service.connect = function () {\n    $log.info("[xmppService] -- ASK CONNECTION --");\n\n    try {\n      if (service.stropheStatus === Strophe.Status.CONNECTING || service.stropheStatus === Strophe.Status.CONNECTED || service.stropheStatus === Strophe.Status.AUTHENTICATING) {\n        $log.info("[xmppService] already connecting"); // Resolve promise\n\n        var error = new Error("XMPP service already-connected");\n        error.details = service.stropheStatus === Strophe.Status.CONNECTING ? "XMPP_IN_CONNECTING_STATE" : "XMPP_ALREADY_CONNECTED";\n        return $q.reject(error);\n      }\n\n      var deferred = $q.defer(); // Create the strophe connection object\n      // Add app and version on query path as not possible yet with headers\n\n      service.connection = new Strophe.Connection(service.serverURL + "?x-rainbow-client=" + authService.getInformationHeadersApp() + "&x-rainbow-client-version=" + authService.getInformationHeadersAppVersion() + "&x-rainbow-xmpp-dom=" + authService.xmppDomain);\n\n      service.connection.rawInput = function (data) {\n        return service.handleRawXmppMessage(data, "Recv: ");\n      };\n\n      service.connection.rawOutput = function (data) {\n        return service.handleRawXmppMessage(data, "Sent: ");\n      }; // Update connection flags\n\n\n      service.connecting = true; // Build the resource according to the type of the application\n\n      service.generateRandomFullJid(authService.jidIm).then(function (fullJid) {\n        if (service.fullJid) {\n          fullJid = service.fullJid;\n        } // Realize the connection\n\n\n        service.connection.connect(fullJid, authService.jidPwd, function (status, reason) {\n          service.stropheStatus = status;\n          reason = angular.isUndefined(reason) ? "" : reason;\n\n          switch (status) {\n            case Strophe.Status.CONNECTING:\n              $log.info("[xmppService] -- Connecting --");\n              $rootScope.$broadcast("ON_CONNECTION_STATE_CHANGE_EVENT", "inProgress");\n              break;\n\n            case Strophe.Status.AUTHFAIL:\n              $log.error("[xmppService] -- Authentication failure -- " + reason);\n              deferred.reject(new Error("Authentication failure -- " + reason));\n              break;\n\n            case Strophe.Status.CONNFAIL:\n              if (service.connecting) {\n                $log.error("[xmppService] -- Connection failure -- " + reason);\n                deferred.reject(new Error("Connection failure -- " + reason));\n              }\n\n              break;\n\n            case Strophe.Status.CONNECTED:\n              $log.info("[xmppService] -- Connected -- " + service.connection.jid);\n              service.connecting = false;\n              service.connected = true;\n              service.jid = authService.jidIm;\n              service.fullJid = service.connection.jid; // Listen for roster modification\n\n              service.connection.addHandler(service.onRosterChanged, "jabber:iq:roster", "iq", "set"); // Attach mam listener\n\n              service.connection.addHandler(service.onMamMessageReceived, Strophe.NS.MAM, "message", null);\n              service.connection.addHandler(service.onMamMessageReceived, Strophe.NS.MAM, "iq", null); // Attach mam listener\n\n              service.connection.addHandler(service.onSearchTextMessageReceived, "urn:xmpp:mam:tmp", "message", null); //reset Jingle handlers \n\n              if (service.connection.jingle) {\n                service.connection.jingle.attachHandlers();\n              } // Attach presence handler \n\n\n              service.addPresenceHandler(); // Reset the presence waiting list\n\n              service.presenceWaitingList = []; // Start ping/pong mechanism\n\n              service.connection.ping.addPingHandler(function (ping) {\n                var date = new Date();\n                $log.info("[xmppService] -- Receive keepAlive Ping request (" + date + ")");\n\n                if (service.connected) {\n                  service.connection.ping.pong(ping);\n                }\n\n                return true;\n              }); // Enable carbon\n\n              service.enableCarbon(); // Resolve promise\n\n              deferred.resolve();\n              break;\n\n            case Strophe.Status.DISCONNECTING:\n              $log.info("[xmppService] -- Disconnecting -- " + reason);\n              break;\n\n            case Strophe.Status.DISCONNECTED:\n              $log.info("[xmppService] -- Disconnected -- " + service.fullJid); // If service is not started simply remove connection watcher\n\n              if (!service.started) {\n                $log.info("[xmppService] -- received disconnect event but service not started !!");\n                $log.info("[xmppService] -- disable ping connection watcher");\n\n                if (service.connectionWatcherPromise) {\n                  $interval.cancel(service.connectionWatcherPromise);\n                }\n\n                $rootScope.disconnected = true;\n              } // Else service is started\n              else {\n                  $rootScope.$broadcast("ON_CONNECTION_STATE_CHANGE_EVENT", "disconnected");\n\n                  if (service.jidsToRemove.indexOf(service.fullJid) === -1) {\n                    service.jidsToRemove.push(service.fullJid);\n                    service.jidsToRemove.forEach(function (jidToRemove) {\n                      $log.info("[xmppService] -- invalid jid to remove -- " + jidToRemove);\n                    });\n                  }\n\n                  if (service.deferDisconnect) {\n                    $log.info("[xmppService] -- disable ping connection watcher");\n\n                    if (service.connectionWatcherPromise) {\n                      $interval.cancel(service.connectionWatcherPromise);\n                    }\n\n                    service.connected = false; // service.fullJid = null;\n\n                    service.deferDisconnect.resolve();\n                  } else {\n                    if (service.connected && !service.connecting) {\n                      $log.error("[xmppService] -- Unexpected disconnection");\n                      service.connecting = true;\n                      service.connected = false;\n                      $rootScope.disconnected = true;\n                      service.disconnectionHandler();\n                    } else if (!service.connected && !service.connecting && service.fullJid) {\n                      $log.error("[xmppService] -- Unexpected disconnection with fullJid");\n                      service.connecting = true;\n                      service.disconnectionHandler();\n                    } else if (!service.connected && !service.connecting && !service.fullJid) {\n                      $log.error("[xmppService] -- Unexpected disconnection without fullJid");\n                      service.connecting = true;\n                      service.disconnectionHandler();\n                    } // ??? else if (service.connecting) --\x3e should reject ?\n\n                  }\n                }\n\n              break;\n\n            default:\n              $log.error("[xmppService] -- Connection to the xmpp server failure -- " + status + " -- " + reason);\n\n              if (service.connecting) {\n                deferred.reject(new Error("Connection failure -- " + reason));\n              } // else { service.disconnectionHandler(); }\n\n\n              break;\n          }\n        });\n      }); // Return the promise\n\n      return deferred.promise;\n    } catch (error) {\n      $log.error("XMPP service connect error : " + error);\n      return $q.reject("catch-connect-error");\n    }\n  };\n  /*********************************************************/\n\n  /**  LOG XMPP RAW MESSAGES                              **/\n\n  /*********************************************************/\n\n\n  service.handleRawXmppMessage = function (data, direction) {\n    // Handle the connection watcher\n    if (service.connectionWatcherPromise) {\n      $interval.cancel(service.connectionWatcherPromise);\n    }\n\n    service.connectionWatcherPromise = $interval(service.connectionWatcher, service.pingTimeout); // Log XMPP message (except photo stanza)\n\n    if (!(data.indexOf("<PHOTO>") > -1)) {\n      var log = direction;\n\n      if (data.indexOf("xmlns=\'jabber:x:bubble:conference\'") > -1 && (data.indexOf("name=\'invitation\'") > -1 || data.indexOf("name=\'conferenceAdd\'") > -1 || data.indexOf("name=\'conferenceRemove\'") > -1)) {\n        log += "Hidden content";\n      } else if (data.indexOf("xmlns=\'urn:xmpp:jingle:1\'") > -1 && (data.indexOf("displayname") > -1 || data.indexOf("number") > -1)) {\n        log += "Hidden content";\n      } else if (data.indexOf("urn:xmpp:janus:1") > -1 && (data.indexOf("displayName") > -1 || data.indexOf("displayname") > -1 || data.indexOf("number") > -1)) {\n        log += "Hidden content";\n      } else {\n        if (data.indexOf("<message") > -1 && (data.indexOf("<body") > -1 || data.indexOf("<content>") > -1)) {\n          log += service.messageBodyDiscretion(data);\n        } else {\n          var result = data;\n          var dataElem = $(data).find("data");\n\n          if (dataElem && dataElem.attr("xmlns") === "http://jabber.org/protocol/ibb") {\n            dataElem.html("Encoded file in base 64");\n            log += dataElem.html();\n          }\n\n          if (!service.showBodyMessage) {\n            //hide identity info from xmpp messages\n            if (data.indexOf("<identity") !== -1) {\n              var firstName = data.indexOf("firstName=");\n              var firstNameIndex = data.indexOf("\'", firstName);\n\n              if (firstName !== -1 && firstNameIndex !== -1) {\n                var firstNameLastIndex = data.indexOf("\'", firstNameIndex + 1);\n\n                if (firstNameIndex + 1 !== firstNameLastIndex) {\n                  result = data.substr(0, firstNameIndex + 2) + "***" + data.substr(firstNameLastIndex);\n                }\n              }\n\n              var lastName = result.indexOf("lastName=");\n              var lastNameIndex = result.indexOf("\'", lastName);\n\n              if (lastName !== -1 && lastNameIndex !== -1) {\n                var lastNameLastIndex = result.indexOf("\'", lastNameIndex + 1);\n\n                if (lastNameIndex + 1 !== lastNameLastIndex) {\n                  result = result.substr(0, lastNameIndex + 2) + "***" + result.substr(lastNameLastIndex);\n                }\n              }\n            } //hide phone number info from xmpp messages\n\n\n            if (result.indexOf("<caller_info") !== -1 || result.indexOf("<callee_info") !== -1) {\n              var number = result.indexOf("number=");\n              var numberIndex = result.indexOf("\'", number);\n\n              if (number !== -1 && numberIndex !== -1) {\n                var numberLastIndex = result.indexOf("\'", numberIndex + 1);\n\n                if (numberIndex + 1 !== numberLastIndex) {\n                  var numberText = result.substr(numberIndex + 1, numberLastIndex - numberIndex - 1);\n                  result = result.substr(0, numberIndex + 1) + utilService.anonymizePhoneNumber(numberText) + result.substr(numberLastIndex);\n                }\n              }\n            }\n\n            if (result.indexOf("<caller>") !== -1) {\n              var caller = result.indexOf("<caller>");\n              var endCaller = result.indexOf("</caller>", caller);\n              var numberText = result.substring(caller + 8, endCaller);\n\n              if (numberText.indexOf("@") === -1 && numberText.indexOf("janus") === -1) {\n                result = result.substr(0, caller + 8) + utilService.anonymizePhoneNumber(numberText) + result.substr(endCaller);\n              }\n            }\n\n            if (result.indexOf("<callee>") !== -1) {\n              var callee = result.indexOf("<callee>");\n              var endCallee = result.indexOf("</callee>", callee);\n              var numberText = result.substring(callee + 8, endCallee);\n\n              if (numberText.indexOf("@") === -1 && numberText.indexOf("janus") === -1) {\n                result = result.substr(0, callee + 8) + utilService.anonymizePhoneNumber(numberText) + result.substr(endCallee);\n              }\n            }\n\n            if (result.indexOf("<event") !== -1) {\n              var message = result.indexOf("<message>");\n              var endMessage = result.indexOf("</message>", message);\n              result = result.substr(0, message + 9) + "***" + result.substr(endMessage);\n            } //Telephony messages things\n\n\n            var endpointTel = result.indexOf("endpointTel=\'");\n\n            if (endpointTel !== -1) {\n              var endEndpointTel = result.indexOf("\'", endpointTel + 13);\n              var numberText = result.substring(endpointTel + 13, endEndpointTel);\n              result = result.substr(0, endpointTel + 13) + utilService.anonymizePhoneNumber(numberText) + result.substr(endEndpointTel);\n            }\n\n            var destination = result.indexOf("destination=\'");\n\n            if (destination !== -1) {\n              var endDestination = result.indexOf("\'", destination + 13);\n              var numberText = result.substring(destination + 13, endDestination);\n              result = result.substr(0, destination + 13) + utilService.anonymizePhoneNumber(numberText) + result.substr(endDestination);\n            }\n          }\n\n          log += result;\n        }\n      }\n\n      $log.debug(log);\n    }\n  };\n\n  service.messageBodyDiscretion = function (data) {\n    if (service.showBodyMessage) {\n      return data;\n    }\n\n    data = service.messageTagDiscretion("content", data);\n    data = service.messageTagDiscretion("body", data);\n    data = service.messageTagDiscretion("subject", data);\n    data = service.messageTagDiscretion("filename", data);\n    return data;\n  };\n\n  service.messageTagDiscretion = function (tag, data) {\n    var startTagIndex = data.indexOf("<" + tag);\n\n    if (startTagIndex !== -1) {\n      var endTagIndex = data.indexOf(">", startTagIndex);\n      var endEmptyTagIndex = data.indexOf("/>", startTagIndex);\n\n      if (endTagIndex !== -1 && endTagIndex !== endEmptyTagIndex + 1) {\n        return data.substr(0, endTagIndex + 2) + "***" + data.substr(data.indexOf("</" + tag + ">") - 1);\n      }\n    }\n\n    return data;\n  };\n  /*********************************************************/\n\n  /** CONNECTION WATCHER STUFF                            **/\n\n  /*********************************************************/\n\n\n  this.connectionWatcher = function () {\n    try {\n      $log.error("[xmppService] -- Connection watcher : so bad, no message since " + service.pingTimeout / 1000 + " seconds (no ping)");\n\n      if (service.connection) {\n        var message = service.stropheStatus === Strophe.Status.CONNECTED ? "Have lost connectivity" : "Stuck in reconnecting state";\n        $log.info("[xmppService] -- Connection watcher -- " + message);\n        service.stropheStatus = null;\n        service.connection.disconnect("No ping");\n      }\n    } catch (error) {\n      $log.error("connectionWatcher error " + error);\n    }\n  };\n  /*********************************************************/\n\n  /** DISCONNECTION STUFF                                 **/\n\n  /*********************************************************/\n\n\n  service.disconnect = function (reason) {\n    service.deferDisconnect = $q.defer();\n    $log.info("[xmppService] -- ASK DISCONNECTION --"); // handle case where xmppService is not started\n\n    if (!this.connected) {\n      $log.info("[xmppService] -- disconnect - service is not started");\n      service.deferDisconnect.resolve();\n    } else if (service.stropheStatus === Strophe.Status.CONNECTED) {\n      service.connection.disconnect(reason);\n    }\n\n    return service.deferDisconnect.promise;\n  };\n  /*********************************************************/\n\n  /** JID GENERATION STUFF                                **/\n\n  /*********************************************************/\n  // Warning this method is overided in centralized service\n\n\n  service.generateRandomFullJid = function (jid) {\n    return service.generateRandomFullJidForWeb(jid);\n  }; // Used for SDK Web as we don\'t have centralizedService\n\n\n  service.generateRandomFullJidForWeb = function (jid) {\n    return $q.when(jid + "/web_sdk_" + version + "_" + helpersService.randomString(8));\n  };\n\n  service.removeOldConnection = function () {\n    $interval(function () {\n      var disconnectJidPromises = service.jidsToRemove.map(function (jid) {\n        if (!jid || jid === "") {\n          $log.info("[xmppService] -- ignore disconnect obsolete jid for empty jid");\n          return;\n        }\n\n        if (jid === service.fullJid) {\n          $log.info("[xmppService] -- ignore disconnect obsolete jid for " + jid);\n          return;\n        }\n\n        return service.disconnectObsoleteJid(jid).then(function () {\n          $log.info("[xmppService] -- disconnect obsolete jid -- " + jid + " done");\n        });\n      });\n      service.jidsToRemove = [];\n      $q.all(disconnectJidPromises)["catch"](function (error) {\n        $log.warn("[xmppService] -- somethings goes wrong during obsolete jid removal -- " + error.message);\n      });\n    }, 10000, 1);\n  };\n\n  service.disconnectObsoleteJid = function (jid) {\n    var iq = $iq({\n      type: "set",\n      id: helpersService.randomString(8),\n      from: service.fullJid\n    }).c("disconnect", {\n      xmlns: "jabber:iq:configuration"\n    }).c("to").t(jid);\n    return service.sendIQ(iq);\n  }; // ************************************************** //\n  // **  Roster event handler                        ** //\n  // ************************************************** //\n\n\n  this.onRosterChanged = function (iq) {\n    try {\n      angular.element(iq).find("item").each(function () {\n        var jid = Strophe.getBareJidFromJid(angular.element(this).attr("jid"));\n        var favorite = angular.element(this).find("group").first().text() === "favorites";\n        var sub = angular.element(this).attr("subscription");\n        var ask = angular.element(this).attr("ask");\n        $rootScope.$apply(function () {\n          $rootScope.$broadcast("ON_ROSTER_CHANGED_EVENT", {\n            jid: jid,\n            subscription: sub ? sub : "none",\n            favorite: favorite,\n            ask: ask ? ask : "none"\n          });\n        });\n      });\n      return true;\n    } catch (error) {\n      return true;\n    }\n  }; // ***************************************************************** //\n  // **  MAM LISTENER                                               ** //\n  // ***************************************************************** // \n\n\n  this.addHistoryHandler = function (handler) {\n    this.historyHandler = handler;\n  };\n\n  this.addSearchTextHandler = function (handler) {\n    this.searchTextHandler = handler;\n  };\n\n  this.addHistoryCallLogsHandler = function (handler) {\n    this.callLogHandler = handler;\n  };\n\n  this.onMamMessageReceived = function (stanza) {\n    $log.info("[XmppService] onMamMessageReceived");\n\n    try {\n      // Get queryId and deleteId\n      var queryId = angular.element(stanza).find("result").attr("queryid");\n\n      if (!queryId) {\n        queryId = angular.element(stanza).find("fin").attr("queryid");\n      } // jidTel are used for callLog\n\n\n      if (queryId && queryId.indexOf("tel_") !== 0 && service.historyHandler) {\n        service.historyHandler(stanza);\n      } // jidIm are used for history\n      else if (service.callLogHandler) {\n          service.callLogHandler(stanza);\n        }\n\n      return true;\n    } catch (error) {\n      return true;\n    }\n  };\n\n  this.onSearchTextMessageReceived = function (stanza) {\n    $log.info("[XmppService] onSearchTextMessageReceived");\n\n    try {\n      // Get queryId and deleteId\n      var queryId = angular.element(stanza).find("result").attr("queryid");\n\n      if (!queryId) {\n        queryId = angular.element(stanza).find("fin").attr("queryid");\n      }\n\n      if (service.searchTextHandler) {\n        service.searchTextHandler(queryId, stanza);\n      }\n\n      return true;\n    } catch (error) {\n      $log.warn("[XmppService] onSearchTextMessageReceived error : " + error.message);\n      return true;\n    }\n  }; // ***************************************************************** //\n  // **  Presence stuff                                             ** //\n  // ***************************************************************** // \n\n\n  this.addPresenceHandler = function () {\n    $log.info("[xmppService] -- Add presence handler");\n    this.connection.addHandler(service.onPresence, null, "presence");\n    return $q.when();\n  };\n  /**\n   * SEND PRESENCE\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.sendPresence = function (show, message, auth) {\n    if (!this.connection && service.stropheStatus !== Strophe.Status.CONNECTED) {\n      $log.error(\'[xmppService] Try to send "presence IQ" but no xmpp connection\');\n      return;\n    }\n\n    try {\n      $log.info("Send presence " + show + " - " + message + " (" + service.jid + ")");\n      var presenceIq = $pres();\n      presenceIq.c("priority").t("5");\n      presenceIq.up();\n\n      if (show && show !== "online") {\n        presenceIq.c("show").t(show);\n      }\n\n      if (message && (!show || show === "online")) {\n        presenceIq.c("status").t(message);\n      } else if (message) {\n        presenceIq.up().c("status").t(message);\n      }\n\n      if (!this.connection || !this.connection.send) {\n        $log.error(\'Try to send "presence IQ" but no xmpp connection\');\n        return;\n      } // Add authentication information\n\n\n      if (auth === true) {\n        presenceIq.c("application", {\n          xmlns: "jabber:iq:application"\n        });\n        presenceIq.c("appid").t(config.rainbowApiClientKey).up();\n        presenceIq.c("userid").t(authService.userId);\n      }\n\n      this.connection.send(presenceIq);\n    } catch (error) {\n      $log.error("this.connection.send error : " + error);\n      return;\n    }\n  };\n\n  this.resetPresence = function (status) {\n    $log.info("Reset presence to " + service.presenceStatus + " (" + service.jid + ")");\n    service.sendPresence(status.show, status.status);\n  };\n\n  this.onPresence = function (presence) {\n    try {\n      // Extract info from stanza\n      var fromJid = angular.element(presence).attr("from");\n      var fromBareJid = Strophe.getBareJidFromJid(fromJid);\n      var namespace = angular.element(presence).find("x").attr("xmlns"); //var priority = angular.element(presence).find("priority").text();\n\n      var ptype = angular.element(presence).attr("type");\n      var show = angular.element(presence).find("show").text(); // Ignore muc presence\n\n      if (namespace && namespace.indexOf(Strophe.NS.MUC) === 0) {\n        return true;\n      }\n\n      if (angular.element(presence).find("actor").length > 0 && angular.element(presence).find("actor").attr("xmlns") === "jabber:iq:configuration") {\n        if (angular.element(presence).find("avatar").length > 0) {\n          // Send rosters updated event\t\t\t\t\n          $rootScope.$broadcast("ON_VCARD_UPDATE_EVENT", fromBareJid, "avatar");\n        } else if (angular.element(presence).find("data").length > 0) {\n          $rootScope.$broadcast("ON_VCARD_UPDATE_EVENT", fromBareJid, "data");\n        }\n\n        if (angular.element(presence).find("x").length && angular.element(presence).find("x").attr("xmlns") === "vcard-temp:x:update") {\n          return true;\n        }\n      } // Handle error message\n\n\n      if (ptype === "error") {\n        $log.error("Receive error presence message");\n      } // Handle new roster subscription\n      else if (ptype === "subscribe") {\n          $log.info("Receive subscribe from (" + fromBareJid + ")"); // Send rosters updated event\n\n          $rootScope.$broadcast("ON_ROSTER_SUBSCRIBE_EVENT", fromBareJid);\n        } // Handle contact presence\n        else {\n            var presenceElem = $(presence); // Handle status and message\n\n            var presenceStatus = "offline";\n            var presenceMessage = "";\n\n            if (ptype !== "unavailable") {\n              show = presenceElem.find("show").text();\n              presenceMessage = presenceElem.find("status").text();\n\n              if (show === "" || show === "chat") {\n                presenceStatus = "online";\n              } else if (show === "dnd") {\n                presenceStatus = "dnd";\n              } else if (show === "xa") {\n                presenceStatus = "xa";\n              } else {\n                presenceStatus = "away";\n              }\n            } // Ignore "Client Inactive" presence messages\n\n            /*var delay = presenceElem.find("delay");\n            var presenceToIgnore = false;\n            delay.each(function(index) { if (delay[index].textContent === "Client Inactive") { presenceToIgnore = true; } });\n            if (presenceToIgnore) {\n            \t$log.warn("[XMPP Service] Ignore presence with \'Client inactive\' message");\n            \treturn true;\n            }*/\n            // Handle presenceStamp parameter\n\n\n            var stamp = presenceElem.find("delay").attr("stamp");\n            var presStamp = stamp ? new Date(stamp) : new Date(); // Handle until parameter\n\n            var until = presenceElem.find("until").text();\n\n            if (until) {\n              until = new Date(until);\n            } else {\n              until = null;\n            } // Send rosters updated event\n\n\n            var eventAttr = {\n              jid: fromJid,\n              status: presenceStatus,\n              message: presenceMessage,\n              stamp: presStamp,\n              until: until\n            };\n\n            if ($rootScope.$$listeners && $rootScope.$$listeners["ON_ROSTER_PRESENCE_CHANGED_EVENT"]) {\n              $rootScope.$broadcast("ON_ROSTER_PRESENCE_CHANGED_EVENT", eventAttr);\n            } else {\n              $log.info("[XMPP Service] Receive presence message but contact service is not ready yet"); //contact service is not yet ready, stock the presence in the waiting list\n\n              service.presenceWaitingList.push(eventAttr);\n            }\n          } // Keep the presence handler alive\n\n\n      return true;\n    } catch (error) {\n      return true;\n    }\n  };\n\n  this.getPresenceWaitingList = function () {\n    return service.presenceWaitingList;\n  };\n\n  this.resetPresenceWaitingList = function () {\n    service.presenceWaitingList = [];\n  }; // ***************************************************************** //\n  // **  Message Carbon XEP-0280                                    ** // \n  // ***************************************************************** //\n\n\n  this.enableCarbon = function () {\n    var iq = $iq({\n      type: "set"\n    });\n    iq.c("enable", {\n      xmlns: "urn:xmpp:carbons:2"\n    });\n    return service.sendIQ(iq);\n  }; // ***************************************************************** //\n  // **  Generic methods                                            ** //\n  // ***************************************************************** //\n\n\n  this.send = function (stanza) {\n    if (!service.connection && service.stropheStatus !== Strophe.Status.CONNECTED) {\n      $log.error(\'[xmppService] Try to send "stanza" but no xmpp connection\');\n      return $q.reject(new Error("No XMPP connection"));\n    }\n\n    try {\n      this.connection.send(stanza);\n    } catch (error) {\n      $log.error("[xmppService] this.connection.send error : " + error);\n      return $q.when();\n    }\n\n    return $q.when();\n  };\n\n  this.sendIQ = function (iq, timeout) {\n    if (!this.connection && service.stropheStatus !== Strophe.Status.CONNECTED) {\n      $log.error(\'[xmppService] Try to send "iq" but no xmpp connection\');\n      return $q.reject(new Error("No XMPP connection"));\n    }\n\n    var defered = $q.defer();\n\n    try {\n      this.connection.sendIQ(iq, function success(data) {\n        defered.resolve(data);\n      }, function error(data) {\n        if (data === null) {\n          defered.reject(new Error("XMPP request timeout"));\n        } else {\n          defered.reject(new Error(data.innerHTML));\n        }\n      }, timeout && timeout > REQUEST_TIMEOUT ? timeout : REQUEST_TIMEOUT);\n    } catch (error) {\n      $log.error("[xmppService] this.connection.sendIQ error : " + error);\n      return $q.reject(new Error("this.connection.sendIQ error"));\n    }\n\n    return defered.promise;\n  };\n\n  this.getBareJidFromJid = function (jId) {\n    return Strophe.getBareJidFromJid(jId);\n  };\n\n  this.getResourceFromJid = function (jid) {\n    return Strophe.getResourceFromJid(jid);\n  };\n\n  this.addHandler = function (handler, ns, name, type, id, from, options) {\n    return this.connection.addHandler(handler, ns, name, type, id, from, options);\n  };\n\n  this.deleteHandler = function (handRef) {\n    if (this.connection) {\n      this.connection.deleteHandler(handRef);\n    }\n  };\n\n  this.addFileTransfertHandlers = function (ibbHandler, fileHandler) {\n    this.connection.ibb.addIBBHandler(ibbHandler);\n    this.connection.si_filetransfer.addFileHandler(fileHandler);\n  };\n\n  this.addCallLogsHandler = function (handler) {\n    //remove old handlers\n    if (this.rtcStartRef) {\n      this.connection.deleteHandler(this.rtcStartRef);\n      this.rtcStartRef = null;\n    }\n\n    if (this.rtcEndRef) {\n      this.connection.deleteHandler(this.rtcEndRef);\n      this.rtcEndRef = null;\n    }\n\n    if (this.rtcRingingRef) {\n      this.connection.deleteHandler(this.rtcRingingRef);\n      this.rtcRingingRef = null;\n    }\n\n    this.rtcStartRef = this.connection.addHandler(handler, null, "message", "webrtc-start");\n    this.rtcEndRef = this.connection.addHandler(handler, null, "message", "webrtc-end");\n    this.rtcRingingRef = this.connection.addHandler(handler, null, "message", "webrtc-ringing");\n  };\n\n  this.addTelephonyCallLogsHandler = function (handler) {\n    //remove old handlers\n    if (this.telephonyMessageRef) {\n      this.connection.deleteHandler(this.telephonyMessageRef);\n      this.telephonyMessageRef = null;\n    }\n\n    if (this.telephonyIqRef) {\n      this.connection.deleteHandler(this.telephonyIqRef);\n      this.telephonyIqRef = null;\n    }\n\n    this.telephonyMessageRef = service.connection.addHandler(handler, Strophe.NS.CALLLOG, "message", null);\n    this.telephonyIqRef = service.connection.addHandler(handler, Strophe.NS.CALLLOG, "iq", null);\n  };\n\n  this.addPubSubPublishHandler = function (handler) {\n    service.connection.addHandler(handler, "jabber:client", "message", "headline", null, "pubsub.demo-all-in-one-dev-1.opentouch.cloud"); //service.connection.addHandler(handler, \'http://jabber.org/protocol/pubsub\', \'iq\', null);\n  };\n\n  this.getIpAddress = function () {\n    return $q(function (resolve, reject) {\n      if (!RTCPeerConnection) {\n        reject();\n        return;\n      }\n\n      var pc = new RTCPeerConnection({\n        iceServers: []\n      });\n\n      var noop = function noop() {};\n\n      var result = []; // Bogus behavior with chromium 73 OSX: after network is back, ice gathering "complete" event is never sent\n\n      var timer = setTimeout(function (result) {\n        pc.onicecandidate = noop;\n\n        if (!result.length) {\n          reject();\n          return;\n        } else {\n          resolve(result);\n        }\n      }, 5000, result);\n      pc.createDataChannel(""); //create a bogus data channel\n\n      pc.createOffer(pc.setLocalDescription.bind(pc), noop); // create offer and set local description\n\n      pc.onicecandidate = function (ice) {\n        if (ice && ice.candidate && ice.candidate.candidate) {\n          var candidateInfo = /([0-9]{1,3}(\\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/.exec(ice.candidate.candidate);\n\n          if (candidateInfo && candidateInfo.length >= 2) {\n            var myIP = candidateInfo[1];\n            $log.info("[xmppService] IP found: " + myIP);\n            result.push(myIP);\n          }\n        } else {\n          //return result when no more ice candidates are found\n          pc.onicecandidate = noop;\n          clearTimeout(timer); //if no candidates found, reject\n\n          if (!result.length) {\n            reject();\n            return;\n          }\n\n          resolve(result);\n        }\n      };\n    });\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/xmppService.js?')},function(module,exports,__webpack_require__){eval('/**\n * @ngdoc service\n * @name contactService\n * @module rainbow\n * @description Rainbow contactService\n */\nangular.module("rainbow").service("contactService", ["$q", "$rootScope", "$translate", "$log", "$injector", "$http", "xmppService", "authService", "Contact", "$interval", "settingsService", "PromiseQueue", "companyService", "errorHelperService", "utilService", function ($q, $rootScope, $translate, $log, $injector, $http, xmppService, authService, Contact, $interval, settingsService, PromiseQueue, companyService, errorHelperService, utilService) {\n  "use strict";\n  /*********************************************************/\n\n  /** LIFECYCLE STUFF                                     **/\n\n  /*********************************************************/\n\n  var that = this;\n\n  that.start = function (stats) {\n    $log.info("");\n    $log.info("[contactService] === STARTING ===");\n    var startDate = performance.now();\n    return $q(function (resolve, reject) {\n      // Initialize properties\n      that.userContact = null;\n      that.contacts = [];\n      that.dbContacts = [];\n      that.jtelContacts = {};\n      that.contactPromises = [];\n      that.getOrCreateContactPromises = [];\n      that.networkSize = 0;\n      that.started = false;\n      that.changePasswordInfo = null;\n      that.subscriptionPromiseQueue = PromiseQueue.create(); // Initialize presence properties\n\n      that.presentationModeActive = false;\n      that.awayStateActive = false;\n      that.busyState = {\n        status: null,\n        message: null\n      };\n      that.forcedState = false;\n      that.manualState = false; // Handle current language\n\n      that.currentLanguage = settingsService.getSetting("lang");\n\n      if (that.langUpdateEventHandlerCleaner) {\n        that.langUpdateEventHandlerCleaner();\n      }\n\n      that.langUpdateEventHandlerCleaner = $rootScope.$on("ON_LANGUAGE_UPDATED_EVENT", function (__event, lang) {\n        that.currentLanguage = lang;\n        that.updateContactsLastActivity();\n      }); // Attach listeners\n\n      if (that.rosterUpdateEventHandlerCleaner) {\n        that.rosterUpdateEventHandlerCleaner();\n      }\n\n      that.rosterUpdateEventHandlerCleaner = $rootScope.$on("ON_ROSTER_CHANGED_EVENT", that.rosterChangedHandler);\n\n      if (that.presenceUpdateEventHandlerCleaner) {\n        that.presenceUpdateEventHandlerCleaner();\n      }\n\n      that.presenceUpdateEventHandlerCleaner = $rootScope.$on("ON_ROSTER_PRESENCE_CHANGED_EVENT", that.contactPresenceChangedHandler);\n\n      if (that.calendarPresenceEventHandlerCleaner) {\n        that.calendarPresenceEventHandlerCleaner();\n      }\n\n      that.calendarPresenceEventHandlerCleaner = $rootScope.$on("ON_CONTACT_CALENDAR_STATUS_CHANGE", that.contactCalendarPresenceChangedHandler); // Create the user contact\n\n      $log.info("[contactService] Create userContact (" + xmppService.jid + ")");\n      that.userContact = new Contact();\n      that.userContact.ask = null;\n      that.userContact.subscription = null; // Attach xmpp information (check)\n\n      that.userContact.id = xmppService.jid;\n      that.userContact.jid = xmppService.jid;\n      that.userContact.fullJid = xmppService.fullJid; // Update contact with user data auth information\n\n      that.userContact.language = that.currentLanguage;\n      that.userContact.updateFromUserData(authService.userData);\n      that.userContact.getAvatar();\n      that.userContact.updateRichStatus(); // Store this contact in contact maps\n\n      that.dbContacts[that.userContact.dbId] = that.userContact;\n      that.contacts[that.userContact.id] = that.userContact;\n      that.jtelContacts[that.userContact.jidtel] = that.userContact; // Strange???? //\n\n      if (!authService.userData.language) {\n        var serverLanguageCode = settingsService.getAppliLanguageCodeForServer();\n        that.updateUserContact({\n          language: serverLanguageCode\n        });\n      } // Get user settings\n\n\n      that.getUserSettings().then(function (settings) {\n        that.manageCalendarPresencePrompt(settings);\n        settingsService.settings.activeAlarm = settings.activeAlarm;\n        settingsService.settings.activeNotif = settings.activeNotif;\n        $log.info("[contactService] Get alarm & notif data (" + settingsService.settings.activeAlarm + " / " + settingsService.settings.activeNotif + ")");\n        settingsService.settings.protectionAgainstMailTypeOffline = settings.protectionAgainstMailTypeOffline;\n        $log.info("[contactService] Get mail setting data (" + settingsService.settings.protectionAgainstMailTypeOffline + ")");\n        return $q.resolve();\n      }).then(function () {\n        return companyService.getCompanyById(that.userContact.company.id);\n      }).then(function (userCompany) {\n        that.userContact.company = userCompany;\n        that.attachHandlers();\n        return that.getMyNetwork();\n      }).then(function () {\n        return that.updateNetworkWithRosterInfo();\n      }).then(function () {\n        // Start Listen application activity status\n        if (that.appActiveEventHandlerCleaner) {\n          that.appActiveEventHandlerCleaner();\n        }\n\n        that.appActiveEventHandlerCleaner = $rootScope.$watch("appActive", function (appActive) {\n          $log.info("[contactService] AppActive changed : " + appActive);\n\n          if (!appActive && that.userContact && that.userContact.status === "online") {\n            that.awayStateActive = true;\n          }\n\n          if (appActive && that.awayStateActive) {\n            that.awayStateActive = false;\n          }\n\n          if (angular.isDefined(appActive)) {\n            that.updatePresence(true);\n          }\n\n          return true;\n        }); // Start listening vcard change event\n\n        if (that.vcardUpdateEventHandlerCleaner) {\n          that.vcardUpdateEventHandlerCleaner();\n        }\n\n        that.vcardUpdateEventHandlerCleaner = $rootScope.$on("ON_VCARD_UPDATE_EVENT", that.onVCardChangeEvent); // Get mising presences\n\n        that.getMissedPresenceMessages(); // Now contact service is started\n\n        var startDuration = Math.round(performance.now() - startDate);\n        stats.push({\n          service: "contactService",\n          startDuration: startDuration\n        });\n        $log.info("[contactService] === STARTED (" + startDuration + " ms) ===");\n        that.started = true;\n        resolve();\n      })["catch"](function (error) {\n        $log.error("[contactService] === STARTING FAILURE === " + error.message);\n        reject(error);\n      }); // Attach event listener\n\n      if (that.connectionStateEventHandlerCleaner) {\n        that.connectionStateEventHandlerCleaner();\n      }\n\n      that.connectionStateEventHandlerCleaner = $rootScope.$on("ON_CONNECTION_STATE_CHANGE_EVENT", that.onConnectionStateChangeEvent); // Start contact updater interval\n\n      that.contactLastActivityTimerInterval = $interval(that.updateContactsLastActivity, 60000);\n    });\n  };\n\n  that.manageCalendarPresencePrompt = function (settings) {\n    // Fetch promptForCalendarPresnce settings\n    if (settings.promptForCalendarPresence !== undefined) {\n      settingsService.setSetting("disableCalendarPresence", settings.promptForCalendarPresence ? "false" : "true");\n      $log.info("[contactService] promptForCalendarPresence -- " + settings.promptForCalendarPresence);\n    } else {\n      var promptForCalendarPresence = settingsService.getSetting("disableCalendarPresence") !== "true";\n      $log.info("[contactService] MIGRATION NECESSARY -- promptForCalendarPresence : " + promptForCalendarPresence);\n      that.setUserSettings({\n        "promptForCalendarPresence": promptForCalendarPresence\n      });\n    }\n  };\n\n  that.getMyNetwork = function () {\n    return $q(function (resolve, reject) {\n      // Send request\n      var serverUrl = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/networks?limit=2000";\n      $http({\n        method: "GET",\n        url: serverUrl,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function (response) {\n        var contactsData = response.data.data;\n        $log.info("[contactService] GetMyNetwork success -- find " + contactsData.length + " contact(s)");\n        contactsData.forEach(function (contactData) {\n          var contact = new Contact();\n          contact.updateFromUserData(contactData);\n          that.contacts[contact.id] = contact;\n          that.dbContacts[contact.dbId] = contact;\n          that.jtelContacts[contact.jidtel] = contact;\n          contact.updateRichStatus();\n          contact.getAvatar();\n          that.sendUpdateEvent(contact);\n        });\n        that.networkSize = contactsData.length;\n        resolve();\n      }, function failure() {\n        var errorMessage = "GetMyNetwork failure";\n        $log.error("[contactService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  that.updateNetworkWithRosterInfo = function () {\n    return $q(function (resolve, reject) {\n      // Get contact rosters\n      xmppService.sendIQ($iq({\n        type: "get"\n      }).c("query", {\n        xmlns: "jabber:iq:roster"\n      })).then(function (stanza) {\n        $log.info("[contactService] Get rosters info successfully"); // Traverse roster array and update associated contacts\n\n        $(stanza).find("item").each(function () {\n          var rosterElem = $(this);\n          var jid = xmppService.getBareJidFromJid(rosterElem.attr("jid")); // Ignore telephony rosters\n\n          if (jid && jid.length && !that.isTelJid(jid)) {\n            var contact = that.contacts[jid];\n\n            if (contact) {\n              var ask = rosterElem.attr("ask");\n              var subscription = rosterElem.attr("subscription");\n              contact.ask = angular.isDefined(ask) ? ask : "none";\n              contact.subscription = angular.isDefined(subscription) ? subscription : "none";\n              contact.roster = true;\n              contact.updateRichStatus();\n              $log.info("[contactService] Update contact from roster (" + contact.ask + ", " + contact.subscription + ") " + jid);\n            }\n          }\n        });\n        resolve();\n      })["catch"](function (error) {\n        $log.error("[contactService] Get rosters failure : " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  that.getMissedPresenceMessages = function () {\n    $log.info("[contactService] GetMissedPresenceMessages");\n\n    try {\n      var list = xmppService.getPresenceWaitingList();\n\n      if (list.length) {\n        $log.info("[contactService] GetMissedPresenceMessages length " + list.length);\n\n        while (list.length > 0) {\n          var item = list.pop();\n          that.contactPresenceChangedHandler(null, item);\n        }\n\n        xmppService.resetPresenceWaitingList();\n      }\n    } catch (error) {\n      $log.error("[contactService] GetMissedPresenceMessages error " + error);\n    }\n  };\n\n  that.attachHandlers = function () {\n    $log.info("[contactService] AttachHandlers");\n\n    if (this.contactConfigRef) {\n      xmppService.connection.deleteHandler(this.contactConfigRef);\n      this.contactConfigRef = null;\n    }\n\n    this.contactConfigRef = xmppService.connection.addHandler(that.onUserManagementEvent, null, "message", "management");\n  };\n\n  that.stop = function () {\n    $log.info("[contactService] Stopping"); // Free arrays\n\n    that.userContact = null;\n    that.contacts = null;\n    that.dbContacts = null;\n    that.started = false;\n    that.presentationModeActive = false;\n    that.awayStateActive = false;\n    that.busyState = {\n      status: null,\n      message: null\n    };\n    that.forcedState = false;\n    that.manualState = false;\n    $log.info("[contactService] Stopped"); // Remove listeners\n\n    if (that.vcardUpdateEventHandlerCleaner) {\n      that.vcardUpdateEventHandlerCleaner();\n      that.vcardUpdateEventHandlerCleaner = null;\n    }\n\n    if (that.connectionStateEventHandlerCleaner) {\n      that.connectionStateEventHandlerCleaner();\n      that.connectionStateEventHandlerCleaner = null;\n    }\n\n    if (that.contactLastActivityTimerInterval) {\n      $interval.cancel(that.contactLastActivityTimerInterval);\n      that.contactLastActivityTimerInterval = null;\n    }\n\n    return $q.when();\n  };\n  /*********************************************************/\n\n  /** EVENT LISTENERS                                     **/\n\n  /*********************************************************/\n\n\n  that.onConnectionStateChangeEvent = function (__event, status) {\n    if (status === "disconnected" && that.userContact) {\n      // Clear all the resources for my account\n      that.userContact.resources = {};\n\n      for (var key in that.contacts) {\n        if (that.contacts.hasOwnProperty(key) && !that.contacts[key].isBot) {\n          that.contacts[key].resources = {};\n\n          if (that.contacts[key].status !== "unknown" && that.contacts[key].subscription !== "none") {\n            that.contacts[key].status = "offline";\n            that.contacts[key].imStatusStamp = {};\n          }\n        }\n      }\n\n      that.presentationModeActive = false;\n      that.awayStateActive = false;\n      that.busyState = {\n        status: null,\n        message: null\n      };\n      that.forcedState = false;\n      that.manualState = false;\n    }\n  };\n\n  that.onVCardChangeEvent = function (event, jid, type) {\n    $log.info("[contactService] onVCardChangeEvent event: " + event + " || status: " + jid + " || type: " + type);\n    $interval(function () {\n      var contact = that.getContactByJid(jid);\n\n      if (contact) {\n        if (type === "avatar" || type === "data") {\n          that.getVCardByDbId(contact.dbId, true).then(function () {\n            if (type === "avatar") {\n              return contact.getAvatar(256, true);\n            }\n\n            return $q.when();\n          }).then(function () {\n            that.sendUpdateEvent(contact);\n          });\n        } else {\n          that.sendUpdateEvent(contact);\n        }\n      }\n    }, 2000, 1);\n  };\n\n  that.onUserManagementEvent = function (stanza) {\n    try {\n      // Handle userSettings update event\n      var userSettingsElem = $(stanza).find("usersettings");\n\n      if (userSettingsElem.length && userSettingsElem.attr("action") === "update") {\n        $log.info("[contactService] onUserManagementEvent - should update the presence");\n        that.sendPresenceFromConfiguration();\n        return true;\n      } // Handle userPassword update event\n\n\n      var userPasswordElem = $(stanza).find("userpassword");\n\n      if (userPasswordElem.length && userPasswordElem.attr("action") === "update") {\n        $log.info("[contactService] onUserManagementEvent - userPassword updated");\n\n        if (!that.changePasswordInfo) {\n          that.changePasswordInfo = {\n            fromThirdParty: true\n          };\n        }\n\n        return true;\n      }\n\n      return true;\n    } catch (error) {\n      return true;\n    }\n  };\n\n  that.updateUserContactFullJid = function () {\n    // Update my fullJid with the new after a reconnection\n    that.userContact.fullJid = xmppService.fullJid;\n    that.attachHandlers();\n  };\n  /***************************************************************/\n\n  /** CONTACT STUFF                                             **/\n\n  /***************************************************************/\n\n\n  this.getMinimumContactByDBId = function (dbId) {\n    return $q(function (resolve) {\n      resolve(that.createEmptyContactContact(dbId));\n    });\n  };\n\n  that.createEmptyContactContact = function (jid) {\n    var contact = that.createBasicContact(jid);\n    contact.initials = "?";\n    contact.displayName = "Unknown contact";\n    contact.lastname = "Unknown contact";\n    contact.firstname = "";\n    contact.temp = true;\n    contact.avatar = new Image();\n    contact.avatar.src = "/resources/skins/rainbow/images/conversations/unknownContact.png";\n    return contact;\n  };\n\n  that.getContact = function (jid, phoneNumber) {\n    var contact = null;\n    var contactId = jid ? jid : phoneNumber;\n\n    if (this.isUserContactJid(contactId)) {\n      contact = that.userContact;\n    } else {\n      contact = this.contacts[contactId];\n    }\n\n    return contact;\n  };\n\n  that.getOrCreateContact = function (jid, phoneNumber) {\n    // Valid params and create contact identifier\n    if (!jid && !phoneNumber) {\n      return $q.reject(new Error("No jid or no phoneNumber"));\n    } // Try to find an existing contact, if found, resolve promise with contact\n    //NB !! Bot contacts should be found here as they do not have a valid JID\n\n\n    if (!that.contacts) {\n      that.contacts = [];\n    }\n\n    var contact = that.getContact(jid, phoneNumber);\n\n    if (contact) {\n      return $q.resolve(contact);\n    } // otherwise, test the JID\n\n\n    if (jid && jid.indexOf("@") === -1) {\n      return $q.reject(new Error("Invalid jid " + jid));\n    }\n\n    var contactId = jid ? jid : phoneNumber; // If phoneNumber only contact\n\n    if (!jid) {\n      return $q.resolve(contact = that.createBasicContact(null, phoneNumber));\n    } // Create promise if not pending\n\n\n    if (!that.getOrCreateContactPromises[contactId]) {\n      that.getOrCreateContactPromises[contactId] = $q(function (resolve, reject) {\n        // Standard contact\n        that.getVCardInfoByJid(jid).then(function (userData) {\n          // Create the contact\n          contact = that.createBasicContact(jid, phoneNumber, false);\n          contact.updateFromUserData(userData);\n          contact.updateRichStatus();\n          contact.getAvatar(); // Store contact in contact hashmaps\n\n          that.contacts[contact.id] = contact;\n          that.dbContacts[contact.dbId] = contact;\n          that.jtelContacts[contact.jidtel] = contact; // Send contact updated event\n\n          that.sendUpdateEvent(contact);\n          resolve(contact);\n          delete that.getOrCreateContactPromises[contactId];\n        })["catch"](function (error) {\n          $log.error("[contactService] getOrCreateContact -- failure -- " + error.message);\n          reject(error);\n          delete that.getOrCreateContactPromises[contactId];\n        });\n        return;\n      });\n    }\n\n    return that.getOrCreateContactPromises[contactId];\n  };\n\n  this.createBasicContact = function (jid, phoneNumber, append) {\n    $log.debug("[contactService] CreateContact " + jid + " " + utilService.anonymizePhoneNumber(phoneNumber)); // Create the contact object\n\n    var contact = new Contact(); // Handle case where we have no jid\n\n    if (!jid) {\n      contact.id = phoneNumber;\n      contact.initials = "?";\n      contact.displayName = phoneNumber ? phoneNumber : "Unknown contact";\n      contact.lastname = phoneNumber ? phoneNumber : "Unknown contact";\n      contact.firstname = "";\n      contact.phoneProCan = phoneNumber ? phoneNumber : "";\n      contact.temp = true;\n      contact.avatar = new Image();\n      contact.avatar.src = "/resources/skins/rainbow/images/conversations/unknownContact.png";\n      contact.setNameUpdatePrio(Contact.NameUpdatePrio.NO_UPDATE_PRIO); //not yet updated\n\n      return contact;\n    } // Compute the contact id\n\n\n    var contactId = jid;\n\n    if (!contactId) {\n      contactId = phoneNumber;\n      contact.phoneProCan = phoneNumber;\n    }\n\n    if (!contactId) {\n      contactId = "anonymous";\n    } // Configure contact\n\n\n    contact.jid = jid;\n    contact.id = contactId;\n    contact.ask = "none";\n    contact.subscription = "none";\n    contact.updateRichStatus(); // Append in contact list\n\n    if (append !== false) {\n      that.contacts[contact.id] = contact;\n    }\n\n    return contact;\n  };\n  /**\n   * GET CONTACT BY JID\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.getContactByJid = function (jid) {\n    var contact = null;\n\n    if (this.isUserContactJid(jid)) {\n      contact = that.userContact;\n    } else {\n      if (this.contacts) {\n        contact = this.contacts[jid];\n      } else {\n        this.contacts = [];\n      }\n    }\n\n    return contact;\n  };\n\n  this.getContactByEmail = function (email) {\n    var contact = null;\n\n    for (var prop in this.contacts) {\n      if (this.contacts.hasOwnProperty(prop)) {\n        if (this.contacts[prop].containsEmail(email)) {\n          contact = this.contacts[prop];\n        }\n      }\n    }\n\n    return contact;\n  };\n  /**\n   * GET ALL CONTACTS\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.getContacts = function () {\n    var contactArray = [];\n\n    for (var key in this.contacts) {\n      if (this.contacts.hasOwnProperty(key)) {\n        contactArray.push(this.contacts[key]);\n      }\n    }\n\n    return contactArray;\n  };\n\n  this.searchContacts = function (criteria) {\n    var contacts = this.getContacts();\n    return contacts.filter(function (contact) {\n      return (contact.roster || contact.isBot) && !contact.isTerminated && that.contactMatcher(contact, criteria);\n    });\n  };\n\n  this.contactMatcher = function (contact, criteria) {\n    var displayname = contact.firstname + " " + contact.lastname;\n    var queries = criteria.toLowerCase().trim().normalize("NFD").replace(/[\\u0300-\\u036f]/g, "").split(/[ ]+/);\n    var names = displayname.toLowerCase().trim().normalize("NFD").replace(/[\\u0300-\\u036f]/g, "").split(/[ ]+/);\n    return queries.every(function (query) {\n      return names.some(function (name, index) {\n        if (name.length && name.indexOf(query) === 0) {\n          names[index] = "";\n          return true;\n        }\n\n        return false;\n      });\n    });\n  };\n  /**\n   * GET A CONTACT BY HIS ID (without search)\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  that.getContactById = function (id) {\n    return that.dbContacts[id];\n  };\n\n  that.getContactByDBId = function (dbId, force) {\n    // Check if the contact already exists\n    var existingContact = that.dbContacts[dbId];\n\n    if (!force && existingContact) {\n      return $q.when(existingContact);\n    } // Check if a request for this contact is already lauched\n\n\n    var existingPromise = that.contactPromises[dbId];\n\n    if (existingPromise) {\n      $log.debug("[contactService] getContactByDBId for " + dbId + " already lauched");\n      return existingPromise.promise;\n    } // Create the defered object\n\n\n    var defered = $q.defer();\n    that.contactPromises[dbId] = defered;\n    var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + dbId;\n    $http({\n      method: "GET",\n      url: url,\n      headers: authService.getRequestHeader()\n    }).then(function success(response) {\n      var user = response.data.data;\n      $log.info("[contactService] GetContactByDBId (" + dbId + ") -- " + user.jid_im + " -- success");\n      var contact = existingContact ? existingContact : that.createBasicContact(user.jid_im);\n      contact.updateFromUserData(user);\n      contact.getAvatar();\n      that.dbContacts[contact.dbId] = contact;\n      that.jtelContacts[contact.jidtel] = contact;\n      defered.resolve(contact);\n      delete that.contactPromises[dbId];\n    }, function failure(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      delete that.contactPromises[dbId];\n      $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "GetContactByDBId"));\n    });\n    return defered.promise;\n  };\n\n  that.completeContactPhoneNumbers = function (contact) {\n    return $q(function (resolve, reject) {\n      if (contact.isBot) {\n        reject(new Error("No phone numbers for bot contacts"));\n        return;\n      }\n\n      if (contact.phoneNumbersInitialized) {\n        //return current contact\n        resolve(contact);\n      } else {\n        //get user contact to retrieve user\'s phone numbers\n        that.getContactByDBId(contact.dbId, true) //force user request\n        .then(function (updatedContact) {\n          //return updated contact\n          resolve(updatedContact);\n        })["catch"](function (error) {\n          // Impossible to get the contact\n          reject(error);\n        });\n      }\n    });\n  };\n\n  this.getContactsByJids = function (jids) {\n    return $q(function (resolve, reject) {\n      $log.info("[contactService] getContactsByJids with [" + jids.join() + "]");\n      var serverUrl = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port;\n      $http({\n        method: "POST",\n        headers: authService.getPostHeader(),\n        url: serverUrl + "/api/rainbow/enduser/v1.0/users/jids?limit=1000",\n        data: {\n          "jid_im": jids\n        }\n      }).then(function success(response) {\n        response.data.data.forEach(function (userData) {\n          var contact = that.getContactByJid(userData.jid_im);\n\n          if (!contact) {\n            contact = new Contact();\n          }\n\n          contact.updateFromUserData(userData);\n          that.contacts[contact.id] = contact;\n          that.dbContacts[contact.dbId] = contact;\n          that.jtelContacts[contact.jidtel] = contact;\n          contact.getAvatar();\n          contact.temp = false;\n        });\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "getContactsByJids"));\n      });\n    });\n  };\n\n  this.getContactsByEmails = function (emails) {\n    return $q(function (resolve, reject) {\n      $log.info("[contactService] getContactsByEmails with [" + emails.join() + "]"); // Prepare request\n\n      var serverUrl = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/loginemails";\n      var lowerCaseEmails = emails.map(function (email) {\n        return email.toLowerCase();\n      });\n      $http({\n        method: "POST",\n        headers: authService.getPostHeader(),\n        url: serverUrl,\n        data: {\n          "loginEmail": lowerCaseEmails\n        }\n      }).then(function success(response) {\n        var contacts = {};\n        var contactsArray = [];\n        response.data.data.forEach(function (userData) {\n          var contact = that.dbContacts[userData.id];\n\n          if (!contact) {\n            contact = new Contact();\n            that.contacts[contact.id] = contact;\n            that.dbContacts[contact.dbId] = contact;\n            that.jtelContacts[contact.jidtel] = contact;\n          }\n\n          contact.updateFromUserData(userData);\n          contact.getAvatar();\n          contacts[contact.loginEmail] = contact;\n          contactsArray.push(contact);\n          lowerCaseEmails.splice(lowerCaseEmails.indexOf(contact.loginEmail.toLowerCase()), 1);\n        });\n        resolve({\n          contacts: contacts,\n          contactsArray: contactsArray,\n          emails: lowerCaseEmails\n        });\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "getContactsByEmails"));\n      });\n    });\n  };\n  /***************************************************************/\n\n  /** USER SETTINGS STUFF                                       **/\n\n  /***************************************************************/\n\n\n  that.getUserSettings = function () {\n    return $q(function (resolve) {\n      // Get and store portalURL\n      var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + that.userContact.dbId + "/settings";\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        $log.info("[contactService] GetUserSettings success");\n        var presence = response.data.data.presence || "online";\n        var activeAlarm = response.data.data.activeAlarm || "relax1";\n        var activeNotif = response.data.data.activeNotif || "notif1";\n        var promptForCalendarPresence = response.data.data.promptForCalendarPresence;\n        var protectionAgainstMailTypeOffline = response.data.data.protectionAgainstMailTypeOffline;\n        var setting = {\n          presence: presence,\n          activeAlarm: activeAlarm,\n          activeNotif: activeNotif,\n          promptForCalendarPresence: promptForCalendarPresence,\n          protectionAgainstMailTypeOffline: protectionAgainstMailTypeOffline\n        };\n        resolve(setting);\n      }, function failure(response) {\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "GetUserSettings"));\n        resolve({\n          presence: "online",\n          activeAlarm: "relax1",\n          activeNotif: "notif1",\n          promptForCalendarPresence: false\n        });\n      });\n    });\n  };\n\n  that.setUserSettings = function (params) {\n    return $q(function (resolve, reject) {\n      var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + that.userContact.dbId + "/settings";\n      $http({\n        method: "PUT",\n        url: url,\n        headers: authService.getRequestHeader(),\n        data: params\n      }).then(function success() {\n        $log.info("[contactService] SetUserSettings " + JSON.stringify(params) + " -- success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "SetUserSettings"));\n        reject(error);\n      });\n    });\n  };\n  /***************************************************************/\n\n  /**  VCARD STUFF                                              **/\n\n  /***************************************************************/\n\n\n  that.getVCardByDbId = function (dbId, shouldSkipAvatar) {\n    return $q(function (resolve, reject) {\n      var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + dbId;\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var user = response.data.data;\n        var contact = that.contacts[user.jid_im];\n        contact.updateFromUserData(user);\n        contact.updateRichStatus(that.isUserContactJid(user.jid_im));\n\n        if (!shouldSkipAvatar) {\n          contact.getAvatar();\n        } // Send contact updated event\n\n\n        that.sendUpdateEvent(contact);\n        resolve(contact);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "getVCardByDbId"));\n      });\n    });\n  };\n\n  that.getVCardInfoByJid = function (jid) {\n    return $q(function (resolve, reject) {\n      var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/jids/" + jid;\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        resolve(response.data.data);\n      })["catch"](function failure(response) {\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "getVCardInfoByJid"));\n        reject(errorHelperService.handleError(response));\n      });\n    });\n  };\n\n  that.getVCardInfoByEmail = function (email) {\n    return $q(function (resolve, reject) {\n      var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/loginemails?format=full";\n      $http({\n        method: "POST",\n        url: url,\n        headers: authService.getRequestHeader(),\n        data: {\n          loginEmail: [email]\n        }\n      }).then(function success(response) {\n        resolve(response.data.data);\n      })["catch"](function failure(response) {\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "getVCardsByEmail"));\n        reject();\n      });\n    });\n  };\n  /***************************************************************/\n\n  /**  AVATAR STUFF                                             **/\n\n  /***************************************************************/\n\n\n  this.pushAvatarImage = function (avatarImg) {\n    var defered = $q.defer();\n    var serverURL = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port;\n    $log.info("[contactService] Push avatar image ");\n    var oldImage = that.userContact.avatar; // Resize image if necessary\n\n    that.resizeImage(avatarImg, 512, 512).then(function (resizedImage) {\n      // Store user contact\n      that.userContact.avatar = resizedImage; // Extarct image type and binary buffer\n\n      var binaryData = that.getBinaryData(resizedImage); // Send image to server\n\n      $http({\n        method: "POST",\n        url: serverURL + "/api/rainbow/enduser/v1.0/users/" + that.userContact.dbId + "/avatar",\n        headers: authService.getPostHeader("image/" + binaryData.type),\n        data: binaryData.data,\n        transformRequest: []\n      }).then(function success() {\n        defered.resolve();\n      }, function failure(response) {\n        that.userContact.avatar = oldImage;\n        var error = errorHelperService.handleError(response);\n        defered.reject(error);\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "pushAvatarImage"));\n      });\n    });\n    return defered.promise;\n  };\n\n  this.resizeImage = function (avatarImg, maxWidth, maxHeight) {\n    var defered = $q.defer();\n    var image = new Image();\n    image.src = avatarImg;\n\n    image.onload = function () {\n      var imageWidth = image.width;\n      var imageHeight = image.height;\n\n      if (imageWidth > imageHeight) {\n        if (imageWidth > maxWidth) {\n          imageHeight *= maxWidth / imageWidth;\n          imageWidth = maxWidth;\n        }\n      } else {\n        if (imageHeight > maxHeight) {\n          imageWidth *= maxHeight / imageHeight;\n          imageHeight = maxHeight;\n        }\n      }\n\n      var canvas = document.createElement("canvas");\n      canvas.width = imageWidth;\n      canvas.height = imageHeight;\n      image.width = imageWidth;\n      image.height = imageHeight;\n      image.crossOrigin = "Anonymous";\n      var ctx = canvas.getContext("2d");\n      ctx.drawImage(this, 0, 0, imageWidth, imageHeight);\n      var resizedImage = new Image();\n      resizedImage.src = canvas.toDataURL("image/png");\n      defered.resolve(resizedImage);\n    };\n\n    return defered.promise;\n  };\n\n  this.getBinaryData = function (image) {\n    var typeIndex = image.src.indexOf("image/") + 6;\n    var binaryIndex = image.src.indexOf(";base64,");\n    var binaryData = image.src.slice(binaryIndex + 8);\n    var imageType = image.src.slice(typeIndex, binaryIndex);\n    var binary_string = window.atob(binaryData);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      bytes[i] = binary_string.charCodeAt(i);\n    }\n\n    return {\n      type: imageType,\n      data: bytes\n    };\n  };\n  /****************************************************/\n\n  /**            XMPP ROSTER MANAGEMENT              **/\n\n  /****************************************************/\n\n\n  this.sendSubscription = function (contact) {\n    // Return immediately if already subscribed\n    if (contact.subscribe === "to" || contact.subscribe === "both") {\n      return $q.when(contact);\n    } // Send subscriptions for im and telephony presences\n\n\n    that.sendSubscribeInvitation(contact.jid);\n    that.sendSubscribeInvitation(contact.jidtel);\n    return $q.when(contact);\n  };\n\n  that.sendSubscribeInvitation = function (jid) {\n    $log.info("[contactService] Send subscribe invitation to " + jid);\n    return xmppService.send($pres({\n      to: jid,\n      "type": "subscribe"\n    }));\n  };\n\n  that.rosterChangedHandler = function (__event, attr) {\n    var subscriptionPromise = function subscriptionPromise() {\n      return that.rosterChangedHandlerPromise(attr);\n    };\n\n    that.subscriptionPromiseQueue.add(subscriptionPromise);\n  };\n\n  that.rosterChangedHandlerPromise = function (attr) {\n    // Ignore telephony events for the moment\n    if (that.isTelJid(attr.jid)) {\n      $log.debug("[contactService] Contact changed (" + attr.jid + ") ignored");\n      return $q.when();\n    }\n\n    return $q(function (resolve) {\n      // Fetch the subscription status\n      var subscription = attr.subscription;\n      var ask = attr.ask;\n      var jid_im = attr.jid; // Get or create the associated contact\n\n      that.getOrCreateContact(jid_im).then(function (contact) {\n        if (subscription === "remove") {\n          contact.ask = "none";\n          contact.subscription = "none";\n          contact.roster = false;\n        } else {\n          contact.ask = ask;\n          contact.subscription = subscription;\n          contact.roster = true;\n\n          if (subscription === "both") {\n            // FIXME MCO : remove this code when server send presence\n            that.updatePresence(true);\n          }\n        }\n\n        contact.updateRichStatus(); // Send contact updated event\n\n        that.sendUpdateEvent(contact);\n        $rootScope.$broadcast("ON_CONTACT_ROSTER_UPDATE_EVENT");\n        $log.info("[contactService] rosterChangedHandler - contact " + attr.jid + " changed (" + ask + ", " + subscription + ") success");\n        resolve();\n      })["catch"](function (error) {\n        $log.error("[contactService] rosterChangedHandler - contact " + attr.jid + " failure - " + error.message);\n        resolve();\n      });\n    });\n  }; // ************************************************** //\n  // **  Remote methods                              ** //\n  // ************************************************** //\n\n\n  this.updateUserContact = function (userData) {\n    $log.info("[contactService] updateUserContact");\n    var defered = $q.defer();\n    var portalURL = config.restServerUrl + "/api/rainbow/enduser/v1.0/"; // Call the REST WebService\n\n    $http({\n      method: "PUT",\n      url: portalURL + "users/" + authService.userId,\n      headers: authService.getPostHeader(),\n      data: userData\n    }).then(function success(response) {\n      $log.info("[contactService] updateUserContact successfully");\n      that.userContact.updateFromUserData(response.data.data);\n      defered.resolve();\n    }, function failure(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "updateUserContact"));\n    });\n    return defered.promise;\n  };\n  /**\n  * Method change the user password\n  * Please note that the password is reset, the XMPP connection is closed.\n  * This method has to be followed by a full reconnection process\n  * \n  * @param oldPassword [required] the user old password\n  * @param newPassword [required] the user new password\n  * @param async [required] the user new password\n  * @returns A promise \n  * \n  */\n\n\n  that.updateUserPassword = function (oldPassword, newPassword, async) {\n    var defered = $q.defer();\n    that.changePasswordInfo = {\n      defered: defered,\n      newPassword: newPassword\n    };\n    $http({\n      method: "PUT",\n      url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + authService.userId + "/change-password",\n      headers: authService.getPostHeader(),\n      data: {\n        "oldPassword": oldPassword,\n        "newPassword": newPassword\n      }\n    }).then(function () {\n      $log.info("[contactService] updateUserPasswordRequest -- success");\n\n      if (!async) {\n        defered.resolve();\n      }\n    })["catch"](function (response) {\n      $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "updateUserPasswordRequest"));\n      that.changePasswordInfo = null;\n      defered.reject(errorHelperService.handleError(response));\n    });\n    return defered.promise;\n  };\n  /* Method deleteUserAccount\n  * Completely deletes the current user account from Rainbow\n  * \n  * @returns A promise \n  *\n  */\n\n\n  this.deleteUserAccount = function () {\n    return $q(function (resolve, reject) {\n      $log.info("[contactService] deleteUserAccount");\n      $http({\n        method: "DELETE",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + that.userContact.dbId,\n        headers: authService.getRequestHeader()\n      }).then(function () {\n        $log.info("[contactService] deleteUserAccount -- success");\n        resolve();\n      })["catch"](function (response) {\n        $log.error("[contactService] " + errorHelperService.getErrorFullMessage(response, "deleteUserAccount"));\n        reject(errorHelperService.handleError(response));\n      });\n    });\n  }; // ************************************************** //\n  // **  jid utilities                               ** //\n  // ************************************************** //\n\n\n  this.isTelJid = function (jid) {\n    return jid.indexOf("tel_") === 0;\n  };\n\n  this.getImJid = function (jid) {\n    var bareJid = xmppService.getBareJidFromJid(jid);\n\n    if (this.isTelJid(bareJid)) {\n      var contact = this.jtelContacts[bareJid];\n\n      if (contact) {\n        return contact.jid;\n      }\n\n      $log.warn("[contactService] -- getIMJid(" + jid + ") -- failure -- no associated contact");\n      return null;\n    }\n\n    return bareJid;\n  };\n\n  this.getRessourceFromJid = function (jid) {\n    var result = "";\n\n    if (jid) {\n      var index = jid.indexOf("/");\n\n      if (index !== -1) {\n        result = jid.substr(index + 1);\n      }\n    }\n\n    return result;\n  };\n\n  this.isUserContactJid = function (jid) {\n    if (!that.userContact || !jid || jid.length === 0) {\n      return false;\n    }\n\n    return jid.startsWith(that.userContact.jid);\n  };\n\n  this.isUserContact = function (contact) {\n    if (!contact || !contact.jid || contact.jid.length === 0) {\n      return false;\n    }\n\n    if (!that.userContact) {\n      return contact.jid.startsWith(xmppService.jid);\n    }\n\n    return contact.jid.startsWith(that.userContact.jid);\n  };\n  /******************************************************************/\n\n  /** LAST ACTIVITY STUFF                                          **/\n\n  /******************************************************************/\n\n\n  that.updateContactsLastActivity = function () {\n    if (that.contacts) {\n      Object.keys(that.contacts).forEach(function (key) {\n        that.contacts[key].updateLastActivityMessage();\n      });\n    }\n  };\n\n  that.updateLastActivity = function (contact) {\n    if (contact.status === "offline" || contact.status === "away") {\n      contact.lastActivityDate = contact.getLastAvailableDate();\n    } else {\n      contact.lastActivityDate = null;\n    }\n  };\n\n  this.createBotContact = function (jid, name, id, botAvatarUrl) {\n    var contact;\n\n    if (that.contacts[jid]) {\n      contact = Contact.updateContactToBot(that.contacts[jid], name, id, botAvatarUrl);\n    } else {\n      contact = Contact.createBotContact(jid, name, id, botAvatarUrl);\n    }\n\n    that.contacts[contact.id] = contact;\n    that.dbContacts[id] = contact;\n    return contact;\n  }; // ************************************************** //\n  // **  Contact event handlers                      ** //\n  // ************************************************** //\n\n\n  this.contactPresenceChangedHandler = function (__event, attr) {\n    // Ignore calendar presence\n    if (that.getRessourceFromJid(attr.jid) === "calendar") {\n      return;\n    } // Get the im jid (attr.jid is potentially a telephony jid)\n\n\n    var jid_im = that.getImJid(attr.jid);\n\n    if (!jid_im) {\n      return;\n    } // Ignore room "caps" presence message\n\n\n    if (jid_im.startsWith("room")) {\n      return;\n    } // Get or create the associated contact\n\n\n    that.getOrCreateContact(jid_im).then(function (contact) {\n      // Update telephony status\n      if (that.isTelJid(attr.jid)) {\n        //sipWise++ From now all xmpp eventAttr is passed instead of only attr.message\n        $log.info("[contactService] Update telephony presence (" + jid_im + ") Source = " + contact.getPCGPresenceSource(attr.jid));\n        $log.info("[contactService] Update telephony presence (" + jid_im + ") msg : " + attr.message + " / status : " + attr.status); //contact.updateTelephonyStatus(attr.message, that.isUserContact(contact));\n\n        contact.updateTelephonyStatus(attr, that.isUserContact(contact)); //sipWise--\n      } // Update im presence status\n      else {\n          $log.info("[contactService] Update im presence contact (" + jid_im + ") : " + attr.status + " " + attr.stamp); //dispatch the auto mode to everybody if user already exists\n\n          if (that.isUserContact(contact) && attr.message === "mode=auto" && contact.status !== "online" && contact.resources.hasOwnProperty(attr.jid) && attr.jid !== contact.fullJid) {\n            //not in PABX call\n            if (contact.telStatus !== "EVT_SERVICE_INITIATED" && contact.telStatus !== "EVT_ESTABLISHED") {\n              //if the current ressource is already online, do not send a message\n              if (contact.resources[contact.fullJid] && contact.resources[contact.fullJid].show === "online") {\n                $log.info("[contactService] Current ressource is already online, ignore message!");\n              } else {\n                //if in manual state, we should leave it\n                if (that.manualState) {\n                  $log.info("[contactService] User is in manual state, leave it");\n                  that.setUserContactStatus("online", "mode=auto");\n                } //If in a WEBRTC call on this device, update the presence\n\n\n                if (that.busyState && that.busyState.status === "dnd" && that.userContact.status !== "busy") {\n                  $log.info("[contactService] User is in call, re-update presence state");\n                  $interval(function () {\n                    that.updatePresence(true);\n                  }, 500, 1, true);\n                }\n              }\n            }\n          }\n\n          contact.updateIMStatus(attr, that.isUserContact(contact));\n          that.updateLastActivity(contact);\n        } // Send contact updated event\n\n\n      that.sendUpdateEvent(contact);\n    });\n  };\n\n  this.contactCalendarPresenceChangedHandler = function (__event, contact) {\n    contact.updateCalendarPresenceInfo();\n  };\n\n  this.setUserContactStatus = function (status, message, withAuthInfo) {\n    try {\n      $log.info("[contactService] Set userContact status : " + status + (message ? "(" + message + ")" : ""));\n\n      if (xmppService.started) {\n        if (status === "online") {\n          that.manualState = false;\n          xmppService.sendPresence(null, message, withAuthInfo);\n        } else {\n          that.manualState = true;\n\n          if (status === "away") {\n            xmppService.sendPresence("away", message);\n          } else if (status === "dnd") {\n            xmppService.sendPresence("dnd", message);\n          } else if (status === "xa") {\n            xmppService.sendPresence("xa", message);\n          }\n        }\n      } else if (status === "online") {\n        var serviceLauncher = $injector.get("serviceLauncher");\n        serviceLauncher.startServices();\n      }\n    } catch (error) {\n      $log.error("[contactService] Set userContact status error : " + error);\n    }\n  };\n\n  this.sendPresenceFromConfiguration = function (sendAuthInfo) {\n    $log.info( true ? "(with auth info)" : undefined);\n    var defered = $q.defer();\n    that.getUserSettings().then(function (setting) {\n      var message = "";\n      var presence = setting.presence;\n\n      if (presence === "invisible") {\n        presence = "xa";\n      } else if (presence === "away") {\n        presence = "xa";\n        message = "away";\n      }\n\n      $log.info("[contactService] sendPresenceFromConfiguration -> getUserSettings are " + presence + " || message : " + message);\n\n      if (that.userContact && that.userContact.resources && that.userContact.resources[that.userContact.fullJid]) {\n        var myRessource = that.userContact.resources[that.userContact.fullJid];\n\n        if (myRessource && (myRessource.show !== presence || myRessource.show === "xa" && myRessource.status !== message)) {\n          //ignore the update of the presence if already in call and not in Manual mode\n          if (!that.busyState || that.busyState.status !== "dnd" || that.manualState) {\n            $log.info("[contactService] sendPresenceFromConfiguration should update my status from " + myRessource.show + " to " + presence + " (" + message + ")");\n            that.setUserContactStatus(presence, message, sendAuthInfo);\n          }\n        } else {\n          $rootScope.$broadcast("ON_RELOAD_CAPABILITIES_FOR_MY_CONYTACT");\n        }\n      } else {\n        $log.info("[contactService] sendPresenceFromConfiguration set initial presence ");\n        that.setUserContactStatus(presence, message, sendAuthInfo);\n      }\n\n      defered.resolve();\n    })["catch"](function () {\n      $log.info("[contactService] sendPresenceFromConfiguration failure, send online");\n      that.setUserContactStatus("online", null, sendAuthInfo);\n      defered.resolve();\n    });\n    return defered.promise;\n  };\n\n  that.updateUserSettings = function (status, message) {\n    var presence = "online";\n\n    if (status === "xa" && message === "away") {\n      presence = "away";\n    } else if (status === "dnd") {\n      presence = "dnd";\n    } else if (status === "xa") {\n      presence = "invisible";\n    }\n\n    that.setUserSettings({\n      "presence": presence\n    });\n  }; // Presentation Mode treatment\n\n\n  var lastUpdatePresentationMode = null;\n  var presentationModeIntervalPromise;\n\n  function startUpdatePresentationModeRefreshTimer() {\n    $log.debug("[contactService] startUpdatePresentationModeRefreshTimer");\n\n    if (presentationModeIntervalPromise !== null) {\n      $interval.cancel(presentationModeIntervalPromise);\n      presentationModeIntervalPromise = null;\n    }\n\n    presentationModeIntervalPromise = $interval(function () {\n      $log.debug("[contactService] startUpdatePresentationModeRefreshTimer interval reach");\n\n      if (lastUpdatePresentationMode !== that.presentationModeActive) {\n        $log.debug("[contactService] startUpdatePresentationModeRefreshTimer interval - request presence update");\n        lastUpdatePresentationMode = that.presentationModeActive;\n        that.updatePresence();\n        startUpdatePresentationModeRefreshTimer();\n      } else {\n        $log.debug("[contactService] startUpdatePresentationModeRefreshTimer interval - no presence update needed");\n        lastUpdatePresentationMode = null;\n      }\n    }, 1000, 1, true);\n  }\n\n  this.onPresentationModeChangedEvent = function (__event, status) {\n    if (status === "active") {\n      that.presentationModeActive = true;\n    } else if (status === "disable") {\n      that.presentationModeActive = false;\n    }\n\n    if (lastUpdatePresentationMode === null) {\n      $log.debug("[contactService] onPresentationModeChangedEvent status:" + status + " request presence update");\n      lastUpdatePresentationMode = that.presentationModeActive;\n      that.updatePresence();\n    }\n\n    startUpdatePresentationModeRefreshTimer();\n  };\n\n  this.changeMyPresence = function (status) {\n    $log.info("[contactService] changeMyPresence " + status + " " + that.userContact.message);\n\n    if (status === "dnd" && that.userContact.message === "presentation" || status === "busy") {\n      return;\n    }\n\n    var message = "";\n\n    if (status === "online") {\n      message = "mode=auto";\n    } //if manual away\n\n\n    if (status === "away") {\n      status = "xa";\n      message = "away";\n    }\n\n    that.setUserContactStatus(status, message);\n\n    if (status === "online") {\n      $interval(function () {\n        that.manualState = false;\n        that.updatePresence();\n      }, 1000, 1, true);\n    }\n\n    that.updateUserSettings(status, message);\n  }; //get available status list\n\n\n  this.computeStatusList = function () {\n    var list = [];\n\n    if (that.userContact && that.userContact.status) {\n      $log.info("[contactService] computeStatusList " + that.userContact.status + " " + that.userContact.message);\n\n      if (that.userContact.status === "offline") {\n        list = ["online"];\n      } else if (that.userContact.status === "busy") {\n        list = ["busy"];\n      } else if (that.userContact.status === "dnd" && that.userContact.message === "presentation") {\n        list = ["dnd"];\n      } else {\n        list = ["online", "away", "xa", "dnd"];\n      }\n    }\n\n    return list;\n  }; // Busy Mode treatment\n\n\n  this.resetBusyState = function () {\n    $log.info("[contactService] resetBusyState");\n    that.setBusyState(null, null, true); //send the stocked presence in the configuration\n\n    that.sendPresenceFromConfiguration();\n  };\n\n  this.setBusyState = function (status, message, noUpdate) {\n    $log.info("[contactService] setBusyState -- " + status + " -- " + message);\n    that.busyState = {\n      status: status,\n      message: message\n    };\n\n    if (!noUpdate) {\n      that.updatePresence();\n    }\n  };\n\n  $rootScope.$on("$destroy", $rootScope.$on("ON_PRESENTATION_MODE_CHANGED_EVENT", that.onPresentationModeChangedEvent)); // Presence Status treatment\n\n  this.updatePresence = function (forced) {\n    $log.info("[contactService] updatePresence");\n\n    if (that.manualState) {\n      $log.info("[contactService] updatePresence manualState");\n\n      if (that.userContact.status === "away" && that.busyState && that.busyState.status === "dnd") {\n        that.setUserContactStatus("online", "mode=auto"); // that.updateUserSettings("online");\n\n        $interval(function () {\n          that.updatePresence();\n        }, 1000, 1, true);\n      }\n    } else if (that.presentationModeActive && (!that.busyState || !that.busyState.status)) {\n      $log.info("[contactService] updatePresence dnd presentation");\n      xmppService.sendPresence("dnd", "presentation");\n    } else if (that.busyState && that.busyState.status === "dnd") {\n      $log.info("[contactService] updatePresence dnd " + that.busyState.message);\n      xmppService.sendPresence("dnd", that.busyState.message);\n    } else if (that.awayStateActive) {\n      $log.info("[contactService] updatePresence away");\n      xmppService.sendPresence("away", "");\n    } else if (that.userContact && that.userContact.status !== "online") {\n      $log.info("[contactService] updatePresence online");\n      that.setUserContactStatus("online");\n    } else if (forced && that.userContact && that.userContact.status === "online") {\n      $log.info("[contactService] updatePresence forced online");\n      that.setUserContactStatus("online");\n    }\n  };\n  /**\n   * REMOVE CONTACT\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.removeContact = function (contact) {\n    return $q(function (resolve, reject) {\n      if (!contact) {\n        $log.error("[contactService] removeContact : missing contact !");\n        reject();\n        return;\n      }\n\n      $log.info("[contactService] removeContact : " + contact.displayNameForLog());\n      that.removeContactFromRoster(contact.dbId).then(function () {\n        $log.info("[contactService] removeContact : " + contact.displayNameForLog() + " success");\n        resolve();\n      })["catch"](function (error) {\n        $log.error("[contactService] removeContact: " + contact.displayNameForLog() + " failure : " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  this.removeContactFromRoster = function (dbId) {\n    return $q(function (resolve, reject) {\n      if (!dbId) {\n        $log.error("[contactService] removeContactFromRoster : missing id !");\n        reject();\n        return;\n      }\n\n      $log.info("[contactService] removeContactFromRoster for id " + dbId);\n      var serverUrl = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/networks/" + dbId;\n      $http({\n        method: "DELETE",\n        url: serverUrl,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function () {\n        $log.info("[contactService] removeContactFromRoster success for id " + dbId);\n        resolve();\n      }, function error(response) {\n        var errorMessage = "removeContactFromRoster failure: no server response";\n\n        if (response) {\n          errorMessage = "removeContactFromRoster failure: " + JSON.stringify(response);\n        }\n\n        $log.error("[contactService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  this.sendUpdateEvent = function (contact) {\n    var event = that.isUserContact(contact) ? "ON_USER_CONTACT_UPDATED_EVENT" : "ON_CONTACT_UPDATED_EVENT";\n    $rootScope.$broadcast(event, contact);\n  };\n\n  this.myMobileAvailable = function () {\n    return that.userContact ? that.userContact.mobileResource : null;\n  };\n\n  this.notifyImByEmail = function (contact) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/notifications/emails/offline",\n        headers: authService.getRequestHeader(),\n        data: {\n          userId: contact.dbId\n        }\n      }).then(function success(response) {\n        var mail = "";\n\n        if (response.data && response.data.data && response.data.data.email) {\n          mail = response.data.data.email.substr(0, 3) + "***" + response.data.data.email.substr(-3);\n        }\n\n        $log.info("[contactService] notifyImByEmail " + mail + " - success");\n        resolve();\n      }, function failure(response) {\n        $log.error("[contactService] notifyImByEmail failure (" + response.data.errorDetailsCode + ") : " + response.data.errorDetails.errorMsg);\n        reject(response);\n      });\n    });\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/contactService.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\nangular.module("rainbow").service("botService", ["$http", "$q", "$log", "$rootScope", "$interval", "authService", "contactService", "conversationService", function ($http, $q, $log, $rootScope, $interval, authService, contactService, conversationService) {\n  "use strict";\n\n  var service = this;\n  /********************************************************/\n\n  /** GLOBALS                                            **/\n\n  /********************************************************/\n\n  service.listeners = [];\n  /********************************************************/\n\n  /** LIFE CYCLE STUFF                                   **/\n\n  /********************************************************/\n\n  service.start = function (stats) {\n    $log.info("[botService] === STARTING ===");\n    var startDate = performance.now();\n    return $q(function (resolve, reject) {\n      service.init(); // Listen xmppService events\n\n      service.startListeners();\n      service.getBots().then(function (bots) {\n        $log.info("");\n        service.findEmily(bots);\n        service.unlockWaitingConversations();\n        var startDuration = Math.round(performance.now() - startDate);\n        stats.push({\n          service: "botService",\n          startDuration: startDuration\n        });\n        $log.info("[botService] === STARTED (" + startDuration + " ms) ===");\n        $log.info("");\n        resolve();\n      })["catch"](function (error) {\n        $log.info("[botService] === STARTING FAILURE === " + error.message);\n        reject();\n      });\n    });\n  };\n\n  service.stop = function () {\n    $log.info("[botService] === STOPPED ===");\n  };\n\n  service.init = function () {\n    service.emily = null; // e-Support bot\n    // Get and store portalURL\n\n    this.portalURL = config.restServerUrl + "/api/rainbow/enduser/v1.0/";\n  };\n  /********************************************************/\n\n  /** EVENT HANDLING                                     **/\n\n  /********************************************************/\n\n\n  service.startListeners = function () {\n    service.listeners.push($rootScope.$on("ON_COMPANY_SUPPORT_AVATAR_CHANGE_EVENT", service.onSupportAvatarChange));\n  };\n\n  service.stopListeners = function () {\n    // unregister listeners\n    var listener;\n\n    while (listener = listeners.pop()) {\n      listener();\n    }\n  };\n\n  service.onSupportAvatarChange = function (__event, supportAvatarInfo) {\n    $log.info("[botService] Emily avatar has been changed");\n\n    if (supportAvatarInfo.companyId === contactService.userContact.company.id) {\n      service.getEmilyBot().then(function (supportBot) {\n        service.updateEmily(supportBot);\n      })["catch"](function (error) {\n        $log.warn("[botService] Impossible to update Emily - " + error.stack || false);\n      });\n    }\n  };\n  /********************************************************/\n\n  /** COMPANY BOTS                                       **/\n\n  /********************************************************/\n\n\n  service.getBots = function (format) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "bots?format=" + (format ? format : "full");\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function (response) {\n        $log.info("[botService] getBots success");\n        resolve(response.data.data);\n      })["catch"](function (response) {\n        var errorMessage = "getBots failure " + response.data.errorDetails + " with status " + response.status;\n        $log.error("[botService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** COMPANY E-SUPPORT BOT (EMILY)                      **/\n\n  /********************************************************/\n\n\n  service.getEmilyBot = function () {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "bots/rainbow-support";\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function (response) {\n        $log.info("[botService] getEmilyBot success");\n        resolve(response.data.data);\n      })["catch"](function (response) {\n        var errorMessage = "getEmilyBot failure " + response.data.errorDetails + " with status " + response.status;\n        $log.error("[botService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.findEmily = function (bots) {\n    bots.forEach(function (bot) {\n      if (bot.name === "Emily") {\n        $log.info("[botService] Emily is found");\n        service.updateEmily(bot);\n      }\n    });\n  };\n\n  service.updateEmily = function (bot) {\n    service.emily = service.emily || bot; // do not override the existing object\n    // Update the existing object\n\n    service.emily.name = bot.name;\n    service.emily.id = bot.id;\n    service.emily.avatarId = bot.avatarId || bot.id;\n    service.emily.lastAvatarUpdateDate = bot.lastAvatarUpdateDate; // Save the URL of the avatar\n\n    service.emily.avatarUrl = service.getBotAvatarUrl(service.emily.avatarId, service.emily.lastAvatarUpdateDate); // Create or update Emily contact\n\n    contactService.createBotContact(service.emily.jid, service.emily.name, service.emily.id, service.emily.avatarUrl);\n    $log.info("[botService] Emily contact has been updated");\n  };\n\n  service.getEmily = function () {\n    return service.emily;\n  };\n\n  service.openConversationWithEmily = function () {\n    return $q(function (resolve, reject) {\n      $log.info("[botService] openConversationWithEmily");\n      var botContact = contactService.getContactByJid(service.emily.jid);\n      conversationService.getOrCreateOneToOneConversation(botContact.jid).then(function (conversation) {\n        conversationService.setActiveConversation(conversation);\n        resolve(conversation);\n      })["catch"](function () {\n        $log.error("[botService] openConversationWithEmily failure");\n        reject();\n      });\n    });\n  };\n\n  service.unlockWaitingConversations = function () {\n    conversationService.unlockWaitingBotConversations(true);\n  };\n  /********************************************************/\n\n  /** COMPANY BOT AVATAR STUFF                           **/\n\n  /********************************************************/\n\n\n  service.getBotAvatarImage = function (avatarId, lastAvatarUpdateDate) {\n    return $q(function (resolve, reject) {\n      $log.info("[botService] getBotAvatarImage"); // Build the image URL\n\n      var imgSrc = service.getBotAvatarUrl(avatarId, lastAvatarUpdateDate); // Create the image\n\n      var image = new Image();\n      var nbErrors = 0;\n\n      image.onload = function () {\n        var loadedImage = this;\n        $interval(function () {\n          $log.log("[botService] Load bot avatar " + avatarId + " lastAvatarUpdateDate " + lastAvatarUpdateDate + " success");\n          resolve(loadedImage);\n        }, 1, 1);\n      };\n\n      image.onerror = function () {\n        nbErrors++;\n        $interval(function () {\n          $log.warn("[botService] Load bor avatar " + avatarId + " lastAvatarUpdateDate " + lastAvatarUpdateDate + " failure");\n\n          if (nbErrors === 1) {\n            $log.warn("[botService] Fallback to default emily avatar"); //image.src = "/resources/skins/rainbow/images/emily.jpg"; //TODO use an asexual picture \n\n            image.src = "/resources/skins/rainbow/images/conversation/icon_headset.png";\n          } else {\n            reject(new Error("No image found"));\n          }\n        }, 1, 1);\n      }; // Load the image\n\n\n      image.src = imgSrc;\n    });\n  };\n\n  service.getBotAvatarUrl = function (botId, lastAvatarUpdateDate) {\n    // Build the image URL\n    var serverURL = config.webservices.protocol + "://" + config.webservices.currentServer;\n\n    if ($rootScope.cdn) {\n      serverURL = $rootScope.cdnServer;\n    }\n\n    var imgSrc = serverURL + "/api/avatar/" + botId + "?size=120";\n\n    if (lastAvatarUpdateDate) {\n      imgSrc += "&update=" + Object(crypto_js__WEBPACK_IMPORTED_MODULE_0__["MD5"])(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Latin1.parse(lastAvatarUpdateDate)).toString(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Hex);\n    } else {\n      imgSrc += "&update=" + Date.now();\n    }\n\n    return imgSrc;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/botService.js?')},function(module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nconst call_model_1 = __webpack_require__(0);\n/**\n * @ngdoc service\n * @name conversationService\n * @module rainbow\n * @description Rainbow conversationService\n */\nangular.module("rainbow").service("conversationService", [\n    "$q",\n    "$log",\n    "$rootScope",\n    "$http",\n    "$interval",\n    "$translate",\n    "xmppService",\n    "authService",\n    "contactService",\n    "Conversation",\n    "videoService",\n    "telephonyService",\n    "roomService",\n    "settingsService",\n    "ConversationServiceEventHandler",\n    "ConversationServiceHistoryHandler",\n    "utilService",\n    "profileService",\n    "SearchTextConvResultsFactory",\n    "pstnConferenceService",\n    "webConferenceService",\n    "webrtcGatewayService",\n    function ($q, $log, $rootScope, $http, $interval, $translate, xmppService, authService, contactService, Conversation, videoService, telephonyService, roomService, settingsService, ConversationServiceEventHandler, ConversationServiceHistoryHandler, utilService, profileService, SearchTextConvResultsFactory, pstnConferenceService, webConferenceService, webrtcGatewayService) {\n        "use strict";\n        /*********************************************************************/\n        /** LIFECYCLE STUFF                                                 **/\n        /*********************************************************************/\n        var service = this;\n        this.started = false;\n        var SEARCHTEXT_INALLCONVERSATIONS_LIMIT = 100;\n        var SEARCHTEXT_INROOM_LIMIT = 5;\n        var SEARCHTEXT_MESSAGES_AROUND_LIMIT = 20;\n        service.start = (stats) => {\n            $log.info("");\n            $log.info("[conversationService] === STARTING ===");\n            // Create the defered object\n            var defered = $q.defer();\n            var startDate = performance.now();\n            this.pendingMessages = {};\n            this.activeConversation = null;\n            this.conversations = [];\n            this.conversationCreationPromise = {};\n            this.inCallConversations = [];\n            this.idleConversations = [];\n            this.involvedContactIds = [];\n            // Search Text context:\n            this.searchTextResults = SearchTextConvResultsFactory();\n            //all conversations with Bots\n            this.waitingBotConversations = [];\n            this.botServiceReady = false;\n            //Allow the user to make PBX call on his deskphone using his Rainbow application\n            this.isBasicCallAllowed = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_BASIC_CALL);\n            //Allow to manage 2 PBX calls using the Rainbow application (Hold/retrieve/consult)\n            this.isSecondCallAllowed = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_SECOND_CALL);\n            // Register to xmpp and call events\n            this.attachHandlers();\n            $log.info("[conversationService] getServerConversations");\n            // Fetch conversations from server\n            service.getServerConversations()\n                .then(() => {\n                // Consider service as started\n                service.started = true;\n                service.linkAllActiveCallsToConversations();\n                var startDuration = Math.round(performance.now() - startDate);\n                stats.push({ service: "conversationService", startDuration: startDuration });\n                $log.info("[conversationService] === STARTED (" + startDuration + " ms) ===");\n                defered.resolve();\n            })\n                .catch((error) => {\n                $log.info("[conversationService] === STARTING FAILURE === " + error.message);\n                defered.reject(error);\n            });\n            // Attach contact event listener\n            if (this.contactUpdateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_CONTACT_UPDATED_EVENT, rehandle it");\n                this.contactUpdateEventHandlerCleaner();\n            }\n            this.contactUpdateEventHandlerCleaner = $rootScope.$on("ON_CONTACT_UPDATED_EVENT", this.onContactChangedEvent);\n            // Attach room event listener\n            if (this.roomUpdateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event " + roomService.ROOM_UPDATE_EVENT + ", rehandle it");\n                this.roomUpdateEventHandlerCleaner();\n            }\n            this.roomUpdateEventHandlerCleaner = $rootScope.$on(roomService.ROOM_UPDATE_EVENT, this.onRoomChangedEvent);\n            // Attach room event listener\n            if (this.roomAddConferenceEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event " + roomService.ROOM_ADD_CONF_ENDPOINT_EVENT + ", rehandle it");\n                this.roomAddConferenceEventHandlerCleaner();\n            }\n            this.roomAddConferenceEventHandlerCleaner = $rootScope.$on(roomService.ROOM_ADD_CONF_ENDPOINT_EVENT, this.onRoomAddConferenceEvent);\n            // Attach room event listener\n            if (this.roomHistoryUpdateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event " + roomService.ROOM_HISTORY_UPDATE_EVENT + ", rehandle it");\n                this.roomHistoryUpdateEventHandlerCleaner();\n            }\n            this.roomHistoryUpdateEventHandlerCleaner = $rootScope.$on(roomService.ROOM_HISTORY_UPDATE_EVENT, this.onRoomHistoryChangedEvent);\n            // Attach room event listener\n            if (this.roomAdminMessageEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event " + roomService.ROOM_ADMIN_MESSAGE_EVENT + ", rehandle it");\n                this.roomAdminMessageEventHandlerCleaner();\n            }\n            this.roomAdminMessageEventHandlerCleaner = $rootScope.$on(roomService.ROOM_ADMIN_MESSAGE_EVENT, this.onRoomAdminMessageEvent);\n            // Attach call event listener\n            if (this.callUpdateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_CALL_UPDATED_EVENT, rehandle it");\n                this.callUpdateEventHandlerCleaner();\n            }\n            this.callUpdateEventHandlerCleaner = $rootScope.$on("ON_CALL_UPDATED_EVENT", this.onCallEvent);\n            if (this.conversationUpdateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_CONVERSATIONS_UPDATED_EVENT, rehandle it");\n                this.conversationUpdateEventHandlerCleaner();\n            }\n            this.conversationUpdateEventHandlerCleaner = $rootScope.$on("ON_CONVERSATIONS_UPDATED_EVENT", this.onConversationEvent);\n            if (this.capacityUpdateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_UPDATE_MYCONTACT_EVENT, rehandle it");\n                this.capacityUpdateEventHandlerCleaner();\n            }\n            this.capacityUpdateEventHandlerCleaner = $rootScope.$on("ON_UPDATE_MYCONTACT_EVENT", this.onMyContactChangedEvent);\n            // Attach telephony service event listener\n            if (this.telephonyStateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_TELEPHONY_STATUS_CHANGED_EVENT, rehandle it");\n                this.telephonyStateEventHandlerCleaner();\n            }\n            this.telephonyStateEventHandlerCleaner = $rootScope.$on("ON_TELEPHONY_STATUS_CHANGED_EVENT", this.onTelephonyStateChangeEvent);\n            // Attach conference services event listeners\n            if (this.conferenceStateEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_CONFERENCE_STATE_EVENT, rehandle it");\n                this.conferenceStateEventHandlerCleaner();\n            }\n            this.conferenceStateEventHandlerCleaner = $rootScope.$on("ON_CONFERENCE_STATE_EVENT", this.onConferenceStateChangeEvent);\n            if (this.conferenceParticipantsEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_CONFERENCE_PARTICIPANT_EVENT, rehandle it");\n                this.conferenceParticipantsEventHandlerCleaner();\n            }\n            this.conferenceParticipantsEventHandlerCleaner = $rootScope.$on("ON_CONFERENCE_PARTICIPANT_EVENT", this.onConferenceParticipantChangeEvent);\n            if (this.reloadCapabilitiesForMyContactEventHandlerCleaner) {\n                $log.warn("[conversationService] already subscribed to event ON_RELOAD_CAPABILITIES_FOR_MY_CONYTACT, rehandle it");\n                this.reloadCapabilitiesForMyContactEventHandlerCleaner();\n            }\n            this.reloadCapabilitiesForMyContactEventHandlerCleaner = $rootScope.$on("ON_RELOAD_CAPABILITIES_FOR_MY_CONYTACT", this.onReloadCapabilitiesForMyContactEvent);\n            return defered.promise;\n        };\n        this.attachHandlers = () => {\n            this.removeHandlers();\n            $log.info("[conversationService] attachHandlers");\n            this.conversationHistoryHandler = ConversationServiceHistoryHandler.create(this);\n            this.conversationServiceEventHandler = ConversationServiceEventHandler.create(this);\n            // Attach MAM event handler\n            xmppService.addHistoryHandler((stanza) => {\n                return service.conversationHistoryHandler.onHistoryMessageReceived(stanza);\n            });\n            xmppService.addSearchTextHandler((queryId, stanza) => {\n                $log.info("[conversationService] addSearchTextHandler");\n                if (service.searchTextResults.isCurrentQuery(queryId)) {\n                    $log.info("[conversationService] searchText: queryId are matching");\n                    var searchTextItem = service.conversationHistoryHandler.onSearchTextMessageReceived(stanza);\n                    if (searchTextItem) {\n                        $log.info("[conversationService] searchText: save item result");\n                        service.searchTextResults.addNewItemResult(searchTextItem.otherJid, searchTextItem);\n                    }\n                }\n                else {\n                    $log.info("[conversationService] searchText: queryId are NOT matching : " + queryId);\n                }\n            });\n            // Attach messages handler\n            if (!this.messageHandlerRef) {\n                this.messageHandlerRef = xmppService.addHandler((stanza) => { service.conversationServiceEventHandler.onChatMessageReceived(stanza); return true; }, null, "message", "chat");\n            }\n            if (!this.messageMucHandlerRef) {\n                this.messageMucHandlerRef = xmppService.addHandler((stanza) => { service.conversationServiceEventHandler.onChatMessageReceived(stanza); return true; }, null, "message", "groupchat");\n            }\n            if (!this.fileMessageHandlerRef) {\n                this.fileMessageHandlerRef = xmppService.addHandler((stanza) => { service.conversationServiceEventHandler.onFileMessageReceived(stanza); return true; }, null, "message", "file");\n            }\n            if (!this.webrtcMessageHandlerRef) {\n                this.webrtcMessageHandlerRef = xmppService.addHandler((stanza) => { service.conversationServiceEventHandler.onWebRTCMessageReceived(stanza); return true; }, null, "message", "webrtc");\n            }\n            if (!this.convMessageHandlerRef) {\n                this.convMessageHandlerRef = xmppService.addHandler((stanza) => { service.conversationServiceEventHandler.onManagementMessageReceived(stanza); return true; }, null, "message", "management");\n            }\n            if (!this.receiptMessageHandlerRef) {\n                this.receiptMessageHandlerRef = xmppService.addHandler((stanza) => { service.conversationServiceEventHandler.onReceiptMessageReceived(stanza); return true; }, null, "message");\n            }\n            if (!this.audioConfMessageHandlerRef) {\n                this.audioConfMessageHandlerRef = xmppService.addHandler((stanza) => { service.conversationServiceEventHandler.onConferenceMessageReceived(stanza); return true; }, "jabber:x:audioconference", "message", "chat");\n            }\n            /*\t\t\tif (!this.recordingMessageHandlerRef) {\n                            this.recordingMessageHandlerRef = xmppService.addHandler((stanza) => {service.conversationServiceEventHandler.onRecordingMessageReceived(stanza); return true; }, null, "message", "recording");\n                        }*/\n        };\n        this.removeHandlers = () => {\n            $log.info("[conversationService] removeHandlers ");\n            //remove conversation handlers\n            if (this.conversationHistoryHandler) {\n                this.conversationHistoryHandler = null;\n            }\n            if (this.conversationServiceEventHandler) {\n                this.conversationServiceEventHandler = null;\n            }\n            //remove all handlers\n            if (this.messageHandlerRef) {\n                xmppService.deleteHandler(this.messageHandlerRef);\n                this.messageHandlerRef = null;\n            }\n            if (this.fileMessageHandlerRef) {\n                xmppService.deleteHandler(this.fileMessageHandlerRef);\n                this.fileMessageHandlerRef = null;\n            }\n            if (this.webrtcMessageHandlerRef) {\n                xmppService.deleteHandler(this.webrtcMessageHandlerRef);\n                this.webrtcMessageHandlerRef = null;\n            }\n            if (this.convMessageHandlerRef) {\n                xmppService.deleteHandler(this.convMessageHandlerRef);\n                this.convMessageHandlerRef = null;\n            }\n            if (this.receiptMessageHandlerRef) {\n                xmppService.deleteHandler(this.receiptMessageHandlerRef);\n                this.receiptMessageHandlerRef = null;\n            }\n            if (this.messageMucHandlerRef) {\n                xmppService.deleteHandler(this.messageMucHandlerRef);\n                this.messageMucHandlerRef = null;\n            }\n            if (this.recordingMessageHandlerRef) {\n                xmppService.deleteHandler(this.recordingMessageHandlerRef);\n                this.recordingMessageHandlerRef = null;\n            }\n            if (this.audioConfMessageHandlerRef) {\n                xmppService.deleteHandler(this.audioConfMessageHandlerRef);\n                this.audioConfMessageHandlerRef = null;\n            }\n        };\n        service.stop = () => {\n            $log.info("[conversationService] === STOPPING ===");\n            this.conversations = null;\n            //remove all handlers\n            if (this.messageHandlerRef) {\n                xmppService.deleteHandler(this.messageHandlerRef);\n                this.messageHandlerRef = null;\n            }\n            if (this.fileMessageHandlerRef) {\n                xmppService.deleteHandler(this.fileMessageHandlerRef);\n                this.fileMessageHandlerRef = null;\n            }\n            if (this.webrtcMessageHandlerRef) {\n                xmppService.deleteHandler(this.webrtcMessageHandlerRef);\n                this.webrtcMessageHandlerRef = null;\n            }\n            if (this.recordingMessageHandlerRef) {\n                xmppService.deleteHandler(this.recordingMessageHandlerRef);\n                this.recordingMessageHandlerRef = null;\n            }\n            if (this.audioConfMessageHandlerRef) {\n                xmppService.deleteHandler(this.audioConfMessageHandlerRef);\n                this.audioConfMessageHandlerRef = null;\n            }\n            //remove all handlers\n            if (this.contactUpdateEventHandlerCleaner) {\n                this.contactUpdateEventHandlerCleaner();\n                this.contactUpdateEventHandlerCleaner = null;\n            }\n            if (this.roomUpdateEventHandlerCleaner) {\n                this.roomUpdateEventHandlerCleaner();\n                this.roomUpdateEventHandlerCleaner = null;\n            }\n            if (this.roomAddConferenceEventHandlerCleaner) {\n                this.roomAddConferenceEventHandlerCleaner();\n                this.roomAddConferenceEventHandlerCleaner = null;\n            }\n            if (this.roomAdminMessageEventHandlerCleaner) {\n                this.roomAdminMessageEventHandlerCleaner();\n                this.roomAdminMessageEventHandlerCleaner = null;\n            }\n            if (this.callUpdateEventHandlerCleaner) {\n                this.callUpdateEventHandlerCleaner();\n                this.callUpdateEventHandlerCleaner = null;\n            }\n            if (this.conversationUpdateEventHandlerCleaner) {\n                this.conversationUpdateEventHandlerCleaner();\n                this.conversationUpdateEventHandlerCleaner = null;\n            }\n            if (this.capacityUpdateEventHandlerCleaner) {\n                this.capacityUpdateEventHandlerCleaner();\n                this.capacityUpdateEventHandlerCleaner = null;\n            }\n            if (this.telephonyStateEventHandlerCleaner) {\n                this.telephonyStateEventHandlerCleaner();\n                this.telephonyStateEventHandlerCleaner = null;\n            }\n            this.started = false;\n            $log.info("[conversationService] === STOPPED ===");\n            return $q.when();\n        };\n        /*********************************************************************/\n        /** CONVERSATION API STUFF                                          **/\n        /*********************************************************************/\n        service.getServerConversations = () => {\n            return $q((resolve, reject) => {\n                $http({\n                    method: "GET",\n                    url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/conversations",\n                    headers: authService.getRequestHeader()\n                })\n                    .then((response) => {\n                    $log.info("[conversationService] getServerConversations -- success");\n                    // Create conversation promises\n                    var conversationPromises = [];\n                    response.data.data.forEach((conversationData) => {\n                        $log.info("[conversationService] getServerConversations -- create conversation " + conversationData.jid_im + " " + conversationData.id);\n                        var missedImCounter = parseInt(conversationData.unreadMessageNumber, 10);\n                        var conversationPromise = null;\n                        var muted = (conversationData.mute === true);\n                        if (conversationData.type === "user") {\n                            conversationPromise = service.getOrCreateOneToOneConversation(conversationData.jid_im, conversationData.id, conversationData.lastMessageDate, conversationData.lastMessageText, missedImCounter, muted, conversationData.creationDate);\n                        }\n                        else {\n                            conversationPromise = service.getRoomConversation(conversationData.jid_im, conversationData.id, conversationData.lastMessageDate, conversationData.lastMessageText, missedImCounter, true, muted, conversationData.creationDate, conversationData.lastMessageSender, conversationData.topic, conversationData.type);\n                        }\n                        conversationPromises.push(conversationPromise);\n                    });\n                    // Resolve all promises\n                    $q.all(conversationPromises)\n                        .then(() => { return service.removeOlderConversations(); })\n                        .then(() => {\n                        service.orderConversations();\n                        resolve();\n                    })\n                        .catch((error) => {\n                        var errorMessage = "getServerConversations failure: " + error.message;\n                        $log.error("[conversationService] " + errorMessage);\n                        reject(new Error(errorMessage));\n                    });\n                }, (response) => {\n                    var errorMessage = "getServerConversations failure: no server response";\n                    if (response) {\n                        errorMessage = "getServerConversations failure: " + JSON.stringify(response);\n                    }\n                    $log.error("[conversationService] " + errorMessage);\n                    reject(new Error(errorMessage));\n                });\n            });\n        };\n        this.createServerConversation = (conversation) => {\n            return $q((resolve, reject) => {\n                if (conversation.dbId) {\n                    resolve(conversation);\n                    return;\n                }\n                var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/conversations";\n                var data = null;\n                switch (conversation.type) {\n                    case Conversation.Type.ONE_TO_ONE:\n                        data = { peerId: conversation.contact.dbId, type: "user" };\n                        break;\n                    case Conversation.Type.ROOM:\n                        data = { peerId: conversation.room.dbId, type: "room" };\n                        break;\n                    case Conversation.Type.BOT:\n                        conversation.type = Conversation.Type.ONE_TO_ONE;\n                        data = { peerId: conversation.contact.dbId, type: "bot" };\n                        break;\n                    default: break;\n                }\n                $http({ method: "POST", url: url, headers: authService.getRequestHeader(), data: data })\n                    .then((response) => {\n                    conversation.dbId = response.data.data.id;\n                    resolve(conversation);\n                })\n                    .catch((response) => {\n                    var errorMessage = "createServerConversation failure: unknown ... ";\n                    if (response.data && response.data.errorDetails) {\n                        errorMessage = "createServerConversation failure: " + response.data.errorDetails;\n                    }\n                    $log.warn("[conversationService] " + errorMessage);\n                    reject(new Error(errorMessage));\n                });\n            });\n        };\n        this.deleteServerConversation = (conversationId) => {\n            var defered = $q.defer();\n            // Ignore conversation without dbId\n            if (!conversationId) {\n                return $q.when();\n            }\n            $http({\n                method: "DELETE",\n                url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/conversations/" + conversationId,\n                headers: authService.getRequestHeader(),\n            }).then(() => {\n                $log.info("[conversationService] deleteServerConversation success: " + conversationId);\n                service.orderConversations();\n                defered.resolve();\n            }, (response) => {\n                // Check particular case where we are trying to remove an already removed conversation\n                if (response.data.errorDetailsCode === 404002) {\n                    $log.info("[conversationService] deleteServerConversation success: " + conversationId);\n                    defered.resolve();\n                }\n                else {\n                    var errorMessage = "deleteServerConversation failure: " + response.data.errorDetails;\n                    $log.warn("[conversationService] " + errorMessage);\n                    defered.reject(new Error(errorMessage));\n                }\n            });\n            return defered.promise;\n        };\n        // Update conversation\n        this.updateServerConversation = (conversation) => {\n            var defered = $q.defer();\n            // Ignore conversation without dbId\n            if (!conversation) {\n                return $q.when();\n            }\n            $http({\n                method: "PUT",\n                url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/conversations/" + conversation.dbId,\n                headers: authService.getPostHeader(),\n                data: { mute: conversation.muted }\n            }).then(() => {\n                $log.info("[conversationService] updateServerConversation success: " + conversation.dbId);\n                defered.resolve();\n            }, (response) => {\n                // Check particular case where we are trying to remove an already removed conversation\n                var errorMessage = "updateServerConversation failure: " + response.data.errorDetails;\n                $log.warn("[conversationService] " + errorMessage);\n                defered.reject(new Error(errorMessage));\n            });\n            return defered.promise;\n        };\n        this.ackAllMessages = (conversationDbId) => {\n            return $q((resolve, reject) => {\n                if (!conversationDbId) {\n                    $log.error("[conversationService] ackAllMessages for conversation error -- missing conversation id");\n                    reject();\n                    return;\n                }\n                var conversation = service.getConversationByDbId(conversationDbId);\n                if (!conversation) {\n                    $log.error("[conversationService] ackAllMessages for conversation error -- can not find conversation");\n                    reject();\n                    return;\n                }\n                $log.info("[conversationService] ackAllMessages for conversation " + conversationDbId);\n                conversation.ackReadAllMessages();\n                $http({\n                    method: "PUT",\n                    url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/conversations/" + conversationDbId + "/markallread",\n                    headers: authService.getPostHeader(),\n                }).then(() => {\n                    $log.info("[conversationService] ackAllMessages success: " + conversationDbId);\n                    resolve();\n                }, (response) => {\n                    var errorMessage = "ackAllMessages failure: " + response.data.errorDetails;\n                    $log.warn("[conversationService] " + errorMessage);\n                    reject(new Error(errorMessage));\n                });\n            });\n        };\n        /*********************************************************/\n        /**                CONVERSATION HELPERS                 **/\n        /*********************************************************/\n        this.getConversationAsyncById = (conversationId, type) => {\n            var methodName = type === "room" ? "getRoomConversation" : "getOrCreateOneToOneConversation";\n            return this[methodName](conversationId);\n        };\n        /**\n         * GET OR CREATE A CONVERSATION\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.getOrCreateOneToOneConversation = (conversationId, conversationDbId, lastModification, lastMessageText, missedIMCounter, muted, creationDate) => {\n            $log.info("[conversationService] getOrCreateOneToOneConversation " + conversationId + " " + conversationDbId + " " + missedIMCounter);\n            if (!service.conversationCreationPromise[conversationId]) {\n                // Fetch existing conversation\n                var conv = service.getConversationById(conversationId);\n                if (conv) {\n                    conv.preload = true;\n                    return $q.resolve(conv);\n                }\n                // No conversation found, then create it\n                service.conversationCreationPromise[conversationId] = $q((resolve, reject) => {\n                    contactService.getOrCreateContact(conversationId)\n                        .then((contact) => {\n                        var conversation = Conversation.createOneToOneConversation(contact);\n                        conversation.lastModification = lastModification ? new Date(lastModification) : undefined;\n                        conversation.lastMessageText = lastMessageText;\n                        conversation.muted = muted;\n                        conversation.creationDate = creationDate ? new Date(creationDate) : new Date();\n                        conversation.preload = false;\n                        service.computeCapabilitiesForContact(contact);\n                        conversation.dbId = conversationDbId;\n                        conversation.missedCounter = missedIMCounter ? missedIMCounter : 0;\n                        return service.createServerConversation(conversation);\n                    })\n                        .then((conversation) => {\n                        service.conversations[conversation.contact.id] = conversation;\n                        service.orderConversations();\n                        $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation, Conversation.EventType.NEW);\n                        resolve(conversation);\n                        delete service.conversationCreationPromise[conversationId];\n                    })\n                        .catch((error) => {\n                        var errorMessage = "getOrCreateOneToOneConversation " + conversationId + " failure " + error.message;\n                        $log.error("[conversationService] " + errorMessage);\n                        reject(new Error(errorMessage));\n                        delete service.conversationCreationPromise[conversationId];\n                    });\n                });\n            }\n            return service.conversationCreationPromise[conversationId];\n        };\n        this.getRoomConversation = (roomJid, conversationDbId, lastModification, lastMessageText, missedIMCounter, noError, muted, creationDate, lastMessageSender, topic, type) => {\n            $log.info("[conversationService] getRoomConversation " + roomJid);\n            if (!service.conversationCreationPromise[roomJid]) {\n                // Fetch existing conversation\n                var conv = service.getConversationById(roomJid);\n                if (conv) {\n                    conv.preload = true;\n                    return $q.resolve(conv);\n                }\n                // No conversation found, then create it\n                service.conversationCreationPromise[roomJid] = $q((resolve, reject) => {\n                    $interval(() => {\n                        // Get the associated room\n                        var room = roomService.getRoomByJid(roomJid);\n                        if (!room) {\n                            if (type !== "bot") {\n                                $log.error("[conversationService] getRoomConversation (" + roomJid + ") failure : no such room");\n                            }\n                            var obj = {\n                                jid: roomJid,\n                                conversationDbId: conversationDbId,\n                                lastModification: lastModification,\n                                lastMessageText: lastMessageText,\n                                missedIMCounter: missedIMCounter,\n                                muted: muted,\n                                creationDate: creationDate\n                            };\n                            service.waitingBotConversations.push(obj);\n                            service.unlockWaitingBotConversations();\n                            resolve();\n                            delete service.conversationCreationPromise[roomJid];\n                        }\n                        else {\n                            var conversation = Conversation.createRoomConversation(room);\n                            conversation.dbId = conversationDbId;\n                            conversation.lastModification = lastModification ? new Date(lastModification) : undefined;\n                            conversation.lastMessageText = lastMessageText;\n                            conversation.muted = muted;\n                            conversation.creationDate = creationDate ? new Date(creationDate) : new Date();\n                            conversation.preload = false;\n                            conversation.lastMessageSender = lastMessageSender;\n                            if (conversation.room && topic) {\n                                conversation.room.desc = topic;\n                            }\n                            if (missedIMCounter) {\n                                conversation.missedCounter = missedIMCounter;\n                            }\n                            if (conversationDbId) {\n                                service.conversations[conversation.id] = conversation;\n                                service.getRoomConferences(conversation)\n                                    .then(() => {\n                                    $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation, Conversation.EventType.NEW);\n                                    resolve(conversation);\n                                    delete service.conversationCreationPromise[roomJid];\n                                })\n                                    .catch((error) => {\n                                    var errorMessage = "getRoomConversation " + roomJid + " failure " + error.message;\n                                    $log.error("[conversationService] " + errorMessage);\n                                    reject(new Error(errorMessage));\n                                    delete service.conversationCreationPromise[roomJid];\n                                });\n                            }\n                            else {\n                                service.createServerConversation(conversation)\n                                    .then((conversation) => {\n                                    var room = roomService.getRoomByJid(roomJid);\n                                    conversation.room = room;\n                                    service.conversations[conversation.id] = conversation;\n                                    service.orderConversations();\n                                    if (room && room.status !== "unsubscribed" && room.isActive) {\n                                        roomService.sendInitialRoomPresence(room);\n                                    }\n                                    $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation, Conversation.EventType.NEW);\n                                    resolve(conversation);\n                                    delete service.conversationCreationPromise[roomJid];\n                                });\n                            }\n                        }\n                    }, 1, 1);\n                });\n            }\n            return service.conversationCreationPromise[roomJid];\n        };\n        service.getRoomConferences = (conversation) => {\n            return $q((resolve) => {\n                var confEndpoints = conversation.room.confEndpoints;\n                if (confEndpoints) {\n                    confEndpoints.forEach((confEndpoint) => {\n                        if (confEndpoint.mediaType === "pstnAudio") {\n                            var conferenceSession = pstnConferenceService.getConferenceSessionById(confEndpoint.confEndpointId);\n                            if (conferenceSession) {\n                                conversation.pstnConferenceSession = conferenceSession;\n                            }\n                        }\n                    });\n                }\n                resolve();\n            });\n        };\n        service.updateRoomConferences = () => {\n            var conversations = service.getConversations();\n            conversations.forEach((conversation) => {\n                if (conversation.room && conversation.room.confEndpoints) {\n                    var conferenceSession = pstnConferenceService.getConferenceSessionById(conversation.room.getPstnConfEndpointId());\n                    if (conferenceSession) {\n                        conversation.pstnConferenceSession = conferenceSession;\n                    }\n                    else {\n                        conversation.pstnConferenceSession = null;\n                    }\n                    var webConfSession = webConferenceService.getConferenceSessionForRoom(conversation.room.confEndpoints);\n                    conversation.webConferenceSession = webConfSession ? webConfSession : null;\n                }\n                else {\n                    // A room conversation without confEndpoint should not have a conferenceSession attached\n                    conversation.pstnConferenceSession = null;\n                    conversation.webConferenceSession = null;\n                }\n            });\n        };\n        /**\n         * CLOSE CONVERSATION\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.closeConversation = (conversation) => {\n            return $q((resolve, reject) => {\n                $log.info("[conversationService] closeConversation " + conversation.id);\n                // Remove this contact from favorite group\n                service.deleteServerConversation(conversation.dbId)\n                    .then(() => { service.removeConversation(conversation); resolve(); })\n                    .catch((error) => { reject(error); });\n            });\n        };\n        this.removeConversation = (conversation) => {\n            $log.info("[conversationService] remove conversation " + conversation.id);\n            if (conversation.videoCall && conversation.videoCall.status !== call_model_1.Call.Status.UNKNOWN) {\n                $log.info("[conversationService] Ignore conversation deletion message for conversation" + conversation.id);\n                return;\n            }\n            delete service.conversations[conversation.id];\n            service.orderConversations();\n            var conversations = service.getOrderedConversations();\n            if (service.activeConversation && !(conversations.idle.indexOf(service.activeConversation) >= 0)) {\n                if (conversations.idle.length > 0) {\n                    service.setActiveConversation(conversations.idle.first());\n                }\n                else if (conversations.inCall.length > 0) {\n                    service.setActiveConversation(conversations.inCall.first());\n                }\n                else {\n                    service.setActiveConversation(null);\n                }\n            }\n            // To avoid leak\n            if (conversation.contact) {\n                conversation.contact.conversation = null;\n                conversation.contact = null;\n            }\n            $rootScope.$broadcast("ON_CONVERSATION_REMOVE_EVENT", conversation);\n            //conversation = null;\n        };\n        this.getConversationByDbId = (dbId) => {\n            if (service.conversations) {\n                for (var key in service.conversations) {\n                    if (service.conversations.hasOwnProperty(key) && service.conversations[key].dbId === dbId) {\n                        return service.conversations[key];\n                    }\n                }\n            }\n            return null;\n        };\n        /**\n         * GET CONVERSATION BY ROOM ID\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.getConversationByRoomDbId = (roomDbId) => {\n            if (service.conversations) {\n                for (var key in service.conversations) {\n                    if (service.conversations.hasOwnProperty(key) && service.conversations[key].room && service.conversations[key].room.dbId === roomDbId) {\n                        return service.conversations[key];\n                    }\n                }\n            }\n            return null;\n        };\n        this.removeOlderConversations = () => {\n            if (!authService.fromSDK) {\n                var maxConversations = parseInt(settingsService.getSetting("nbMaxConversations"), 10);\n                //add protection when the local storage does not work correctly ...\n                if (!maxConversations || maxConversations < 15) {\n                    settingsService.setSetting("nbMaxConversations", 15);\n                    maxConversations = 15;\n                }\n                var orderedConversations = service.getConversations().sort(service.sortFunction);\n                $log.info("[conversationService] removeOlderConversations -- maxConversations : " + maxConversations);\n                if (orderedConversations.length > maxConversations) {\n                    $log.info("[conversationService] removeOlderConversations -- orderedConversations : " + orderedConversations.length);\n                    var removePromises = [];\n                    for (var index = maxConversations; index < orderedConversations.length; index++) {\n                        removePromises.push(service.closeConversation(orderedConversations[index]));\n                    }\n                    return $q.all(removePromises);\n                }\n            }\n            return $q.when();\n        };\n        this.searchConversations = (criteria) => {\n            var queries = utilService.removeDiacritis(criteria.toLowerCase()).trim().normalize("NFD").replace(/[\\u0300-\\u036f]/g, "").split(/[ -]+/);\n            return service.getOrderedConversations().idle.filter((conversation) => {\n                var filterNames = conversation.filterName.trim().normalize("NFD").replace(/[\\u0300-\\u036f]/g, "");\n                var names = filterNames.split(/[ -]+/);\n                return queries.every((query) => {\n                    return names.some((name, index) => {\n                        if (name.length && name.indexOf(query) !== -1) {\n                            names[index] = "";\n                            return true;\n                        }\n                        return false;\n                    });\n                });\n            });\n        };\n        /*this.searchFavoritesConversations = (criteria) => {\n            var queries = utilService.removeDiacritis(criteria.toLowerCase()).trim().split(/[ ]+/);\n            return service.getOrderedConversations().favorites.filter((conversation) => {\n                var names = conversation.filterName.trim().split(/[ ]+/);\n                var match = queries.every((query) => {\n                    return names.some((name) => {\n                        if (name.length && (name.indexOf(query) === 0)) {\n                            return true;\n                        }\n                        return false;\n                    });\n                });\n                return match;\n            });\n        };*/\n        /*********************************************************/\n        /**                   MESSAGES STUFF                    **/\n        /*********************************************************/\n        this.cleanFile = (file) => {\n            let stripScripts = (s) => {\n                let div = document.createElement(\'div\');\n                div.innerHTML = s;\n                let scripts = div.getElementsByTagName(\'script\');\n                let i = scripts.length;\n                while (i--) {\n                    scripts[i].parentNode.removeChild(scripts[i]);\n                }\n                return div.innerHTML;\n            };\n            return new Promise((resolve) => {\n                if (file.type === "image/svg+xml") {\n                    let reader = new FileReader();\n                    reader.addEventListener("loadend", (e) => {\n                        let elem = e.srcElement;\n                        let cleanblob = new Blob([stripScripts(elem.result)], { type: "image/svg+xml" });\n                        let cleanFile = new File([cleanblob], file.name, { type: "image/svg+xml", lastModified: Date.now() });\n                        resolve(cleanFile);\n                    });\n                    reader.readAsText(file);\n                }\n                else {\n                    resolve(file);\n                }\n            });\n        };\n        /**\n         * SEND FS MESSAGE\n         */\n        this.sendFSMessage = (conversation, file, data, voiceMessage) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                let cleanFile = file; //await this.cleanFile(file);\n                if (!data || data.length === 0) {\n                    data = cleanFile.name;\n                }\n                let message = yield conversation.sendFSMessage(cleanFile, data, voiceMessage);\n                service.pendingMessages[message.id] = { conversation: conversation, message: message };\n                return message;\n            }\n            catch (error) {\n                var msgKey = error.translatedMessage ? error.translatedMessage : "Unable to share file";\n                $rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", {\n                    popupTitle: "fileTransfer",\n                    popupBodyTranslated: msgKey,\n                    okLabel: "ok"\n                });\n                throw new Error(error);\n            }\n        });\n        /**\n         * SEND Existing FS MESSAGE (with File already shared)\n         */\n        this.sendEFSMessage = (conversation, fileDescriptor, data, voiceMessage) => {\n            var message = conversation.sendEFSMessage(fileDescriptor, data, voiceMessage);\n            this.pendingMessages[message.id] = { conversation: conversation, message: message };\n            $rootScope.$broadcast("ON_SEND_EFS_MESSAGE", fileDescriptor);\n            return message;\n        };\n        /**\n         * SEND CHAT MESSAGE\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.sendChatMessage = (conversation, data, alternativeContent) => {\n            var message = conversation.sendChatMessage(data, null, alternativeContent);\n            this.pendingMessages[message.id] = { conversation: conversation, message: message };\n            return message;\n        };\n        /**\n         * SEND Answer CHAT MESSAGE\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.sendAnswerChatMessage = (conversation, data, answeredMsg) => {\n            var message = conversation.sendChatMessage(data, answeredMsg);\n            this.pendingMessages[message.id] = { conversation: conversation, message: message };\n            return message;\n        };\n        /**\n         * SEND ISTyping\n         * Used by SDK (public)\n         */\n        this.sendIsTypingState = (conversation, isTypingState) => {\n            conversation.sendIsTypingState(isTypingState);\n        };\n        /**\n         * SEND RECORDING MESSAGE\n         */\n        this.sendRecordingMessage = (conversation, data) => {\n            var message = conversation.sendRecordingMessage(data);\n            this.pendingMessages[message.id] = { conversation: conversation, message: message };\n            return message;\n        };\n        /**\n         * SEND CORRECTED MESSAGE\n         */\n        this.sendCorrectedChatMessage = (conversation, data, origMsgId) => {\n            var originalMessage = conversation.getMessageById(origMsgId);\n            if (originalMessage.from.jid !== contactService.userContact.jid) {\n                $log.info("[conversationService] sendCorrectedChatMessage forbidden Action - only sent messages can be modified");\n                return;\n            }\n            if (conversation.lastEditableMsg.id !== originalMessage.id) {\n                $log.info("[conversationService] sendCorrectedChatMessage forbidden Action - only last sent message can be modified");\n                return;\n            }\n            var sentMessageId = conversation.sendCorrectedChatMessage(originalMessage, data, origMsgId);\n            this.pendingMessages[sentMessageId] = { conversation: conversation, message: originalMessage };\n        };\n        /**\n         * REMOVE ALL MESSAGES\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.removeAllMessages = (conversation) => {\n            $log.info("[conversationService] removeAllMessage " + conversation.id);\n            // Create the defered object\n            var defered = $q.defer();\n            var mamRequestId = xmppService.connection.getUniqueId();\n            var mamRequest = {\n                "queryid": mamRequestId,\n                "with": conversation.id,\n                "onComplete": () => {\n                    // FIXME : handle error message (ask Andreï)\n                    defered.resolve();\n                }\n            };\n            var queryId = xmppService.connection.getUniqueId();\n            // Request for history messages\n            xmppService.connection.mam.delete(queryId, mamRequest);\n            return defered.promise;\n        };\n        this.removeMessagesFromConversation = (conversation, date, number) => {\n            $log.info("[conversationService] removeMessagesFromConversation " + conversation.id);\n            $log.info("[conversationService] removing " + number + " messages after " + date);\n            // Create the defered object\n            var defered = $q.defer();\n            var mamRequest = {\n                "queryid": "remove_" + conversation.id,\n                "with": conversation.id,\n                "start": moment(date).format("YYYY-MM-DDTHH:mm:ss.SSSSSSZ"),\n                "max": number,\n                "onComplete": () => {\n                    $log.info("[conversationService] MAM Message deleted !!!");\n                    defered.resolve();\n                }\n            };\n            // Request for history messages\n            xmppService.connection.mam.delete(conversation.id, mamRequest);\n            return defered.promise;\n        };\n        this.sendConversationByEmail = (conversation) => {\n            var defered = $q.defer();\n            var userContact = contactService.userContact;\n            var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + userContact.dbId + "/conversations/" + conversation.dbId + "/downloads";\n            $http({ method: "POST", url: url, headers: authService.getRequestHeader(), data: {} })\n                .then(() => {\n                $log.error("[conversationService] sendConversationByEmail - success");\n                defered.resolve();\n            }, (response) => {\n                var error = { message: "Impossible to download conversation", messageKey: null };\n                if (response && response.data && response.data.errorDetailsCode === 409011) {\n                    error.message = "No messages to export for the last 30 days.";\n                    error.messageKey = "noMessagesToExport";\n                }\n                $log.error("[adminUserService] sendConversationByEmail - " + error.message);\n                defered.reject(error);\n            });\n            return defered.promise;\n        };\n        /*********************************************************/\n        /**                   HISTORY STUFF                     **/\n        /*********************************************************/\n        /**\n         * GET HISTORY PAGE\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.getHistoryPage = (conversation, size) => {\n            //should not get the history page if the service is reinitializing\n            if (!service.isReinit) {\n                return service.conversationHistoryHandler.getHistoryPage(conversation, size);\n            }\n            $log.debug("[conversationService] getHistoryPage --- service is reinitialising !");\n            return $q.reject(new Error("Service is reinitialising !"));\n        };\n        this.getHistoryPageAroundMsg = (conversation, centeredMsgDate) => {\n            return service.conversationHistoryHandler.getHistoryPageAroundMsg(conversation, SEARCHTEXT_MESSAGES_AROUND_LIMIT, centeredMsgDate + "000");\n        };\n        this.retrieveMsgByDate = (conversation, msgDate) => {\n            $log.debug("[conversationService] >retrieveMsgByDate: " + msgDate);\n            return service.conversationHistoryHandler.retrieveMsgByDate(conversation, msgDate + "000");\n        };\n        this.clearSearchText = () => {\n            $log.debug("[conversationService] - clearSearchText");\n            this.searchTextResults.clearAll();\n        };\n        this.clearAndGetAllMessagesResults = (searchedText, rooms) => {\n            $log.debug("[conversationService] - clearAndGetAllMessagesResults");\n            this.searchTextResults.clearAll();\n            this.searchTextResults.searchCount();\n            var promisesArray = [];\n            rooms.forEach((room) => {\n                if (!room.desc || (room.desc && !room.desc.startsWith("Rainbow_OutlookCreation_InternalUseOnly"))) {\n                    promisesArray.push(service.searchTextInRoom(contactService.userContact.jid, room, searchedText, SEARCHTEXT_INROOM_LIMIT, service.searchTextResults.searchCounter));\n                }\n            });\n            $q.all(promisesArray).finally(() => {\n                $log.debug("[conversationService] - ALL SearchText Promises finished");\n                service.searchTextInConversations(searchedText, SEARCHTEXT_INALLCONVERSATIONS_LIMIT);\n            });\n        };\n        this.searchTextInConversations = (searchedText, limitSize) => {\n            $log.debug("[conversationService] - searchTextInConversations: " + searchedText);\n            var defered = $q.defer();\n            var queryId = xmppService.connection.getUniqueId();\n            this.searchTextResults.queryIds.push(queryId);\n            this.searchTextResults.searchedText = searchedText;\n            $log.debug("[conversationService] - searchTextResults QueryId: " + queryId);\n            service.conversationHistoryHandler.searchTextInConversations(queryId, searchedText, limitSize)\n                .then((count) => {\n                service.searchTextResults.totalCount += parseInt(count, 10);\n                service.searchTextResults.results.forEach((item) => {\n                    item.convRes.sort((res1, res2) => {\n                        if (!res1.date) {\n                            return -1;\n                        }\n                        if (!res2.date) {\n                            return 1;\n                        }\n                        return moment(res1.date).diff(moment(res2.date));\n                    });\n                    if (!item.isRoom()) {\n                        service.getConversationTextCount(searchedText, item.otherJid).then((convCount) => {\n                            item.totalCount = parseInt(convCount, 10);\n                        });\n                        var contact = contactService.getContactByJid(item.otherJid);\n                        if (contact) {\n                            item.contact = contact;\n                            if (!contact.avatar) {\n                                contact.getAvatar();\n                            }\n                        }\n                        else {\n                            // Resolve Contact :\n                            contactService.getContactsByJids([item.otherJid])\n                                .then(() => {\n                                $log.info("[conversations] getContactsByJids success");\n                                contact = contactService.getContactByJid(item.otherJid);\n                                if (contact) {\n                                    item.contact = contact;\n                                    if (!contact.avatar) {\n                                        contact.getAvatar();\n                                    }\n                                }\n                                else {\n                                    $log.info("[conversations] Contact with Id " + item.otherJid + " not Found");\n                                    var itemIndex = service.searchTextResults.results.indexOf(item);\n                                    if (itemIndex >= 0) {\n                                        // Remove obsolete item\n                                        service.searchTextResults.results.splice(itemIndex, 1);\n                                        service.searchTextResults.totalCount -= item.totalCount;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    defered.resolve(parseInt(count, 10));\n                });\n            }).catch((error) => {\n                $log.warn("[conversationService] - searchTextInConversations: Error " + error.message);\n                defered.reject(error);\n            });\n            return defered.promise;\n        };\n        // Only for Peer2Peer conversation\n        this.searchTextResultsInConversation = (searchedText, conversation) => {\n            $log.debug("[conversationService] - searchTextResultsInConversation: " + searchedText);\n            var defered = $q.defer();\n            var queryId = xmppService.connection.getUniqueId();\n            this.searchTextResults.queryIds.push(queryId);\n            if (conversation.room) {\n                service.searchTextInRoom(contactService.userContact.jid, conversation.room, searchedText, SEARCHTEXT_INROOM_LIMIT, this.searchTextResults.searchCounter)\n                    .then((count) => {\n                    var searchTextResult = service.searchTextResults.createNewResult(conversation.id);\n                    // searchTextResult.otherJid = conversation.id;\n                    searchTextResult.totalCount = parseInt(count, 10);\n                    searchTextResult.conversation = conversation;\n                    searchTextResult.room = conversation.room;\n                    service.searchTextResults.results.forEach((item) => {\n                        item.convRes.sort((res1, res2) => {\n                            if (!res1.date) {\n                                return -1;\n                            }\n                            if (!res2.date) {\n                                return 1;\n                            }\n                            return moment(res1.date).diff(moment(res2.date));\n                        });\n                    });\n                    service.searchTextResults.totalCount = parseInt(count, 10);\n                    defered.resolve(parseInt(count, 10));\n                });\n            }\n            else {\n                service.conversationHistoryHandler.searchTextResultsInConversation(queryId, searchedText, conversation.id, SEARCHTEXT_INROOM_LIMIT)\n                    .then((count) => {\n                    var searchTextResult = service.searchTextResults.createNewResult(conversation.id);\n                    // searchTextResult.otherJid = conversation.id;\n                    searchTextResult.totalCount = parseInt(count, 10);\n                    searchTextResult.contact = conversation.contact;\n                    searchTextResult.conversation = conversation;\n                    service.searchTextResults.results.forEach((item) => {\n                        item.convRes.sort((res1, res2) => {\n                            if (!res1.date) {\n                                return -1;\n                            }\n                            if (!res2.date) {\n                                return 1;\n                            }\n                            return moment(res1.date).diff(moment(res2.date));\n                        });\n                    });\n                    service.searchTextResults.totalCount = parseInt(count, 10);\n                    defered.resolve(parseInt(count, 10));\n                });\n            }\n            return defered.promise;\n        };\n        this.searchTextMoreResultsInConversation = (searchedText, conversation, messageDate) => {\n            $log.debug("[conversationService] - searchTextMoreResultsInConversation: " + searchedText);\n            var defered = $q.defer();\n            var queryId = xmppService.connection.getUniqueId();\n            this.searchTextResults.queryIds.push(queryId);\n            if (conversation.room) {\n                service.conversationHistoryHandler.searchTextMoreResultsInRoom(queryId, searchedText, contactService.userContact.jid, conversation.room.jid, messageDate + "000", SEARCHTEXT_INROOM_LIMIT)\n                    .then((count) => {\n                    service.searchTextResults.results.forEach((item) => {\n                        item.convRes.sort((res1, res2) => {\n                            if (!res1.date) {\n                                return -1;\n                            }\n                            if (!res2.date) {\n                                return 1;\n                            }\n                            return moment(res1.date).diff(moment(res2.date));\n                        });\n                    });\n                    defered.resolve(parseInt(count, 10));\n                });\n            }\n            else {\n                service.conversationHistoryHandler.searchTextMoreResultsInConversation(queryId, searchedText, conversation.id, messageDate + "000", SEARCHTEXT_INROOM_LIMIT)\n                    .then((count) => {\n                    service.searchTextResults.results.forEach((item) => {\n                        item.convRes.sort((res1, res2) => {\n                            if (!res1.date) {\n                                return -1;\n                            }\n                            if (!res2.date) {\n                                return 1;\n                            }\n                            return moment(res1.date).diff(moment(res2.date));\n                        });\n                    });\n                    defered.resolve(parseInt(count, 10));\n                });\n            }\n            return defered.promise;\n        };\n        this.getConversationTextCount = (searchedText, contactJid) => {\n            $log.debug("[conversationService] - getConversationTextCount: " + searchedText);\n            var queryId = xmppService.connection.getUniqueId();\n            this.searchTextResults.queryIds.push(queryId);\n            return service.conversationHistoryHandler.getConversationTextCount(queryId, searchedText, contactJid);\n        };\n        this.searchTextInRoom = (userJid, room, searchedText, limitSize, searchCount) => {\n            $log.debug("[conversationService] - searchTextInRoom: " + searchedText);\n            var defered = $q.defer();\n            if (this.searchTextResults.searchCounter !== searchCount) {\n                $log.debug("[conversationService] - counter has changed - skip promise");\n                return defered.promise;\n            }\n            var queryId = xmppService.connection.getUniqueId();\n            this.searchTextResults.queryIds.push(queryId);\n            service.conversationHistoryHandler.searchTextInRoom(queryId, userJid, room.jid, searchedText, limitSize)\n                .then((count) => {\n                $log.info("[conversationService] - searchTextInRoom: Room response received : " + count);\n                var countValue = parseInt(count, 10);\n                if (countValue > 0) {\n                    service.searchTextResults.totalCount += countValue;\n                    service.searchTextResults.results.forEach((item) => {\n                        if (item.otherJid === room.jid) {\n                            item.totalCount = parseInt(count, 10);\n                            item.room = room;\n                        }\n                    });\n                }\n                defered.resolve(count);\n            }).catch((error) => {\n                $log.warn("[conversationService] - searchTextInRoom: Error " + error.message);\n                defered.reject(error);\n            });\n            return defered.promise;\n        };\n        // ************************************************ //\n        // ** PUBLIC METHODS && PROPERTIES               ** //\n        // ************************************************ //\n        this.setActiveConversation = (conversation) => {\n            $log.debug("[conversationService] - setActiveConversation: " + (conversation ? conversation.id : "null"));\n            this.activeConversation = conversation;\n            return this.activeConversation;\n        };\n        this.setMostRecentConversationActive = () => {\n            // Select most recent conversation\n            var conversations = service.getConversations().sort(service.sortFunction);\n            if (conversations.length > 0) {\n                return this.setActiveConversation(conversations.first());\n            }\n            return this.setActiveConversation(null);\n        };\n        this.getActiveConversation = () => {\n            return this.activeConversation;\n        };\n        /**\n         * GET CONVERSATION BY ID\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.getConversationById = (conversationId) => {\n            if (!service.conversations) {\n                return null;\n            }\n            return service.conversations[conversationId];\n        };\n        /**\n         * GET ALL CONVERSATIONS\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n        this.getConversations = () => {\n            var conversationArray = [];\n            for (var key in service.conversations) {\n                if (service.conversations.hasOwnProperty(key)) {\n                    conversationArray.push(service.conversations[key]);\n                }\n            }\n            return conversationArray;\n        };\n        this.orderConversations = () => {\n            service.inCallConversations = [];\n            service.idleConversations = [];\n            service.involvedContactIds = [];\n            Object.keys(service.conversations).forEach((key) => {\n                var conversation = service.conversations[key];\n                if (conversation.type === Conversation.Type.ROOM) {\n                    // Only push room in conversation list if it is not a meeting with active conference\n                    if (conversation.room.owner && conversation.room.isMeetingRoom()) {\n                        var confSession = pstnConferenceService.getConferenceSessionById(conversation.room.getPstnConfEndpointId());\n                        if (confSession && confSession.isActive()) {\n                            return;\n                        }\n                    }\n                }\n                if (conversation.isInCall()) {\n                    service.inCallConversations.push(conversation);\n                }\n                else {\n                    service.idleConversations.push(conversation);\n                }\n                if (conversation.type === Conversation.Type.ONE_TO_ONE) {\n                    service.involvedContactIds.push(conversation.contact.id);\n                }\n            });\n            // Sort idle conversations\n            service.idleConversations.sort(service.sortFunction);\n            $log.info("[conversationService] orderConversations");\n            service.idleConversations.forEach((conv) => {\n                let log = conv.id + " || ";\n                log += (conv.lastModification) ? conv.lastModification.toString() : conv.creationDate;\n                $log.info(log);\n            });\n        };\n        this.getOrderedConversations = () => {\n            return { inCall: service.inCallConversations, idle: service.idleConversations, contactIds: service.involvedContactIds, favorites: service.favorites };\n        };\n        this.sortFunction = (aa, bb) => {\n            var aLast = aa.lastModification;\n            var aCreation = aa.creationDate;\n            var bLast = bb.lastModification;\n            var bCreation = bb.creationDate;\n            var aDate = aCreation;\n            var bDate = bCreation;\n            //get the most recent of the creation date or the last message date\n            if (!aLast && aCreation) {\n                aDate = aCreation;\n            }\n            else {\n                aDate = aLast;\n            }\n            if (!bLast && bCreation) {\n                bDate = bCreation;\n            }\n            else {\n                bDate = bLast;\n            }\n            return (bDate - aDate);\n        };\n        this.formatDate = (date) => {\n            return moment(date).utc().format("YYYY-MM-DDTHH:mm:ss") + "Z";\n        };\n        this.resetConversationMissedCounters = (conversation) => {\n            if ($rootScope.appVisible) {\n                conversation.missedCounter = 0;\n                conversation.missedCalls = 0;\n                this.updateMissedCounters();\n            }\n        };\n        this.decreaseMissedIMCounterForConversation = (conversation) => {\n            if (conversation.missedCounter > 0) {\n                conversation.missedCounter -= 1;\n            }\n            this.updateMissedCounters();\n        };\n        var currentMissedIMCounter = 0;\n        var currentMissedCallCounter = 0;\n        this.updateMissedCounters = () => {\n            var missedIMCounter = 0;\n            var missedCallCounter = 0;\n            var missedIMDetails = [];\n            Object.keys(service.conversations).forEach((key) => {\n                var conversation = service.conversations[key];\n                if (conversation.missedCounter !== 0) {\n                    missedIMCounter += conversation.missedCounter;\n                    missedIMDetails.push(conversation);\n                }\n                //for now, we don\'t take into account the missedCallCounter\n                //missedCallCounter += conversation.missedCalls;\n            });\n            if (missedIMCounter === currentMissedIMCounter && missedCallCounter === currentMissedCallCounter) {\n                return;\n            }\n            currentMissedIMCounter = missedIMCounter;\n            currentMissedCallCounter = missedCallCounter;\n            $rootScope.$broadcast("ON_MISSED_COUNTER_CHANGED_EVENT", {\n                missedIMCounter: missedIMCounter,\n                missedCallCounter: missedCallCounter,\n                missedIMDetails: missedIMDetails\n            });\n        };\n        // ************************************************ //\n        // ** ACTIONS                                    ** //\n        // ************************************************ //\n        this.dropConversationCall = (conversation) => {\n            // Release the telephony call\n            if (conversation.audioCall) {\n                telephonyService.releaseCall(conversation.audioCall);\n            }\n            // Release the video call\n            if (conversation.videoCall) {\n                videoService.attachLocalMediaStream(false);\n                videoService.attachDistantMediaStream(false);\n                videoService.releaseCall(conversation.videoCall);\n            }\n        };\n        this.holdConversationCall = (conversation) => {\n            if (conversation.audioCall) {\n                telephonyService.holdCall(conversation.audioCall);\n                // Release the video call\n                if (conversation.videoCall) {\n                    videoService.attachLocalMediaStream(false);\n                    videoService.attachDistantMediaStream(false);\n                    videoService.releaseCall(conversation.videoCall);\n                }\n            }\n        };\n        this.retrieveConversationCall = (conversation) => {\n            // Release the telephony call\n            if (conversation.audioCall) {\n                telephonyService.retrieveCall(conversation.audioCall);\n            }\n            // Release the video call\n            if (conversation.videoCall) {\n                $log.error("Not implemented for the moment");\n            }\n        };\n        // ************************************************ //\n        // ** CAPABILITIES                               ** //\n        // ************************************************ //\n        this.allowDesktopSharing = () => { return false; };\n        this.allowAdvancedDesktopSharing = () => { return false; };\n        this.updateConversationCall = (conversation, call) => {\n            // Update call\n            if (call.type === call_model_1.Call.Type.WEBRTC) {\n                conversation.videoCall = call;\n            }\n            else if (call.type === call_model_1.Call.Type.PHONE) {\n                conversation.audioCall = call;\n            }\n            call.setConversationId(conversation.id);\n            // Update conversation capabilities\n            this.computeCapabilitiesForContact(conversation.contact);\n            service.computeCapabilitiesForMyContact();\n        };\n        this.computeCapabilitiesForContact = (contact, skipUpdateConversation) => {\n            var telephony = false;\n            var webRTC = false;\n            var sharedDesktop = false;\n            var fileTransfert = false;\n            var addMedia = false;\n            var contactStatus = contact.status;\n            var fullJid = contact.fullJid;\n            var myContact = contactService.userContact;\n            //do not update\n            if (contact.jid === myContact.jid) {\n                this.computeCapabilitiesForMyContact();\n                return;\n            }\n            //temporary workaround for Call hors roster\n            var isContactInMyCompany = (contact.company && contactService.userContact.company && contact.company.name !== "Rainbow" && contact.company.name !== "Default" && contact.company.name === contactService.userContact.company.name);\n            // Get eventual conversation with this contact\n            var conversation = this.getConversationById(contact.id);\n            // Handle videoCall and sharedDesktop actions\n            if (videoService.started) {\n                var videoCall = conversation ? conversation.videoCall : null;\n                if ((!videoCall || videoCall.status === call_model_1.Call.Status.UNKNOWN) && ((contactStatus === "unknown" && isContactInMyCompany) || contactStatus === "online" || contactStatus === "online-mobile" || contactStatus === "away" || (contactStatus === "busy" && contact.message === "audioPhone"))) {\n                    //if user is not in another webrtc call with this contact\n                    webRTC = true;\n                    sharedDesktop = true;\n                }\n            }\n            // Handle audioCall\n            if (telephonyService.started) {\n                var phoneNumberAvailable = (contact.phonePro || (contact.phonePbx && contact.pbxId) || contact.mobilePro || contact.phonePerso || contact.mobilePerso);\n                var audioCalls = telephonyService.getActiveCallsForContact(contact);\n                if ((audioCalls.length === 0) && phoneNumberAvailable) {\n                    telephony = true;\n                }\n                //do not propose to add audio to sharing if user is already in pbx call with this online contact, or user is in mediapillar call\n                if (((audioCalls.length !== 0) || videoService.getMediaPillarAudioCall()) && fullJid) {\n                    addMedia = true;\n                }\n            }\n            // Handle fileTransfert\n            if (contactStatus === "online" || contactStatus === "busy" || contactStatus === "away" || contactStatus === "dnd") {\n                fileTransfert = true;\n            }\n            // Compute conversation capability\n            var capabilities = { telephony: telephony, webRTC: webRTC, sharedDesktop: sharedDesktop, fileTransfert: fileTransfert, mediaAvailable: (telephony || webRTC), addMedia: addMedia };\n            // If Emily, remove the capabilities !\n            if (contact.isBot || (contact.displayName && contact.displayName.indexOf("E-HELPER") !== -1)) {\n                capabilities = { telephony: false, webRTC: false, sharedDesktop: false, fileTransfert: false, mediaAvailable: false, addMedia: false };\n            }\n            // Update contact capabilities\n            contact.capabilities = capabilities;\n            // Update conversation capabilities\n            if (conversation) {\n                conversation.capabilities = capabilities;\n                if (!skipUpdateConversation) {\n                    $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation, Conversation.EventType.CAPABILITIES);\n                }\n            }\n            $log.info(\'[conversationService] update capabilities for contact "\' + contact.displayNameForLog() + \'" capabilities (tel:\' + telephony + ", webRTC:" + webRTC + ", sharing: " + sharedDesktop + ", addMedia: " + addMedia + ")");\n        };\n        this.computeCapabilitiesForMyContact = () => {\n            var telephony = false;\n            var webRTC = false;\n            var sharedDesktop = false;\n            var myContact = contactService.userContact;\n            // Handle videoCall and sharedDesktop actions\n            if (videoService.started) {\n                var isInCallWebRtc = videoService.isUserContactInCall();\n                if (!isInCallWebRtc && (myContact.status !== "busy" || (myContact.status === "busy" && myContact.message === "audioPhone"))) {\n                    //if I\'m not in another webrtc call\n                    webRTC = true;\n                    if (service.allowDesktopSharing()) {\n                        sharedDesktop = true;\n                    }\n                }\n                if (isInCallWebRtc) {\n                    // If I\'m in a mediapillar audio webrtc call, the webRTC capability stays false (not possible to make a second webrtc call)\n                    // but the sharedDesktop capability must be evaluated if no sharing call already exists\n                    if (videoService.getMediaPillarAudioCall() && !videoService.getCurrentSharingCall() && service.allowDesktopSharing()) {\n                        sharedDesktop = true;\n                    }\n                }\n            }\n            // Handle audioCall\n            if (telephonyService.started) {\n                var calls = telephonyService.getCalls();\n                //CRRAINB-4813++ In mediapillar mode computer, forbid tel call when wbrtc call already engaged\n                if (webrtcGatewayService.isMediaPillarCallSituation() && (Object.keys(videoService.calls).length >= 1)) { //profile webrtcGateWay setted and webrtc call already engaged\n                    if (calls.length >= 1 && service.isSecondCallAllowed) { //but used for a media Pillar call\n                        telephony = true;\n                    }\n                    else { //webrtc resource used but not for webrtcgateway call then forbide webrtcgateway new call \n                        telephony = false;\n                    }\n                }\n                else { //not in mediaPillar mode or no webrtc call engaged\n                    if ((calls.length === 0 && service.isBasicCallAllowed) || (calls.length === 1 && service.isSecondCallAllowed)) {\n                        telephony = true;\n                    }\n                } //CRRAINB-4813--\t\t\t\t\n            }\n            // Compute conversation capability\n            var capabilities = { telephony: telephony, webRTC: webRTC, sharedDesktop: sharedDesktop, mediaAvailable: (telephony || webRTC) };\n            // Update contact capabilities\n            myContact.capabilities = capabilities;\n            // // Update conversation capabilities\n            // if (conversation) {\n            // \tconversation.capabilities = capabilities;\n            // \tif (!skipUpdateConversation) {\n            // \t\t$rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation);\n            // \t}\n            // }\n            $log.info("[conversationService] update capabilities for my contact : capabilities (tel:" + telephony + ", webRTC:" + webRTC + ", sharing: " + sharedDesktop + ")");\n        };\n        // ************************************************ //\n        // ** EVENT HANDLERS                             ** //\n        // ************************************************ //\n        this.onCallEvent = (__event, call) => {\n            switch (call.type) {\n                case call_model_1.Call.Type.WEBRTC:\n                    //CRRAINB-7438++\n                    // manage webrtc mediaPillar calls\n                    if (webrtcGatewayService.isMediaPillarJid(call.fullJid)) {\n                        //do not creat a webrtc conversation\n                        //but Send specific event for desktop (headset) to follow webrtc media acitivity\n                        $rootScope.$broadcast("ON_MPMEDIA_CONVERSATION_CALL_UPDATED_EVENT", {\n                            call: call //the callId for webrtc part\n                        });\n                        return;\n                    } //CRRAINB-7438--\n                    // Else create the webrtc conversation\n                    service.getOrCreateOneToOneConversation(call.contact.id)\n                        .then((conversation) => {\n                        // Attach this call to conversation\n                        service.updateConversationCall(conversation, call);\n                        // Re-order conversations\n                        service.orderConversations();\n                        // Send event\n                        $rootScope.$broadcast("ON_CONVERSATION_CALL_UPDATED_EVENT", {\n                            conversation: conversation,\n                            call: call\n                        });\n                    });\n                    break;\n                case call_model_1.Call.Type.PHONE:\n                    if (call.status === call_model_1.Call.Status.UNKNOWN) {\n                        //release webrtc calls (screen sharing) established with this contact (except if a pbx conference is established with the call contact)\n                        if (call.contact && !telephonyService.getConferenceCallForContact(call.contact)) {\n                            videoService.endAllCallsForContact(call.contact);\n                        }\n                        //If we are releasing a pbx conference call, we release also webrtc calls (screen sharing) established with any participant of the released conference\n                        if (call.isConference) {\n                            // We defer the release of webrtc calls with participants by 1 second, to be compatible with the end of the conference on Oxo usecase, \n                            // which clears the conference call, just before recreating a hold call with the participant: in this case , we don\'t clear the possible webrtc calls, \n                            // because we actually stay in call with the participant\n                            $interval(() => {\n                                (call.participants || []).forEach((participantContact) => {\n                                    if (participantContact && telephonyService.getActiveCallsForContact(participantContact).length === 0) {\n                                        videoService.endAllCallsForContact(participantContact);\n                                    }\n                                });\n                            }, 1000, 1);\n                        }\n                    }\n                    // Ignore ringing telephony event for mediapillar call\n                    //if ((call.status === Call.Status.RINGING_INCOMMING || call.status === Call.Status.QUEUED_INCOMMING) &&\n                    /*if ((call.status === Call.Status.RINGING_INCOMMING) &&\n                        webrtcGatewayService.isMediaPillarCallSituation(call)) {\n                        return;\n                    }*/\n                    if (webrtcGatewayService.isMediaPillarCallSituation(call)) {\n                        //see with Alex, when he\'ll come back\t\t\t\t\t\t\n                        if (!call.isSecondary) {\n                            $rootScope.$broadcast("ON_UPDATE_TELEPHONY_ICON_EVENT");\n                            return;\n                        }\n                        //if (call.status === Call.Status.RINGING_INCOMMING || call.status === Call.Status.QUEUED_INCOMMING) {return;}\n                        if (call.status === call_model_1.Call.Status.RINGING_INCOMMING) {\n                            /*fix CRRAINB-7525 do not display incomming call popup before webrtcgatewayService sync (=> remove PLE CRRAINB-6284 09/07/2019)\n                            $rootScope.$broadcast("ON_CONVERSATION_CALL_UPDATED_EVENT", {\n                                conversation: null,\n                                call: call\n                            });\n                            */\n                            return;\n                        }\n                    }\n                    if (call.status !== call_model_1.Call.Status.UNKNOWN && call.connectionId !== null) {\n                        $log.info("[ConversationService] onCallEvent -- " + call.connectionId + "  -- relevantEquipmentId : " + call.relevantEquipmentId);\n                        //var callEquipmentId = Call.getDeviceIdFromConnectionId(call.connectionId);//sipWise+\n                        var callEquipmentId = call.getDeviceIdFromConnectionIdFromCall(); //sipWise+\n                        if (callEquipmentId !== call.relevantEquipmentId && call.status !== call_model_1.Call.Status.ACTIVE) {\n                            //active state must be excluded of this filtering because only this state update the incomming popup\n                            $rootScope.$broadcast("ON_UPDATE_TELEPHONY_ICON_EVENT");\n                            return;\n                        }\n                    }\n                    $rootScope.$broadcast("ON_CONVERSATION_CALL_UPDATED_EVENT", {\n                        conversation: null,\n                        call: call\n                    });\n                    break;\n                default:\n                    break;\n            }\n        };\n        this.onReloadCapabilitiesForMyContactEvent = (__event) => {\n            $log.info("[conversationService] onReloadCapabilitiesForMyContactEvent");\n            service.computeCapabilitiesForMyContact();\n        };\n        this.onConversationEvent = () => {\n            service.updateMissedCounters();\n        };\n        this.onContactChangedEvent = (__event, contact) => {\n            service.computeCapabilitiesForContact(contact);\n            service.computeCapabilitiesForMyContact();\n        };\n        this.onTelephonyStateChangeEvent = (__event) => {\n            var conversations = service.getConversations();\n            if (conversations) {\n                conversations.forEach((conversation) => {\n                    if (conversation.type === Conversation.Type.ONE_TO_ONE) {\n                        service.computeCapabilitiesForContact(conversation.contact);\n                    }\n                });\n            }\n            service.computeCapabilitiesForMyContact();\n        };\n        this.onConferenceStateChangeEvent = () => {\n            service.updateRoomConferences();\n            service.orderConversations();\n            $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT");\n        };\n        this.onConferenceParticipantChangeEvent = () => {\n            service.orderConversations();\n            $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT");\n        };\n        this.onRoomChangedEvent = (__event, room, action) => {\n            if (room) {\n                var conversation = service.getConversationById(room.jid);\n                if (conversation) {\n                    if (action === "remove") {\n                        service.closeConversation(conversation);\n                    }\n                    else {\n                        conversation.room = room;\n                    }\n                }\n            }\n        };\n        this.onRoomHistoryChangedEvent = (__event, room) => {\n            if (room) {\n                var conversation = service.getConversationById(room.jid);\n                if (conversation && conversation.chatRenderer) {\n                    conversation.reset();\n                    conversation.chatRenderer.loadMore();\n                }\n            }\n        };\n        this.onRoomAdminMessageEvent = (__event, roomJid, userJid, type, msgId) => {\n            $log.info("[conversationService] onRoomAdminMessageEvent");\n            var conversation = service.getConversationById(roomJid);\n            if (conversation && type === "welcome" && conversation.room && conversation.room.ownerContact) {\n                userJid = conversation.room.ownerContact.jid;\n            }\n            var contact = contactService.getContactByJid(userJid);\n            if (conversation && contact) {\n                // If invitation msg and I\'m not the owner\n                if (!conversation.room.owner && type === "invitation") {\n                    return;\n                }\n                if (conversation.room && conversation.room.isMeetingRoom()) {\n                    return;\n                }\n                service.conversationServiceEventHandler.onRoomAdminMessageReceived(conversation, contact, type, msgId);\n            }\n        };\n        this.onRoomAddConferenceEvent = (__event) => {\n            $log.info("[conversationService] onRoomAddConferenceEvent");\n            service.orderConversations();\n            $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT");\n        };\n        this.onMyContactChangedEvent = () => {\n            var conversations = service.getOrderedConversations();\n            conversations.idle.forEach((conversation) => {\n                if (conversation.type === Conversation.Type.ONE_TO_ONE) {\n                    service.computeCapabilitiesForContact(conversation.contact);\n                }\n            });\n            service.computeCapabilitiesForMyContact();\n        };\n        /*********************************************************************/\n        /** Remove the conversation history                                 **/\n        /*********************************************************************/\n        this.reinit = () => {\n            var defered = $q.defer();\n            $log.info("[conversationService] Re-initialize conversation service");\n            // Remove all my conversation\n            if (service.activeConversation) {\n                service.activeConversation.reset();\n                service.activeConversation = null;\n            }\n            delete service.conversations;\n            service.conversations = [];\n            //bot service is ready\n            service.botServiceReady = true;\n            service.isReinit = true;\n            // Fetch conversations from server\n            $log.info("[conversationService] getServerConversations");\n            service.getServerConversations()\n                .then(() => {\n                service.isReinit = false;\n                service.linkAllActiveCallsToConversations();\n                //reset the missed im counter \n                $rootScope.$broadcast("ON_MISSED_COUNTER_CHANGED_EVENT", {\n                    missedIMCounter: currentMissedIMCounter,\n                    missedCallCounter: currentMissedCallCounter\n                });\n                defered.resolve();\n            }).catch(() => {\n                service.isReinit = false;\n                $interval(() => {\n                    $log.info("[conversationService] getServerConversations failure, try again");\n                    service.getServerConversations()\n                        .then(() => {\n                        service.linkAllActiveCallsToConversations();\n                    });\n                }, 10000, 1, true);\n                defered.resolve();\n            });\n            return defered.promise;\n        };\n        this.linkAllActiveCallsToConversations = () => {\n            // Handle current calls (FIXME : CERTAINLY NOT AT THE RIGHT PLACE!!!!)\n            for (var key in telephonyService.calls) {\n                if (telephonyService.calls.hasOwnProperty(key)) {\n                    var call = telephonyService.calls[key];\n                    $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n                }\n            }\n            // Handle current calls (FIXME : CERTAINLY NOT AT THE RIGHT PLACE!!!!)\n            for (var key in videoService.calls) {\n                if (videoService.calls.hasOwnProperty(key)) {\n                    var call = videoService.calls[key];\n                    $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n                }\n            }\n        };\n        /*********************************************************************/\n        /** BOT SERVICE IS RUNNING, CREATE ALL BOT CONVERSATIONS            **/\n        /*********************************************************************/\n        this.unlockWaitingBotConversations = (isBotServiceReady) => {\n            if (isBotServiceReady) {\n                service.botServiceReady = true;\n            }\n            if (service.botServiceReady) {\n                //stop infinite loop in case of error\n                service.botServiceReady = false;\n                service.waitingBotConversations.forEach((obj, index) => {\n                    var contact = contactService.getContactByJid(obj.jid);\n                    if (contact) {\n                        service.getOrCreateOneToOneConversation(contact.jid, obj.conversationDbId, obj.lastModification, obj.lastMessageText, obj.missedIMCounter, obj.muted, obj.creationDate);\n                        service.waitingBotConversations.splice(index, 1);\n                    }\n                });\n                service.waitingBotConversations = [];\n            }\n        };\n    }\n]);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/conversationService.ts?')},function(module,exports){eval('angular.module("rainbow").factory("ConversationServiceEventHandler", ["$q", "$log", "$rootScope", "contactService", "xmppService", "roomService", "Conversation", "Message", "fileStorageService", "fileServerService", "webrtcGatewayService", function ($q, $log, $rootScope, contactService, xmppService, roomService, Conversation, Message, fileStorageService, fileServerService, webrtcGatewayService) {\n  "use strict";\n  /*********************************************************************/\n\n  /** PUBLIC STATIC FACTORY                                           **/\n\n  /*********************************************************************/\n\n  ConversationServiceEventHandler.create = function (conversationService) {\n    return new ConversationServiceEventHandler(conversationService);\n  };\n  /*********************************************************************/\n\n  /** PRIVATE CONSTRUCTOR                                             **/\n\n  /*********************************************************************/\n\n\n  function ConversationServiceEventHandler(conversationService) {\n    this.conversationService = conversationService;\n  }\n  /*********************************************************************/\n\n  /** PUBLIC API                                                      **/\n\n  /*********************************************************************/\n\n\n  ConversationServiceEventHandler.prototype.onChatMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceEventHandler] onChatMessageReceived");\n\n    try {\n      var that = this;\n      var stanzaElem = $(stanza);\n\n      if (stanzaElem.find("event").length > 0 || stanzaElem.find("propose").length > 0 || stanzaElem.find("received").length > 0) {\n        $log.info("[ConversationServiceEventHandler] onChatMessageReceived ignore the message");\n      } else {\n        if (stanzaElem.find("recording").length > 0) {\n          //intercept recording msg\n          $log.info("[ConversationServiceEventHandler] onChatMessageReceived : recording msg case");\n          this.onRecordingMessageReceived(stanza);\n        } else {\n          this.extractStanzaData(stanza).then(function (stanzaData) {\n            if (stanzaData.body || stanzaData.oob || stanzaData.conference || stanzaData.replace) {\n              that.handleChatMessage(stanzaData);\n            } else if (!stanzaData.outgoingMessage && !contactService.isUserContact(stanzaData.participant) && stanzaData.status) {\n              that.handleStatusMessage(stanzaData.conversation, stanzaData.participant, stanza);\n            }\n          });\n        }\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[ConversationServiceEventHandler] onChatMessageReceived ERROR " + error);\n      return true;\n    }\n  };\n\n  ConversationServiceEventHandler.prototype.onConferenceMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceEventHandler] onConferenceMessageReceived");\n\n    try {\n      var that = this;\n      var stanzaElem = $(stanza);\n\n      if (stanzaElem.find("event").length > 0) {\n        this.extractStanzaData(stanza).then(function (stanzaData) {\n          if (stanzaData.conference) {\n            that.handleChatMessage(stanzaData);\n          }\n        });\n      } else {\n        $log.info("[ConversationServiceEventHandler] onConferenceMessageReceived ignore the message");\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[ConversationServiceEventHandler] onConferenceMessageReceived ERROR " + error);\n      return true;\n    }\n  };\n\n  ConversationServiceEventHandler.prototype.onFileTransfertReceived = function (fileTransfert) {\n    var bareJid = xmppService.getBareJidFromJid(fileTransfert.from);\n    var that = this; // Get the associated conversation\n\n    this.conversationService.getOrCreateOneToOneConversation(bareJid).then(function (conversation) {\n      var participant = conversation.contact; // Add message\n\n      var messageId = Conversation.getUniqueMessageId();\n      var message = conversation.addFTMessage(participant, new Date(), fileTransfert, messageId);\n      conversation.setStatusMessage(participant, Conversation.Status.ACTIVE); // Update counter\n\n      if (conversation !== that.conversationService.activeConversation || !$rootScope.appVisible || $rootScope.activeApplication !== "conversations") {\n        conversation.missedCounter += 1;\n      } // Always ack the message\n\n\n      conversation.sendAckReceivedMessage(message); // Send conversations update event\n\n      $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation, Conversation.EventType.FILE);\n    });\n  };\n\n  ConversationServiceEventHandler.prototype.onRoomAdminMessageReceived = function (conversation, contact, type, msgId) {\n    $log.info("[ConversationServiceEventHandler] onRoomAdminMessageReceived");\n    var that = this; // Add message\n\n    var message = conversation.addAdminBubbleMessage(contact, new Date(), type, msgId);\n    conversation.setStatusMessage(contact, Conversation.Status.ACTIVE);\n    conversation.sendAckReceivedMessage(message); // Update counter\n\n    if (conversation !== that.conversationService.activeConversation || !$rootScope.appVisible || $rootScope.activeApplication !== "conversations") {\n      conversation.missedCounter += 1;\n    } // else {\n    //     conversation.sendAckReadMessage(message);\n    // }\n    // Send conversations update event\n\n\n    $rootScope.$broadcast("ON_CONVERSATION_MESSAGE_RECEIVED", message, conversation, false);\n    $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation, Conversation.EventType.IM);\n  };\n\n  ConversationServiceEventHandler.prototype.onFileMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceEventHandler] onFileMessageReceived");\n\n    try {\n      this.extractStanzaData(stanza).then(function (stanzaData) {\n        if (stanzaData.body) {\n          var conversation = stanzaData.conversation;\n          conversation.addFileMessage(stanzaData.participant, stanzaData.date, stanzaData.body, stanzaData.messageId);\n          conversation.setStatusMessage(stanzaData.participant, Conversation.Status.ACTIVE);\n          $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation, Conversation.EventType.FILE);\n        }\n      });\n      return true;\n    } catch (error) {\n      $log.error("[ConversationServiceEventHandler] onFileMessageReceived ERROR " + error);\n      return true;\n    }\n  };\n\n  ConversationServiceEventHandler.prototype.onWebRTCMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceEventHandler] onWebRTCMessageReceived");\n\n    try {\n      // Treat new call_log messages\n      if (angular.element(stanza).find("call_log").length > 0) {\n        this.extractWebrtcStanzaData(stanza).then(function (stanzaData) {\n          if (stanzaData && stanzaData.body) {\n            var conversation = stanzaData.conversation;\n            conversation.addWebRTCMessage(stanzaData.participant, stanzaData.date, stanzaData.body, stanzaData.messageId);\n            conversation.setStatusMessage(stanzaData.participant, Conversation.Status.ACTIVE);\n            $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation);\n          }\n        });\n      } else {\n        // Compatibility with old messages\n        this.extractStanzaData(stanza).then(function (stanzaData) {\n          if (stanzaData && stanzaData.body) {\n            var conversation = stanzaData.conversation;\n            conversation.addWebRTCMessage(stanzaData.participant, stanzaData.date, stanzaData.body, stanzaData.messageId);\n            conversation.setStatusMessage(stanzaData.participant, Conversation.Status.ACTIVE);\n            $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation);\n          }\n        });\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[ConversationServiceEventHandler] onWebRTCMessageReceived error " + error);\n      return true;\n    }\n  };\n\n  ConversationServiceEventHandler.prototype.onManagementMessageReceived = function (stanza) {\n    try {\n      var that = this;\n      var stanzaElem = angular.element(stanza);\n      var conversationElem = stanzaElem.find("conversation");\n\n      if (conversationElem) {\n        var action = conversationElem.attr("action");\n        var conversationGetterPromise = null;\n\n        if (action === "create") {\n          var jid = xmppService.getBareJidFromJid(conversationElem.find("peer").text());\n          var convType = conversationElem.find("type").text();\n          conversationGetterPromise = this.conversationService.getConversationAsyncById(jid, convType);\n        } else {\n          conversationGetterPromise = $q.resolve(this.conversationService.getConversationByDbId(conversationElem.attr("id")));\n        }\n\n        conversationGetterPromise.then(function (conversation) {\n          $log.info("[ConversationServiceEventHandler] onManagementMessageReceived (" + action + " conversation)");\n\n          if (conversation) {\n            switch (action) {\n              case "create":\n                conversation.dbId = conversationElem.attr("id");\n                conversation.lastModification = new Date(conversationElem.find("lastMessageDate").text());\n                conversation.missedCounter = parseInt(conversationElem.find("unreadMessageNumber").text(), 10) || 0;\n                conversation.muted = conversationElem.find("mute").text() === "true";\n                that.conversationService.favoriteService.updateFavorites(conversation);\n                that.conversationService.orderConversations();\n                $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT");\n                break;\n\n              case "delete":\n                that.conversationService.removeConversation(conversation);\n                break;\n\n              default:\n                break;\n            }\n          } else if (action === "create") {\n            var convId = xmppService.getBareJidFromJid(conversationElem.find("peer").text());\n            var convDbId = conversationElem.attr("id");\n            var lastModification = new Date(conversationElem.find("lastMessageDate").text());\n            var lastMessageText = conversationElem.find("lastMessageText").text();\n            var lastMessageSender = conversationElem.find("lastMessageSender").text();\n            var missedIMCounter = parseInt(conversationElem.find("unreadMessageNumber").text(), 10) || 0;\n            var muted = conversationElem.find("mute").text() === "true";\n            var type = conversationElem.find("type").text();\n            var conversationGetter = type === "room" ? "getRoomConversation" : "getOrCreateOneToOneConversation";\n            that.conversationService[conversationGetter](convId).then(function (conv) {\n              $log.info("[ConversationServiceEventHandler] onManagementMessageReceived update conversation (" + conv.id + ")");\n              conv.dbId = convDbId;\n              conv.lastModification = lastModification ? new Date(lastModification) : undefined;\n              conv.lastMessageText = lastMessageText;\n              conv.lastMessageSender = lastMessageSender;\n              conv.muted = muted;\n              conv.preload = true;\n              conv.missedCounter = missedIMCounter;\n\n              if (type === Conversation.Type.BOT) {\n                conv.type = Conversation.Type.ONE_TO_ONE;\n              }\n\n              that.conversationService.favoriteService.updateFavorites(conv);\n              $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conv);\n            });\n          }\n        });\n      } // Handle mute/unmute room                        \n\n\n      if (stanzaElem.find("mute") || stanzaElem.find("unmute")) {\n        var muteElem = stanzaElem.find("mute");\n        var mute = false;\n\n        if (muteElem.length) {\n          if (muteElem.text().length) {\n            mute = muteElem.text() === "true";\n          } else {\n            mute = true;\n          }\n        }\n\n        var conversationDbId = stanzaElem.find("mute").attr("conversation") || stanzaElem.find("unmute").attr("conversation");\n        var conversation = this.conversationService.getConversationByDbId(conversationDbId);\n\n        if (conversation) {\n          $log.info("[ConversationServiceEventHandler] onManagementMessageReceived : mute is changed to " + mute);\n          conversation.muted = mute;\n        }\n      }\n    } catch (error) {\n      $log.error("[ConversationServiceEventHandler] onManagementMessageReceived error " + error);\n      return true;\n    }\n\n    return true;\n  };\n\n  ConversationServiceEventHandler.prototype.onReceiptMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceEventHandler] onReceiptMessageReceived");\n\n    try {\n      // Get stanza element\n      var stanzaElement = angular.element(stanza);\n      var messageSender = xmppService.getBareJidFromJid(stanzaElement.attr("from"));\n      var carbonStanza = stanzaElement.find("message");\n\n      if (contactService.isUserContactJid(messageSender) && carbonStanza.length > 0) {\n        stanzaElement = angular.element(carbonStanza);\n      } // Extract stanza data\n\n\n      var recvMessage = stanzaElement.find("received");\n\n      if (recvMessage.length && recvMessage.length > 0) {\n        var messageId = angular.element(recvMessage).attr("id");\n        var entity = angular.element(recvMessage).attr("entity");\n        var event = angular.element(recvMessage).attr("event"); // Handle server response\n\n        if (entity === "server" && event === "received") {\n          var messageInfo = this.conversationService.pendingMessages[messageId];\n\n          if (messageInfo && messageInfo.message) {\n            var message = messageInfo.message;\n            var conversation = messageInfo.conversation;\n            $log.info("[conversationService] Receive server ack (" + conversation.id + ", " + message.id + ")");\n            message.setReceiptStatus(Message.ReceiptStatus.SENT);\n            conversation.updateMessage(message);\n            delete this.conversationService.pendingMessages[messageId];\n            $rootScope.$broadcast("ON_CONVERSATION_RECEIPT_RECEIVED", message, conversation, "server");\n          }\n        } else if (entity === "client") {\n          var that = this;\n          this.extractStanzaData(stanza).then(function (stanzaData) {\n            that.handleReceiptReceiveMessage(stanzaData.conversation, stanza);\n            /*if (!stanzaData.outgoingMessage && !contactService.isUserContact(stanzaData.participant) && stanzaData.status) {\n                that.handleStatusMessage(stanzaData.conversation, stanzaData.participant, stanza);\n            }*/\n          });\n        }\n      } else if (stanzaElement.find("mark_as_read").length) {\n        var conversationId = stanzaElement.find("mark_as_read").attr("with");\n        var conversation = this.conversationService.getConversationById(conversationId);\n\n        if (conversation) {\n          switch (stanzaElement.find("mark_as_read").attr("id")) {\n            case "all-received":\n              // messages for this conversation have been acknowledged \n              conversation.missedCounter = 0;\n              break;\n\n            case "all-sent":\n              // messages for this conversation have been read\n              conversation.ackReadAllMessages();\n              break;\n\n            default:\n              $log.error("[ConversationServiceEventHandler] onReceiptMessageReceived error - unknown read type");\n              break;\n          }\n        }\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[ConversationServiceEventHandler] onReceiptMessageReceived error " + error);\n      return true;\n    }\n  };\n  /*********************************************************************/\n\n  /** PRIVATE METHODS                                                 **/\n\n  /*********************************************************************/\n\n\n  ConversationServiceEventHandler.prototype.extractStanzaData = function (stanza) {\n    // Extract message sender info\n    var messageSender = xmppService.getBareJidFromJid(angular.element(stanza).attr("from"));\n    var stanzaData = {};\n    var conversationId = null;\n    var resource = null;\n    var delay = null;\n    var defered = $q.defer();\n    var carbonStanza = angular.element(stanza).find("message"); // Handle carbon message\n\n    if (contactService.isUserContactJid(messageSender) && carbonStanza.length > 0) {\n      var from = xmppService.getBareJidFromJid(angular.element(carbonStanza).attr("from"));\n      var fromResource = xmppService.getResourceFromJid(angular.element(carbonStanza).attr("from"));\n      var to = xmppService.getBareJidFromJid(angular.element(carbonStanza).attr("to"));\n      var toResource = xmppService.getResourceFromJid(angular.element(carbonStanza).attr("to"));\n      stanzaData.outgoingMessage = contactService.isUserContactJid(from);\n      stanzaData.body = angular.element(carbonStanza).find("body").text();\n      stanzaData.participant = stanzaData.outgoingMessage ? contactService.userContact : null;\n      stanzaData.messageId = angular.element(carbonStanza).attr("id");\n      stanzaData.carbon = true;\n      stanzaData.answeredMsg = angular.element(carbonStanza).find("answeredMsg");\n      stanzaData.alternativeContent = angular.element(carbonStanza).find("content");\n      conversationId = stanzaData.outgoingMessage ? to : from;\n      resource = stanzaData.outgoingMessage ? toResource : fromResource;\n      delay = angular.element(carbonStanza).find("delay"); // To check today\n      // Handle FileSharing\n\n      var oob = angular.element(carbonStanza).find("x[xmlns=\'jabber:x:oob\']");\n\n      if (oob && oob.length) {\n        var url = angular.element(oob).find("url").text();\n        var mime = angular.element(oob).find("mime").text();\n        var filename = angular.element(oob).find("filename").text();\n        var filesize = angular.element(oob).find("size").text();\n        stanzaData.oob = {\n          url: url,\n          mime: mime,\n          filename: filename,\n          filesize: filesize\n        };\n      } // Handle Conference\n\n\n      var conference = $(stanza).find("x[xmlns=\'jabber:x:audioconference\']");\n\n      if (conference && conference.length) {\n        var conferenceElem = $(conference);\n        var subject = conferenceElem.attr("subject");\n        var confendpointid = conferenceElem.attr("confendpointid");\n        var jid = conference.attr("jid");\n        var type = conference.attr("type");\n        stanzaData.conference = {\n          type: type,\n          subject: subject,\n          confendpointid: confendpointid,\n          roomjid: jid,\n          ownerjid: conversationId\n        };\n      }\n\n      var replace = carbonStanza.find("replace");\n\n      if (replace && replace.length) {\n        var replaceId = replace.attr("id");\n        stanzaData.replace = {\n          id: replaceId\n        };\n      } // Compute conversation status\n\n\n      stanzaData.status = null;\n      var composing = angular.element(stanza).find("composing");\n      var paused = angular.element(stanza).find("paused");\n      var active = angular.element(stanza).find("active");\n\n      if (composing.length) {\n        stanzaData.status = "composing";\n      } else if (paused.length) {\n        stanzaData.status = "paused";\n      } else if (active.length) {\n        stanzaData.status = "active";\n      } // Handle geoloc\n\n\n      var geoloc = angular.element(carbonStanza).find("geoloc");\n\n      if (geoloc && geoloc.length) {\n        var geolocElem = $(geoloc);\n        var lon = geolocElem.find("lon").text();\n        var lat = geolocElem.find("lat").text();\n        stanzaData.geoloc = {\n          lon: lon,\n          lat: lat\n        };\n      } // Handle VoicMessage\n\n\n      var voiceMessage = angular.element(carbonStanza).find("voicemessage");\n\n      if (voiceMessage && voiceMessage.length) {\n        stanzaData.voiceMessage = true;\n      }\n    } // Handle standard message\n    else {\n        var stanzaElem = $(stanza);\n        stanzaData.outgoingMessage = false;\n        stanzaData.body = stanzaElem.find("body").text();\n        stanzaData.messageId = stanzaElem.attr("id");\n        stanzaData.carbon = false;\n        stanzaData.answeredMsg = stanzaElem.find("answeredMsg");\n        stanzaData.alternativeContent = stanzaElem.find("content");\n        conversationId = xmppService.getBareJidFromJid(stanzaElem.attr("from"));\n        resource = xmppService.getResourceFromJid(stanzaElem.attr("from"));\n        delay = stanzaElem.find("delay"); // To check today        \n\n        var archived = stanzaElem.find("retransmission").attr("source") === "push"; // Handle FileSharing\n\n        var oob = stanzaElem.find("x[xmlns=\'jabber:x:oob\']");\n\n        if (oob && oob.length) {\n          var oobElem = $(oob);\n          var url = oobElem.find("url").text();\n          var mime = oobElem.find("mime").text();\n          var filename = oobElem.find("filename").text();\n          var filesize = oobElem.find("size").text();\n          stanzaData.oob = {\n            url: url,\n            mime: mime,\n            filename: filename,\n            filesize: filesize\n          };\n        } // Handle geolocalisation\n\n\n        var geoloc = stanzaElem.find("geoloc");\n\n        if (geoloc && geoloc.length) {\n          var geolocElem = $(geoloc);\n          var lon = geolocElem.find("lon").text();\n          var lat = geolocElem.find("lat").text();\n          stanzaData.geoloc = {\n            lon: lon,\n            lat: lat\n          };\n        } // Handle VoicMessage\n\n\n        var voiceMessage = stanzaElem.find("voicemessage");\n\n        if (voiceMessage && voiceMessage.length) {\n          stanzaData.voiceMessage = true;\n        } // Handle Conference\n\n\n        var conference = stanzaElem.find("x[xmlns=\'jabber:x:audioconference\']");\n\n        if (conference && conference.length) {\n          var conferenceElem = $(conference);\n          var message = conferenceElem.attr("message");\n          var confendpointid = conferenceElem.attr("confendpointid");\n          var jid = conference.attr("jid");\n          var type = conference.attr("type");\n          stanzaData.conference = {\n            type: type,\n            message: message,\n            confendpointid: confendpointid,\n            roomjid: jid,\n            ownerjid: conversationId\n          }; // we really just want to show the message when it is a reminder\n\n          if (type === "reminder") {\n            conversationId = jid;\n          } else {\n            $log.debug("[conversationServiceEventHandler] ignored message stanza for conference");\n            defered.resolve(stanzaData);\n            return defered.promise;\n          }\n        }\n\n        var replace = stanzaElem.find("replace");\n\n        if (replace && replace.length) {\n          var replaceId = replace.attr("id");\n          stanzaData.replace = {\n            id: replaceId\n          };\n        } // Handle Markdown and other content type\n\n\n        stanzaData.additionalContent = null;\n        var contents = stanzaElem.find("content[xmlns=\'urn:xmpp:content\']");\n\n        if (contents) {\n          contents.each(function () {\n            if (!stanzaData.additionalContent) {\n              stanzaData.additionalContent = {};\n            }\n\n            var contentType = $(this).attr(\'type\');\n            var content = $(this).text(); // Specific to markdown => No regression with client and SDK\n\n            if ("text/markdown" === contentType) {\n              stanzaData.markdown = true;\n              stanzaData.body = content;\n            }\n\n            stanzaData.additionalContent[contentType] = {\n              type: contentType,\n              message: content\n            };\n          });\n        } // Handle subject\n\n\n        var subject = stanzaElem.find("subject");\n\n        if (subject && subject.text() !== "") {\n          stanzaData.subject = subject.text();\n        } // Compute conversation status\n\n\n        stanzaData.status = null;\n        var composing = stanzaElem.find("composing");\n        var paused = stanzaElem.find("paused");\n        var active = stanzaElem.find("active");\n\n        if (composing.length) {\n          stanzaData.status = "composing";\n        } else if (paused.length) {\n          stanzaData.status = "paused";\n        } else if (active.length) {\n          stanzaData.status = "active";\n        }\n      } // Handle common data\n\n\n    stanzaData.date = new Date();\n    stanzaData.offline = false;\n\n    if (delay.text() === "Offline Storage") {\n      stanzaData.date = new Date(delay.attr("stamp"));\n      stanzaData.offline = true;\n    } // Handle pushed messages\n\n\n    if (archived) {\n      var conversation = this.conversationService.getConversationById(conversationId);\n\n      if (!conversation) {\n        var cs = this.conversationService;\n        var createPromise = conversationId.startsWith("room_") ? cs.getRoomConversation(conversationId) : cs.getOrCreateOneToOneConversation(conversationId);\n        createPromise.then(function (conv) {\n          conversation = conv;\n          defered.reject();\n        });\n      } else {\n        defered.reject();\n      }\n\n      return defered.promise;\n    }\n\n    var existingConv = this.conversationService.getConversationById(conversationId);\n    stanzaData.convReady = existingConv && existingConv.dbId != null; // Get or create the associated conversation only if body or existing conversation\n\n    if (stanzaData.body || existingConv || stanzaData.oob || stanzaData.conference) {\n      // Handle room conversation\n      if (conversationId.indexOf("room_") === 0) {\n        var room = roomService.getRoomByJid(conversationId);\n        var subject = stanzaElem.find("subject");\n        var emptySubject = subject.length && subject.text() === ""; // Ignore message dediceted to un-accepted rooms\n\n        if (room && room.status !== "accepted" || emptySubject) {\n          $log.info("[conversationServiceEvent] extractStanzaData -- ignore this stanza message");\n        } else {\n          this.conversationService.getRoomConversation(conversationId).then(function (roomConv) {\n            stanzaData.conversation = roomConv;\n\n            if (stanzaData.conference && stanzaData.conference.ownerjid) {\n              return contactService.getOrCreateContact(stanzaData.conference.ownerjid);\n            }\n\n            if (resource && resource.indexOf("/") !== -1) {\n              resource = resource.split("/")[0];\n            }\n\n            return contactService.getOrCreateContact(resource);\n          }).then(function (contact) {\n            stanzaData.participant = contact;\n            defered.resolve(stanzaData);\n          })["catch"](function (error) {\n            $log.error("[conversationServiceEventHandler] impossible to fetch conversation " + error.message);\n            defered.reject();\n          });\n        }\n      } else {\n        this.conversationService.getOrCreateOneToOneConversation(conversationId).then(function (conv) {\n          stanzaData.conversation = conv;\n\n          if (!stanzaData.participant) {\n            stanzaData.participant = conv.contact;\n          }\n\n          defered.resolve(stanzaData);\n        })["catch"](function (error) {\n          $log.error("[conversationServiceEventHandler] impossible to fetch conversation " + error.message);\n          defered.reject();\n        });\n      }\n    } else if ($(stanza).find("deleted")) {\n      var deleted = $(stanza).find("deleted")[0];\n\n      if (deleted && deleted.getAttribute("id") === "all") {\n        var conv = this.conversationService.getConversationById(deleted.getAttribute("with"));\n\n        if (conv) {\n          $log.info("[conversationServiceEventHandler] Remove all messages for conversation " + conv.id);\n          conv.reset();\n        }\n      }\n    } else {\n      $log.debug("[conversationServiceEventHandler] ignored message stanza");\n      defered.reject();\n    }\n\n    return defered.promise;\n  };\n\n  ConversationServiceEventHandler.prototype.extractWebrtcStanzaData = function (stanza) {\n    $log.debug("[conversationServiceEventHandler] extractWebrtcStanzaData");\n    var that = this;\n    return $q(function (resolve, reject) {\n      // Extract message sender info\n      var stanzaData = {};\n      stanzaData.messageId = $(stanza).attr("id");\n      stanzaData.callerJid = $(stanza).find("caller").text();\n      stanzaData.calleeJid = $(stanza).find("callee").text();\n      stanzaData.state = $(stanza).find("state").text(); // Extract conversationId    \n\n      var conversationId = null;\n\n      if (!contactService.isUserContactJid(stanzaData.callerJid)) {\n        conversationId = stanzaData.callerJid;\n      } else {\n        conversationId = stanzaData.calleeJid;\n        stanzaData.participant = contactService.userContact;\n      } // Ignore Janus messages\n\n\n      if (conversationId.indexOf("janusgateway") !== -1) {\n        $log.debug("[conversationServiceEventHandler] extractWebrtcStanzaData -- ignore Janus message");\n        return reject();\n      } // Ignore MediaPillar messages\n\n\n      if (webrtcGatewayService.isMediaPillarJid(stanzaData.callerJid)) {\n        $log.debug("[conversationServiceEventHandler] extractWebrtcStanzaData -- ignore MediaPillar message");\n        return resolve();\n      } // Compute call duration\n\n\n      var duration = 0;\n\n      if ($(stanza).find("duration")) {\n        duration = parseInt($(stanza).find("duration").text(), 10);\n      }\n\n      if (duration > 0) {\n        stanzaData.duration = "(" + moment.duration(duration, "ms").format("h[H] mm[m] ss[s]") + ")";\n      } else {\n        stanzaData.duration = 0;\n      } // Compute call date\n\n\n      var date = $(stanza).find("date").text();\n\n      if (date) {\n        date = new Date(date);\n      }\n\n      stanzaData.date = date; // Fill body\n\n      stanzaData.body = "";\n\n      if (stanzaData.state === "missed") {\n        stanzaData.body = "missedCall||" + date;\n      } else if (stanzaData.state === "answered") {\n        stanzaData.body = "activeCallMsg||" + date + "||" + stanzaData.duration;\n      } // Get the associated conversation\n\n\n      that.conversationService.getOrCreateOneToOneConversation(conversationId).then(function (conversation) {\n        stanzaData.conversation = conversation;\n\n        if (!stanzaData.participant) {\n          stanzaData.participant = conversation.contact;\n        }\n\n        resolve(stanzaData);\n      })["catch"](function (error) {\n        $log.error("[conversationServiceEventHandler] impossible to fetch conversation " + error.message);\n        reject();\n      });\n    });\n  };\n\n  ConversationServiceEventHandler.prototype.handleChatMessage = function (stanzaData) {\n    // Create the chat message\n    $log.info("[ConversationServiceEventHandler] handleChatMessage");\n    var that = this;\n    var conversation = stanzaData.conversation;\n    var message = null;\n    var body = stanzaData.body;\n\n    if (stanzaData.oob) {\n      var url = stanzaData.oob.url;\n      var fileName = stanzaData.oob.filename;\n      var fileId = fileStorageService.extractFileIdFromUrl(url);\n      fileStorageService.retrieveAndStoreOneFileDescriptor(fileId).then(function (fileDescriptor) {\n        message = conversation.addFileSharingMessage(stanzaData.participant, stanzaData.date, stanzaData.body, stanzaData.messageId, fileId, fileName, stanzaData.geoloc, stanzaData.voiceMessage);\n        that.acknowledgeHandledChatMessage(stanzaData, conversation, message);\n        fileServerService.getBlobThumbnailFromFileDescriptor(fileDescriptor).then(function (blob) {\n          var newFileDescriptor = fileStorageService.getFileDescriptorById(fileDescriptor.id);\n          newFileDescriptor.previewBlob = blob;\n          $rootScope.$broadcast("ON_FILE_DESCRIPTOR_RECEIVED_EVENT", {\n            fileId: newFileDescriptor.id\n          });\n        });\n        $rootScope.$broadcast("ON_FILE_DESCRIPTOR_RECEIVED_EVENT", {\n          fileId: fileDescriptor.id\n        });\n      })["catch"](function (error) {\n        $log.info("[ConversationServiceEventHandler] handleChatMessage error " + error);\n      });\n    } else if (stanzaData.conference) {\n      var conferenceDescriptor = {\n        type: stanzaData.conference.type,\n        message: stanzaData.conference.subject,\n        confendpointid: stanzaData.conference.confendpointid,\n        roomjid: stanzaData.conference.roomjid\n      };\n      conversation = this.conversationService.getConversationById(conferenceDescriptor.roomjid);\n      $rootScope.$broadcast("ROOM_UPDATE_CONFID");\n\n      if (conversation) {\n        message = conversation.addConferenceMessage(stanzaData.participant, stanzaData.date, stanzaData.messageId, conferenceDescriptor);\n      } else {\n        return true;\n      }\n    } else if (stanzaData.replace) {\n      message = conversation.getMessageById(stanzaData.replace.id);\n\n      if (message && stanzaData.participant.jid !== message.from.jid) {\n        $log.warn("[ConversationServiceEventHandler] handleChatMessage : message Replaced by somebody else - Skip");\n        message = null;\n      } else {\n        if (!message) {\n          message = conversation.addChatMessage(stanzaData.participant, stanzaData.date, "", stanzaData.messageId, null, stanzaData.markdown, stanzaData.subject, null, null, stanzaData.additionalContent);\n        }\n\n        message.addReplaceMsg(stanzaData.messageId, body);\n      }\n    } else if (body.length > 0) {\n      var answeredMsgId = stanzaData.answeredMsg ? stanzaData.answeredMsg.text() : null;\n      var answeredMsgDate = stanzaData.answeredMsg ? stanzaData.answeredMsg.attr("stamp") : null;\n      var alternativeContent = stanzaData.alternativeContent.length > 0 ? {\n        type: stanzaData.alternativeContent.attr("type"),\n        message: stanzaData.alternativeContent.text()\n      } : null;\n      message = conversation.addChatMessage(stanzaData.participant, stanzaData.date, stanzaData.body, stanzaData.messageId, null, stanzaData.markdown, stanzaData.subject, answeredMsgId, answeredMsgDate, stanzaData.additionalContent, alternativeContent);\n    }\n\n    if (message) {\n      that.acknowledgeHandledChatMessage(stanzaData, conversation, message);\n    }\n  };\n\n  ConversationServiceEventHandler.prototype.acknowledgeHandledChatMessage = function (stanzaData, conversation, message) {\n    // Create the chat message\n    $log.info("[ConversationServiceEventHandler] acknowledgeHandledChatMessage");\n\n    if (!message) {\n      //ACK my messages inside a room (only for the device I\'ve used to send the message)\n      message = conversation.getMessageById(stanzaData.messageId);\n\n      if (conversation.room && message && message.side === Message.Side.RIGHT) {\n        conversation.sendAckReceivedMessage(message);\n      }\n\n      return true;\n    } // Handle received messages\n\n\n    if (message.side === Message.Side.LEFT) {\n      // If active conversation ack-read the message\n      if (conversation === this.conversationService.activeConversation && contactService.userContact.status !== "away" && $rootScope.appVisible && $rootScope.activeApplication === "conversations") {\n        conversation.sendAckReceivedMessage(message);\n      } // Else ack-received the message and increment missed counter\n      else {\n          conversation.sendAckReceivedMessage(message);\n\n          if (!stanzaData.offline && stanzaData.convReady) {\n            conversation.missedCounter += 1;\n          }\n        }\n\n      if (message.isTextModified()) {\n        //if message is already read, auto-ack the modification of the message (delete or modify)\n        if (message.receiptStatus === Message.ReceiptStatus.READ) {\n          conversation.sendAckReadOrReceivedMessage(stanzaData.messageId, "read");\n        }\n\n        conversation.updateMessage(message);\n      }\n    } else {\n      if (stanzaData.carbon) {\n        message.setReceiptStatus(Message.ReceiptStatus.SENT);\n      } else {\n        message.setReceiptStatus(Message.ReceiptStatus.IN_PROGRESS);\n      }\n\n      conversation.updateMessage(message);\n    }\n\n    conversation.setStatusMessage(stanzaData.participant, Conversation.Status.ACTIVE); // Send conversations update event\n\n    $rootScope.$broadcast("ON_CONVERSATION_MESSAGE_RECEIVED", message, conversation, stanzaData.carbon);\n    $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation);\n  };\n\n  ConversationServiceEventHandler.prototype.handleReceiptReceiveMessage = function (conversation, stanza) {\n    $log.info("[ConversationServiceEventHandler] handleReceiptReceiveMessage"); // Look for "received" child in stanza\n\n    var recvMessage = angular.element(stanza).find("received[xmlns=\'urn:xmpp:receipts\']");\n\n    if (recvMessage.length) {\n      // Get the associate message (if already available (can be not also load from mam))\n      var messageId = angular.element(recvMessage).attr("id");\n      var message = conversation.getMessageById(messageId);\n\n      if (message) {\n        var contactJid = angular.element(stanza).attr("from").split("/")[1];\n\n        if (!contactJid) {\n          contactJid = angular.element(stanza).attr("from");\n        }\n\n        var event = angular.element(recvMessage).attr("event"); //if room and message is send by me\n        //or P2P conversation\n\n        if (conversation.room && contactService.isUserContactJid(contactJid) || !conversation.room) {\n          // Update message receiptStatus\n          if (event === "received") {\n            message.setReceiptStatus(Message.ReceiptStatus.UNREAD);\n          } // Handle missed counter\n          else if (event === "read") {\n              message.setReceiptStatus(Message.ReceiptStatus.READ);\n              conversation.missedCounter = 0;\n            }\n        } //if P2P, update the timestamp \n        // if (!conversation.room) {\n        //     if (message.side === "R" || (contactService.isUserContactJid(contactJid) && event === "read")) {\n        //         var timestamp = angular.element(stanza).find("timestamp").attr("value");\n        //         if (timestamp) {\n        //             message.date = new Date(timestamp);\n        //         }\n        //     }\n        // }\n        //if I\'ve read the message on another device, update the missed Counter\n\n\n        if (contactService.isUserContactJid(contactJid) && event === "read" && message.side === "L") {\n          conversation.missedCounter = 0;\n        } // Update message \n\n\n        conversation.updateMessage(message); // Send conversations update event\n\n        $rootScope.$broadcast("ON_CONVERSATION_RECEIPT_RECEIVED", message, conversation, event);\n        $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation);\n      } else {\n        var temp = angular.element(stanza).attr("from");\n        var event = angular.element(recvMessage).attr("event");\n        var contactJid = "";\n\n        if (temp) {\n          contactJid = temp.split("/")[1];\n        }\n\n        if (!contactJid) {\n          contactJid = temp;\n        }\n\n        if (contactService.isUserContactJid(contactJid) && event === "read") {\n          //message does not exist on our client, check if we\'ve read it on another device\n          conversation.missedCounter = 0;\n          $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation);\n        }\n      }\n    }\n  };\n\n  ConversationServiceEventHandler.prototype.handleStatusMessage = function (conversation, participant, stanza) {\n    $log.info("[conversationServiceEventHandler] handleStatusMessage "); // Handle conversation status\n\n    var status = ""; //Incoming message from Android\n\n    if (angular.element(stanza).children().prop("tagName") === "thread") {\n      status = Conversation.stringToStatus(angular.element(angular.element(stanza).children()[1]).prop("tagName"));\n    } else {\n      status = Conversation.stringToStatus(angular.element(stanza).children().prop("tagName"));\n    }\n\n    conversation.setStatusMessage(participant, status);\n    $rootScope.$broadcast("ON_CONVERSATIONS_STATUS_MESSAGE_EVENT", conversation, participant, status);\n  };\n\n  ConversationServiceEventHandler.prototype.onRecordingMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceEventHandler] onRecordingMessageReceived");\n\n    try {\n      var msgContent = stanza.textContent;\n      this.extractStanzaData(stanza).then(function (stanzaData) {\n        if (msgContent === "start") {\n          var conversation = stanzaData.conversation;\n          conversation.addRecordingMessage(stanzaData.participant, stanzaData.date, msgContent, stanzaData.messageId);\n          conversation.setStatusMessage(stanzaData.participant, Conversation.Status.ACTIVE);\n          $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT", conversation);\n          $rootScope.$broadcast("ON_RECORDING_START_MSG_RECEIVED");\n        } else if (msgContent === "stop") {\n          var conversation = stanzaData.conversation;\n\n          if (conversation) {\n            conversation.addRecordingMessage(stanzaData.participant, stanzaData.date, msgContent, stanzaData.messageId);\n          }\n\n          $rootScope.$broadcast("ON_RECORDING_STOP_MSG_RECEIVED");\n        } else if (msgContent === "remoteStopVideo") {\n          $rootScope.$broadcast("ON_RECORDING_REMOTESTOPVIDEO_MSG_RECEIVED");\n        } else if (msgContent === "remoteChangeMediaVideo") {\n          $rootScope.$broadcast("ON_RECORDING_REMOTECHANGEMEDIAVIDEO_MSG_RECEIVED");\n        } else if (msgContent === "remoteStopSharing") {\n          $rootScope.$broadcast("ON_RECORDING_REMOTESTOPSHARING_MSG_RECEIVED");\n        } else if (msgContent === "remoteChangeMediaSharing") {\n          $rootScope.$broadcast("ON_RECORDING_REMOTECHANGEMEDIASHARING_MSG_RECEIVED");\n        }\n      });\n      return true;\n    } catch (error) {\n      $log.error("[ConversationServiceEventHandler] onRecordingMessageReceived error " + error);\n      return true;\n    }\n  };\n\n  return ConversationServiceEventHandler;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/conversationServiceEventHandler.js?')},function(module,exports){eval('angular.module("rainbow").factory("ConversationServiceHistoryHandler", ["$log", "$q", "$filter", "$rootScope", "xmppService", "contactService", "fileStorageService", "fileServerService", "Message", "SearchTextMsgResultFactory", function ($log, $q, $filter, $rootScope, xmppService, contactService, fileStorageService, fileServerService, Message, SearchTextMsgResultFactory) {\n  "use strict";\n  /*********************************************************************/\n\n  /** PUBLIC STATIC FACTORY                                           **/\n\n  /*********************************************************************/\n\n  ConversationServiceHistoryHandler.create = function (conversationService) {\n    return new ConversationServiceHistoryHandler(conversationService);\n  };\n  /*********************************************************************/\n\n  /** PRIVATE CONSTRUCTOR                                             **/\n\n  /*********************************************************************/\n\n\n  function ConversationServiceHistoryHandler(conversationService) {\n    this.conversationService = conversationService;\n  }\n  /*********************************************************************/\n\n  /** PUBLIC API                                                      **/\n\n  /*********************************************************************/\n\n\n  ConversationServiceHistoryHandler.prototype.getHistoryPage = function (conversation, nbMessages) {\n    var that = this;\n    var room = conversation.room;\n\n    if (room && room.initPresPromise) {\n      return room.initPresPromise.promise.then(function () {\n        return that.getHistoryPageInternal(conversation, nbMessages);\n      });\n    }\n\n    return this.getHistoryPageInternal(conversation, nbMessages);\n  };\n\n  ConversationServiceHistoryHandler.prototype.getHistoryPageInternal = function (conversation, size) {\n    // Avoid to call several time the same request\n    if (conversation.currentHistoryId && conversation.currentHistoryId === conversation.historyIndex) {\n      $log.info("[ConversationServiceHistoryHandler] getHistoryPage(" + conversation.id + ", " + size + ", " + conversation.historyIndex + ") already asked");\n      return $q.reject();\n    }\n\n    conversation.currentHistoryId = conversation.historyIndex;\n    $log.info("[ConversationServiceHistoryHandler] getHistoryPage(" + conversation.id + ", " + size + ", " + conversation.historyIndex + ")"); // Create the defered object\n\n    var defered = conversation.historyDefered = $q.defer(); // Do nothing for userContact\n\n    if (contactService.isUserContact(conversation.contact)) {\n      defered.reject();\n      return defered.promise;\n    }\n\n    if (conversation.historyComplete) {\n      $log.info("[ConversationServiceHistoryHandler] getHistoryPage(" + conversation.id + ") : already complete");\n      defered.reject();\n      return defered.promise;\n    }\n\n    var mamRequest = {\n      "queryid": conversation.id,\n      "with": conversation.id,\n      "max": size,\n      "before": ""\n    };\n\n    if (conversation.historyIndex !== -1) {\n      mamRequest.before = conversation.historyIndex;\n    } // Request for history messages for the room chat\n\n\n    if (conversation.room) {\n      mamRequest = {\n        "queryid": conversation.id,\n        "with": contactService.userContact.jid,\n        "max": size,\n        "before": ""\n      };\n\n      if (conversation.historyIndex !== -1) {\n        mamRequest.before = conversation.historyIndex;\n      }\n\n      xmppService.connection.mam.querymuc(conversation.id, conversation.room.jid, mamRequest);\n    } else {\n      // Request for history messages for the conversation\n      xmppService.connection.mam.query(conversation.id, mamRequest);\n    }\n\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.retrieveMsgByDate = function (conversation, msgDate) {\n    // Create the defered object\n    conversation.historyDefered = $q.defer();\n    var defered = $q.defer(); // Do nothing for userContact\n\n    if (contactService.isUserContact(conversation.contact)) {\n      defered.reject();\n      return defered.promise;\n    }\n\n    var queryId = "cache_" + conversation.id;\n    ConversationServiceHistoryHandler.prototype.getCommonHistoryPageAroundMsg(queryId, conversation, 1, msgDate, "after", function () {\n      $log.info("[ConversationServiceHistoryHandler] retrieveMsgByDate finished");\n      defered.resolve();\n    });\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.getHistoryPageAroundMsg = function (conversation, size, centeredMsgDate) {\n    // Create the defered object\n    conversation.historyDefered = $q.defer();\n    var defered = $q.defer(); // Do nothing for userContact\n\n    if (contactService.isUserContact(conversation.contact)) {\n      defered.reject();\n      return defered.promise;\n    }\n\n    ConversationServiceHistoryHandler.prototype.getCommonHistoryPageAroundMsg(conversation.id, conversation, size + 1, centeredMsgDate, "after", function () {\n      $log.info("[ConversationServiceHistoryHandler] getCommonHistoryPageAroundMsg BEFORE finished");\n      ConversationServiceHistoryHandler.prototype.getCommonHistoryPageAroundMsg(conversation.id, conversation, size, centeredMsgDate, "before", function () {\n        $log.info("[ConversationServiceHistoryHandler] getCommonHistoryPageAroundMsg AFTER finished");\n        defered.resolve();\n      }); // defered.resolve();\n    });\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.getCommonHistoryPageAroundMsg = function (queryId, conversation, size, centeredMsgDate, order, finishMethod) {\n    $log.info("[ConversationServiceHistoryHandler] getCommonHistoryPageAroundMsg(" + queryId + ", " + size + ", " + conversation.historyIndex + ")"); // Request for history messages for the room chat\n\n    if (conversation.room) {\n      var mamRequest = {\n        "queryid": queryId,\n        "with": contactService.userContact.jid,\n        "max": size,\n        onComplete: finishMethod\n      };\n      mamRequest[order] = centeredMsgDate;\n      xmppService.connection.mam.querymuc(queryId, conversation.room.jid, mamRequest);\n    } else {\n      var mamRequest = {\n        "queryid": queryId,\n        "with": conversation.id,\n        "max": size,\n        onComplete: finishMethod\n      };\n      mamRequest[order] = centeredMsgDate; // Request for history messages for the conversation\n\n      xmppService.connection.mam.query(queryId, mamRequest);\n    }\n  };\n\n  ConversationServiceHistoryHandler.prototype.searchTextInConversations = function (queryId, text, limitSize) {\n    $log.info("[ConversationServiceHistoryHandler] searchTextInConversations(" + text + ")");\n    var defered = $q.defer();\n    var iqId = xmppService.connection.getUniqueId();\n    var iq = $iq({\n      id: iqId,\n      type: "get"\n    }).c("query", {\n      queryid: queryId,\n      xmlns: "urn:xmpp:mam:tmp"\n    }).c("set", {\n      xmlns: "http://jabber.org/protocol/rsm"\n    }).c("max").t(limitSize).up().c("before").up().up().c("x", {\n      xmlns: "jabber:x:data",\n      type: "form"\n    }).c("field", {\n      "var": "FORM_TYPE",\n      type: "hidden"\n    }).c("value").t("urn:xmpp:mam:1").up().up().c("field", {\n      "var": "withtext",\n      type: "text-single"\n    }).c("value").t(text).up().up(); // Send "get MAM" iq\n\n    xmppService.sendIQ(iq).then(function (data) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Success: " + text);\n      var queryElem = $(data).find("query");\n      var count = queryElem.find("set").find("count").text();\n      $log.info("[ConversationServiceHistoryHandler] >searchTextInConversations: count= " + count);\n      defered.resolve(count);\n    })["catch"](function (error) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Failure: " + error.message);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.getConversationTextCount = function (queryId, text, contactJid) {\n    $log.info("[ConversationServiceHistoryHandler] getConversationTextCount(" + text + ")");\n    var defered = $q.defer(); // var now = Date.now();\n\n    var iqId = xmppService.connection.getUniqueId();\n    var iq = $iq({\n      id: iqId,\n      type: "get"\n    }).c("query", {\n      queryid: queryId,\n      xmlns: "urn:xmpp:mam:tmp"\n    }).c("set", {\n      xmlns: "http://jabber.org/protocol/rsm"\n    }).c("max").t("0").up().up().c("x", {\n      xmlns: "jabber:x:data",\n      type: "form"\n    }).c("field", {\n      "var": "FORM_TYPE",\n      type: "hidden"\n    }).c("value").t("urn:xmpp:mam:1").up().up().c("field", {\n      "var": "withtext",\n      type: "text-single"\n    }).c("value").t(text).up().up().c("field", {\n      "var": "with",\n      type: "text-single"\n    }).c("value").t(contactJid).up().up(); // Send "get MAM" iq\n\n    xmppService.sendIQ(iq).then(function (data) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Success: " + text);\n      var queryElem = $(data).find("query");\n      var count = queryElem.find("set").find("count").text();\n      $log.info("[ConversationServiceHistoryHandler] >getConversationTextCount: count= " + count);\n      defered.resolve(count);\n    })["catch"](function (error) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Failure: " + error.message);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.searchTextResultsInConversation = function (queryId, text, contactJid, limitSize) {\n    $log.info("[ConversationServiceHistoryHandler] searchTextResultsInConversation(" + text + ")");\n    var defered = $q.defer();\n    var iqId = xmppService.connection.getUniqueId();\n    var iq = $iq({\n      id: iqId,\n      type: "get"\n    }).c("query", {\n      queryid: queryId,\n      xmlns: "urn:xmpp:mam:tmp"\n    }).c("set", {\n      xmlns: "http://jabber.org/protocol/rsm"\n    }).c("max").t(limitSize).up().c("before").up().up().c("x", {\n      xmlns: "jabber:x:data",\n      type: "form"\n    }).c("field", {\n      "var": "FORM_TYPE",\n      type: "hidden"\n    }).c("value").t("urn:xmpp:mam:1").up().up().c("field", {\n      "var": "withtext",\n      type: "text-single"\n    }).c("value").t(text).up().up().c("field", {\n      "var": "with",\n      type: "text-single"\n    }).c("value").t(contactJid).up().up(); // Send "get MAM" iq\n\n    xmppService.sendIQ(iq).then(function (data) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Success: " + text);\n      var queryElem = $(data).find("query");\n      var count = queryElem.find("set").find("count").text();\n      $log.info("[ConversationServiceHistoryHandler] >getConversationTextCount: count= " + count);\n      defered.resolve(count);\n    })["catch"](function (error) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Failure: " + error.message);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.searchTextMoreResultsInConversation = function (queryId, text, contactJid, messageDate, limitSize) {\n    $log.info("[ConversationServiceHistoryHandler] searchTextMoreResultsInConversation(" + text + ")");\n    var defered = $q.defer();\n    var iqId = xmppService.connection.getUniqueId();\n    var iq = $iq({\n      id: iqId,\n      type: "get"\n    }).c("query", {\n      queryid: queryId,\n      xmlns: "urn:xmpp:mam:tmp"\n    }).c("set", {\n      xmlns: "http://jabber.org/protocol/rsm"\n    }).c("max").t(limitSize).up().c("before").t(messageDate).up().up().c("x", {\n      xmlns: "jabber:x:data",\n      type: "form"\n    }).c("field", {\n      "var": "FORM_TYPE",\n      type: "hidden"\n    }).c("value").t("urn:xmpp:mam:1").up().up().c("field", {\n      "var": "withtext",\n      type: "text-single"\n    }).c("value").t(text).up().up().c("field", {\n      "var": "with",\n      type: "text-single"\n    }).c("value").t(contactJid).up().up(); // Send "get MAM" iq\n\n    xmppService.sendIQ(iq).then(function (data) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Success: " + text);\n      var queryElem = $(data).find("query");\n      var count = queryElem.find("set").find("count").text();\n      $log.info("[ConversationServiceHistoryHandler] >getConversationTextCount: count= " + count);\n      defered.resolve(count);\n    })["catch"](function (error) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Failure: " + error.message);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.searchTextInRoom = function (queryId, userJid, roomJid, text, limitSize) {\n    $log.info("[ConversationServiceHistoryHandler] searchTextInRoom(" + text + ")");\n    var defered = $q.defer();\n    var iqId = xmppService.connection.getUniqueId();\n    var iq = $iq({\n      to: roomJid,\n      id: iqId,\n      type: "get"\n    }).c("query", {\n      queryid: queryId,\n      xmlns: "urn:xmpp:mam:tmp"\n    }).c("set", {\n      xmlns: "http://jabber.org/protocol/rsm"\n    }).c("max").t(limitSize).up().c("before").up().up().c("x", {\n      xmlns: "jabber:x:data",\n      type: "form"\n    }).c("field", {\n      "var": "FORM_TYPE",\n      type: "hidden"\n    }).c("value").t("urn:xmpp:mam:1").up().up().c("field", {\n      "var": "with",\n      type: "text-single"\n    }).c("value").t(userJid).up().up().c("field", {\n      "var": "withtext",\n      type: "text-single"\n    }).c("value").t(text).up().up(); // Send "get MAM" iq\n\n    xmppService.sendIQ(iq).then(function (data) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Success: " + text);\n      var queryElem = $(data).find("query");\n      var count = queryElem.find("set").find("count").text();\n      $log.info("[ConversationServiceHistoryHandler] >searchTextInRoom: count= " + count);\n      defered.resolve(count);\n    })["catch"](function (error) {\n      $log.info("[ConversationServiceHistoryHandler] >searchTextInRoom: Failure: " + error.message);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n\n  ConversationServiceHistoryHandler.prototype.searchTextMoreResultsInRoom = function (queryId, text, contactJid, roomJid, messageDate, limitSize) {\n    $log.info("[ConversationServiceHistoryHandler] searchTextMoreResultsInConversation(" + text + ")");\n    var defered = $q.defer();\n    var iqId = xmppService.connection.getUniqueId();\n    var iq = $iq({\n      to: roomJid,\n      id: iqId,\n      type: "get"\n    }).c("query", {\n      queryid: queryId,\n      xmlns: "urn:xmpp:mam:tmp"\n    }).c("set", {\n      xmlns: "http://jabber.org/protocol/rsm"\n    }).c("max").t(limitSize).up().c("before").t(messageDate).up().up().c("x", {\n      xmlns: "jabber:x:data",\n      type: "form"\n    }).c("field", {\n      "var": "FORM_TYPE",\n      type: "hidden"\n    }).c("value").t("urn:xmpp:mam:1").up().up().c("field", {\n      "var": "withtext",\n      type: "text-single"\n    }).c("value").t(text).up().up().c("field", {\n      "var": "with",\n      type: "text-single"\n    }).c("value").t(contactJid).up().up(); // Send "get MAM" iq\n\n    xmppService.sendIQ(iq).then(function (data) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Success: " + text);\n      var queryElem = $(data).find("query");\n      var count = queryElem.find("set").find("count").text();\n      $log.info("[ConversationServiceHistoryHandler] >getConversationTextCount: count= " + count);\n      defered.resolve(count);\n    })["catch"](function (error) {\n      $log.info("[ConversationServiceHistoryHandler] sendIq Failure: " + error.message);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n  /*********************************************************************/\n\n  /** PRIVATE METHODS                                                 **/\n\n  /*********************************************************************/\n\n\n  ConversationServiceHistoryHandler.prototype.onHistoryMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceHistoryHandler] onHistoryMessageReceived"); // Handle response\n\n    try {\n      var conversation = null;\n      var stanzaElem = $(stanza);\n      var queryId = stanzaElem.find("result").attr("queryid");\n\n      if (queryId) {\n        // Get associated conversation\n        conversation = this.conversationService.getConversationById(queryId);\n\n        if (conversation) {\n          if (stanzaElem.find("call_log").length) {\n            return this.onWebrtcHistoryMessageReceived(stanza, conversation);\n          } // Extract info\n\n\n          var brutJid = stanzaElem.find("forwarded message").attr("from"); // Extract fromJid\n\n          var fromJid;\n          var roomEvent = false;\n\n          if (brutJid && brutJid.indexOf("room_") === 0) {\n            fromJid = brutJid.split("/")[1];\n          } else {\n            fromJid = xmppService.getBareJidFromJid(stanzaElem.find("forwarded message").attr("from"));\n          }\n\n          if (!fromJid && stanzaElem.find("event").length) {\n            roomEvent = stanzaElem.find("event").attr("name");\n            fromJid = stanzaElem.find("event").attr("jid");\n\n            if (roomEvent === "welcome" && conversation.room && conversation.room.ownerContact) {\n              fromJid = conversation.room.ownerContact.jid;\n            }\n          }\n\n          if (!fromJid) {\n            $log.warn("[ConversationServiceHistoryHandler] onHistoryMessageReceived - Receive message without valid fromJid information");\n            return true;\n          }\n\n          var from = contactService.getContactByJid(fromJid);\n          var type = stanzaElem.find("forwarded message").attr("type");\n          var messageId = stanzaElem.find("forwarded message").attr("id");\n          var date = new Date(stanzaElem.find("forwarded delay").attr("stamp"));\n          var body = stanzaElem.find("forwarded message body").text();\n          var ack = stanzaElem.find("forwarded message ack");\n          var oob = stanzaElem.find("forwarded message x[xmlns=\'jabber:x:oob\']");\n          var conference = stanzaElem.find("forwarded message x[xmlns=\'jabber:x:bubble:conference:pstn\']");\n          var contents = stanzaElem.find("content[xmlns=\'urn:xmpp:content\']");\n          var replace = stanzaElem.find("replace");\n          var answeredMsg = stanzaElem.find("answeredMsg");\n          var alternativeContent = stanzaElem.find("content");\n          var side = contactService.isUserContact(from) ? Message.Side.RIGHT : Message.Side.LEFT;\n          var geoloc = stanzaElem.find("geoloc"); // Handle VoicMessage\n\n          var voiceMessage = stanzaElem.find("voicemessage");\n\n          if (voiceMessage && voiceMessage.length) {\n            var voiceMessageData = true;\n          }\n\n          if (geoloc && geoloc.length) {\n            var geolocElem = $(geoloc);\n            var lon = geolocElem.find("lon").text();\n            var lat = geolocElem.find("lat").text();\n            var geolocData = {\n              lon: lon,\n              lat: lat\n            };\n          }\n\n          if (!from) {\n            $log.warn("[ConversationServiceHistoryHandler] onHistoryMessageReceived missing contact for jid : " + fromJid + ", ignore message"); //create basic contact\n\n            from = contactService.createEmptyContactContact(fromJid);\n          }\n\n          if (roomEvent) {\n            $log.info("[ConversationServiceHistoryHandler] (" + conversation.id + ") add Room admin event message " + roomEvent);\n            type = "admin"; // Ignore meeting events\n\n            if (conversation.room && conversation.room.isMeetingRoom()) {\n              if (roomEvent === "welcome" || roomEvent === "conferenceAdd" || roomEvent === "conferenceRemove" || roomEvent === "invitation") {\n                return true;\n              }\n            }\n\n            if ((roomEvent === "conferenceAdd" || roomEvent === "conferenceRemove") && conversation.room && conversation.room.ownerContact) {\n              var userJid = stanzaElem.find("event").attr("jid");\n              var user = conversation.room.getUserByJid(userJid);\n              from = user && user.contact ? user.contact : conversation.room.ownerContact;\n            }\n          }\n\n          var message = conversation.getMessageById(messageId);\n\n          if (!message) {\n            message = conversation.historyMessages.find(function (item) {\n              return item.id === messageId;\n            });\n          }\n\n          if (message) {\n            $log.info("[ConversationServiceHistoryHandler] (" + conversation.id + ") try to add an already stored message with id " + message.id);\n          } else {\n            // Create new message \n            switch (type) {\n              case "file":\n                message = Message.createFileMessage(messageId, date, from, side, body, false);\n                break;\n\n              case "webrtc":\n                message = Message.createWebRTCMessage(messageId, date, from, side, body, false);\n                break;\n\n              case "admin":\n                message = Message.createBubbleAdminMessage(messageId, date, from, roomEvent);\n                break;\n\n              case "recording":\n                message = Message.createRecordingAdminMessage(messageId, date, from, "Admin");\n                break;\n\n              default:\n                if (oob && oob.length) {\n                  var oobElem = $(oob);\n                  var url = oobElem.find("url").text();\n                  var fileName = oobElem.find("filename").text();\n                  var fileId = fileStorageService.extractFileIdFromUrl(url);\n\n                  if (voiceMessageData) {\n                    message = Message.createVoiceMessage(messageId, date, from, side, body, false, fileId, fileName, voiceMessageData);\n                  } else {\n                    message = Message.createFileSharingMessage(messageId, date, from, side, body, false, fileId, fileName, geolocData);\n                  }\n\n                  fileStorageService.retrieveAndStoreOneFileDescriptor(fileId).then(function (fileDescriptor) {\n                    if (fileDescriptor && fileDescriptor.state === "not_uploaded") {\n                      message.receiptStatus = 1; // icon_ko\n\n                      message.fileErrorMsg = $filter("translate")("file_notuploaded");\n                    }\n\n                    fileServerService.getBlobThumbnailFromFileDescriptor(fileDescriptor).then(function successCallback(blob) {\n                      fileDescriptor.previewBlob = blob;\n                      $rootScope.$broadcast("ON_FILE_DESCRIPTOR_RECEIVED_EVENT", {\n                        fileId: fileDescriptor.id\n                      });\n                    });\n                    $rootScope.$broadcast("ON_FILE_DESCRIPTOR_RECEIVED_EVENT", {\n                      fileId: fileDescriptor.id\n                    });\n                  })["catch"](function (error) {\n                    $log.info("[ConversationServiceHistoryHandler] onHistoryMessageReceived error " + error);\n                  });\n                } else if (conference && conference.length) {\n                  var conferenceElem = $(conference);\n                  var subject = conferenceElem.attr("subject");\n                  var confendpointid = conferenceElem.attr("confendpointid");\n                  var jid = conference.attr("jid");\n                  var conferenceType = conference.attr("type");\n\n                  if (conferenceType === "reminder") {\n                    return true;\n                  } // No need for reminder messgaes in MaM\n\n\n                  var conferenceDescriptor = {\n                    subject: subject,\n                    confendpointid: confendpointid,\n                    roomjid: jid\n                  };\n                  message = Message.createConferenceMessage(messageId, date, from, side, false, conferenceDescriptor);\n                } else {\n                  var isMarkdown = false;\n                  var additionalContent = {}; // Handle additional content type\n\n                  if (contents) {\n                    contents.each(function () {\n                      var contentType = $(this).attr(\'type\');\n                      var content = $(this).text(); // Specific to markdown => No regression with client and SDK\n\n                      if ("text/markdown" === contentType) {\n                        isMarkdown = true;\n                        body = content;\n                      }\n\n                      additionalContent[contentType] = {\n                        type: contentType,\n                        message: content\n                      };\n                    });\n                  }\n\n                  if (replace && replace.length) {\n                    //   <replace xmlns=\'urn:xmpp:message-correct:0\' id=\'web_c777ffbe-7644-441b-ae8b-ecce3c14516f0\'></replace>\n                    var replacedMsgId = replace.attr("id");\n                    var replacedMessage = conversation.getMessageByIdInHistory(replacedMsgId);\n\n                    if (!replacedMessage) {\n                      replacedMessage = Message.create(replacedMsgId, date, from, side, body, false, isMarkdown, null, null, null, additionalContent);\n                      message = replacedMessage;\n                    }\n\n                    if (from.jid !== replacedMessage.from.jid) {\n                      $log.warn("[ConversationServiceHistoryHandler] onHistoryMessageReceived : message Replaced by somebody else - Skip");\n                      message = null;\n                    } else {\n                      if (replacedMessage) {\n                        replacedMessage.addReplaceMsg(messageId, body);\n                      }\n                    }\n                  } else {\n                    var answeredMsgId = answeredMsg ? answeredMsg.text() : null;\n                    var answeredMsgDate = answeredMsg ? answeredMsg.attr("stamp") : null;\n                    var alternativeContent = alternativeContent ? {\n                      type: alternativeContent.attr("type"),\n                      message: alternativeContent.text()\n                    } : null;\n                    message = Message.create(messageId, date, from, side, body, false, isMarkdown, null, answeredMsgId, answeredMsgDate, additionalContent, alternativeContent);\n                  }\n                }\n\n                break;\n            } // console.error("message "+ JSON.stringify(message.date));\n\n\n            if (message) {\n              message.receiptStatus = angular.element(ack).attr("read") === "true" ? 5 : angular.element(ack).attr("recv") === "true" ? 4 : 3;\n              $log.info("[ConversationServiceHistoryHandler] onHistoryMessageReceived : pushing msg inside historyMessages");\n              conversation.addMessageInHistoryMessages(message);\n            }\n          }\n        } else if (queryId.startsWith("cache_")) {\n          $log.info("[ConversationServiceHistoryHandler] onHistoryMessageReceived : Query Id for Cached Message");\n          var conversationId = queryId.substr(6);\n          conversation = this.conversationService.getConversationById(conversationId);\n\n          if (conversation) {\n            $log.info("[ConversationServiceHistoryHandler] onHistoryMessageReceived : Conversation Found"); // Extract fromJid\n\n            var fromJid;\n            var brutJid = stanzaElem.find("forwarded message").attr("from");\n\n            if (brutJid && brutJid.indexOf("room_") === 0) {\n              fromJid = brutJid.split("/")[1];\n            } else {\n              fromJid = xmppService.getBareJidFromJid(stanzaElem.find("forwarded message").attr("from"));\n            }\n\n            if (!fromJid && stanzaElem.find("event").length) {\n              roomEvent = stanzaElem.find("event").attr("name");\n              fromJid = stanzaElem.find("event").attr("jid");\n\n              if (roomEvent === "welcome" && conversation.room && conversation.room.ownerContact) {\n                fromJid = conversation.room.ownerContact.jid;\n              }\n            }\n\n            if (!fromJid) {\n              $log.warn("[ConversationServiceHistoryHandler] onHistoryMessageReceived - Receive message without valid fromJid information");\n              return true;\n            }\n\n            var from = contactService.getContactByJid(fromJid);\n            var messageId = stanzaElem.find("forwarded message").attr("id");\n            var date = new Date(stanzaElem.find("forwarded delay").attr("stamp"));\n            var body = stanzaElem.find("forwarded message body").text();\n            var side = contactService.isUserContact(from) ? Message.Side.RIGHT : Message.Side.LEFT;\n\n            if (!from) {\n              $log.warn("[ConversationServiceHistoryHandler] onHistoryMessageReceived missing contact for jid : " + fromJid + ", ignore message"); //create basic contact\n\n              from = contactService.createEmptyContactContact(fromJid);\n            }\n\n            message = Message.create(messageId, date, from, side, body, false, false);\n\n            if (message) {\n              conversation.addMessageInCacheMessages(message);\n            }\n          }\n        }\n      } else {\n        // Get associated conversation\n        queryId = angular.element(stanza).find("fin").attr("queryid");\n        conversation = this.conversationService.getConversationById(queryId);\n\n        if (conversation) {\n          // Extract info\n          conversation.historyComplete = angular.element(stanza).find("fin").attr("complete") === "true";\n          var historyIndex = angular.element(stanza).find("fin set first").text(); // Handle very particular case of historyIndex == -1\n\n          if (conversation.historyIndex === -1) {\n            conversation.messages.unshift.apply(conversation.messages, conversation.historyMessages);\n\n            if (conversation.chatRenderer) {\n              conversation.chatRenderer.prependMessages(conversation.messages, conversation.room);\n            }\n          } // Classic case\n          else {\n              conversation.messages.unshift.apply(conversation.messages, conversation.historyMessages);\n\n              if (conversation.chatRenderer) {\n                conversation.chatRenderer.prependMessages(conversation.historyMessages, conversation.room);\n              }\n            }\n\n          conversation.historyIndex = historyIndex;\n          conversation.historyMessages = [];\n\n          if (angular.isDefined(conversation.messages) && conversation.messages.length > 0) {\n            conversation.lastMessageText = conversation.messages[conversation.messages.length - 1].data;\n          } else {\n            // conversation.lastModification = conversation.historyIndex === "" ? new Date() : new Date(0);\n            conversation.lastMessageText = "";\n          } // this.conversationService.orderConversations();\n          // $rootScope.$broadcast("ON_CONVERSATIONS_UPDATED_EVENT");\n\n\n          if (conversation.historyDefered) {\n            conversation.historyDefered.resolve(conversation);\n          }\n        }\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[ConversationServiceHistoryHandler] onHistoryMessageReceived error : " + error);\n      return true;\n    }\n  };\n\n  ConversationServiceHistoryHandler.prototype.onSearchTextMessageReceived = function (stanza) {\n    $log.info("[ConversationServiceHistoryHandler] onSearchTextMessageReceived"); // Handle response\n\n    try {\n      var stanzaElem = $(stanza); // Extract info\n\n      var otherJid;\n      var fromJid = stanzaElem.find("forwarded message").attr("from");\n      var toJid = stanzaElem.find("forwarded message").attr("to"); // Extract fromJid\n\n      var isSent = false;\n      var isRoom = false;\n\n      if (contactService.isUserContactJid(fromJid)) {\n        $log.info("[ConversationServiceHistoryHandler] sent message");\n        isSent = true;\n        otherJid = toJid;\n      } else {\n        $log.info("[ConversationServiceHistoryHandler] received message");\n        isSent = false;\n        otherJid = fromJid;\n      } // var other;\n\n\n      if (otherJid && otherJid.indexOf("room_") === 0) {\n        otherJid = otherJid.split("/")[0];\n        isRoom = true;\n      } else {\n        otherJid = xmppService.getBareJidFromJid(otherJid); // other = contactService.getContactByJid(otherJid);\n      }\n\n      if (!otherJid) {\n        $log.warn("[ConversationServiceHistoryHandler] onSearchTextMessageReceived - Receive message without valid otherJid information");\n        return undefined;\n      } // var type = stanzaElem.find("forwarded message").attr("type");\n\n\n      var messageId = stanzaElem.find("forwarded message").attr("id");\n      var date = new Date(stanzaElem.find("forwarded delay").attr("stamp"));\n      var body = stanzaElem.find("forwarded message body").text();\n      var searchMsgResult = SearchTextMsgResultFactory();\n      searchMsgResult.body = body;\n      searchMsgResult.date = date;\n      searchMsgResult.isRoom = isRoom;\n      searchMsgResult.isSent = isSent;\n      searchMsgResult.messageId = messageId;\n      searchMsgResult.otherJid = otherJid;\n      return searchMsgResult;\n    } catch (error) {\n      $log.error("[ConversationServiceHistoryHandler] onSearchTextMessageReceived error : " + error);\n      return true;\n    }\n  };\n\n  ConversationServiceHistoryHandler.prototype.onWebrtcHistoryMessageReceived = function (stanza, conversation) {\n    // Handle onWebrtcHistoryMessageReceived\n    console.log("onWebrtcHistoryMessageReceived");\n\n    try {\n      var stanzaElem = $(stanza);\n      var messageId = stanzaElem.find("forwarded message").attr("id");\n      var callerJid = stanzaElem.find("caller").text();\n      var state = stanzaElem.find("state").text();\n      var duration = 0;\n\n      if (stanzaElem.find("duration")) {\n        duration = stanzaElem.find("duration").text();\n        duration = parseInt(duration, 10);\n      }\n\n      if (duration > 0) {\n        duration = "(" + moment.duration(duration, "ms").format("h[H] mm[m] ss[s]") + ")";\n      } else {\n        duration = 0;\n      }\n\n      var date = stanzaElem.find("date").text();\n\n      if (date) {\n        date = new Date(date);\n      } else {\n        date = new Date(stanzaElem.find("forwarded delay").attr("stamp"));\n      }\n\n      var body = "";\n\n      if (state === "missed") {\n        body = "missedCall||" + date;\n      } else if (state === "answered") {\n        body = "activeCallMsg||" + date + "||" + duration;\n      }\n\n      var message = conversation.getMessageById(messageId);\n\n      if (!message) {\n        message = conversation.historyMessages.find(function (item) {\n          return item.id === messageId;\n        });\n      }\n\n      if (message) {\n        $log.info("[ConversationServiceHistoryHandler] (" + conversation.id + ") try to add an already stored message with id " + message.id);\n      } else {\n        var from = contactService.getContactByJid(callerJid); // Create new message \n\n        if (!from) {\n          $log.warn("[ConversationServiceHistoryHandler] onWebrtcHistoryMessageReceived missing contact for jid : " + callerJid + ", ignore message"); //create basic contact\n\n          from = contactService.createEmptyContactContact(callerJid);\n        }\n\n        var side = contactService.isUserContact(from) ? Message.Side.RIGHT : Message.Side.LEFT;\n        message = Message.createWebRTCMessage(messageId, date, from, side, body, false);\n        var ack = stanzaElem.find("forwarded message ack");\n\n        if (ack) {\n          message.receiptStatus = angular.element(ack).attr("read") === "true" ? 5 : angular.element(ack).attr("received") === "true" ? 4 : 3;\n        }\n\n        conversation.historyMessages.push(message);\n      }\n\n      return true;\n    } catch (error) {\n      console.error(error);\n      return true;\n    }\n  };\n\n  return ConversationServiceHistoryHandler;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/conversationServiceHistoryHandler.js?')},function(module,exports,__webpack_require__){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst favorite_1 = __webpack_require__(95);\nclass FavoriteService {\n    constructor($http, $log, contactService, authService, roomService, conversationService, xmppService) {\n        this.$http = $http;\n        this.$log = $log;\n        this.contactService = contactService;\n        this.authService = authService;\n        this.roomService = roomService;\n        this.conversationService = conversationService;\n        this.xmppService = xmppService;\n        this.favorites = [];\n    }\n    start(stats) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info('[favoriteService] === STARTING ===');\n            let startDate = performance.now();\n            this.getServerFavorites();\n            this.conversationService.favoriteService = this;\n            this.attachHandlers();\n            let startDuration = Math.round(performance.now() - startDate);\n            stats.push({ service: 'favoriteService', startDuration: startDuration });\n            this.$log.info(`[favoriteService] === STARTED (${startDuration} ms) ===`);\n        });\n    }\n    reconnect() {\n        this.getServerFavorites();\n        this.conversationService.favoriteService = this;\n        this.attachHandlers();\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info('[favoriteService] Stopping');\n            if (this.xmppManagementHandler) {\n                this.xmppService.deleteHandler(this.xmppManagementHandler);\n                this.xmppManagementHandler = null;\n            }\n            this.$log.info('[favoriteService] Stopped');\n        });\n    }\n    getServerFavorites() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites`;\n                let response = yield this.$http({ method: \"GET\", url: url, headers: this.authService.getRequestHeader() });\n                let promises = response.data.data.map((data) => __awaiter(this, void 0, void 0, function* () { return this.createFavorite(data.id, data.peerId, data.type); }));\n                let favorites = yield Promise.all(promises);\n                this.favorites = favorites.filter((favorite) => { return favorite !== null; });\n                this.$log.info(`[favoriteService] getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);\n                return this.favorites;\n            }\n            catch (error) {\n                let errorMessage = `getServerFavorites -- FAILURE -- ${error.message}`;\n                this.$log.error(`[favoriteService] ${errorMessage}`);\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    addServerFavorite(peerId, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites`;\n                let data = { peerId, type };\n                yield this.$http({ method: \"POST\", url, headers: this.authService.getRequestHeader(), data });\n                this.$log.info(`[favoriteService] addServerFavorite(${peerId}, ${type}) -- SUCCESS`);\n            }\n            catch (error) {\n                let errorMessage = `addServerFavorite(${peerId}, ${type}) -- FAILURE -- ${error.message}`;\n                this.$log.error(`[favoriteService] ${errorMessage}`);\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    removeServerFavorite(favoriteId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites/${favoriteId}`;\n                yield this.$http({ method: \"DELETE\", url: url, headers: this.authService.getRequestHeader() });\n                this.$log.info(`[favoriteService] removeServerFavorite(${favoriteId}) -- SUCCESS`);\n            }\n            catch (error) {\n                let errorMessage = `removeServerFavorite(${favoriteId}) -- FAILURE -- ${error.statusText}`;\n                this.$log.error(`[favoriteService] ${errorMessage}`);\n                throw new Error(errorMessage);\n            }\n        });\n    }\n    toggleFavorite(conversation) {\n        let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n        let type = conversation.contact ? (conversation.contact.isBot ? 'bot' : 'user') : 'room';\n        let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\n        if (!favorite) {\n            this.addServerFavorite(peerId, type);\n        }\n        else {\n            this.removeServerFavorite(favorite.id);\n        }\n    }\n    updateFavorites(conversation) {\n        let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;\n        let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\n        if (favorite) {\n            conversation.isFavorite = true;\n            favorite.conv = conversation;\n        }\n    }\n    getFavorite(peerId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\n            let convGetter = favorite.contact ? this.conversationService.getOrCreateOneToOneConversation(favorite.contact.jid) : this.conversationService.getRoomConversation(favorite.room.jid);\n            return yield convGetter;\n        });\n    }\n    createFavorite(id, peerId, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let favorite = new favorite_1.Favorite(id, peerId, type);\n                // Get peer object\n                if (type === 'room') {\n                    favorite.room = this.roomService.getRoomById(peerId);\n                }\n                else {\n                    favorite.contact = yield this.contactService.getContactByDBId(peerId);\n                }\n                // Fetch eventual conversation\n                let convId = favorite.room ? favorite.room.jid : favorite.contact.jid;\n                let conv = this.conversationService.getConversationById(convId);\n                if (conv) {\n                    conv.isFavorite = true;\n                    favorite.conv = conv;\n                }\n                return favorite;\n            }\n            catch (error) {\n                this.$log.warn(`[favoriteService] createFavorite(${id}, ${peerId}, ${type}) -- FAILURE -- ${error.message}`);\n                return null;\n            }\n        });\n    }\n    onXmppEvent(stanza) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let stanzaElem = $(stanza);\n                let favoriteElem = stanzaElem.find(\"favorite\");\n                if (favoriteElem) {\n                    let id = favoriteElem.attr(\"id\");\n                    let type = favoriteElem.attr(\"type\");\n                    let peerId = favoriteElem.attr(\"peer_id\");\n                    let action = favoriteElem.attr(\"action\");\n                    if (action === 'create') {\n                        let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });\n                        if (!favorite) {\n                            favorite = yield this.createFavorite(id, peerId, type);\n                            this.favorites.push(favorite);\n                            this.sendEvent('ON_FAVORITE_CREATED', { favorite });\n                        }\n                    }\n                    if (action === 'delete') {\n                        var index = this.favorites.findIndex((fav) => { return fav.id === id; });\n                        if (index !== -1) {\n                            var favorite = this.favorites[index];\n                            if (favorite.conv) {\n                                favorite.conv.isFavorite = false;\n                            }\n                            this.favorites.splice(index, 1);\n                            this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });\n                        }\n                    }\n                }\n                return true;\n            }\n            catch (error) {\n                return true;\n            }\n        });\n    }\n    sendEvent(eventName, detail) {\n        let event = new CustomEvent(eventName, { detail });\n        window.dispatchEvent(event);\n    }\n    attachHandlers() {\n        if (this.xmppManagementHandler) {\n            this.xmppService.deleteHandler(this.xmppManagementHandler);\n        }\n        this.xmppManagementHandler = this.xmppService.addHandler((stanza) => { this.onXmppEvent(stanza); return true; }, null, \"message\", \"management\");\n    }\n}\nFavoriteService.$inject = ['$http', '$log', 'contactService', 'authService', 'roomService', 'conversationService', 'xmppService'];\nexports.FavoriteService = FavoriteService;\nangular.module(\"rainbow\").service(\"favoriteService\", FavoriteService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/favoriteService.ts?")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nclass Favorite {\n    constructor(id, peerId, type) {\n        this.id = id;\n        this.peerId = peerId;\n        this.type = type;\n    }\n}\nexports.Favorite = Favorite;\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/models/appli/favorite.ts?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__);\n\nangular.module("rainbow").service("telephonyService", ["$q", "$interval", "$http", "$rootScope", "$log", "xmppService", "contactService", "authService", "TelephonyServiceEventHandler", "errorHelperService", "VoiceMail", "profileService", "utilService", "videoService", "$injector", "settingsService", function ($q, $interval, $http, $rootScope, $log, xmppService, contactService, authService, TelephonyServiceEventHandler, errorHelperService, VoiceMail, profileService, utilService, videoService, $injector, settingsService) {\n  "use strict";\n  /*********************************************************/\n\n  /**                 LIFECYCLE STUFF                     **/\n\n  /*********************************************************/\n\n  var service = this;\n  var listeners = [];\n  var CALLSERVICE_NS = "urn:xmpp:pbxagent:callservice:1";\n  var telephonyServiceEventHandlerSipWise = null; //sipWise+\n\n  var telephonyServiceSipWise = null; //sipWise+\n\n  var sipWise = false; //sipWise+\n\n  var SIPWISE_RVCP = "RVCP Subscriber"; //sipWise+\n\n  service.start = function (stats) {\n    $log.info("[telephonyService] === STARTING ==="); //sipWise++\n\n    service.setSipWise(contactService.userContact.systDeviceName === SIPWISE_RVCP); //sipWise only if RVCP Subscriber\n\n    if (service.isSipWise()) {\n      $log.info("[telephonyService] starting in sipWise mode");\n      CALLSERVICE_NS = "urn:xmpp:pbxagent:telephony:1"; //new name space\n\n      try {\n        service.telephonyServiceEventHandlerSipWise = $injector.get("TelephonyServiceEventHandlerSipWise");\n      } catch (error) {\n        var errorMessage = error && error.message ? error.message : "Unknown error";\n        var errorStack = error && error.stack ? error.stack : "Unknown stack";\n        $log.error("[telephonyService] injection TelephonyServiceEventHandlerSipWise  exception  -- " + errorMessage + " : " + errorStack);\n      }\n\n      try {\n        service.telephonyServiceSipWise = $injector.get("telephonyServiceSipWise");\n      } catch (error) {\n        var errorMessage = error && error.message ? error.message : "Unknown error";\n        var errorStack = error && error.stack ? error.stack : "Unknown stack";\n        $log.error("[telephonyService] injection TelephonyServiceSipWise  exception  -- " + errorMessage + " : " + errorStack);\n      }\n    } //sipWise--\t\t\t\n\n\n    service.startDate = performance.now();\n    service.stats = stats;\n    /**\n          \t * service.calls\n          \t * Used by SDK (public)\n          \t * Warning when modifying this property\n          \t */\n\n    service.calls = [];\n    service.starting = service.started = false;\n    service.agentStatus = {\n      phoneApi: "disconnected",\n      xmppAgent: "stopped",\n      agentVersion: "unknown"\n    };\n    service.voicemailNumber = contactService.userContact.voicemailNumber;\n    service.pbxId = contactService.userContact.pbxId;\n    service.makingCall = false;\n    service.voiceMail = VoiceMail.create();\n    service.forwardObject = {};\n    service.nomadicObject = {};\n    service.nomadicAnswerNotTakedIntoAccount = false;\n    service.isBasicCallAllowed = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_BASIC_CALL);\n    service.isSecondCallAllowed = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_SECOND_CALL);\n    service.isTransferAllowed = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_TRANSFER_CALL);\n    service.isConferenceAllowed = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_CONFERENCE_CALL);\n    service.isVMDeflectCallAllowed = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_DEFLECT_CALL);\n    service.voiceMailFeatureEnabled = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_VOICE_MAIL);\n    service.isForwardEnabled = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_CALL_FORWARD);\n    service.isNomadicEnabled = profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_NOMADIC); // Store the user jid tel\n\n    service.userJidTel = authService.jidTel;\n    service.portalURL = config.restServerUrl + "/api/rainbow/telephony/v1.0/"; // Register on user telephony presence\n\n    listeners.push($rootScope.$on("ON_ROSTER_PRESENCE_CHANGED_EVENT", service.onTelPresenceChange)); // Create the telephonyEventHandler\n    //sipWise++\n\n    if (!service.isSipWise()) {\n      service.telephonyEventHandler = TelephonyServiceEventHandler.create(service);\n    } else {\n      //SipWise case\n      service.telephonyEventHandler = service.telephonyServiceEventHandlerSipWise.create(service);\n    } //sipWise--\n\n\n    $log.info("[telephonyService] starting on user jidTel: " + service.userJidTel);\n\n    if (contactService.userContact) {\n      $log.info("[telephonyService] starting user name: " + contactService.userContact.getNameForLogs() + ", full jid: " + contactService.userContact.fullJid);\n      $log.info("[telephonyService] starting phonePbx: " + utilService.anonymizePhoneNumber(contactService.userContact.phonePbx) + ", phonePro: " + utilService.anonymizePhoneNumber(contactService.userContact.phonePro) + ", voicemailNumber: " + utilService.anonymizePhoneNumber(contactService.userContact.voicemailNumber) + ", pbxId: " + contactService.userContact.pbxId);\n    } //start with existing tel presence or wait for it if it has not yet been received\n\n\n    if (contactService.userContact) {\n      if (contactService.userContact.telStatus) {\n        //tel status of our user has already been received => start telephony service\n        $log.info("[telephonyService] start with my existing telephony presence " + contactService.userContact.telStatus + " of user contact (" + contactService.userContact.jidtel + ") ");\n        service.onTelPresenceChange(null, {\n          jid: service.userJidTel + "/phone",\n          status: contactService.userContact.telStatus\n        });\n      } else {\n        $log.info("[telephonyService] Subscribe and wait for my telephony presence (" + contactService.userContact.jidtel + ")");\n        contactService.sendSubscribeInvitation(contactService.userContact.jidtel);\n      }\n    }\n  };\n\n  service.onTelPresenceChange = function (__event, attr) {\n    if (contactService.isTelJid(attr.jid)) {\n      //sipWise++\n      var ressourceFromJid = contactService.getRessourceFromJid(attr.jid);\n\n      if (ressourceFromJid !== "phone" && ressourceFromJid !== "pcg2") {\n        return true;\n      } //sipWise--\n\n\n      var jid_im = contactService.getImJid(attr.jid);\n\n      if (!jid_im) {\n        return true;\n      }\n\n      var status = attr.status;\n\n      if (contactService.isUserContactJid(jid_im)) {\n        // Receive unavailable status\n        if (status === "unavailable" || status === "offline") {\n          $log.info("[telephonyService] received my telephony presence -- " + status);\n          service.starting = service.started = false;\n          service.telephonyOfflineCallManagement();\n          $rootScope.$broadcast("ON_TELEPHONY_STATUS_CHANGED_EVENT", "stopped");\n          $log.info("[telephonyService] === STOPPED ===");\n        } // Service is not started, try to fetch agent status\n        else if (!service.started && !service.starting) {\n            $log.info("[telephonyService] received my telephony presence -- " + status);\n            service.starting = true;\n            service.getAgentStatus().then(function () {\n              service.attachHandlers(); //sipWise++ PROVISOIRE_SIPWISE\t\t\n\n              if (service.isSipWise()) {\n                $log.info("[telephonyService] getNomadicStatus -- SipWise BYPASS");\n                return service.getTelephonyState(false);\n              } //sipWise-- PROVISOIRE_SIPWISE\t\t\t\t\t\t\t\t\n              // Make snapshot device\n              // We must first retrieve nomadic config to know the current device (main or secondary), and make the snapshot only on the current device\n\n\n              if (service.isNomadicEnabled) {\n                return service.getNomadicStatus().then(function () {\n                  var snapshotSecondary = service.nomadicObject.featureActivated && service.nomadicObject.modeActivated && !service.nomadicObject.makeCallInitiatorIsMain;\n                  return service.getTelephonyState(snapshotSecondary);\n                });\n              }\n\n              return service.getTelephonyState(false);\n            }).then(function () {\n              if (service.isForwardEnabled) {\n                service.getForwardStatus();\n              }\n            }).then(function () {\n              var startDuration = Math.round(performance.now() - service.startDate);\n              service.stats.push({\n                service: "telephonyService",\n                startDuration: startDuration\n              });\n              $log.info("[telephonyService] === STARTED (" + startDuration + " ms) ===");\n              service.started = true;\n              service.starting = false;\n              $rootScope.$broadcast("ON_TELEPHONY_STATUS_CHANGED_EVENT", "started");\n            })["catch"](function (error) {\n              service.starting = false;\n              $log.error("[telephonyService] receive telephony presence but error in initialization - " + (error ? error.message : "unknown error"));\n            });\n          }\n      }\n    }\n\n    return true;\n  };\n\n  service.launchTelephonyInitilization = function () {\n    if (contactService.userContact && contactService.userContact.telStatus) {\n      $log.info("[telephonyService] launchTelephonyInitilization telStatus: " + contactService.userContact.telStatus + " => start");\n      service.onTelPresenceChange(null, {\n        jid: service.userJidTel + "/phone",\n        status: contactService.userContact.telStatus\n      });\n    } else {\n      $log.info("[telephonyService] launchTelephonyInitilization no tel presence => do nothing");\n    }\n  };\n\n  service.reconnect = function () {\n    $log.info("[telephonyService] reconnect (xmpp reconnection)");\n    service.starting = service.started = false;\n    service.telephonyOfflineCallManagement();\n    $rootScope.$broadcast("ON_TELEPHONY_STATUS_CHANGED_EVENT", "stopped");\n    service.attachHandlers();\n  };\n\n  service.telephonyOfflineCallManagement = function () {\n    $log.info("[telephonyService] telephony Offline Call Management");\n\n    try {\n      var webrtcGatewayService = $injector.get("webrtcGatewayService");\n      Object.keys(service.calls || []).forEach(function (key) {\n        var call = service.calls[key];\n\n        if (call) {\n          // Manage incoming calls : send CALL_UPDATED_EVENT with UNKNOWN status only for ringing incoming calls in order to close the incoming\n          // popup and to stop the ringing sound\n          if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING || call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_INCOMMING) {\n            if (call.mediaPillarCall && call.mediaPillarCall.webrtcCallRef) {\n              $log.info("[telephonyService] Offline Call Management: release MP webrtc call for phone call " + call.id + " in state " + call.status.value);\n              videoService.releaseCall(call.mediaPillarCall.webrtcCallRef);\n            }\n\n            $log.info("[telephonyService] Offline Call Management: stop popup and ringing tone for phone call " + call.id + " in state " + call.status.value);\n            call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n            $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n          } // Manage outgoing calls : release mediapillar calls in state RINGING_OUtGOING\n\n\n          if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_OUTGOING && webrtcGatewayService.isMediaPillarCallSituation(call) && call.mediaPillarCall && call.mediaPillarCall.webrtcCallRef) {\n            $log.info("[telephonyService] Offline Call Management: release MP webrtc call for phone call " + call.id + " in state " + call.status.value);\n            videoService.releaseCall(call.mediaPillarCall.webrtcCallRef);\n          } // delete all calls but keep established mediapillar calls\n\n\n          var keepCall = webrtcGatewayService.isMediaPillarCallSituation(call) && call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE;\n\n          if (!keepCall) {\n            delete service.calls[call.id];\n            $log.info("[telephonyService] Offline Call Management: phone call deleted: " + call.id + " in state " + call.status.value);\n          } else {\n            //keep established mediapillar call\n            //mark the call to know that the pxb connection is down\n            $log.info("[telephonyService] Offline Call Management: keep MP call for phone call " + call.id + " in state " + call.status.value);\n            call.pbxConnectionDown = true;\n          }\n        }\n      });\n    } catch (error) {\n      var errorMessage = error && error.message ? error.message : "Unknown error";\n      var errorStack = error && error.stack ? error.stack : "Unknown stack";\n      $log.error("[telephonyService] telephonyOfflineCallManagement  exception  -- " + errorMessage + " : " + errorStack);\n    }\n  };\n\n  service.getTelephonyState = function (secondary) {\n    //sipWise++\t\t\n    if (service.isSipWise()) {\n      $log.info("[telephonyService] getTelephonyState -- sipWise snapshot");\n      return service.telephonyServiceSipWise.processSnapshot(service);\n    } //sipWise--\n\n\n    var defered = $q.defer(); // Create the iq request\n\n    var iq;\n\n    if (!secondary) {\n      iq = $iq({\n        type: "get",\n        to: service.userJidTel + "/phone"\n      }).c("callservice", {\n        xmlns: CALLSERVICE_NS\n      }).c("connections");\n    } else {\n      iq = $iq({\n        type: "get",\n        to: service.userJidTel + "/phone"\n      }).c("callservice", {\n        xmlns: CALLSERVICE_NS\n      }).c("connections", {\n        deviceType: "SECONDARY"\n      });\n    } // Send "get connections" iq\n\n\n    xmppService.sendIQ(iq, 60000) // connections response may come after the standard 10 sec timeout : use 60 sec here\n    .then(function (data) {\n      // Handle eventual error message\n      var errorMessage = service.getErrorMessage(data, "getTelephonyState");\n\n      if (errorMessage) {\n        $log.info("[telephonyService] getTelephonyState -- failure -- " + errorMessage);\n        defered.reject(new Error(errorMessage));\n        return defered.promise;\n      } // Handle existing calls\n\n\n      var existingCalls = angular.element(data).find("connection");\n      $log.info("[telephonyService] getTelephonyState (" + (secondary ? "SECONDARY" : "MAIN") + ") -- success -- " + existingCalls.length + " existing call(s)");\n\n      if (existingCalls.length === 0) {\n        defered.resolve();\n        return defered.promise;\n      } // Build existing calls\n\n\n      var getCallPromises = [];\n      existingCalls.each(function () {\n        getCallPromises.push(service.createCallFromConnectionElem(this, secondary));\n      }); // Send all getContactPromise\n\n      $q.all(getCallPromises).then(function () {\n        $log.info("[telephonyService] getTelephonyState (" + (secondary ? "SECONDARY" : "MAIN") + ") -- calls creation completed -- " + existingCalls.length + " calls created");\n        defered.resolve();\n      })["catch"](function (error) {\n        $log.error("[telephonyService] getTelephonyState -- calls creation failure -- " + error.message);\n        defered.reject(error);\n      });\n      return defered.promise;\n    })["catch"](function (error) {\n      $log.error("[telephonyService] getTelephonyState -- failure -- " + error.message);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n\n  service.getAgentStatus = function () {\n    var defered = $q.defer(); //sipWise++\n\n    var TYPE_SIPWISE_RVCP = "RVCP";\n    var toPCG = "/phone"; //standard PCGv1\t\n\n    if (service.isSipWise()) {\n      $log.info("[telephonyService] getAgentStatus --- sipWise version");\n      toPCG = "/pcg2";\n    } //sipWise--\n    // Forge request iq\n\n\n    var getAgentIq = $iq({\n      type: "get",\n      to: service.userJidTel + toPCG\n    }).c("pbxagentstatus", {\n      xmlns: "urn:xmpp:pbxagent:monitoring:1"\n    }); // Send "getAgentIq" iq\n\n    xmppService.sendIQ(getAgentIq, 60000) //agent status response may come after the standard 10 sec timeout : use 60 sec here\n    .then(function (data) {\n      var phoneApi = angular.element(data).find("phoneapi").text();\n      var xmppAgent = angular.element(data).find("xmppagent").text();\n      var agentVersion = angular.element(data).find("version").text();\n      var features = angular.element(data).find("features").text();\n      var type = angular.element(data).find("type").text();\n\n      if (agentVersion) {\n        service.agentStatus = {\n          phoneApi: phoneApi,\n          xmppAgent: xmppAgent,\n          agentVersion: agentVersion,\n          features: features\n        };\n\n        if (type) {\n          service.isOxe = type.toLowerCase().includes("oxe");\n          service.isOxo = type.toLowerCase().includes("oxo");\n        } else {\n          service.isOxe = agentVersion.toLowerCase().includes("oxe");\n          service.isOxo = agentVersion.toLowerCase().includes("oxo");\n        }\n\n        ;\n      }\n\n      if (service.isSipWise()) {\n        if (type !== TYPE_SIPWISE_RVCP) {\n          service.setSipWise(false);\n          var errorMessage = "getAgentStatus -- sipWise failure : wrong PCG type";\n          $log.error("[telephonyService] " + errorMessage);\n          defered.reject(new Error(errorMessage));\n        }\n      }\n\n      $log.info("[telephonyService] getAgentStatus -- success -- version " + agentVersion + " isOxe:" + service.isOxe + " isOxo:" + service.isOxo);\n      defered.resolve();\n    })["catch"](function (error) {\n      var errorMessage = "getAgentStatus -- failure : " + error.message;\n      $log.error("[telephonyService] " + errorMessage);\n      defered.reject(new Error(errorMessage));\n    }); // Return the promise\n\n    return defered.promise;\n  };\n\n  service.getSnapshotCall = function (callId) {\n    $log.info("[telephonyService] getSnapshotCall");\n    return $q(function (resolve, reject) {\n      // Create the iq request\n      var iq = $iq({\n        type: "get",\n        to: service.userJidTel + "/phone"\n      }).c("callservice", {\n        xmlns: CALLSERVICE_NS\n      }).c("snapshotCall", {\n        callId: callId\n      }); // Send "get SnapshotCall" iq\n\n      xmppService.sendIQ(iq).then(function (data) {\n        console.error(data);\n        resolve();\n      })["catch"](function (error) {\n        var errorMessage = "getSnapshotCall failure : " + error.message;\n        $log.error("[telephonyService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.createCallFromConnectionElem = function (connectionElemObj, secondary) {\n    return $q(function (resolve, reject) {\n      // Extract information\n      var connectionElem = angular.element(connectionElemObj);\n      var jid = connectionElem.attr("endpointIm");\n      var phoneNumber = connectionElem.attr("endpointTel");\n      var connectionId = connectionElem.attr("callId");\n      var endpointLci = connectionElem.attr("endpointLci");\n      var lci = connectionElem.attr("lci");\n      var participantsElem = connectionElem.find("participant");\n      var identityFirstName = connectionElem.find("identity").attr("firstName");\n      var identityLastName = connectionElem.find("identity").attr("lastName");\n      var firstName = "";\n      var lastName = "";\n\n      if (!jid && !phoneNumber) {\n        phoneNumber = "****";\n      } //manage name resolution\n\n\n      if (profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_PHONE_BOOK)) {\n        //find Xnames, here for simple call only\n        if (participantsElem.length === 0 && identityLastName && identityLastName.length) {\n          lastName = identityLastName;\n\n          if (identityFirstName && identityFirstName.length) {\n            firstName = identityFirstName;\n          }\n\n          $log.info("[telephonyService] createCallFromConnectionElem - name resolution for: " + connectionId + " for phoneNumber:" + utilService.anonymizePhoneNumber(phoneNumber) + " with firstname : " + firstName.slice(0, 1) + "***");\n        }\n      } // Create initiated calls only for nomadic computer case (ignore initiated calls in other cases)\n\n\n      if (lci === "LCI_INITIATED" && !(secondary && $injector.get("webrtcGatewayService").IsMediaPillarUserSelected())) {\n        resolve();\n        return;\n      } // Define getParticipants promise\n\n\n      var getParticipants = function getParticipants() {\n        if (participantsElem.length === 0) {\n          return contactService.getOrCreateContact(jid, phoneNumber);\n        }\n\n        return service.getParticipantsFromParticipantsElem(participantsElem);\n      }; // Call the promise\n\n\n      getParticipants().then(function (response) {\n        // Extract call status\n        var callStatus = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE;\n\n        if (lci === "LCI_INITIATED") {\n          callStatus = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING;\n        }\n\n        if (lci === "LCI_HELD" && endpointLci === "LCI_CONNECTED") {\n          callStatus = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.HOLD;\n        }\n\n        if (lci === "LCI_CONNECTED" && endpointLci === "LCI_HELD") {\n          callStatus = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.PUT_ON_HOLD;\n        }\n\n        if (lci === "LCI_CONNECTED" && endpointLci === "LCI_QUEUED") {\n          callStatus = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_OUTGOING;\n        }\n\n        if (lci === "LCI_QUEUED" && endpointLci === "LCI_CONNECTED") {\n          callStatus = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_INCOMMING;\n        }\n\n        if (lci === "LCI_ALERTING") {\n          callStatus = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING;\n        } // Create the call object\n\n\n        var call = null;\n\n        if (participantsElem.length === 0) {\n          if (response && response.temp && lastName !== "") {\n            response.updateName(firstName, lastName);\n          }\n\n          call = service.getOrCreateCall(callStatus, connectionId, response);\n          $log.info("[telephonyService] createCallFromConnectionElem - create call for user: " + response.id + " with callId: " + connectionId + " " + lci);\n        } else {\n          var call = service.getOrCreateCall(callStatus, connectionId);\n          call.setParticipants(response);\n          call.isConference = true;\n          $log.info("[telephonyService] createCallFromConnectionElem - create conference call with callId: " + connectionId + " " + lci);\n        }\n\n        call.relevantEquipmentId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(connectionId);\n        call.isSecondary = secondary; // Note : we don\'t reset the \'pbxConnectionDown\' attribute to keep the info that the call has been maintained after a telephony loss, \n        // even if the telephony service has come back.\n        // On oxe, we don\'t receive events for a call existing before the csta initialization: that\'s why we propose a degraded telephony service on such calls (no hold call...)\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n        resolve(call);\n      })["catch"](function (error) {\n        $log.error("[TelephonyService] createCallFromConnectionElem - failure - " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  service.getParticipantsFromParticipantsElem = function (participants) {\n    return $q(function (resolve, reject) {\n      var confParticipants = []; // Create getParticipantPromise\n\n      var participantPromises = [];\n      participants.each(function () {\n        var participantElem = angular.element(this);\n        var endpointTel = participantElem.find("endpointTel").text();\n        var endpointIm = participantElem.find("endpointIm").text();\n\n        if (!(endpointIm && contactService.isUserContactJid(endpointIm))) {\n          participantPromises.push($q(function (resolvePromise, rejectPromise) {\n            if (!endpointIm && !endpointTel) {\n              endpointTel = "****";\n            }\n\n            contactService.getOrCreateContact(endpointIm, endpointTel).then(function (contact) {\n              confParticipants.push(contact);\n              resolvePromise();\n            })["catch"](function (error) {\n              rejectPromise(error);\n            });\n          }));\n        }\n      }); // Get participants asynchronously\n\n      $q.all(participantPromises).then(function success() {\n        resolve(confParticipants);\n      }, function failure(error) {\n        reject(error);\n      });\n    });\n  };\n\n  service.getOrCreateCall = function (status, connectionId, contact) {\n    // Get eventual existing call\n    var call = service.calls[_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(connectionId)];\n\n    if (call) {\n      call.setConnectionId(connectionId);\n      call.startDate = new Date();\n    } else {\n      call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(status, null, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.PHONE, contact);\n      call.setConnectionId(connectionId);\n      service.calls[call.id] = call;\n    }\n\n    return call;\n  }; //sipWise++\n\n\n  service.getOrCreateCallSipWise = function (status, callId, legId, deviceId, contact) {\n    // Get eventual existing call\n    var call = null;\n\n    if (callId) {\n      call = service.calls[callId];\n    }\n\n    if (call) {\n      call.setConnectionIdSipWise(legId);\n\n      if (contact) {\n        call.setContact(contact);\n      }\n\n      ;\n\n      if (deviceId) {\n        call.setDeviceIdSipWise(deviceId);\n      }\n\n      call.startDate = new Date();\n    } else {\n      //create it\n      call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(status, callId, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.PHONE, contact);\n      call.setConnectionIdSipWise(legId);\n      call.setDeviceIdSipWise(deviceId);\n      service.calls[call.id] = call;\n    }\n\n    return call;\n  }; //sipWise--\n\n\n  service.attachHandlers = function () {\n    $log.info("[telephonyService] attachHandlers");\n\n    if (Object.keys(service.calls || []).length === 0) {\n      $rootScope.telephonyAreaClass = ""; //CRRAINB-4545 : hide residual calls\n    }\n\n    if (service.messageHandlerRef) {\n      xmppService.deleteHandler(service.messageHandlerRef);\n      service.messageHandlerRef = null;\n    }\n\n    service.messageHandlerRef = xmppService.addHandler(function (stanza) {\n      service.telephonyEventHandler.onCallserviceMessageReceived(stanza);\n      return true;\n    }, CALLSERVICE_NS, "message", null);\n  };\n\n  service.stop = function () {\n    $log.info("");\n    $log.info("[telephonyService] === STOPPING ===");\n    service.starting = service.started = false;\n    service.userJidTel = null;\n    service.calls = null;\n\n    if (service.messageHandlerRef) {\n      xmppService.deleteHandler(service.messageHandlerRef);\n      service.messageHandlerRef = null;\n    } // Remove listeners\n\n\n    var listener;\n\n    while (listener = listeners.pop()) {\n      listener();\n    }\n\n    $log.info("[telephonyService] === STOPPED ===");\n    $rootScope.$broadcast("ON_TELEPHONY_STATUS_CHANGED_EVENT", "stopped");\n    return $q.when();\n  };\n  /*********************************************************/\n\n  /**                   CALL HANDLERS                     **/\n\n  /*********************************************************/\n\n\n  service.getCallToHangOut = function () {\n    var calls = service.getCalls();\n\n    if (!calls || calls.length === 0) {\n      return null;\n    }\n\n    var callStatus = calls[0].status;\n\n    if (calls.length === 1 || callStatus === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING || callStatus === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE || callStatus === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.PUT_ON_HOLD) {\n      return calls[0];\n    }\n\n    return calls[1];\n  };\n\n  service.getActiveCall = function () {\n    var activeCall = null;\n    Object.keys(service.calls || []).forEach(function (key) {\n      var call = service.calls[key];\n\n      if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE) {\n        activeCall = call;\n      }\n    });\n    return activeCall;\n  };\n\n  service.getCalls = function () {\n    var calls = [];\n    Object.keys(service.calls || []).forEach(function (key) {\n      var call = service.calls[key];\n      var status = call.status;\n\n      if (status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING || status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_OUTGOING || status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_OUTGOING || status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE || status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.HOLD || status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.PUT_ON_HOLD || status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ERROR) {\n        calls.push(service.calls[key]);\n      }\n    });\n    return calls;\n  };\n\n  service.getActiveCallsForContact = function (contact) {\n    var calls = [];\n\n    if (contact && contact.jid) {\n      Object.keys(service.calls || []).forEach(function (key) {\n        if (service.calls[key].contact && service.calls[key].contact.jid === contact.jid && (service.calls[key].status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING || service.calls[key].status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_OUTGOING || service.calls[key].status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE || service.calls[key].status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.HOLD || service.calls[key].status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.PUT_ON_HOLD)) {\n          calls.push(service.calls[key]);\n        }\n      });\n    }\n\n    return calls;\n  };\n\n  service.getConferenceCallForContact = function (contact) {\n    var conferenceCall = null;\n\n    if (contact && contact.jid) {\n      Object.keys(service.calls || []).forEach(function (key) {\n        if (service.calls[key].status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE && service.calls[key].isConference && (service.calls[key].participants || []).some(function (participantContact) {\n          return participantContact && participantContact.jid === contact.jid;\n        })) {\n          conferenceCall = service.calls[key];\n        }\n      });\n    }\n\n    return conferenceCall;\n  };\n\n  service.logMakecallReqData = function (reqData, contact) {\n    var reqDataForLogs = {};\n    Object.keys(reqData).forEach(function (reqDataProperty) {\n      switch (reqDataProperty) {\n        case "calleeExtNumber":\n        case "calleeIntNumber":\n        case "calleeShortNumber":\n          reqDataForLogs[reqDataProperty] = utilService.anonymizePhoneNumber(reqData[reqDataProperty]);\n          break;\n\n        case "calleeDisplayName":\n          if (contact) {\n            reqDataForLogs[reqDataProperty] = contact.getNameForLogs();\n          }\n\n          break;\n\n        default:\n          reqDataForLogs[reqDataProperty] = reqData[reqDataProperty];\n          break;\n      }\n    });\n    $log.info("[telephonyService] makeSimpleCall data: " + JSON.stringify(reqDataForLogs));\n  };\n  /*************************************************************/\n\n  /*                    MAKE CALL STUFF                        */\n\n  /*************************************************************/\n\n\n  service.makeCall = function (contact, phoneNumber, callSubject) {\n    var activeCall = service.getActiveCall();\n\n    if (service.makingCall) {\n      $log.warn("[telephonyService] makeCall failure - makeCall already making a call");\n      return $q.reject();\n    } // Set makingCall flag \n\n\n    service.makingCall = true; // Handle simpleCall\n\n    if (!activeCall) {\n      //sipWise++\n      if (!service.isSipWise()) {\n        //not sipWise\n        return service.makeSimpleCall(contact, phoneNumber, callSubject);\n      } else {\n        //sipWise case\n        return service.telephonyServiceSipWise.makeSimpleCallSipWise(service, contact, phoneNumber);\n      } //sipWise--\n\n    } // Handle consultationCall\n    //sipWise++\n\n\n    if (!service.isSipWise()) {\n      //not sipWise\n      return service.makeConsultationCall(contact, phoneNumber, activeCall.connectionId);\n    } else {\n      //sipWise case\n      if (service.sipWiseMode() === "demo") {\n        return service.telephonyServiceSipWise.makeSimpleCallSipWise(service, contact, phoneNumber);\n      } else {\n        $log.info("[telephonyService] makeConsultationCall sipWise not implemented");\n      }\n    } //sipWise--\n\n  };\n\n  service.makeSimpleCall = function (contact, phoneNumber, callSubject) {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] makeSimpleCall to " + (contact ? contact.getNameForLogs() : utilService.anonymizePhoneNumber(phoneNumber))); //reject not allowed operations\n\n      if (!service.isBasicCallAllowed) {\n        var profileError = new Error("makeSimpleCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message); // Release makingCall flag\n\n        service.makingCall = false;\n        reject(profileError);\n        return;\n      } //CRRAINB-4813++ \n      //do not allow makeSimpleCall webrtcGateWay situation when another WEBRTC audio call already engaged\n      //because only one media web resource avalaible\n\n\n      var webrtcGatewayService = $injector.get("webrtcGatewayService");\n\n      if (webrtcGatewayService.isMediaPillarCallSituation()) {\n        //profile webrtcGateWay setted\n        if (videoService.getWebrtcAudioCall()) {\n          // audio webrtc call (non mediapillar) already engaged\n          $log.info("[telephonyService] makeCall failure - webrtcgateway call not possible when webrtc call already engaged"); // Release makingCall flag\n\n          service.makingCall = false;\n          $rootScope.$broadcast("ON_CALL_NOTALLOWED_EVENT", "webCallAlreadyProgress");\n          reject("webCallAlreadyProgress");\n          return; // call is abandonned\n        }\n      } //CRRAINB-4813--\n\n\n      var phoneInfo = service.getPhoneInfo(contact, phoneNumber);\n      var reqMethod = "POST";\n      var reqUrl = service.portalURL + "calls";\n      var reqData = {\n        calleeExtNumber: phoneInfo.longNumber,\n        calleeIntNumber: phoneInfo.internalNumber,\n        calleeShortNumber: phoneInfo.shortNumber,\n        calleePbxId: phoneInfo.pbxId,\n        calleeDisplayName: contact.displayName,\n        callSubject: callSubject,\n        secondaryDeviceMakeCall: angular.isDefined(service.nomadicObject.makeCallInitiatorIsMain) && service.nomadicObject.featureActivated === true && service.isNomadicEnabled ? service.nomadicObject.makeCallInitiatorIsMain ? "false" : "true" : undefined\n      };\n      $log.info("[telephonyService] makeSimpleCall " + reqMethod + " " + reqUrl);\n      service.logMakecallReqData(reqData, contact);\n      $http({\n        method: reqMethod,\n        url: reqUrl,\n        headers: authService.getRequestHeader(),\n        data: reqData\n      }).then(function success(response) {\n        $log.info("[telephonyService] makeSimpleCall success : callee " + utilService.anonymizePhoneNumber(phoneNumber)); // Create the call object\n\n        var call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING, null, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.PHONE, contact);\n        call.setConnectionId(response.data.data.callId);\n        call.setRelevantEquipmentId(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(call.connectionId));\n        call.isSecondary = service.nomadicObject && !service.nomadicObject.makeCallInitiatorIsMain;\n        call.isOwner = true; // The web client is the owner of this call\n\n        service.calls[call.id] = call;\n        $log.info("[telephonyService] makeSimpleCall Call created (" + call + ")"); // Release makinCall flag\n\n        service.makingCall = false; // Indicate whether it is a call to own voicemail\n\n        call.setIsVm(phoneNumber === service.voicemailNumber); // Send call update event\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n        resolve(call.id);\n      }, function failure(response) {\n        var call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ERROR, null, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.PHONE, contact);\n        call.errorMessage = response && response.errorDetailsCode === "403" ? "notAllowed" : "invalidPhoneNumber";\n        service.calls[call.contact.id] = call;\n        call.autoClear = $interval(function () {\n          service.clearCall(call);\n        }, 5000, 1); // Release makinCall flag\n\n        service.makingCall = false; // Send call update event\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "makeCall"));\n      });\n    });\n  };\n\n  service.makeConsultationCall = function (contact, phoneNumber, callId) {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] makeConsultationCall to " + (contact ? contact.getNameForLogs() : utilService.anonymizePhoneNumber(phoneNumber))); //reject not allowed operations\n\n      if (!service.isSecondCallAllowed) {\n        var profileError = new Error("makeConsultationCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message); // Release makingCall flag\n\n        service.makingCall = false;\n        reject(profileError);\n        return;\n      }\n\n      var phoneInfo = service.getPhoneInfo(contact, phoneNumber);\n      var reqMethod = "POST";\n      var reqUrl = service.portalURL + "calls/" + encodeURIComponent(callId) + "/consultation";\n      var reqData = {\n        calleeExtNumber: phoneInfo.longNumber,\n        calleeIntNumber: phoneInfo.internalNumber,\n        calleeShortNumber: phoneInfo.shortNumber,\n        calleePbxId: phoneInfo.pbxId,\n        calleeDisplayName: contact.displayName\n      };\n      $log.info("[telephonyService] makeConsultationCall " + reqMethod + " " + reqUrl); //$log.info("[telephonyService] makeConsultationCall data: " + JSON.stringify(reqData)); //CRRAINB-6211\n\n      $http({\n        method: reqMethod,\n        url: reqUrl,\n        headers: authService.getRequestHeader(),\n        data: reqData\n      }).then(function success(response) {\n        $log.info("[telephonyService] makeConsultationCall success : callee " + utilService.anonymizePhoneNumber(phoneNumber)); // Create the call object\n\n        var call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING, null, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.PHONE, contact);\n        call.setConnectionId(response.data.data.callId);\n        call.setRelevantEquipmentId(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(call.connectionId));\n        call.isSecondary = service.nomadicObject && !service.nomadicObject.makeCallInitiatorIsMain;\n        call.isOwner = true; // The web client is the owner of this call\n\n        service.calls[call.id] = call;\n        $log.info("[telephonyService] makeConsultationCall Call created (" + call + ")"); // Release makinCall flag\n\n        service.makingCall = false; // Indicate whether it is a call to own voicemail\n\n        call.setIsVm(phoneNumber === service.voicemailNumber); // Send call update event\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n        resolve(call.id);\n      }, function failure(response) {\n        var call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ERROR, null, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.PHONE, contact);\n        call.errorMessage = response && response.errorDetailsCode === "403" ? "notAllowed" : "invalidPhoneNumber";\n        service.calls[call.contact.id] = call;\n        call.autoClear = $interval(function () {\n          service.clearCall(call);\n        }, 5000, 1); // Release makinCall flag\n\n        service.makingCall = false;\n        var error = errorHelperService.handleError(response); //clean active client call not existing on server\n\n        service.deleteCallIfInvalid(error, service.calls[_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(callId)]); // Send call update event\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "makeConsultationCall"));\n      });\n    });\n  };\n  /**\n   * MAKE CALL BY PHONE NUMBER\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.makeCallByPhoneNumber = function (phoneNumber) {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] makeCallByPhoneNumber : " + utilService.anonymizePhoneNumber(phoneNumber));\n\n      if (contactService.userContact.phonePro === phoneNumber || contactService.userContact.phoneProCan === phoneNumber || contactService.userContact.phonePbx === phoneNumber) {\n        var errorMessage = "makeCallByPhoneNumber failure: impossible to call its own phone number";\n        $log.error("[telephonyService] " + errorMessage);\n        reject(new Error(errorMessage));\n        return;\n      }\n\n      var myContact = null;\n      contactService.getOrCreateContact(null, phoneNumber).then(function (contact) {\n        myContact = contact;\n        return service.makeCall(contact, phoneNumber);\n      }).then(function () {\n        resolve();\n      })["catch"](function (error) {\n        var _errorMessage = "makeCallByPhoneNumber failure " + (error ? error.message : "");\n\n        $log.error("[telephonyService] - callService - " + _errorMessage);\n        reject(new Error(_errorMessage));\n      });\n    });\n  };\n  /* TO DO */\n\n  /*\t\tservice.makeCallWithMobile = function(mobileRessource, phoneNumber) {\n  \t\n  \t\t\tvar defer = $q.defer();\n  \t\n  \t\t\tif (contactService.userContact.mobilePro === phoneNumber || contactService.userContact.mobilePerso === phoneNumber) {\n  \t\t\t\tvar errorMessage = "makeCallWithMobile failure: impossible to call its own mobile phone number";\n  \t\t\t\t$log.error("[telephonyService] " + errorMessage);\n  \t\t\t\tdefer.reject(new Error(errorMessage));\n  \t\t\t\treturn defer.promise;\n  \t\t\t}\n  \t\n  \t\t\t// Forge request IQ\n  \t\t\tvar makeMobileCallMsg = $iq({ type: "set", to: mobileRessource })\n  \t\t\t\t.c("call", { xmlns: "urn:xmpp:call", phoneNumber: phoneNumber, directCall: false });\n  \t\n  \t\t\txmppService.sendIQ(makeMobileCallMsg)\n  \t\t\t\t.then(function() {\n  \t\t\t\t\tdefer.resolve();\n  \t\t\t\t})\n  \t\t\t\t.catch(function(error) {\n  \t\t\t\t\tvar errorMessageMobile = "makeCallWithMobile failure : " + error.message;\n  \t\t\t\t\t$log.error("[telephonyService] - callService - " + errorMessageMobile);\n  \t\t\t\t\tdefer.reject(new Error(errorMessageMobile));\n  \t\t\t\t});\n  \t\n  \t\t\t// Return the promise\n  \t\t\treturn defer.promise;\n  \t\t};\n  */\n\n\n  service.getPhoneInfo = function (contact, phoneNumber) {\n    var longNumber = phoneNumber;\n    var shortNumber = "";\n    var internalNumber = ""; //#29475\t\t\t\n\n    var pbxId = "";\n\n    if (contact) {\n      if (phoneNumber === contact.phonePro || phoneNumber === contact.phoneProCan) {\n        longNumber = contact.phoneProCan ? contact.phoneProCan : ""; //if (!longNumber && contact.phonePro) { longNumber = contact.phonePro; }\n\n        shortNumber = contact.phonePbx;\n        pbxId = contact.pbxId;\n        internalNumber = contact.phoneInternalNumber; //#29475\n      } else if (phoneNumber === contact.phonePbx) {\n        longNumber = "";\n        shortNumber = contact.phonePbx;\n        pbxId = contact.pbxId;\n        internalNumber = contact.phoneInternalNumber; //#29475\n      }\n    }\n\n    return {\n      longNumber: longNumber,\n      shortNumber: shortNumber,\n      pbxId: pbxId,\n      internalNumber: internalNumber\n    }; //#29475\n  };\n\n  service.getErrorMessage = function (data, actionLabel) {\n    var errorMessage = actionLabel + " failure : ";\n\n    if (angular.element(data).attr("type") === "error") {\n      var error = angular.element(data).find("error");\n\n      if (error) {\n        var errorType = error.attr("type");\n        var errorCode = error.attr("code");\n\n        if (errorType) {\n          errorMessage += errorType + " : ";\n\n          if (errorType === "modify") {\n            errorMessage += error.find("text").text();\n          }\n        }\n\n        if (errorCode) {\n          if (errorCode === "503") {\n            errorMessage += "Agent error : service unavailable";\n          }\n        }\n\n        $log.error("[telephonyService] " + errorMessage);\n      } else {\n        errorMessage += "Unknown error";\n      }\n\n      return errorMessage;\n    }\n\n    return null;\n  };\n  /*************************************************************/\n\n  /*                    RELEASE CALL STUFF                     */\n\n  /*************************************************************/\n\n  /**\n   * RELEASE CALL\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.releaseCall = function (call) {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] releaseCall " + call.id); //reject not allowed operations\n\n      if (!service.isBasicCallAllowed) {\n        var profileError = new Error("releaseCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      } //clear a mediapillar call without pbx csta connection : This mediapillar call has been maintained after telephony loss.\n      //=> we release the webrtc call of the mediapillar context, because we cannot release the phone call (no csta pbx connection), \n      //even if telephony has come back.\n\n\n      if (call.pbxConnectionDown) {\n        if (call.mediaPillarCall && call.mediaPillarCall.webrtcCallRef && call.mediaPillarCall.webrtcCallRef.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN) {\n          //terminate the webrtc call\n          $log.info("[telephonyService] releaseCall " + call.id + " with pbx connection down : we release the mediapillar web call: " + call.mediaPillarCall.webrtcCallRef);\n          videoService.releaseCall(call.mediaPillarCall.webrtcCallRef);\n        } else {\n          $log.info("[telephonyService] releaseCall " + call.id + " with pbx connection down : " + (!call.mediaPillarCall ? "no MP context!" : !call.mediaPillarCall.webrtcCallRef ? "no MP webrtc call to release" : "no need to release webrtc call with status " + call.mediaPillarCall.webrtcCallRef));\n        } //remove pbx call (to clear telephony bar)\n\n\n        $log.info("[telephonyService] releaseCall " + call.id + " with pbx connection down : we remove the phone call");\n        service.clearCall(call);\n        resolve(call);\n        return;\n      } //sipWise++\n\n\n      if (service.isSipWise()) {\n        //sipWise case\n        service.telephonyServiceSipWise.releaseCallSipWise(service, call).then(function success(theCall) {\n          resolve(theCall);\n        });\n        return;\n      }\n\n      ; //sipWise--\n\n      var reqMethod = "DELETE";\n      var reqUrl = service.portalURL + "calls/" + encodeURIComponent(call.connectionId);\n      $log.info("[telephonyService] releaseCall " + reqMethod + " " + reqUrl);\n      $http({\n        method: reqMethod,\n        url: reqUrl,\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        // Update call status\n        call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n        call.startDate = null;\n        call.vm = false;\n        $log.info("[telephonyService] releaseCall " + call.id + " - success"); // Send call update event\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call); // Remove the call from calls map\n\n        delete service.calls[call.id];\n        resolve(call);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response); //clean client call not existing on server\n\n        service.deleteCallIfInvalid(error, call);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "releaseCall"));\n      });\n    });\n  };\n  /**\n   * deleteCallIfInvalid\n   * delete call if not existing on server\n   */\n\n\n  service.deleteCallIfInvalid = function (error, call) {\n    if (error && error.portal === "telephony" && error.errorDetailsCode === 404100 && error.message && (error.message.toLowerCase().includes("invalid connection identifier") || error.message.toLowerCase().includes("failed to send releasecall")) && call) {\n      // Invalid connection identifier\n      $log.warn("[telephonyService] deleteCallIfInvalid: delete client call non existing on server: " + call.id);\n      call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN); // Send call update event\n\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call); // Clean the call array\n\n      if (service.calls[call.id]) {\n        delete service.calls[call.id];\n      }\n    }\n  };\n  /*************************************************************/\n\n  /*                     ANSWER CALL STUFF                     */\n\n  /*************************************************************/\n\n  /**\n   * ANSWER CALL\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.answerCall = function (call) {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] answerCall : " + call.id); // First hold the current active call\n\n      var activeCall = service.getActiveCall(); //reject not allowed operations\n\n      if (!service.isBasicCallAllowed) {\n        var profileError = new Error("answerCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      } //CRRAINB-6969++\n\n\n      if (call.isMediaPillarCall()) {\n        var webrtcGatewayService = $injector.get("webrtcGatewayService");\n\n        if (webrtcGatewayService.isMediaPillarCallSituation(call)) {\n          if ($rootScope.isDesktopApp) {\n            //only in desktop case for headset answer button\n            var MP_context = call.getMediaPillarCall();\n\n            if (MP_context && MP_context.webrtcCallRef) {\n              // Then answer to the webrtc part \n              videoService.answerCall(MP_context.webrtcCallRef, "audio");\n              $log.info("[telephonyService] answer webrtcgateway sending webrtc proceed");\n              resolve(call);\n              return;\n            } else {\n              $log.info("[telephonyService] answer webrtcgateway | Anomaly media Pillar : answer but no webrtcCallref");\n            }\n          }\n        }\n      } //CRRAINB-6969--\t\t\t\t\n      //sipWise++\n\n\n      if (service.isSipWise()) {\n        //sipWise case\n        service.telephonyServiceSipWise.answerCallSipWise(service, call).then(function success(theCall) {\n          resolve(theCall);\n        }, function failure(error) {\n          reject(error);\n        });\n        return;\n      }\n\n      ; //sipWise--\n\n      if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_INCOMMING && activeCall && service.isOxe) {\n        // On Oxe pbx only, in order to answer a queued call on a multiline device, we must first hold the active call before answering the queued call\n        service.holdCall(activeCall)["catch"](function (error) {\n          //we don\'t reject if this holdCall service has failed because it is normal on monoline devices\n          //Quest: Is it possible to have a queued call on a monoline device ?\n          $log.warn("[telephonyService] holdCall (before answerCall) failed on callId:" + activeCall.connectionId + " " + error);\n        }).then(function () {\n          return service.answerCall(call);\n        }).then(function (thecall) {\n          resolve(thecall);\n        })["catch"](function (error) {\n          var errorMessage = "answerCall failure : " + error.message;\n          $log.error("[telephonyService] - callService -  " + errorMessage);\n          reject(new Error(errorMessage));\n        });\n      } else {\n        $http({\n          method: "PUT",\n          url: service.portalURL + "calls/" + encodeURIComponent(call.connectionId) + "/answer",\n          headers: authService.getRequestHeader()\n        }).then(function success(response) {\n          // Update call status \n          call.setConnectionId(response.data.data.callId);\n          call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n          $log.info("[telephonyService] answerCall success : " + utilService.anonymizePhoneNumber(call.contact.phone) + " Call (" + call + ")"); // Send call update event\n\n          $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n          resolve(call);\n        }, function failure(response) {\n          // UGLY ERROR TEST MANAGMENT (NO ERROR CODE)\n          if (response.data && response.data.errorDetails === "Device is not able to answer a call") {\n            $rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", {\n              autoClose: false,\n              okLabel: "close",\n              popupTitle: "warning",\n              popupBody: "deviceDoesntAllowAnswer"\n            });\n          }\n\n          call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "answerCall"));\n        });\n      }\n    });\n  };\n  /*************************************************************/\n\n  /*                      HOLD CALL STUFF                      */\n\n  /*************************************************************/\n\n  /**\n   * HOLD CALL\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.holdCall = function (call) {\n    return $q(function (resolve, reject) {\n      // Ignore call already hold\n      if (!call || call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.HOLD) {\n        resolve(call);\n        return;\n      } //reject not allowed operations\n\n\n      if (!service.isSecondCallAllowed) {\n        var profileError = new Error("holdCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      } //sipWise++\n\n\n      if (service.isSipWise()) {\n        //sipWise case\n        service.telephonyServiceSipWise.holdCallSipWise(service, call).then(function success(theCall) {\n          resolve(theCall);\n        }, function failure(error) {\n          reject(error);\n        });\n        return;\n      }\n\n      ; //sipWise--\t\t\t\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "calls/" + encodeURIComponent(call.connectionId) + "/hold",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        $log.info("[telephonyService] holdCall success : " + utilService.anonymizePhoneNumber(call.contact.phone) + " Call (" + call + ")"); // Update call status \n\n        call.setConnectionId(response.data.data.callId);\n        call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.HOLD); // Send call update event\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n        resolve(call);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "holdCall"));\n      });\n    });\n  };\n  /*************************************************************/\n\n  /*                     RETRIEVE CALL STUFF                   */\n\n  /*************************************************************/\n\n  /**\n   * RETRIEVE\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.retrieveCall = function (call) {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] retrieveCall : " + call.contact.displayNameForLog()); //reject not allowed operations\t\t\t\t\n\n      if (!service.isSecondCallAllowed) {\n        var profileError = new Error("retrieveCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      } // First hold the current active call \n\n\n      var activeCall = service.getActiveCall();\n\n      if (activeCall) {\n        service.holdCall(activeCall).then(function () {\n          return service.retrieveCall(call);\n        }).then(function (thecall) {\n          resolve(thecall);\n        })["catch"](function (error) {\n          var errorMessage = "retrieveCall failure : " + error.message;\n          $log.error("[telephonyService] - callService -  " + errorMessage);\n          reject(new Error(errorMessage));\n        });\n      } else {\n        //sipWise++\n        if (service.isSipWise()) {\n          //sipWise case\n          service.telephonyServiceSipWise.retrieveCallSipWise(service, call).then(function success(theCall) {\n            resolve(theCall);\n          }, function failure(error) {\n            reject(error);\n          });\n          return;\n        }\n\n        ; //sipWise--\n\n        $http({\n          method: "PUT",\n          url: service.portalURL + "calls/" + encodeURIComponent(call.connectionId) + "/retrieve",\n          headers: authService.getRequestHeader()\n        }).then(function success(response) {\n          $log.info("[telephonyService] retrieveCall success : " + utilService.anonymizePhoneNumber(call.contact.phone) + " Call (" + call + ")"); // Update call status \n\n          call.setConnectionId(response.data.data.callId);\n          call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE); // Send call update event\n\n          $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n          resolve();\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response); //clean client call not existing on server\n\n          service.deleteCallIfInvalid(error, call);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "retrieveCall"));\n        });\n      }\n    });\n  };\n  /*************************************************************/\n\n  /*                     DEFLECT CALL STUFF                    */\n\n  /*************************************************************/\n\n  /**\n   * DEFLECT TO VM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.deflectCallToVM = function (call) {\n    return $q(function (resolve, reject) {\n      // Ignore wrong request\n      if (!call) {\n        resolve(call);\n        return;\n      } //reject not allowed operations\t\t\t\t\n\n\n      if (!service.isVMDeflectCallAllowed) {\n        var profileError = new Error("deflectCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      $log.info("[telephonyService] deflectCallToVM " + call.contact.displayNameForLog()); //sipWise++\n\n      if (service.isSipWise()) {\n        //sipWise case\n        service.telephonyServiceSipWise.deflectCallSipWise(service, call, service.voicemailNumber).then(function success() {\n          resolve();\n        }, function failure(error) {\n          reject(error);\n        });\n        return;\n      }\n\n      ; //sipWise--\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "calls/" + encodeURIComponent(call.connectionId) + "/deflect",\n        headers: authService.getRequestHeader(),\n        data: {\n          calleeExtNumber: "",\n          calleeIntNumber: service.voicemailNumber,\n          calleeShortNumber: service.voicemailNumber,\n          calleePbxId: service.pbxId\n        }\n      }).then(function success() {\n        $log.info("[telephonyService] deflectCall success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "deflectCallToVM"));\n      });\n    });\n  };\n  /**\n   * DEFLECT TO OTHER NUMBER\n   * Used by SDK (public)\n   * Warning when modifying this method\n   * note: only available with sipwise\n   */\n\n\n  service.deflectCallToNumber = function (call, number) {\n    return $q(function (resolve, reject) {\n      // Ignore wrong request\n      if (!call || !number) {\n        resolve(call);\n        return;\n      } //reject not allowed operations\t(note : isVMDeflectCallAllowed is also for non VM deflect\t)\t\t\n\n\n      if (!service.isVMDeflectCallAllowed) {\n        var profileError = new Error("deflectCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      $log.info("[telephonyService] deflectCallToNumber " + call.contact.displayNameForLog()); //sipWise++\n\n      if (service.isSipWise() && service.sipWiseMode() === "demo") {\n        //sipWise case DEMO MODE RESTRICTION\n        service.telephonyServiceSipWise.deflectCallSipWise(service, call, number).then(function success() {\n          resolve();\n        }, function failure(error) {\n          reject(error);\n        });\n        return;\n      } else {\n        var profileError = new Error("deflectCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n      }\n\n      ; //sipWise--\n    });\n  };\n  /*************************************************************/\n\n  /*                   TRANSFERT CALL STUFF                    */\n\n  /* Used by SDK (public)                                      */\n\n  /* Warning when modifying this method                        */\n\n  /*************************************************************/\n\n\n  service.transfertCall = function (activeCall, heldCall) {\n    return $q(function (resolve, reject) {\n      // Ignore wrong request\n      if (!activeCall || !heldCall) {\n        resolve();\n        return;\n      } //reject not allowed operations\n\n\n      if (!service.isTransferAllowed) {\n        var profileError = new Error("transferCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      $log.info("[telephonyService] transfertCall held(" + heldCall.contact.displayName + ") to active(" + activeCall.contact.displayName + ")"); //sipWise++\n\n      if (service.isSipWise()) {\n        //sipWise case\n        if (service.sipWiseMode() === "demo") {\n          return service.telephonyServiceSipWise.transfertCallSipWise(service, activeCall, heldCall);\n        } else {\n          $log.info("[telephonyService] Transfert sipWise not implemented");\n          var profileError = new Error("transferCall failure - Not Allowed");\n          profileError.status = profileError.errorDetailsCode = "403";\n          $log.error("[telephonyService] " + profileError.message);\n          reject(profileError);\n          return;\n        }\n      } //sipWise--\n\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "calls/" + encodeURIComponent(activeCall.connectionId) + "/transfer/" + encodeURIComponent(heldCall.connectionId),\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[telephonyService] transferCall success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "transfertCall"));\n      });\n    });\n  };\n  /*************************************************************/\n\n  /*               BLIND TRANSFERT CALL STUFF (only sipwise)   */\n\n  /*************************************************************/\n\n\n  service.blindTransfertCall = function (activeCall, calleNumber) {\n    return $q(function (resolve, reject) {\n      // Ignore request without parameters\n      if (!activeCall || !calleNumber) {\n        resolve();\n        return;\n      } //reject not allowed operations\n\n\n      if (!service.isTransferAllowed || !service.isSipWise()) {\n        //only when sipwise\n        var profileError = new Error("blind transfertCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      } //sipWise++ only sipwise use case\n\n\n      if (service.sipWiseMode() === "demo") {\n        return service.telephonyServiceSipWise.blindTransfertCallSipWise(service, activeCall, calleNumber);\n      } else {\n        $log.info("[telephonyService]  blind Transfert sipWise not implemented");\n        var profileError = new Error("blind transferCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      } //sipWise--\n\n    });\n  };\n  /*************************************************************/\n\n  /* MAKE CONFERENCE CALL STUFF                                */\n\n  /*************************************************************/\n\n\n  service.conferenceCall = function (activeCall, heldCall) {\n    return $q(function (resolve, reject) {\n      // Ignore wrong request\n      if (!activeCall || !heldCall) {\n        resolve();\n        return;\n      } //reject not allowed operations\n\n\n      if (!service.isConferenceAllowed) {\n        var profileError = new Error("conferenceCall failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      $log.info("[telephonyService] conferenceCall " + activeCall.contact.displayName + " and " + heldCall.contact.displayName); //sipWise++\n\n      if (service.isSipWise()) {\n        //sipWise case\n        if (service.sipWiseMode() === "demo") {\n          return service.telephonyServiceSipWise.conferenceCallSipWise(service, activeCall, heldCall);\n        } else {\n          $log.info("[telephonyService] Conference sipWise not implemented");\n          return;\n        }\n      } //sipWise--\n\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "calls/" + encodeURIComponent(activeCall.connectionId) + "/conference/" + encodeURIComponent(heldCall.connectionId),\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[telephonyService] conferenceCall success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "conferenceCall"));\n      });\n    });\n  };\n  /*************************************************************/\n\n  /* FORWARD CALL STUFF               \t\t                 */\n\n  /* Used by SDK (public)                                      */\n\n  /* Warning when modifying this method                        */\n\n  /*************************************************************/\n\n\n  service.forwardToDevice = function (phoneNumber) {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] forwardToDevice : " + phoneNumber); //reject not allowed operations\n\n      if (!service.isForwardEnabled) {\n        var profileError = new Error("forwardToDevice failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      if (contactService.userContact.phonePro === phoneNumber || contactService.userContact.phoneProCan === phoneNumber || contactService.userContact.phonePbx === phoneNumber) {\n        var errorMessage = "forwardToDevice failure: impossible to forward its own phone number";\n        $log.error("[telephonyService] " + errorMessage);\n        reject(new Error(errorMessage));\n        return;\n      } //sipWise++\n\n\n      if (service.isSipWise()) {\n        //sipWise case\n        if (service.sipWiseMode() === "demo") {\n          service.telephonyServiceSipWise.forwardToDeviceSipWise(service, phoneNumber).then(function success() {\n            resolve();\n          }, function failure(response) {\n            var error = errorHelperService.handleError(response);\n            reject(error);\n            $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "forwardToDevice"));\n          });\n          return;\n        } else {\n          var errorMessage = "forwardToDevice : not implemented";\n          $log.error("[telephonyService] " + errorMessage);\n          reject(new Error(errorMessage));\n          return;\n        }\n      } //sipWise--\n\n\n      contactService.getOrCreateContact(null, phoneNumber).then(function (contact) {\n        var phoneInfo = service.getPhoneInfo(contact, phoneNumber);\n        $http({\n          method: "PUT",\n          url: service.portalURL + "forward",\n          headers: authService.getRequestHeader(),\n          data: {\n            calleeExtNumber: phoneInfo.longNumber,\n            calleeIntNumber: phoneInfo.internalNumber,\n            calleeShortNumber: phoneInfo.shortNumber,\n            calleePbxId: phoneInfo.pbxId,\n            calleeDisplayName: contact.displayName\n          }\n        }).then(function success() {\n          // TODO: subscribe somehow to ON_CALL_FORWARDED_EVENT is order to know that foward is applied\t\n          resolve();\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "forwardToDevice"));\n        });\n      });\n    });\n  };\n  /*************************************************************/\n\n  /* Used by SDK (public)                                      */\n\n  /* Warning when modifying this method                        */\n\n  /*************************************************************/\n\n\n  service.forwardToVoicemail = function () {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] forwardToVoicemail");\n\n      if (!service.voiceMailFeatureEnabled || !service.isForwardEnabled) {\n        var profileError = new Error("forwardToVoicemail failure - voicemail/forward feature not enabled");\n        profileError.status = profileError.errorDetailsCode = "404";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "forward",\n        headers: authService.getRequestHeader(),\n        data: {\n          calleeExtNumber: "",\n          calleeIntNumber: service.voicemailNumber,\n          calleePbxId: service.pbxId\n        }\n      }).then(function success() {\n        // TODO: subscribe somehow to ON_CALL_FORWARDED_EVENT is order to know that foward is applied\t\n        $log.info("[telephonyService] forwardToVoicemail success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "forwardToVoicemail"));\n      });\n    });\n  };\n  /*************************************************************/\n\n  /* Used by SDK (public)                                      */\n\n  /* Warning when modifying this method                        */\n\n  /*************************************************************/\n\n\n  service.cancelForward = function () {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] cancelForward"); //reject not allowed operations\n\n      if (!service.isForwardEnabled) {\n        var profileError = new Error("cancelForward failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      } //sipWise++\n\n\n      if (service.isSipWise()) {\n        //sipWise case\n        if (service.sipWiseMode() === "demo") {\n          service.telephonyServiceSipWise.cancelForwardSipWise(service).then(function success() {\n            resolve();\n          }, function failure(response) {\n            var error = errorHelperService.handleError(response);\n            reject(error);\n            $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "cancelForward"));\n          });\n          return;\n        } else {\n          var errorMessage = "cancelForward : not implemented";\n          $log.error("[telephonyService] " + errorMessage);\n          reject(new Error(errorMessage));\n          return;\n        }\n      } //sipWise--\n\n\n      if (contactService.userContact.phonePbx) {\n        $http({\n          method: "PUT",\n          url: service.portalURL + "forward",\n          headers: authService.getRequestHeader(),\n          data: {\n            calleeExtNumber: "",\n            calleeIntNumber: "CANCELFORWARD",\n            calleePbxId: service.pbxId\n          }\n        }).then(function success() {\n          $log.info("[telephonyService] cancelForward success");\n          resolve();\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "cancelForward"));\n        });\n      } else {\n        reject();\n      }\n    });\n  };\n  /*************************************************************/\n\n  /* Used by SDK (public)                                      */\n\n  /* Warning when modifying this method                        */\n\n  /*************************************************************/\n\n\n  service.getForwardStatus = function () {\n    return $q(function (resolve, reject) {\n      //sipWise++ PROVISOIRE\t\t\n      if (service.isSipWise()) {\n        $log.info("[telephonyService] getForwardStatus -- SipWise BYPASS");\n        resolve();\n        return;\n      } //sipWise-- PROVISOIRE\n      //reject not allowed operations\n\n\n      if (!service.isForwardEnabled) {\n        var profileError = new Error("getForwardStatus failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      if (service.starting || service.started) {\n        //telephony starting or started means that the user is attached to a pbx device\n        $http({\n          method: "GET",\n          url: service.portalURL + "forward",\n          headers: authService.getRequestHeader()\n        }).then(function success() {\n          // Nothing much to do here, the real call forward status will arrive by XMPP (see ON_CALL_FORWARDED_EVENT)\n          $log.info("[telephonyService] getForwardStatus success");\n          resolve();\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "getForwardStatus"));\n        });\n      } else {\n        reject(new Error("getForwardStatus failure - Telephony not started"));\n      }\n    });\n  };\n  /*************************************************************/\n\n  /* Used by SDK (public)                                      */\n\n  /* Warning when modifying this method                        */\n\n  /*************************************************************/\n\n\n  service.getForwardObject = function () {\n    return service.forwardObject;\n  };\n  /*************************************************************/\n\n  /* NOMADIC CALL STUFF               \t\t                 */\n\n  /*************************************************************/\n\n\n  service.nomadicLogin = function (phoneNumber, isUnchangeableNumber, NotTakeIntoAccount) {\n    return $q(function (resolve, reject) {\n      //reject not allowed operations\n      if (!service.isNomadicEnabled || !service.nomadicObject.featureActivated) {\n        var profileError = new Error("nomadicLogin failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      if (contactService.userContact.phonePro === phoneNumber || contactService.userContact.phoneProCan === phoneNumber || contactService.userContact.phonePbx === phoneNumber) {\n        var errorMessage = "nomadicLogin failure: impossible to use its own phone number like nomadic phone";\n        $log.error("[telephonyService] " + errorMessage);\n        reject(new Error(errorMessage));\n        return;\n      }\n\n      $log.info("[telephonyService] nomadicLogin : " + utilService.anonymizePhoneNumber(phoneNumber));\n      NotTakeIntoAccount = NotTakeIntoAccount || false;\n      isUnchangeableNumber = isUnchangeableNumber || false;\n      service.nomadicAnswerNotTakedIntoAccount = NotTakeIntoAccount;\n      contactService.getOrCreateContact(null, phoneNumber).then(function (contact) {\n        var phoneInfo = service.getPhoneInfo(contact, phoneNumber);\n        $http({\n          method: "PUT",\n          url: service.portalURL + "nomadic/login",\n          headers: authService.getRequestHeader(),\n          data: {\n            destinationExtNumber: phoneInfo.longNumber,\n            destinationIntNumber: phoneInfo.internalNumber,\n            destinationShortNumber: phoneInfo.shortNumber,\n            destinationRainbowNumber: isUnchangeableNumber ? phoneNumber : "",\n            destinationPbxId: phoneInfo.pbxId,\n            destinationDisplayName: contact.displayName,\n            destinationCountry: contact.country\n          }\n        }).then(function success() {\n          //service.forwardToDevice(phoneNumberReceived);\n          // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\t\n          $log.info("[telephonyService] nomadicLogin success"); //service.isMakeCallInitiatorIsMain = false;\n\n          resolve();\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "nomadicLogin"));\n        });\n      });\n    });\n  };\n\n  service.nomadicLoginOnOfficePhone = function () {\n    return $q(function (resolve, reject) {\n      //reject not allowed operations\n      if (!service.isNomadicEnabled || !service.nomadicObject.featureActivated) {\n        var profileError = new Error("nomadicLoginOnOfficePhone failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      $log.info("[telephonyService] nomadicLoginOnOfficePhone");\n      $http({\n        method: "PUT",\n        url: service.portalURL + "nomadic/login",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        //service.cancelForward();\n        // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\t\n        $log.info("[telephonyService] nomadicLoginOnOfficePhone success"); //service.isMakeCallInitiatorIsMain = true;\n\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "nomadicLoginOnOfficePhone"));\n      });\n    });\n  };\n\n  service.nomadicLogout = function () {\n    return $q(function (resolve, reject) {\n      //reject not allowed operations\n      if (!service.isNomadicEnabled || !service.nomadicObject.featureActivated) {\n        var profileError = new Error("nomadicLogout failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      $log.info("[telephonyService] nomadicLogout");\n      $http({\n        method: "PUT",\n        url: service.portalURL + "nomadic/logout",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        //service.cancelForward();\n        // TODO: subscribe somehow to ON_NOMADIC_EVENT is order to know that foward is applied\t\n        $log.info("[telephonyService] nomadicLogout success"); //service.isMakeCallInitiatorIsMain = true;\n\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "nomadicLogout"));\n      });\n    });\n  };\n\n  service.getNomadicStatus = function () {\n    return $q(function (resolve, reject) {\n      //sipWise++ PROVISOIRE_SIPWISE\t\t\n      if (service.isSipWise()) {\n        $log.info("[telephonyService] getNomadicStatus -- SipWise bypass Nomadic");\n        var response = "";\n        response.featureActivated === "true";\n        response.modeActivated === "true";\n        response.makeCallInitiatorIsMain === "true"; //service.updateNomadicData(response);\n\n        resolve();\n        return;\n      } //sipWise-- PROVISOIRE_SIPWISE\n      //reject not allowed operations\n\n\n      if (!service.isNomadicEnabled) {\n        var profileError = new Error("getNomadicStatus failure - Not Allowed");\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[telephonyService] " + profileError.message);\n        reject(profileError);\n        return;\n      }\n\n      if (service.starting || service.started) {\n        //telephony starting or started means that the user is attached to a pbx device\n        $http({\n          method: "GET",\n          url: service.portalURL + "nomadic",\n          headers: authService.getRequestHeader()\n        }).then(function success(response) {\n          $log.info("[telephonyService] getNomadicStatus success");\n          service.updateNomadicData(response.data.data);\n          resolve();\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "getNomadicStatus"));\n        });\n      } else {\n        reject(new Error("getNomadicStatus failure - Telephony not started"));\n      }\n    });\n  };\n\n  service.setNomadicState = function () {\n    return $q(function (resolve, reject) {\n      $log.info("[telephonyService] setNomadicState");\n      $http({\n        method: "PUT",\n        url: service.portalURL + "nomadic/state",\n        headers: authService.getRequestHeader(),\n        data: {\n          makeCallInitiatorIsMain: "true"\n        }\n      }).then(function success() {\n        $log.info("[telephonyService] setNomadicState success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "setNomadicState"));\n      });\n    });\n  };\n\n  service.updateNomadicData = function (response) {\n    var destination = response.destination ? utilService.anonymizePhoneNumber(response.destination) : "";\n    $log.info("[telephonyService] updateNomadicData destination:" + destination + " featureActivated:" + response.featureActivated + " makeCallInitiatorIsMain:" + response.makeCallInitiatorIsMain + " modeActivated:" + response.modeActivated + " monodevice:" + contactService.userContact.isVirtualTerm);\n    var nomadicObjectOrg = JSON.parse(JSON.stringify(service.nomadicObject));\n    service.nomadicObject.featureActivated = response.featureActivated === "true";\n    service.nomadicObject.modeActivated = response.modeActivated === "true";\n    service.nomadicObject.destination = response.destination;\n    service.nomadicObject.makeCallInitiatorIsMain = response.makeCallInitiatorIsMain === "true";\n    var makeCallInitiatorIsMainChanged = nomadicObjectOrg.makeCallInitiatorIsMain !== service.nomadicObject.makeCallInitiatorIsMain;\n\n    if (!service.nomadicAnswerNotTakedIntoAccount) {\n      $rootScope.$broadcast("ON_CALL_NOMADIC_EVENT", service.nomadicObject);\n    }\n\n    service.nomadicAnswerNotTakedIntoAccount = false; // By default if mobilepro or mobileperso exist, then add it on destination\n\n    /*if (service.nomadicObject.featureActivated && (service.nomadicObject.destination === "" || service.nomadicObject.destination === undefined) && (contactService.userContact.mobileProCan || contactService.userContact.mobilePerso)) {\n    \tvar defaultNumber = contactService.userContact.mobileProCan ? contactService.userContact.mobileProCan : contactService.userContact.mobilePerso;\n    \tservice.nomadicLogin(defaultNumber)\n    \t\t.then(function() {\n    \t\t\tservice.nomadicLoginOnOfficePhone();\n    \t\t});\n    }*/\n    // by default, in monodevice, if mediapillar exist, then add it on destination\n    // else if by default, in monodevice, mobilepro or mobileperso exist, then add it on destination\n\n    var webrtcGatewayService = $injector.get("webrtcGatewayService");\n\n    if (contactService.userContact.isVirtualTerm && service.nomadicObject.featureActivated && (service.nomadicObject.destination === "" || service.nomadicObject.destination === undefined) && webrtcGatewayService.isMediaPillarConfigured()) {\n      var defaultNumber = webrtcGatewayService.getMyMediaPillarRemoteExtension();\n      service.nomadicLogin(defaultNumber);\n    } else if (contactService.userContact.isVirtualTerm && service.nomadicObject.featureActivated && (service.nomadicObject.destination === "" || service.nomadicObject.destination === undefined) && (contactService.userContact.mobileProCan || contactService.userContact.mobilePerso)) {\n      var defaultNumber = contactService.userContact.mobileProCan ? contactService.userContact.mobileProCan : contactService.userContact.mobilePerso;\n      service.nomadicLogin(defaultNumber);\n    }\n\n    return makeCallInitiatorIsMainChanged;\n  };\n\n  service.getNomadicObject = function () {\n    return service.nomadicObject;\n  };\n\n  service.getNomadicDestination = function () {\n    return service.nomadicObject.destination;\n  };\n  /*************************************************************/\n\n  /* DTMF             \t\t                 \t\t\t\t*/\n\n  /*************************************************************/\n\n\n  service.sendDtmf = function (call, dtmf) {\n    return $q(function (resolve, reject) {\n      if (call && dtmf) {\n        //sipWise++\n        if (service.isSipWise()) {\n          //sipWise case\n          service.telephonyServiceSipWise.sendDtmfSipWise(service, call, dtmf).then(function success() {\n            resolve();\n          }, function failure(error) {\n            reject(error);\n          });\n          return;\n        }\n\n        ; //sipWise--\n        //normal PBX case\n\n        $http({\n          method: "PUT",\n          url: service.portalURL + "calls/" + encodeURIComponent(call.connectionId) + "/dtmf",\n          headers: authService.getRequestHeader(),\n          data: {\n            dtmf: dtmf\n          }\n        }).then(function success() {\n          $rootScope.$broadcast("ON_DTMF_SENT", dtmf);\n          resolve();\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[telephonyService] " + errorHelperService.getErrorFullMessage(response, "sendDtmf"));\n        });\n      } else {\n        reject();\n      }\n    });\n  };\n\n  service.clearCall = function (call, nobroadcast) {\n    $log.info("[telephonyService] clearCall for call id: " + call.id);\n    call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n\n    if (!nobroadcast) {\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n    }\n\n    if (call.contact) {\n      delete service.calls[call.contact.id];\n    }\n\n    if (call.getCurrentCalled()) {\n      call.setCurrentCalled(null);\n    } //delete service.calls[call.id];\n\n  };\n\n  service.startAsPhoneNumber = function (phoneNumber) {\n    var cleanPhoneNumber = phoneNumber.trim().split(".").join("");\n    var pattern1 = /^(\\+|\\d|#|\\*|\\(|\\)|\\.|-|–|—|\\s|\\/)*$/;\n    var match = cleanPhoneNumber.match(pattern1);\n\n    if (!match) {\n      return false;\n    }\n\n    return match[0] === cleanPhoneNumber;\n  };\n\n  service.updateContactFromOutlookInfos = function (__contact, __phoneNumber, __reload, __mode) {\n    $log.info("[telephonyService] default updateContactFromOutlookInfos"); //reject by default\n\n    return $q.reject();\n  };\n  /*********************************************************/\n\n  /**                 SIPWISE STUFF                       **/\n\n  /*********************************************************/\n\n\n  service.setSipWise = function (condition) {\n    sipWise = condition;\n  }; //end setSipWise\t\n\n\n  service.isSipWise = function () {\n    return sipWise;\n  }; //end IsSipWise\n\n\n  service.sipWiseMode = function () {\n    var mode = settingsService.getSetting("sipWiseMode");\n\n    if (!sipWise) {\n      mode = false;\n    }\n\n    ;\n    return mode;\n  }; //end SipWiseMode\n\n\n  service.resetAllSipWiseCall = function () {\n    /*WARNING: \n    \tThat is a servicing IQ for maintenance only,\n    \trequesting PCG to force cleaning all ghost stucked user\'s calls\n    */\n    if (service.isSipWise()) {\n      // Forge request iq\n      var iq = $iq({\n        type: "set",\n        to: service.userJidTel + "/pcg2"\n      }).c("telephony", {\n        xmlns: "urn:xmpp:pbxagent:telephony:1"\n      }).c("service").c("deleteCalls", {\n        forced: "true"\n      }); // Send "get SnapshotCall" iq\n\n      xmppService.sendIQ(iq, 60000).then(function (data) {\n        $log.info("[telephonyService] resetAllSipWiseCall : try to reset all ghost calls !");\n        console.error(data);\n      })["catch"](function (error) {\n        var errorMessage = "resetAllSipWiseCall failure : " + error.message;\n        $log.error("[telephonyService]" + errorMessage);\n      });\n    }\n  }; //end resetAllSipWiseCall\t\t\t\t\t\t\n\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/telephony/telephonyService.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__);\n\nangular.module("rainbow").factory("TelephonyServiceEventHandler", ["$log", "$q", "$rootScope", "$interval", "$injector", "contactService", "profileService", "Contact", "PromiseQueue", "pstnConferenceService", "utilService", function ($log, $q, $rootScope, $interval, $injector, contactService, profileService, Contact, PromiseQueue, pstnConferenceService, utilService) {\n  "use strict";\n  /*********************************************************************/\n\n  /** PUBLIC STATIC FACTORY                                           **/\n\n  /*********************************************************************/\n\n  TelephonyServiceEventHandler.create = function (telephonyService) {\n    return new TelephonyServiceEventHandler(telephonyService);\n  };\n  /*********************************************************************/\n\n  /** PRIVATE CONSTRUCTOR                                             **/\n\n  /*********************************************************************/\n\n\n  function TelephonyServiceEventHandler(telephonyService) {\n    this.telephonyService = telephonyService;\n    this.promiseQueue = PromiseQueue.create();\n  }\n  /*********************************************************************/\n\n  /** PRIVATE CONSTRUCTOR                                             **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.CallFailureLabels = {\n    "DESTNOTOBTAINABLE": "outOfService",\n    "DONOTDISTURB": "dnd",\n    "TRUNKSBUSY": "trunksbusy",\n    "BUSY": "busy"\n  };\n  /*********************************************************************/\n\n  /** PUBLIC METHODS                                                  **/\n\n  /*********************************************************************/\n\n  TelephonyServiceEventHandler.prototype.existingCall = function (callId) {\n    var exist = this.telephonyService.calls[callId];\n    $log.debug("[TelephonyServiceEventHandler] existingCall -- " + callId + " => " + exist);\n    return exist;\n  };\n\n  TelephonyServiceEventHandler.prototype.onCallserviceMessageReceived = function (stanza) {\n    try {\n      var stanzaElem = $(stanza);\n      var that = this; // Ignore "Offline" message\n\n      var delay = stanzaElem.find("delay");\n\n      if (delay.text() === "Offline Storage") {\n        return true;\n      } // Extract payload element\n\n\n      var actionElem = stanzaElem.find("callservice").children();\n      var tagNames = actionElem.prop("tagName").split(":");\n      var actionElemName = tagNames[tagNames.length - 1].toLowerCase();\n      var callId = actionElem.attr("callId");\n      var callIdForLogs = callId ? " -- " + callId : "";\n      var evtDeviceType = actionElem.attr("deviceType");\n      var displayDeviceType = evtDeviceType ? " -- " + evtDeviceType : "";\n      var oldCallId = actionElem.attr("oldCallId");\n      oldCallId = oldCallId ? " -- old " + oldCallId : "";\n\n      if (!evtDeviceType) {\n        evtDeviceType = "MAIN";\n      }\n\n      var cfgNomadic = this.telephonyService.getNomadicObject();\n      var cfgOfficePhone = cfgNomadic ? cfgNomadic.makeCallInitiatorIsMain || !cfgNomadic.modeActivated : true;\n      var callStateEvent = !["messaging", "voicemessages", "forwarded", "nomadicstatus", "opendesktop"].includes(actionElemName);\n\n      if (callStateEvent && (evtDeviceType === "MAIN" && !cfgOfficePhone || evtDeviceType === "SECONDARY" && cfgOfficePhone) && !that.existingCall(callId)) {\n        $log.info("[TelephonyServiceEventHandler] onCallserviceMessageReceived -- " + actionElemName.toUpperCase() + callIdForLogs + oldCallId + displayDeviceType + " => IGNORED");\n        return true;\n      } else {\n        $log.info("[TelephonyServiceEventHandler] onCallserviceMessageReceived -- " + actionElemName.toUpperCase() + callIdForLogs + oldCallId + displayDeviceType);\n      } // Handle the event\n\n\n      switch (actionElemName) {\n        case "initiated":\n          this.promiseQueue.add(function () {\n            return that.onInitiatedEvent(actionElem);\n          });\n          break;\n\n        case "originated":\n          this.promiseQueue.add(function () {\n            return that.onOriginatedEvent(actionElem);\n          });\n          break;\n\n        case "delivered":\n          this.promiseQueue.add(function () {\n            return that.onDeliveredEvent(actionElem);\n          });\n          break;\n\n        case "established":\n          this.promiseQueue.add(function () {\n            return that.onEstablishedEvent(actionElem);\n          });\n          break;\n\n        case "retrievecall":\n          this.promiseQueue.add(function () {\n            return that.onRetrieveCallEvent(actionElem);\n          });\n          break;\n\n        case "queued":\n          this.promiseQueue.add(function () {\n            return that.onQueuedEvent(actionElem);\n          });\n          break;\n\n        case "holdcall":\n        case "held":\n          this.promiseQueue.add(function () {\n            return that.onHeldEvent(actionElem);\n          });\n          break;\n        // OLD SYNTAX TO BE REMOVED\n\n        case "diverted":\n          this.promiseQueue.add(function () {\n            return that.onDivertedEvent(actionElem);\n          });\n          break;\n\n        case "transfercall":\n        case "transferred":\n          this.promiseQueue.add(function () {\n            return that.onTransferEvent(actionElem);\n          });\n          break;\n        // OLD SYNTAX TO BE REMOVED\n\n        case "conferenced":\n          this.promiseQueue.add(function () {\n            return that.onConferenceEvent(actionElem);\n          });\n          break;\n\n        case "connectioncleared":\n          this.promiseQueue.add(function () {\n            return that.onClearCallEvent(actionElem);\n          });\n          break;\n\n        case "failed":\n          this.promiseQueue.add(function () {\n            return that.onFailCallEvent(actionElem);\n          });\n          break;\n\n        case "voicemessages":\n          this.promiseQueue.add(function () {\n            return that.onVoiceMessageEvent(actionElem);\n          });\n          break;\n\n        case "updatecall":\n          this.promiseQueue.add(function () {\n            return that.onUpDateCallEvent(actionElem);\n          });\n          break;\n\n        case "forwarded":\n          this.promiseQueue.add(function () {\n            return that.onCallForwardedEvent(actionElem);\n          });\n          break;\n\n        case "callsubject":\n          this.promiseQueue.add(function () {\n            return that.onCallSubjectEvent(actionElem);\n          });\n          break;\n\n        case "nomadicstatus":\n          this.promiseQueue.add(function () {\n            return that.onCallNomadicEvent(actionElem);\n          });\n          break;\n\n        case "opendesktop":\n          $log.info("[TelephonyServiceEventHandler] openDesktop detected ");\n          break;\n\n        default:\n          break;\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[TelephonyServiceEventHandler] onCallserviceMessageReceived -- failure -- " + error.message);\n      return true;\n    }\n  };\n  /*********************************************************************/\n\n  /** INITIATED CALL STUFF                                           **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onInitiatedEvent = function (initiatedElem) {\n    $log.info("[TelephonyServiceEventHandler] onInitiatedEvent");\n    var that = this;\n    return this.getCall(initiatedElem).then(function (call) {\n      try {\n        var deviceState = initiatedElem.attr("deviceState");\n        var newConnectionId = initiatedElem.attr("newCallId");\n\n        if (newConnectionId !== undefined) {\n          that.getOrCreateCall(newConnectionId).then(function (newCall) {\n            $log.info("[TelephonyServiceEventHandler] onInitiatedEvent : changed call id from " + call.id + " to " + newConnectionId); // compute relevantEqtId and isSecondary properties of new call\n\n            that.computeCallRelevancy(initiatedElem, newCall); // copy status from old call to new call\n\n            if (deviceState === "LCI_CONNECTED") {\n              newCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n            } else {\n              newCall.setStatus(call.status);\n            } // copy contact from old call to new call\n\n\n            newCall.setContact(call.contact); // copy isOwner from old call to new call\n\n            newCall.isOwner = call.isOwner; // PGi makeCall when user connected to OXO system\n\n            var confSession = pstnConferenceService.getConferenceSessionWithConnId(call.connectionId);\n\n            if (confSession) {\n              confSession.setCallId(newConnectionId);\n            } // Media Pillar ++: swap callref in media pillar context \n\n\n            if (call.isMediaPillarCall()) {\n              var webrtcGatewayService = $injector.get("webrtcGatewayService");\n              webrtcGatewayService.replaceCallRefs(newCall, call);\n            } // Media Pillar --\n            // remove old call\n\n\n            that.telephonyService.clearCall(call);\n            that.sendCallUpdateEvent(call);\n            that.sendCallUpdateEvent(newCall);\n            delete that.telephonyService.calls[call.id];\n          });\n        } else {\n          that.computeCallRelevancy(initiatedElem, call);\n          /*CRRAINB-5204++\n          that.computeCallRelevancy(initiatedElem, call);\n          call.setStatus(Call.Status.DIALING);\n          that.sendCallUpdateEvent(call);\n          */\n          //CRRAINB-5204++\n        }\n\n        return $q.when();\n      } catch (error) {\n        var errorMessage = "onInitiatedEvent -- " + error.message;\n        $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n        return $q.reject(new Error(errorMessage));\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** ORIGINATED CALL STUFF                                           **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onOriginatedEvent = function (originatedElem) {\n    $log.info("[TelephonyServiceEventHandler] onOriginatedEvent");\n    var that = this;\n    return this.getCall(originatedElem).then(function (call) {\n      try {\n        var jid = originatedElem.attr("endpointIm");\n        var phoneNumber = originatedElem.attr("endpointTel");\n        var newConnectionId = originatedElem.attr("newCallId");\n        var currentCalled = {\n          contactPhoneNumber: "",\n          contact: call.contact,\n          participantsPhoneNumbers: null,\n          participants: null\n        }; // PCG has some info\n\n        if (jid || phoneNumber) {\n          currentCalled.contactPhoneNumber = phoneNumber ? phoneNumber : "";\n        } // Unknown user\n        else if (call.contact && call.contact.temp) {\n            currentCalled.contactPhoneNumber = call.contact.id; //that is the only current known phoneNumber\n          }\n\n        call.setCurrentCalled(currentCalled);\n\n        if (newConnectionId !== undefined) {\n          that.getOrCreateCall(newConnectionId, jid, phoneNumber).then(function (newCall) {\n            $log.info("[TelephonyServiceEventHandler] onOriginatedEvent : changed call id from " + call.id + " to " + newConnectionId); // compute relevantEqtId and isSecondary properties of new call\n\n            that.computeCallRelevancy(originatedElem, newCall); // copy status from old call to new call\n\n            newCall.setStatus(call.status); // copy contact from old call to new call\n\n            newCall.setContact(call.contact); // copy currentCalled from old call to new call\n\n            newCall.setCurrentCalled(currentCalled); // copy isOwner from old call to new call\n\n            newCall.isOwner = call.isOwner; // PGi makeCall when user connected to OXO system\n\n            var confSession = pstnConferenceService.getConferenceSessionWithConnId(call.connectionId);\n\n            if (confSession) {\n              confSession.setCallId(newConnectionId);\n            } // Media Pillar ++: swap callref in media pillar context \n\n\n            if (call.isMediaPillarCall()) {\n              var webrtcGatewayService = $injector.get("webrtcGatewayService");\n              webrtcGatewayService.replaceCallRefs(newCall, call);\n            } // Media Pillar --\n            // remove old call\n\n\n            that.telephonyService.clearCall(call);\n            that.sendCallUpdateEvent(call);\n            that.sendCallUpdateEvent(newCall);\n            delete that.telephonyService.calls[call.id];\n          });\n        } else {\n          that.sendCallUpdateEvent(call);\n        }\n\n        return $q.when();\n      } catch (error) {\n        var errorMessage = "onOriginatedEvent -- " + error.message;\n        $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n        return $q.reject(new Error(errorMessage));\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** DELIVERED STUFF                                                 **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onDeliveredEvent = function (deliveredElem) {\n    $log.info("[TelephonyServiceEventHandler] onDeliveredEvent");\n    var that = this;\n    return this.getCall(deliveredElem).then(function (call) {\n      try {\n        that.computeCallRelevancy(deliveredElem, call); //NEW_MP1++\n        //if (!call.isSecondary) {that.computeCallRelevancy(deliveredElem, call);}\t\t\t\t\t\n        //NEW_MP1--\n\n        if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_INCOMMING) {\n          return $q.resolve();\n        }\n\n        var type = deliveredElem.attr("type");\n        var jid = deliveredElem.attr("endpointIm");\n        var phoneNumber = deliveredElem.attr("endpointTel");\n        call.setStatus(type === "outgoing" ? _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_OUTGOING : _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING);\n        call.startDate = null;\n        call.vm = false; // Update contact info if necessary\n\n        return that.updateCallContact(jid, phoneNumber, deliveredElem, call);\n      } catch (error) {\n        var errorMessage = "onDeliveredEvent -- " + error.message;\n        $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n        return $q.reject(new Error(errorMessage));\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** ESTABLISHED STUFF                                               **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onEstablishedEvent = function (establishedElem) {\n    $log.info("[TelephonyServiceEventHandler] onEstablishedEvent");\n    var that = this;\n    return this.getCall(establishedElem).then(function (call) {\n      try {\n        that.computeCallRelevancy(establishedElem, call);\n        var jid = establishedElem.attr("endpointIm");\n        var phoneNumber = establishedElem.attr("endpointTel");\n        var connectionId = establishedElem.attr("callId"); // Call already exists and IS NOT a conference, update contact info if necessary\n\n        if (call.contact && call.contact.id) {\n          call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n          call.setConnectionId(connectionId);\n          that.sendCallUpdateEvent(call, establishedElem); // Update contact info as necessary\n\n          return that.updateCallContact(jid, phoneNumber, establishedElem, call);\n        } // Call already exists and IS a conference, update contact info if necessary\n        else if (call.participants && call.participants.length > 0) {\n            //recover former matching contact from participants \n            var contactRecovered = null;\n\n            for (var i = 0; i < call.participants.length && !contactRecovered; i++) {\n              if (call.participants[i].id === jid) {\n                contactRecovered = call.participants[i];\n              } else if (call.currentCalled.participantsPhoneNumbers && call.currentCalled.participantsPhoneNumbers.length > 0 && call.currentCalled.participantsPhoneNumbers[i] === phoneNumber) {\n                contactRecovered = call.participants[i];\n              }\n            } //clean former conf struct & update contact\n\n\n            call.participants = [];\n            call.isConference = false;\n            var currentCalled = call.getCurrentCalled();\n\n            if (contactRecovered) {\n              call.setContact(contactRecovered);\n              call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n              currentCalled = {\n                contactPhoneNumber: phoneNumber,\n                contact: contactRecovered\n              };\n              call.setCurrentCalled(currentCalled);\n              that.sendCallUpdateEvent(call, establishedElem);\n            } else {\n              // no matching contact strange but go ahead ...\n              if (!jid && !phoneNumber) {\n                phoneNumber = "****";\n              }\n\n              return contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n                call.setContact(contact);\n                call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n                currentCalled = {\n                  contactPhoneNumber: phoneNumber,\n                  contact: contact\n                };\n                call.setCurrentCalled(currentCalled);\n                that.sendCallUpdateEvent(call, establishedElem);\n                return $q.when();\n              });\n            }\n          } else {\n            //strange situation, no call contact and not a conf with call participants\n            //CRRAINB-4392\n            $log.info("[TelephonyServiceEventHandler] onEstablishedEvent, no call contact / no participants");\n\n            if (!jid && !phoneNumber) {\n              phoneNumber = "****";\n            }\n\n            return contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n              call.setContact(contact);\n              call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n              currentCalled = {\n                contactPhoneNumber: phoneNumber,\n                contact: contact\n              };\n              call.setCurrentCalled(currentCalled);\n              that.sendCallUpdateEvent(call, establishedElem);\n              return $q.when();\n            });\n          }\n\n        return $q.when();\n      } catch (error) {\n        var errorMessage = "onEstablishedEvent -- " + error.message;\n        $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n        return $q.reject(new Error(errorMessage));\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** RETRIEVE CALL STUFF                                             **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onRetrieveCallEvent = function (retrieveElem) {\n    $log.info("[TelephonyServiceEventHandler] onRetrieveCallEvent");\n    var that = this;\n    return this.getCall(retrieveElem, true).then(function (call) {\n      call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE); // Don\'t compute call relevancy here because equipmentId may be the Equipment Id of the other party\n\n      that.sendCallUpdateEvent(call, retrieveElem);\n    });\n  };\n  /*********************************************************************/\n\n  /** CLEAR CALL STUFF                                                **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onClearCallEvent = function (clearElem) {\n    var that = this;\n    var connectionId = clearElem.attr("callId");\n    var callId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(connectionId);\n    $log.info("[TelephonyServiceEventHandler] onClearCallEvent, connectionId: " + connectionId);\n\n    if (this.telephonyService.calls[callId]) {\n      return this.getCall(clearElem).then(function (call) {\n        that.computeCallRelevancy(clearElem, call); //MP_GENE_SEC\n\n        that.telephonyService.clearCall(call, true); //2nd para true for clearcall without broadcast\n\n        that.sendCallUpdateEvent(call, clearElem);\n      });\n    } else {\n      $log.info("[TelephonyServiceEventHandler] onClearCallEvent, no call for connectionId: " + connectionId);\n    }\n\n    return $q.resolve();\n  };\n  /*********************************************************************/\n\n  /** HOLD CALL STUFF                                                 **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onHeldEvent = function (heldElem) {\n    $log.info("[TelephonyServiceEventHandler] onHeldEvent");\n    var that = this;\n    return this.getCall(heldElem, true).then(function (call) {\n      try {\n        var connectionId = heldElem.attr("callId");\n        var callDeviceId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(call.connectionId);\n        var holdDeviceId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(connectionId);\n\n        if (callDeviceId === holdDeviceId) {\n          call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.HOLD);\n        } // Same callId but different equipmentId (We receive equipment id of user who put us in held)\n        else {\n            call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.PUT_ON_HOLD);\n          } // Don\'t compute call relevancy here because equipmentId may be the Equipment Id of the other party\n\n\n        that.sendCallUpdateEvent(call, heldElem);\n        return $q.when();\n      } catch (error) {\n        var errorMessage = "onHeldEvent -- " + error.message;\n        $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n        return $q.reject(new Error(errorMessage));\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** QUEUED STUFF                                                    **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onQueuedEvent = function (queuedElem) {\n    $log.info("[TelephonyServiceEventHandler] onQueuedEvent");\n    var that = this;\n    var cause = queuedElem.attr("cause");\n\n    if (cause === "PARK") {\n      $log.warn("[TelephonyServiceEventHandler] onQueuedEvent - ignore PARK cause");\n      return $q.when();\n    }\n\n    if (cause === "NEWCALL") {\n      $log.warn("[TelephonyServiceEventHandler] onQueuedEvent - ignore NEWCALL cause");\n      return $q.when();\n    }\n\n    return this.getCall(queuedElem).then(function (call) {\n      try {\n        that.computeCallRelevancy(queuedElem, call); //MP_GENE_SEC\n\n        var type = queuedElem.attr("type");\n        var jid = queuedElem.attr("endpointIm");\n        var phoneNumber = queuedElem.attr("endpointTel");\n        var status = type === "outgoing" ? _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_OUTGOING : _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.QUEUED_INCOMMING;\n        call.setStatus(status);\n        call.startDate = null;\n        call.vm = false;\n        call.relevantEquipmentId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(call.connectionId); // Update contact info if necessary\n\n        return that.updateCallContact(jid, phoneNumber, queuedElem, call);\n      } catch (error) {\n        var errorMessage = "onQueuedEvent -- " + error.message;\n        $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n        return $q.reject(new Error(errorMessage));\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** DIVERTED STUFF                                                  **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onDivertedEvent = function (divertedElem) {\n    $log.info("[TelephonyServiceEventHandler] onDivertedEvent");\n    var that = this; //CRRAINB-3416\n\n    var oldConnectionId = divertedElem.attr("oldCallId");\n    var oldCallId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(oldConnectionId);\n    var call = this.telephonyService.calls[oldCallId];\n\n    if (!call) {\n      $log.warn("[TelephonyServiceEventHandler] onDivertedEvent - receive divertedEvent on unknown call --- ignored");\n      return $q.when();\n    }\n\n    that.computeCallRelevancy(divertedElem, call); //CRRAINB-3416\n\n    var webrtcGatewayService = $injector.get("webrtcGatewayService");\n\n    if (!webrtcGatewayService.isMediaPillarCallCase()) {\n      this.telephonyService.clearCall(call);\n    } else {\n      //CRRAINB-3416++\n      if (call.isSecondary) {\n        this.telephonyService.clearCall(call);\n      } else {\n        this.telephonyService.clearCall(call, true); //2nd para true for cleacall without broadcast\n      } //CRRAINB-3416--\t\t\t\t\t\t\t\t\t\t\n\n    }\n\n    this.sendCallUpdateEvent(call, divertedElem);\n    return $q.when();\n  };\n  /*********************************************************************/\n\n  /** TRANSFER STUFF                                                  **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onTransferEvent = function (transferElem) {\n    $log.info("[TelephonyServiceEventHandler] onTransferEvent");\n    var that = this; // Extract transfert call parameters\n\n    var activeConnectionId = transferElem.attr("activeCallId");\n    var heldConnectionId = transferElem.attr("heldCallId");\n    var newConnectionId = transferElem.attr("newCallId"); // Get active call\n\n    var activeCallId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(activeConnectionId);\n    var activeCall = this.telephonyService.calls[activeCallId]; //Note: activeCall may be null (case of blind transfer by operator)\n\n    if (heldConnectionId) {\n      // Get the held call \n      var heldCallId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(heldConnectionId);\n      var heldCall = this.telephonyService.calls[heldCallId]; // Release both calls (active and held)\n\n      if (heldCall) {\n        heldCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n      }\n\n      if (activeCall) {\n        activeCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n      }\n\n      if (heldCall) {\n        that.sendCallUpdateEvent(heldCall);\n      }\n\n      if (activeCall) {\n        that.sendCallUpdateEvent(activeCall);\n      }\n    }\n\n    if (newConnectionId) {\n      var jid = transferElem.attr("newEndpointIm");\n      var phoneNumber = transferElem.attr("newEndpointTel");\n      var deviceState = transferElem.attr("deviceState");\n\n      if (!deviceState) {\n        deviceState = transferElem.attr("deviceStatus");\n      } // TO BE REMOVED\n\n\n      var deviceType = transferElem.attr("deviceType");\n\n      if (!deviceType) {\n        deviceType = "MAIN";\n      } // Release current call\n\n\n      if (activeCall) {\n        activeCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n        that.sendCallUpdateEvent(activeCall);\n      }\n\n      if (!jid && !phoneNumber) {\n        //secret identity\n        phoneNumber = "****";\n      }\n\n      return this.getOrCreateCall(newConnectionId, jid, phoneNumber).then(function (newCall) {\n        if (deviceState && deviceState === "LCI_ALERTING") {\n          newCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING);\n        } else {\n          newCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n        }\n\n        newCall.relevantEquipmentId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(newConnectionId);\n        newCall.isSecondary = deviceType && deviceType === "SECONDARY"; // Update contact info if necessary\n\n        return that.updateCallContact(jid, phoneNumber, transferElem, newCall);\n      });\n    }\n\n    return $q.resolve();\n  };\n  /*********************************************************************/\n\n  /** CONFERENCE STUFF                                                **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onConferenceEvent = function (conferencedElem) {\n    $log.info("[TelephonyServiceEventHandler] onConferenceEvent"); // Store context\n\n    var that = this; // Get connectionsIds\n\n    var primaryOldConnectionId = conferencedElem.find("primaryOldCallId").text();\n    var secondaryOldConnectionId = conferencedElem.find("secondaryOldCallId").text();\n    var newConnectionId = conferencedElem.find("newCallId").text(); // Extract callIds\n\n    var primaryOldCallId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(primaryOldConnectionId);\n    var secondaryOldCallId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getIdFromConnectionId(secondaryOldConnectionId); // Get current calls\n\n    var primaryOldCall = this.telephonyService.calls[primaryOldCallId];\n    var secondaryOldCall = this.telephonyService.calls[secondaryOldCallId]; // Prepare participant promises \n\n    var confParticipants = [];\n    var participantPromises = [];\n    var confParticipantsPhoneNumbers = [];\n    conferencedElem.find("participant").each(function () {\n      var participantElem = angular.element(this);\n      var endpointTel = participantElem.find("endpointTel").text();\n      var endpointIm = participantElem.find("endpointIm").text();\n\n      if (!(endpointIm && contactService.isUserContactJid(endpointIm))) {\n        participantPromises.push($q(function (resolve, reject) {\n          if (!endpointIm && !endpointTel) {\n            endpointTel = "****";\n          } //if no endpointIm try to extract contact info from primary or secondary calls \n\n\n          if (!endpointIm && primaryOldCall && primaryOldCall.contact && primaryOldCall.currentCalled.contactPhoneNumber === endpointTel) {\n            confParticipants.push(primaryOldCall.contact);\n            confParticipantsPhoneNumbers.push(endpointTel);\n            resolve();\n          } else if (!endpointIm && secondaryOldCall && secondaryOldCall.contact && secondaryOldCall.currentCalled.contactPhoneNumber === endpointTel) {\n            confParticipants.push(secondaryOldCall.contact);\n            confParticipantsPhoneNumbers.push(endpointTel);\n            resolve();\n          } else {\n            contactService.getOrCreateContact(endpointIm, endpointTel).then(function (contact) {\n              confParticipants.push(contact);\n              confParticipantsPhoneNumbers.push(endpointTel); //manage Outlook Call Party identification\n\n              that.telephonyService.updateContactFromOutlookInfos(contact, endpointTel).then(function successCallback(updateStatus) {\n                if (updateStatus) {\n                  $log.debug("[TelephonyServiceEventHandler] on conferenced, update from outlook for contact :" + contact.displayNameMD5); //that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\n                } else {\n                  $log.debug("[TelephonyServiceEventHandler] on conferenced, no update from outlook for contact :" + contact.displayNameMD5);\n                }\n              }, function errorCallback() {\n                $log.debug("[TelephonyServiceEventHandler] on conferenced, no Outlook search available");\n              })["finally"](function () {\n                resolve();\n              });\n            })["catch"](function (error) {\n              $log.error("[TelephonyServiceEventHandler] onConferenceEvent - Impossible to get contact - " + error.message);\n              resolve();\n            });\n          }\n        }));\n      }\n    }); // Get participants asynchronously\n\n    return $q.all(participantPromises)["finally"](function () {\n      var isSecondaryDevice = false; //NEW_MP1 + CR #3380\n      // updtate isSecondaryDevice CRRAINB-3750\n\n      if (primaryOldCall) {\n        isSecondaryDevice = isSecondaryDevice || primaryOldCall.isSecondary; //NEW_MP1\n      }\n\n      if (secondaryOldCall) {\n        isSecondaryDevice = isSecondaryDevice || secondaryOldCall.isSecondary; //NEW_MP1\n      } // Create the new conference call\n\n\n      var newConferenceCall = that.createConferenceCall(newConnectionId, confParticipants); //update currentcalled structure\n\n      var currentCalled = newConferenceCall.getCurrentCalled();\n      currentCalled.participants = confParticipants;\n      currentCalled.participantsPhoneNumbers = confParticipantsPhoneNumbers;\n      newConferenceCall.setCurrentCalled(currentCalled);\n      newConferenceCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n      newConferenceCall.relevantEquipmentId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(newConnectionId);\n      newConferenceCall.isSecondary = isSecondaryDevice; //NEW_MP1\n\n      $log.debug("[TelephonyServiceEventHandler] on conferenced, create new call: " + newConferenceCall);\n      that.sendCallUpdateEvent(newConferenceCall); // Release previous calls\n\n      if (primaryOldCall) {\n        primaryOldCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n        $log.debug("[TelephonyServiceEventHandler] on conferenced, updated primaryOldCall: " + primaryOldCall);\n        that.sendCallUpdateEvent(primaryOldCall);\n      }\n\n      if (secondaryOldCall) {\n        secondaryOldCall.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN);\n        $log.debug("[TelephonyServiceEventHandler] on conferenced, updated secondaryOldCall: " + secondaryOldCall);\n        that.sendCallUpdateEvent(secondaryOldCall);\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** VOICE MESSAGE STUFF                                     \t\t**/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onVoiceMessageEvent = function (messagingElem) {\n    $log.info("[TelephonyServiceEventHandler] onVoiceMessageEvent"); // Look for a voiceMessageCounter child\n\n    var voiceMessageCounters = messagingElem.find("voiceMessagesCounters");\n\n    if (voiceMessageCounters) {\n      var totalMessages = voiceMessageCounters.attr("totalVoiceMessages");\n      var unreadMessages = voiceMessageCounters.attr("unreadVoiceMessages");\n      var counters = {};\n      counters.totalMessages = Number(totalMessages);\n      counters.unreadMessages = Number(unreadMessages); //if (Number.isInteger(ct) && (ct >= 0)) {\n\n      $log.info("[TelephonyServiceEventHandler] onVoiceMessageEvent - Messages total : " + counters.totalMessages + " - Messages Unread : " + counters.unreadMessages); //\tthis.telephonyService.voiceMail.setVMCounter(ct);\n      //\tthis.telephonyService.voiceMail.setVMFlag((ct > 0));\n      //\tthis.telephonyService.voiceMail.setInfoMsg("");\n\n      $rootScope.$broadcast("ON_VOICE_MESSAGE_UPDATE_EVENT", counters); //}\n    }\n\n    return $q.when();\n  };\n  /*********************************************************************/\n\n  /** UPDATECALL STUFF                                                **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onUpDateCallEvent = function (updatecallElem) {\n    $log.info("[TelephonyServiceEventHandler] onUpDateCallEvent");\n    var that = this;\n    return this.getCall(updatecallElem).then(function (call) {\n      var jid = updatecallElem.attr("endpointIm");\n      var phoneNumber = updatecallElem.attr("endpointTel");\n      var firstName = "";\n      var lastName = "";\n      var identityFirstName = updatecallElem.find("identity").attr("firstName");\n      var identityLastName = updatecallElem.find("identity").attr("lastName");\n      var identityDisplayName = updatecallElem.find("identity").attr("displayName");\n      var contactUpdateDone = false;\n\n      if (!config.permitSearchFromPhoneBook) {\n        // <--- allow to permit search even if not the good profile\n        //check if phonebook is allowed by profile else no result\n        if (!profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_PHONE_BOOK)) {\n          $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent xnames not allowed for the user profile => IGNORED event");\n          return $q.when();\n        }\n      } //find Xnames from directories\n\n\n      if (identityLastName && identityLastName.length) {\n        lastName = identityLastName;\n\n        if (identityFirstName && identityFirstName.length) {\n          firstName = identityFirstName;\n        }\n\n        $log.info("[TelephonyServiceEventHandler] onUpDateCallEvent received for call " + call.id + " for phoneNumber:" + utilService.anonymizePhoneNumber(phoneNumber) + " with name : " + firstName.slice(0, 1) + "***");\n      } else {\n        if (identityDisplayName && identityDisplayName.length && identityDisplayName !== phoneNumber) {\n          lastName = identityDisplayName; //Workaround last resort, only displayName is available, hack is to use it as lastName\t\t\t\t\t\n\n          $log.info("[TelephonyServiceEventHandler] onUpDateCallEvent only displayName available");\n        } else {\n          $log.info("[TelephonyServiceEventHandler] onUpDateCallEvent xnames not available => IGNORED event");\n          return $q.when();\n        }\n      }\n      /*debug+\n      if (!call.currentCalled.contactPhoneNumber || call.currentCalled.contactPhoneNumber === "") {\n      \t$log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent  call.currentCalled.contactPhoneNumber EMPTY !!!");\n      \t$log.debug("[TelephonyServiceEventHandler] for call " + call.id + " conf = " + call.isConference);\n      }\n      //debug-*/\n      // update contact as necessary\n\n\n      return contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n        if (contact.temp) {\n          //not a rainbow user\n          contact.updateName(firstName, lastName);\n\n          if (call.contact && call.contact.id) {\n            //not a conf\n            var currentCalled = {\n              contactPhoneNumber: phoneNumber,\n              contact: contact\n            };\n\n            if (call.contact.id !== contact.id || call.contact.displayName === phoneNumber || call.contact.getNameUpdatePrio() === Contact.NameUpdatePrio.OUTLOOK_UPDATE_PRIO) {\n              contact.setNameUpdatePrio(Contact.NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\n\n              call.setContact(contact);\n              call.setCurrentCalled(currentCalled);\n              contactUpdateDone = true;\n              $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent xnames updated for " + phoneNumber + " with contact : " + contact.displayNameMD5);\n            }\n          } else if (call.participants && call.participants.length > 0) {\n            var currentCalled = call.getCurrentCalled();\n\n            for (var i = 0; i < call.participants.length; i++) {\n              if (call.participants[i].temp) {\n                if (call.participants[i].phoneProCan && call.participants[i].phoneProCan === phoneNumber) {\n                  //concerned participant\n                  $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent temp participant " + call.participants[i].displayNameMD5 + " updated with : " + contact.displayNameMD5);\n                  call.participants[i] = contact;\n                  call.participants[i].setNameUpdatePrio(Contact.NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\n\n                  currentCalled.participantsPhoneNumbers[i] = phoneNumber;\n                  currentCalled.participants[i] = contact;\n                  contactUpdateDone = true;\n                }\n              } else {\n                //former participant is a rainbow user I don\'t know what to do !!!???\n                $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent STRANGE former participant was a rainbow: " + call.participants[i].displayNameMD5);\n              }\n            }\n\n            call.setCurrentCalled(currentCalled);\n          }\n        } else {\n          //rainbow contact found\n          if (call.contact && call.contact.id) {\n            //not a conf\n            var currentCalled = {\n              contactPhoneNumber: phoneNumber,\n              contact: contact\n            };\n\n            if (call.contact.id !== contact.id) {\n              //update call.contact if not the good one\n              //workaround+ Because of msg crossing pb udate old temp contact before to set the new one\n              if (call.contact.temp) {\n                call.contact.updateName(firstName, lastName);\n                call.contact.setNameUpdatePrio(Contact.NameUpdatePrio.SERVER_UPDATE_PRIO); //flag as server prio\t\t\t\t\t\t\t\t\t\t\n              } //workaround-\n\n\n              call.setContact(contact);\n              call.setCurrentCalled(currentCalled);\n              contactUpdateDone = true;\n              $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent call update with rainbow contact : " + contact.displayNameMD5);\n            }\n          } else if (call.participants && call.participants.length > 0) {\n            var currentCalled = call.getCurrentCalled();\n\n            for (var i = 0; i < call.participants.length; i++) {\n              if (call.participants[i].temp) {\n                if (call.participants[i].phoneProCan && call.participants[i].phoneProCan === phoneNumber) {\n                  //concerned participant\n                  $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent temp participant " + call.participants[i].displayNameMD5 + " updated with : " + contact.displayNameMD5);\n                  call.participants[i] = contact;\n                  call.setParticipants(call.participants); //to force an update of the avatars\n\n                  currentCalled.participantsPhoneNumbers[i] = phoneNumber;\n                  currentCalled.participants[i] = contact;\n                  contactUpdateDone = true;\n                }\n              } else {\n                //if former participant is the same rainbow user nothing to do except store phoneNumber and participant in call\n                if (call.participants[i].jid === jid) {\n                  //concerned participant\n                  //call.participants[i] = contact;\n                  currentCalled.participantsPhoneNumbers[i] = phoneNumber;\n                  currentCalled.participants[i] = call.participants[i];\n                  contactUpdateDone = true; //??\n\n                  $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent rainbow participant " + call.participants[i].displayNameMD5 + " updated with the same : " + contact.displayNameMD5);\n                } else {\n                  //not the  good participant nothing to do\n                  $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent other participant not updated : " + call.participants[i].displayNameMD5 + " vs " + contact.displayNameMD5);\n                }\n              }\n            }\n\n            call.setCurrentCalled(currentCalled);\n          }\n        }\n\n        if (contactUpdateDone) {\n          //CR #28178 : workaround : delay event to avoid notification RBNotification mess !!\n          // with telescoping with incoming call popup\n          $interval(function () {\n            that.sendCallUpdateEvent(call, updatecallElem);\n          }, 300, 1); //CRRAINB-5196  add updatecallElem\n        } else {\n          $log.debug("[TelephonyServiceEventHandler] onUpDateCallEvent, no update needed for call : " + call.id);\n        }\n      });\n    });\n  };\n  /*********************************************************************/\n\n  /** FAILURE STUFF                                                   **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onFailCallEvent = function (failedElem) {\n    $log.info("[TelephonyServiceEventHandler] onFailCallEvent");\n    var cause = failedElem.attr("cause");\n    var that = this;\n    return this.getCall(failedElem).then(function (call) {\n      call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ERROR);\n      call.errorMessage = TelephonyServiceEventHandler.CallFailureLabels[cause];\n\n      if (!call.errorMessage) {\n        call.errorMessage = cause;\n      }\n\n      that.sendCallUpdateEvent(call, failedElem);\n    });\n  };\n  /*********************************************************************/\n\n  /** NOMADIC CALL STUFF                                              **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onCallNomadicEvent = function (nomadicElem) {\n    $log.info("[TelephonyServiceEventHandler] onCallNomadicEvent");\n\n    if (!this.telephonyService.started && !this.telephonyService.starting) {\n      //we receive a nomadic status event while the telephony is not yet initialized: initialize it first\n      $log.info("[TelephonyServiceEventHandler] onCallNomadicEvent on uninitialized telephony => relaunch telephony initialization");\n      this.telephonyService.launchTelephonyInitilization();\n      return $q.when();\n    }\n\n    var response = {\n      destination: nomadicElem.attr("destination"),\n      featureActivated: nomadicElem.attr("featureActivated"),\n      makeCallInitiatorIsMain: nomadicElem.attr("makeCallInitiatorIsMain"),\n      modeActivated: nomadicElem.attr("modeActivated")\n    };\n    var makeCallInitiatorIsMainChanged = this.telephonyService.updateNomadicData(response); //get connections snapshot when we switch from Office to Nomadic or from Nomadic to Office\n\n    if (makeCallInitiatorIsMainChanged) {\n      var snapshotSecondary = this.telephonyService.nomadicObject.featureActivated && this.telephonyService.nomadicObject.modeActivated && !this.telephonyService.nomadicObject.makeCallInitiatorIsMain;\n      this.telephonyService.getTelephonyState(snapshotSecondary);\n    }\n\n    return $q.when();\n  };\n  /*********************************************************************/\n\n  /** FORWARD CALL STUFF                                              **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.onCallForwardedEvent = function (forwardElem) {\n    var forwardType = forwardElem.attr("forwardType");\n    var forwardTo = forwardElem.attr("forwardTo");\n    $log.info("[TelephonyServiceEventHandler] onCallForwardedEvent forwardType: " + forwardType + " forwardTo: " + forwardTo);\n    $rootScope.$broadcast("ON_CALL_FORWARDED_EVENT", {\n      "forwardType": forwardType,\n      "forwardTo": forwardTo\n    });\n    this.telephonyService.forwardObject.forwardType = forwardType;\n    this.telephonyService.forwardObject.forwardTo = forwardTo;\n    return $q.when();\n  };\n\n  TelephonyServiceEventHandler.prototype.onCallSubjectEvent = function (callElem) {\n    $log.info("[TelephonyServiceEventHandler] onCallSubjectEvent");\n    var that = this;\n    return this.getCall(callElem).then(function (call) {\n      try {\n        call.subject = callElem.find("subject").text();\n\n        if (call.subject) {\n          $log.info("[TelephonyServiceEventHandler] subject display" + call.subject);\n          that.sendCallUpdateEvent(call);\n        }\n      } catch (error) {\n        var errorMessage = "onCallSubjectEvent -- " + error.message;\n        $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n        $q.reject(new Error(errorMessage));\n      }\n    });\n  };\n  /*********************************************************************/\n\n  /** PRIVATE UTILITY METHODS                                         **/\n\n  /*********************************************************************/\n\n\n  TelephonyServiceEventHandler.prototype.computeCallRelevancy = function (elem, call) {\n    var newCallId = elem.attr("newCallId");\n    var connectionId = newCallId ? newCallId : elem.attr("callId");\n    var deviceType = elem.attr("deviceType");\n    var equipmentId = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getDeviceIdFromConnectionId(connectionId);\n    var nomadicInfo = this.telephonyService.getNomadicObject();\n    var makeCallInitiatorIsMain = nomadicInfo.makeCallInitiatorIsMain;\n\n    if (!deviceType) {\n      deviceType = "MAIN";\n    }\n\n    if (!nomadicInfo.modeActivated) {\n      makeCallInitiatorIsMain = true;\n    } // Handle call information\n\n\n    if (deviceType === "MAIN" && makeCallInitiatorIsMain) {\n      call.relevantEquipmentId = equipmentId;\n      call.connectionId = connectionId;\n    }\n\n    if (deviceType === "SECONDARY" && !makeCallInitiatorIsMain) {\n      call.relevantEquipmentId = equipmentId;\n      call.connectionId = connectionId;\n    }\n\n    call.isSecondary = deviceType && deviceType === "SECONDARY" && !makeCallInitiatorIsMain;\n    $log.info("[TelephonyServiceEventHandler] computeCallRelevancy -- relevantEquipmentId: " + call.relevantEquipmentId + " connectionId: " + call.connectionId + " isSecondary: " + call.isSecondary);\n  };\n\n  TelephonyServiceEventHandler.prototype.getCall = function (elem, doNotUseEqtIdFromElem) {\n    var that = this;\n    return $q(function (resolve) {\n      var jid = elem.attr("endpointIm");\n      var phoneNumber = elem.attr("endpointTel");\n      var connectionId = elem.attr("callId");\n      that.getOrCreateCall(connectionId, jid, phoneNumber, doNotUseEqtIdFromElem).then(function (call) {\n        resolve(call);\n      });\n    });\n  };\n\n  TelephonyServiceEventHandler.prototype.getOrCreateCall = function (connectionId, jid, phoneNumber, doNotUseEqtIdFromElem) {\n    var that = this;\n\n    if (doNotUseEqtIdFromElem) {\n      //search call by callId (not by connectionId) : used when the event\'s connectionId may contain the connection Id of the other party (ex: hold/retrieve)\n      var orgConnectionId = connectionId;\n      connectionId = Object.keys(this.telephonyService.calls || []).find(function (callConnectionId) {\n        var callIter = that.telephonyService.calls[callConnectionId];\n        return callIter.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN && _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getCallIdFromConnectionId(callConnectionId) === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getCallIdFromConnectionId(connectionId);\n      });\n      $log.debug("[TelephonyServiceEventHandler] getOrCreateCall - search call with callId: " + _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].getCallIdFromConnectionId(connectionId) + " from connection id: " + orgConnectionId + " => found connectionId: " + connectionId);\n    }\n\n    if (!connectionId) {\n      return $q.reject("no connection id");\n    }\n\n    var call = this.telephonyService.calls[connectionId];\n\n    if (call) {\n      $log.debug("[TelephonyServiceEventHandler] getOrCreateCall - " + connectionId + " - " + utilService.anonymizePhoneNumber(phoneNumber) + " - " + jid + " => found call: " + call);\n      return $q.when(call);\n    }\n\n    $log.debug("[TelephonyServiceEventHandler] getOrCreateCall - " + connectionId + " - " + utilService.anonymizePhoneNumber(phoneNumber) + " - " + jid + " => not found : create call...");\n    return $q(function (resolve) {\n      if (jid || phoneNumber) {\n        contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n          resolve(that.telephonyService.getOrCreateCall(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN, connectionId, contact));\n        });\n      } else {\n        resolve(that.telephonyService.getOrCreateCall(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN, connectionId));\n      }\n    });\n  };\n\n  TelephonyServiceEventHandler.prototype.createConferenceCall = function (connectionId, participants) {\n    // Create and configure the conference call\n    var conferenceCall = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN, null, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.PHONE);\n    conferenceCall.setConnectionId(connectionId);\n    conferenceCall.isConference = true;\n    conferenceCall.setParticipants(participants);\n    this.telephonyService.calls[conferenceCall.id] = conferenceCall;\n    return conferenceCall;\n  };\n\n  TelephonyServiceEventHandler.prototype.sendCallUpdateEvent = function (call, elem) {\n    var infoEvt = this.extractInfoEvent(elem);\n    $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call, infoEvt);\n  };\n\n  TelephonyServiceEventHandler.prototype.extractInfoEvent = function (elem) {\n    var infoEvent = {\n      actionElemName: "",\n      cause: ""\n    };\n\n    if (elem && elem !== null) {\n      var tagNames = elem.prop("tagName").split(":");\n      infoEvent.actionElemName = tagNames[tagNames.length - 1].toLowerCase();\n      infoEvent.cause = elem.attr("cause");\n      infoEvent.cause = infoEvent.cause ? infoEvent.cause : "";\n    } else {\n      infoEvent = null;\n    }\n\n    return infoEvent;\n  };\n  /*********************************************************************/\n\n  /** CALL UPDATE STUFF                                               **/\n\n  /*********************************************************************/\n\n  /** \n  * Method analyzeContactChange\n  * Analyse if a setContact has to be done following situation\n  * @public\n  * @param jid [required] jid from PCG \n  * @param phoneNumber [required] phone number from PCG\n  * @param call [required] the call to update\n  * @returns object:{ updateContactToBeDone : boolean, searchOutlookToBeDone :boolean} \n  *  updateContactToBeDone true if the contact has to be updated in the call (by setContact)\n  *  searchOutlookToBeDone true if an outlook search has to be performed to resolve call identity\n  * @memberof TelephonyServiceEventHandler\n  */\n\n\n  TelephonyServiceEventHandler.prototype.analyzeContactChange = function (jid, phoneNumber, call) {\n    var updateContact = false;\n    var searchOutlook = false;\n\n    if (!jid && !phoneNumber) {\n      //nothing could be analysed then updated\n      return null;\n    } // One2One Call (not a conference) only call.contact is impacted\n\n\n    if (!call.isConference) {\n      // No contact... Whatever situation set contact\n      if (!call.contact) {\n        return {\n          updateContactToBeDone: true,\n          searchOutlookToBeDone: true\n        }; //return { updateContactToBeDone: true, searchOutlookToBeDone: false };  //OUTLOOK NOT YET DELIVERED\n      } // PCG known the distant as a rainbow user (no outlook search is necessary)\n\n\n      if (jid !== "") {\n        // Only change if not the same from previous call setting\n        if (call.contact.id !== jid) {\n          updateContact = true;\n          searchOutlook = false;\n        }\n      } // No jid available\n      else {\n          // call.contact not known as rainbow user, contact.id contain former phoneNumber\n          if (call.contact.temp) {\n            if (call.contact.id !== phoneNumber) //called change\n              {\n                updateContact = true;\n                searchOutlook = true;\n              } else if (call.contact.displayName === phoneNumber) {\n              //no change but name not known\n              updateContact = false;\n              searchOutlook = true; //try an outlook research\n              //searchOutlook = false; //OUTLOOK NOT YET DELIVERED\n            }\n          } // call.contact known as rainbow user update only if phoneNumber change (except ringing empty case)\n          else if (call.getCurrentCalled().contactPhoneNumber !== "" && phoneNumber !== "") {\n              if (call.getCurrentCalled().contactPhoneNumber !== phoneNumber) {\n                updateContact = true;\n                searchOutlook = true; //searchOutlook = false;\t//OUTLOOK NOT YET DELIVERED\t\t\t\t\t\t\n              }\n            }\n        }\n\n      return updateContact || searchOutlook ? {\n        updateContactToBeDone: updateContact,\n        searchOutlookToBeDone: searchOutlook\n      } : null;\n    }\n  };\n  /** \n  * Method updateCallContact\n  * @public\n  * @param jid [required] jid from PCG \n  * @param phoneNumber [required] phone number from PCG\n  * @param actionElem [required] action event\n  * @param call [required] the call to update\n  * @returns {ng.IPromise<{}>} status promise\n  * @memberof TelephonyServiceEventHandler\n  */\n\n\n  TelephonyServiceEventHandler.prototype.updateCallContact = function (jid, phoneNumber, actionElem, call) {\n    var that = this;\n    var tagNames = actionElem.prop("tagName").split(":");\n    var actionElemName = tagNames[tagNames.length - 1].toLowerCase();\n\n    try {\n      // Determine if the contact has to be updated from event information\n      var updateAnalyse = that.analyzeContactChange(jid, phoneNumber, call); // Whatever the contact change, for simple call, after analyse, update at least the call current phoneNumber\n\n      if (!call.isConference && phoneNumber !== "") {\n        call.setCurrentCalledContactNumber(phoneNumber);\n      }\n\n      if (updateAnalyse) {\n        return contactService.getOrCreateContact(jid, phoneNumber).then(function (contact) {\n          // Outlook Call Party identification\n          if (updateAnalyse.searchOutlookToBeDone) {\n            //* OUTLOOK Call Party identification\n            return that.telephonyService.updateContactFromOutlookInfos(contact, phoneNumber).then(function successCallback(updateStatus) {\n              if (updateStatus) {\n                $log.debug("[TelephonyServiceEventHandler] on " + actionElemName + ", update from outlook for contact :" + contact.displayNameMD5);\n                that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\n              } else {\n                $log.debug("[TelephonyServiceEventHandler] on " + actionElemName + ", no update from outlook for contact :" + contact.displayNameMD5);\n\n                if (updateAnalyse.updateContactToBeDone) {\n                  $log.debug("[TelephonyServiceEventHandler] on " + actionElemName + ", update contact :" + contact.displayNameMD5);\n                  that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\n                } else {\n                  that.sendCallUpdateEvent(call, actionElem);\n                }\n              }\n            }, function errorCallback() {\n              $log.debug("[TelephonyServiceEventHandler] on " + actionElemName + ", no Outlook search available");\n\n              if (updateAnalyse.updateContactToBeDone) {\n                $log.debug("[TelephonyServiceEventHandler] on " + actionElemName + ", update contact :" + contact.displayNameMD5);\n                that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\n              } else {\n                that.sendCallUpdateEvent(call, actionElem);\n              }\n            });\n          } // Only simple updateContactToBeDone no outlook stuff\n\n\n          $log.debug("[TelephonyServiceEventHandler] on " + actionElemName + ", update contact :" + contact.displayNameMD5);\n          that.makeUpdateContact(call, contact, phoneNumber, actionElemName);\n          return $q.when();\n        })["catch"](function (error) {\n          if (error) {\n            var errorMessage = "updateCallContact -- " + error.message;\n            $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n          }\n\n          $log.debug("[TelephonyServiceEventHandler] on " + actionElemName + ", no Outlook search available");\n          that.sendCallUpdateEvent(call, actionElem);\n          return $q.when();\n        });\n      }\n\n      that.sendCallUpdateEvent(call, actionElem);\n      return $q.when();\n    } catch (error) {\n      var errorMessage = "updateCallContact -- " + error.message;\n      $log.error("[TelephonyServiceEventHandler] " + errorMessage);\n      return $q.reject(new Error(errorMessage));\n    }\n  };\n\n  TelephonyServiceEventHandler.prototype.makeUpdateContact = function (call, contact, phoneNumber, actionElemName) {\n    var that = this;\n    call.setContact(contact);\n    var currentCalled = {\n      contactPhoneNumber: phoneNumber,\n      contact: contact\n    };\n    call.setCurrentCalled(currentCalled);\n\n    if (actionElemName === "delivered" && call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING) {\n      //CR #28178 : workaround : delay event to avoid notification RBNotification mess !!\n      // with telescoping with incoming call popup\n      $interval(function () {\n        that.sendCallUpdateEvent(call);\n      }, 300, 1);\n    } else {\n      that.sendCallUpdateEvent(call);\n    }\n  };\n\n  return TelephonyServiceEventHandler;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/telephony/telephonyServiceEventHandler.js?')},function(module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @ngdoc service\n * @module rainbow\n * @name directoryService\n * @requires $rootScope\n * @requires $log\n * @requires $http\n * @requires $injector\n * @requires contactService\n * @requires authService\n * @requires orderByFilter\n * @requires conversationService\n * @requires errorHelperService\n * @description Rainbow Directory allow access to contacts search\n */\nclass DirectoryService {\n    constructor($rootScope, $log, $http, $injector, contactService, authService, orderByFilter, conversationService, errorHelperService, profileService, utilService) {\n        this.$rootScope = $rootScope;\n        this.$log = $log;\n        this.$http = $http;\n        this.$injector = $injector;\n        this.contactService = contactService;\n        this.authService = authService;\n        this.orderByFilter = orderByFilter;\n        this.conversationService = conversationService;\n        this.errorHelperService = errorHelperService;\n        this.profileService = profileService;\n        this.utilService = utilService;\n        this.started = false;\n        this.centralizedService = null;\n    }\n    start(stats) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info("[DirectoryService] === STARTING ===");\n            let startDate = performance.now();\n            try {\n                this.centralizedService = this.$injector.get("centralizedService");\n            }\n            catch (error) { /* for SDK */ }\n            // Now service is started\n            let startDuration = Math.round(performance.now() - startDate);\n            stats.push({ service: "directoryService", startDuration: startDuration });\n            this.started = true;\n            this.$log.info("[DirectoryService] === STARTED (" + startDuration + " ms) ===");\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info("[DirectoryService] Stopping");\n            this.started = false;\n            this.$log.info("[DirectoryService] Stopped");\n        });\n    }\n    /**\n     * @async\n     * @description Method search for contacts matching a string.\n     * Used by SDK (public)\n     * Warning when modifying this method\n     * @param {string} searchText text to search\n     * @param {boolean} addRosters [optional] whether or not to include our contact roster in the search. Default: false\n     * @param {number} limit [optional] Max number of result. Default: 20\n     * @param {string} companyId [optional] ID of company to search. Default = ""\n     * @returns a Promise that resolves with an array containing a list of contacts matching the searchText or rejects with an Error\n     * @memberof DirectoryService\n     */\n    search(searchText, addRosters = false, limit = 20, companyId = "", excludeCompanyId = null) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info("[DirectoryService] searchContact with text " + this.utilService.anonymizeString(searchText));\n            let searchByTag = this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.SEARCH_BY_TAGS);\n            let searchType = searchByTag ? "search=" : "displayName=";\n            let serverUrl = config.restServerUrl + "/api/rainbow/search/v1.0/users?limit=" + limit + "&" + searchType + encodeURIComponent(searchText);\n            if (companyId) {\n                serverUrl += "&companyId=" + encodeURIComponent(companyId);\n            }\n            if (excludeCompanyId) {\n                serverUrl += "&excludeCompanyId=" + encodeURIComponent(excludeCompanyId);\n            }\n            try {\n                const response = yield this.$http({ method: "GET", url: serverUrl, headers: this.authService.getRequestHeader() });\n                const contactsData = response.data.data;\n                this.$log.info("[DirectoryService] search find " + contactsData.length + " contact(s)");\n                let contacts = [];\n                contactsData.forEach((contactData) => {\n                    // Ignore userContact\n                    if (this.contactService.isUserContactJid(contactData.jid_im)) {\n                        return;\n                    }\n                    // Check if this contact already exists in contactService\n                    let contact = this.contactService.getContactByJid(contactData.jid_im);\n                    // Else create temporary contact\n                    if (!contact) {\n                        contact = this.contactService.createBasicContact(contactData.jid_im);\n                        contact.updateFromUserData(contactData);\n                        contact.getAvatar();\n                        this.contactService.dbContacts[contactData.id] = contact;\n                        this.contactService.jtelContacts[contact.jidtel] = contact;\n                    }\n                    contact.tags = contactData.tags;\n                    contact.dbId = contactData.id;\n                    contact.updateRichStatus();\n                    this.conversationService.computeCapabilitiesForContact(contact, false);\n                    contacts.push(contact);\n                });\n                if (addRosters) {\n                    let rosterContacts = this.contactService.searchContacts(searchText);\n                    contacts = contacts.concat(rosterContacts.filter((item) => { return item.roster && (contacts.indexOf(item) < 0); }));\n                }\n                contacts = this.orderByFilter(contacts, "_displayName", false);\n                return contacts;\n            }\n            catch (error) {\n                let e = error;\n                // Handle $http errors\n                if (error && error.data) {\n                    e = this.errorHelperService.handleError(error);\n                    this.$log.error("[DirectoryService] search - " + e.message);\n                    if (error.data.errorCode === 401) {\n                        this.$rootScope.$broadcast("ON_SESSION_EXPIRED_NOTIFICATION_EVENT");\n                    }\n                }\n                // Other errors are rethrown\n                throw (e);\n            }\n        });\n    }\n    /**\n     * @async\n     * @description Method search for contacts whose loginEmail matchs a string.\n     * Used by SDK (public)\n     * Warning when modifying this method\n     * @param {string} loginEmail text to search\n     * @returns a Promise that resolves with a contact matching the loginEmail provided or rejects with an Error\n     * @memberof DirectoryService\n     */\n    searchUserByLogin(loginEmail) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info(\'[DirectoryService] searchUserByLogin with "\' + loginEmail + \'"\');\n            // Forge the request\n            const serverUrl = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/enduser/v1.0/";\n            try {\n                // Send request\n                const response = yield this.$http({\n                    method: "POST",\n                    url: serverUrl + "users/loginEmails",\n                    headers: this.authService.getPostHeader(),\n                    data: { loginEmail: [loginEmail] }\n                });\n                const userArray = response.data.data;\n                if (userArray.length === 1 /*&& userArray[0].isActive*/) { //CR_10870\n                    let contact = yield this.contactService.getOrCreateContact(userArray[0].jid_im);\n                    // Add loginEmail to contact (missed after GPRD)\n                    contact.loginEmail = loginEmail;\n                    return contact;\n                }\n            }\n            catch (error) {\n                let e = error;\n                // Handle $http errors\n                if (error && error.data) {\n                    e = this.errorHelperService.handleError(error);\n                    this.$log.error("[DirectoryService] searchUserByLogin - " + e.message);\n                    if (error.data.errorCode === 401) {\n                        this.$rootScope.$broadcast("ON_SESSION_EXPIRED_NOTIFICATION_EVENT");\n                    }\n                }\n                // Other errors are rethrown\n                throw (e);\n            }\n        });\n    }\n    /**\n     * @async\n     * @description Method search for contacts whose jid matchs a string.\n     * Used by SDK (public)\n     * Warning when modifying this method\n     * @param {string} jid text to search\n     * @returns a Promise that resolves with a contact matching the jid provided or rejects with an Error\n     * @memberof DirectoryService\n     */\n    searchUserByJid(jid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info(\'[DirectoryService] searchUserByJid with "\' + jid + \'"\');\n            // Forge the request\n            const serverUrl = config.webservices.protocol + "://" + config.webservices.currentServer + ":" + config.webservices.port + "/api/rainbow/enduser/v1.0/users/jids/";\n            try {\n                const userResult = yield this.$http({\n                    method: "GET",\n                    url: serverUrl + encodeURIComponent(jid),\n                    headers: this.authService.getRequestHeader()\n                });\n                const user = userResult.data;\n                if (user) {\n                    let contact = yield this.contactService.getOrCreateContact(jid);\n                    contact.updateFromUserData(user.data);\n                    return contact;\n                }\n            }\n            catch (error) {\n                let e = error;\n                // Handle $http errors\n                if (error && error.data) {\n                    e = this.errorHelperService.handleError(error);\n                    this.$log.error("[DirectoryService] searchUserByJid - " + e.message);\n                    if (error.data.errorCode === 401) {\n                        this.$rootScope.$broadcast("ON_SESSION_EXPIRED_NOTIFICATION_EVENT");\n                    }\n                }\n                // Other errors are rethrown\n                throw (e);\n            }\n        });\n    }\n    /**\n     * @async\n     * @description Method search for contacts matching a string.\n     * Used by SDK (public)\n     * Warning when modifying this method\n     * @param {string} searchText text to search\n     * @param {number} limit [optional] Max number of result. Default: 20\n     * @param {string} companyId [optional] ID of company to search. Default = ""\n     * @param {boolean} addRosters [optional] whether or not to include our contact roster in the search. Default: true\n     * @param {boolean} addOutlook [optional] whether or not to include our outlook contacts. Default: true\n     * @returns a Promise that resolves with an array containing a list of contacts matching the searchText or rejects with an Error\n     * @memberof DirectoryService\n     */\n    searchAllContacts(searchText, limit = 20, companyId = "", addRosters = true, addOutlook = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info("[DirectoryService] searchAllContacts with text " + searchText);\n            try {\n                let contacts = [];\n                // Search local roster contacts\n                if (addRosters) {\n                    contacts = this.contactService.searchContacts(searchText);\n                }\n                const rainbowContacts = yield this.search(searchText, false, limit, companyId);\n                contacts = contacts.concat(rainbowContacts.filter((item) => { return !item.roster || (contacts.indexOf(item) < 0); }));\n                // Search Outlook contacts\n                if (addOutlook && this.centralizedService) {\n                    const [outlookContactsByEmail, outlookContactsByName] = yield Promise.all([this.searchOutlookUsersByEmail(searchText), this.searchOutlookUsersByName(searchText)]);\n                    const outlookResults = this.centralizedService.outlook.mergeOutlookContact(outlookContactsByEmail, outlookContactsByName);\n                    contacts = contacts.concat(outlookResults);\n                }\n                return contacts;\n            }\n            catch (error) {\n                this.$log.error("[DirectoryService] searchAllContacts - Unable to search all contacts");\n                // Other errors are rethrown\n                throw (error);\n            }\n        });\n    }\n    /*********************************************************************/\n    /** OUTLOOK STUFF                                                   **/\n    /*********************************************************************/\n    searchOutlookUsersByName(searchPattern) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.centralizedService) {\n                try {\n                    return yield this.centralizedService.outlook.searchByNameWithAvatar(searchPattern, 2);\n                }\n                catch (_a) {\n                    this.$log.warn("[DirectoryService] searchOutlookUsersByName - Outlook service unavailable");\n                    return [];\n                }\n            }\n        });\n    }\n    searchOutlookUsersByEmail(searchPattern) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.centralizedService && this.centralizedService.outlook) {\n                try {\n                    return yield this.centralizedService.outlook.searchByEmailWithAvatar(searchPattern, 2);\n                }\n                catch (_a) {\n                    this.$log.warn("[DirectoryService] searchOutlookUsersByEmail - Outlook service unavailable");\n                    return [];\n                }\n            }\n        });\n    }\n}\nDirectoryService.$inject = [\n    "$rootScope",\n    "$log",\n    "$http",\n    "$injector",\n    "contactService",\n    "authService",\n    "orderByFilter",\n    "conversationService",\n    "errorHelperService",\n    "profileService",\n    "utilService"\n];\nexports.DirectoryService = DirectoryService;\nangular.module("rainbow").service("directoryService", DirectoryService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/directoryService.ts?')},function(module,exports){eval('/**\n * @ngdoc service\n * @name invitationService\n * @module rainbow\n * @description Rainbow invitationService\n */\nangular.module("rainbow").service("invitationService", ["$q", "$log", "$http", "$rootScope", "authService", "Invitation", "contactService", "xmppService", "errorHelperService", "settingsService", function ($q, $log, $http, $rootScope, authService, Invitation, contactService, xmppService, errorHelperService, settingsService) {\n  "use strict";\n\n  var service = this;\n  /************************************************************/\n\n  /** LIFECYCLE STUFF                                        **/\n\n  /************************************************************/\n\n  service.start = function (stats) {\n    $log.info("");\n    $log.info("[invitationService] === STARTING ===");\n    var startDate = performance.now(); // Private invitation storage\n\n    service.receivedInvitations = {};\n    service.sentInvitations = {}; // Public invitation storage\n\n    service.acceptedInvitationsArray = [];\n    service.sentInvitationsArray = [];\n    service.receivedInvitationsArray = [];\n    service.listeners = [];\n    service.portalURL = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/";\n    service.attachHandlers();\n    service.getAllSentInvitations();\n    service.getAllReceivedInvitations();\n    var startDuration = Math.round(performance.now() - startDate);\n    stats.push({\n      service: "invitationService",\n      startDuration: startDuration\n    });\n    $log.info("[invitationService] === STARTED (" + startDuration + " ms) ==="); //update the sentInvitations list when new invitation is accepted\t\n\n    service.listeners.push($rootScope.$on("ON_ROSTER_CHANGED_EVENT", service.getAllSentInvitations));\n    return $q.when();\n  };\n\n  service.stop = function () {\n    $log.info("");\n    $log.info("[invitationService] === STOPPING ==="); // Remove listeners\n\n    var listener;\n\n    if (service.listeners) {\n      while (listener = service.listeners.pop()) {\n        listener();\n      }\n    }\n\n    $log.info("[invitationService] === STOPPED ===");\n    return $q.when();\n  };\n  /************************************************************/\n\n  /** EVENT HANDLING STUFF                                   **/\n\n  /************************************************************/\n\n\n  service.attachHandlers = function () {\n    $log.info("[invitationService] attachHandlers");\n\n    if (service.contactConfigRef) {\n      xmppService.connection.deleteHandler(service.contactConfigRef);\n      service.contactConfigRef = null;\n    }\n\n    service.contactConfigRef = xmppService.connection.addHandler(service.onInvitationsUpdate, null, "message", "management");\n  };\n\n  service.onInvitationsUpdate = function (stanza) {\n    var userInviteElem = $(stanza).find("userinvite");\n\n    if (userInviteElem.length) {\n      var id = userInviteElem.attr("id");\n      var type = userInviteElem.attr("type");\n      var action = userInviteElem.attr("action");\n\n      switch (type) {\n        case "received":\n          service.handleReceivedInvitation(id, action);\n          break;\n\n        case "sent":\n          service.handleSentInvitation(id, action);\n          break;\n\n        default:\n          $log.warn("[invitationService] onInvitationsUpdate - received unexpected type - " + type);\n          break;\n      }\n    }\n\n    return true;\n  };\n\n  service.handleReceivedInvitation = function (id, action) {\n    $log.info("[invitationService] handleReceivedInvitation"); // Handle deletion action\n\n    if (action === "delete") {\n      delete service.receivedInvitations[id];\n      service.updateReceivedInvitationsArray();\n    } // Hanle other actions\n    else {\n        service.getServerInvitation(id).then(function (invitation) {\n          var updateInvitation = null;\n          var status = "none";\n\n          switch (invitation.status) {\n            case "pending":\n              service.receivedInvitations[invitation.id] = invitation;\n              updateInvitation = invitation;\n              status = "ask";\n              break;\n\n            case "accepted":\n            case "auto-accepted":\n              service.receivedInvitations[invitation.id] = invitation;\n              $rootScope.$broadcast("ON_INVITATION_ACCEPTED", invitation.invitingUserId);\n\n              if (invitation.invitingUserId) {\n                contactService.getContactByDBId(invitation.invitingUserId, true).then(function (contact) {\n                  $rootScope.$broadcast("ON_CONTACT_UPDATED_EVENT", contact);\n                });\n              } //$rootScope.$broadcast("ON_INVITATION_EMAIL_RECEIVED", invitation);\n\n\n              break;\n\n            default:\n              delete service.receivedInvitations[invitation.id];\n              status = "unknown";\n              break;\n          }\n\n          if (invitation.invitingUserId) {\n            service.updateContactInvitationStatus(invitation.invitingUserId, status, updateInvitation).then(function () {\n              service.updateReceivedInvitationsArray();\n            });\n          } else {\n            service.updateReceivedInvitationsArray();\n          } // Needed for SDK\n\n\n          $rootScope.$broadcast("ON_INVITATION_CHANGED", invitation);\n        });\n      }\n  };\n\n  service.handleSentInvitation = function (id, action) {\n    return $q(function (resolve) {\n      $log.info("[invitationService] handleSentInvitation"); // Handle deletion action\n\n      if (action === "delete") {\n        delete service.sentInvitations[id];\n        service.updateReceivedInvitationsArray();\n        resolve();\n      } // Handle other actions\n      else {\n          service.getServerInvitation(id).then(function (invitation) {\n            var contactStatus = null;\n\n            switch (invitation.status) {\n              case "pending":\n                service.sentInvitations[invitation.id] = invitation;\n                contactStatus = "wait";\n                break;\n\n              case "accepted":\n              case "auto-accepted":\n                $rootScope.$broadcast("ON_INVITATION_ACCEPTED", invitation.invitedUserId);\n\n                if (invitation.invitedUserId) {\n                  contactService.getContactByDBId(invitation.invitedUserId, true).then(function (contact) {\n                    $rootScope.$broadcast("ON_CONTACT_UPDATED_EVENT", contact);\n                  });\n                }\n\n                break;\n\n              default:\n                delete service.sentInvitations[invitation.id];\n                contactStatus = "unknown";\n                break;\n            }\n\n            if (invitation.invitedUserId) {\n              service.updateContactInvitationStatus(invitation.invitedUserId, contactStatus, invitation).then(function () {\n                service.updateSentInvitationsArray();\n                resolve();\n              });\n            } else {\n              service.updateSentInvitationsArray();\n              resolve();\n            }\n          });\n\n          if (action === "resend") {\n            $rootScope.$broadcast("ON_INVITATIONS_RE_SEND", id);\n          }\n        }\n    });\n  };\n\n  service.updateReceivedInvitationsArray = function () {\n    // Handle received invitations\n    service.receivedInvitationsArray = [];\n    service.acceptedInvitationsArray = [];\n\n    for (var key in service.receivedInvitations) {\n      if (service.receivedInvitations.hasOwnProperty(key)) {\n        var invitation = service.receivedInvitations[key];\n\n        switch (invitation.status) {\n          case "pending":\n            service.receivedInvitationsArray.push(invitation);\n            break;\n\n          case "accepted":\n          case "auto-accepted":\n            service.acceptedInvitationsArray.push(invitation);\n            break;\n\n          default:\n            break;\n        }\n      }\n    } // Handle received invitations\n\n\n    service.receivedInvitationsArray.sort(service.sortInvitationArray); // Handle accepted invitations\n\n    service.acceptedInvitationsArray = service.acceptedInvitationsArray.filter(function (acceptedInvitation) {\n      var lastInvite = moment(acceptedInvitation.lastNotificationDate);\n      var duration = moment.duration(moment().diff(lastInvite));\n      var hours = duration.asHours();\n      return hours < 168; // 168 hours = 1 week :)\n    });\n    service.acceptedInvitationsArray.sort(service.sortInvitationArray);\n    $rootScope.$broadcast("ON_INVITATIONS_NUMBER_UPDATED");\n  };\n\n  service.updateSentInvitationsArray = function () {\n    service.sentInvitationsArray = [];\n\n    for (var key in service.sentInvitations) {\n      if (service.sentInvitations.hasOwnProperty(key)) {\n        service.sentInvitationsArray.push(service.sentInvitations[key]);\n      }\n    }\n\n    service.sentInvitationsArray.sort(service.sortInvitationArray);\n    $rootScope.$broadcast("ON_INVITATIONS_NUMBER_UPDATED");\n  };\n\n  service.getServerInvitation = function (invitationId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + contactService.userContact.dbId + "/invitations/" + invitationId,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        $log.info("[invitationService] getServerInvitation success");\n        var receivedInvitation = Invitation.createFromData(response.data.data);\n        resolve(receivedInvitation);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "getServerInvitation"));\n      });\n    });\n  };\n  /************************************************************/\n\n  /** PUBLIC METHODS                                         **/\n\n  /************************************************************/\n\n  /**\n         * GET RECEIVED INVITATIONS\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.getReceivedInvitations = function () {\n    return service.receivedInvitationsArray;\n  };\n\n  service.getAcceptedInvitations = function () {\n    return service.acceptedInvitationsArray;\n  };\n  /**\n         * GET SENT INVITATIONS\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.getSentInvitations = function () {\n    return service.sentInvitationsArray;\n  };\n\n  service.getInvitationsNumberForCounter = function () {\n    return service.receivedInvitationsArray.length;\n  };\n\n  service.getAllInvitationsNumber = function () {\n    return service.receivedInvitationsArray.length + service.sentInvitationsArray.length + service.acceptedInvitationsArray.length;\n  }; // Getter method\n\n  /**\n         * GET INVITATION BY ID\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.getInvitation = function (invitationId) {\n    var invitationFound = service.receivedInvitations[invitationId];\n\n    if (!invitationFound) {\n      invitationFound = service.acceptedInvitationsArray[invitationId];\n    }\n\n    if (!invitationFound) {\n      invitationFound = service.sentInvitations[invitationId];\n    }\n\n    return invitationFound;\n  }; // Sender methods\n\n  /**\n         * SEND INVITATION\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.joinContactInvitation = function (contact) {\n    return $q(function (resolve, reject) {\n      $log.info("[invitationService] joinContactInvitation contact (" + contact.jid + ")");\n      $http({\n        method: "POST",\n        url: service.portalURL + contactService.userContact.dbId + "/invitations",\n        headers: authService.getRequestHeader(),\n        data: {\n          invitedUserId: contact.dbId\n        }\n      }).then(function success() {\n        $log.info("[invitationService] joinContactInvitation - success (" + contact.jid + ")");\n\n        if (contact.status === "unknown") {\n          service.updateContactInvitationStatus(contact.dbId, "wait");\n        }\n\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "joinContactInvitation"));\n      });\n    });\n  };\n\n  service.sendInvitationByEmail = function (email, customMessage) {\n    return $q(function (resolve, reject) {\n      var lang = settingsService.getAppliLanguageCodeForServer();\n      $log.info("[invitationService] sendInvitationByEmail");\n      $http({\n        method: "POST",\n        url: service.portalURL + contactService.userContact.dbId + "/invitations",\n        headers: authService.getRequestHeader(),\n        data: {\n          email: email,\n          lang: lang,\n          customMessage: customMessage\n        }\n      }).then(function success() {\n        $log.info("[invitationService] sendInvitationByEmail - success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "sendInvitationByEmail"));\n      });\n    });\n  };\n\n  service.cancelOneSendInvitation = function (invitation) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + invitation.invitingUserId + "/invitations/" + invitation.id + "/cancel",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[invitationService] cancelOneSendInvitation success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "cancelOneSendInvitation"));\n      });\n    });\n  };\n\n  service.reSendInvitation = function (invitationId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/invitations/" + invitationId + "/re-send",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[invitationService] reSendInvitation " + invitationId + " - success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "reSendInvitation"));\n      });\n    });\n  };\n  /**\n         * SEND INVITATIONS PAR BULK\n         * LIMITED TO 100 invitations\n         */\n\n\n  service.sendInvitationsParBulk = function (listOfMails) {\n    if (!listOfMails.length || listOfMails.length > 100) {\n      $log.error("[invitationService] sendInvitationsParBulk mail list length not correct");\n      return $q.reject();\n    }\n\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/invitations/bulk",\n        headers: authService.getRequestHeader(),\n        data: {\n          emails: listOfMails\n        }\n      }).then(function success() {\n        $log.info("[invitationService] sendInvitationsParBulk - success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "sendInvitationsParBulk"));\n      });\n    });\n  }; // Invited methods\n\n  /**\n         * ACCEPT INVITATION\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.acceptInvitation = function (invitation) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + invitation.invitedUserId + "/invitations/" + invitation.id + "/accept",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[invitationService] acceptInvitation success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n\n        if (error.errorDetailsCode && error.errorDetailsCode === 409605) {\n          contactService.getContactByDBId(invitation.invitingUserId, true).then(function (contact) {\n            $rootScope.$broadcast("ON_CONTACT_UPDATED_EVENT", contact);\n          });\n        } else {\n          reject(error);\n          $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "acceptInvitation"));\n        }\n      });\n    });\n  };\n  /**\n         * DECLINE INVITATION\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.declineInvitation = function (invitation) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + invitation.invitedUserId + "/invitations/" + invitation.id + "/decline",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[invitationService] declineInvitation success");\n        resolve();\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "declineInvitation"));\n      });\n    });\n  };\n  /************************************************************/\n\n  /** PRIVATE METHODS                                        **/\n\n  /************************************************************/\n\n\n  service.updateContactInvitationStatus = function (contactDBId, status, invitation) {\n    return $q(function (resolve) {\n      contactService.getContactByDBId(contactDBId).then(function (contact) {\n        switch (status) {\n          case "ask":\n            contact.status = "unknown";\n            contact.ask = "ask";\n            contact.invitation = invitation;\n            break;\n\n          case "wait":\n            contact.status = "wait";\n            contact.ask = "subscribe";\n            contact.invitation = invitation;\n            break;\n\n          default:\n            contact.ask = "none";\n            contact.invitation = null;\n            break;\n        }\n\n        contact.updateRichStatus();\n        resolve();\n      });\n    });\n  };\n\n  service.sortInvitationArray = function (invitA, invitB) {\n    return new Date(invitB.lastNotificationDate) - new Date(invitA.lastNotificationDate);\n  };\n\n  service.getAllReceivedInvitations = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + contactService.userContact.dbId + "/invitations/received?format=full&status=pending&status=accepted&status=auto-accepted&limit=500",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var invitationsData = response.data.data;\n        $log.info("[invitationService] getAllReceivedInvitations success (find " + invitationsData.length + " invitations)");\n        service.receivedInvitations = {};\n        service.acceptedInvitations = {};\n        invitationsData.forEach(function (invitationData) {\n          if (invitationData.status === "pending" && invitationData.type !== "registration") {\n            var invitation = Invitation.createFromData(invitationData);\n            service.receivedInvitations[invitationData.id] = invitation;\n\n            if (invitationData.invitingUserId) {\n              service.updateContactInvitationStatus(invitationData.invitingUserId, "ask", invitation);\n            }\n          } else if (invitationData.status === "accepted" || invitationData.status === "auto-accepted") {\n            service.receivedInvitations[invitationData.id] = Invitation.createFromData(invitationData);\n          }\n        });\n        service.updateReceivedInvitationsArray();\n        resolve(service.receivedInvitations);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "getAllReceivedInvitations"));\n      });\n    });\n  };\n\n  service.getAllSentInvitations = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + contactService.userContact.dbId + "/invitations/sent?format=full&status=pending&limit=500",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var invitationsData = response.data.data;\n        $log.info("[invitationService] getAllSentInvitations success (find " + invitationsData.length + " invitations)");\n        service.sentInvitations = {};\n        invitationsData.forEach(function (invitationData) {\n          if (invitationData.status === "pending" && !invitationData.inviteToJoinMeeting) {\n            var sentInvitation = Invitation.createFromData(invitationData);\n            service.sentInvitations[invitationData.id] = sentInvitation;\n\n            if (sentInvitation.invitedUserId !== undefined) {\n              service.updateContactInvitationStatus(sentInvitation.invitedUserId, "wait", sentInvitation);\n            }\n          }\n        });\n        service.updateSentInvitationsArray();\n        resolve(service.sentInvitations);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[invitationService] " + errorHelperService.getErrorFullMessage(response, "getAllSentInvitations"));\n      });\n    });\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/invitationService.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\nangular.module("rainbow").service("roomService", ["$q", "$log", "$rootScope", "$http", "$filter", "$interval", "authService", "contactService", "fileStorageService", "xmppService", "Room", "utilService", "profileService", "errorHelperService", "helpersService", "orderByFilter", "$translate", "settingsService", function ($q, $log, $rootScope, $http, $filter, $interval, authService, contactService, fileStorageService, xmppService, Room, utilService, profileService, errorHelperService, helpersService, orderByFilter, $translate, settingsService) {\n  "use strict";\n\n  var service = this;\n  service.ROOM_UPDATE_EVENT = "ROOM_UPDATE_EVENT";\n  service.ROOM_AVATAR_UPDATE_EVENT = "ROOM_AVATAR_UPDATE_EVENT";\n  service.ROOM_HISTORY_UPDATE_EVENT = "ROOM_HISTORY_UPDATE_EVENT";\n  service.ROOM_ADMIN_MESSAGE_EVENT = "ROOM_ADMIN_MESSAGE_EVENT";\n  service.ROOM_INVITATION = "ROOM_INVITATION";\n  service.ROOM_ADD_CONF_ENDPOINT_EVENT = "ROOM_ADD_CONF_ENDPOINT_EVENT";\n  service.ROOM_REMOVE_CONF_ENDPOINT_EVENT = "ROOM_REMOVE_CONF_ENDPOINT_EVENT";\n  service.ROOM_ADD_USERS_EVENT = "ROOM_ADD_USERS_EVENT";\n  service.ROOM_DELETE_USERS_EVENT = "ROOM_DELETE_USERS_EVENT";\n  service.RoomUserStatus = {\n    "INVITED": "invited",\n    "ACCEPTED": "accepted",\n    "UNSUBSCRIBED": "unsubscribed",\n    "REJECTED": "rejected",\n    "DELETED": "deleted"\n  };\n  service.listeners = [];\n  /*********************************************************/\n\n  /** INITIALISATION STUFF                                **/\n\n  /*********************************************************/\n\n  service.start = function (stats) {\n    return $q(function (resolve) {\n      var startDate = performance.now();\n      $log.info("");\n      $log.info("[roomService] === STARTING ===");\n      service.portalURL = config.restServerUrl + "/api/rainbow/enduser/v1.0/";\n      service.invitationCounter = 0;\n      service.meetingInvitationCounter = 0;\n      service.rooms = {};\n      service.roomsByJids = {};\n      service.roomsInProgress = {};\n      service.contactsInProgress = {};\n      service.updateLater = {};\n      service.maxRoomsUsers = profileService.getFeatureLimitMax(profileService.FeaturesEnum.BUBBLE_PARTICIPANT_COUNT);\n      service.personalAudioRoomId = "";\n      service.openInviteIdByRoomId = {};\n      service.attachHandlers();\n      service.getServerRooms().then(function () {\n        service.computeInvitationCounter();\n        service.retrieveOpenInviteData();\n        var startDuration = Math.round(performance.now() - startDate);\n        stats.push({\n          service: "roomService",\n          startDuration: startDuration\n        });\n        $log.info("[roomService] === STARTED (" + startDuration + " ms) ===");\n        resolve();\n      })["catch"](function (error) {\n        $log.error("[roomService] === STARTING FAILURE === " + error.message);\n        service.computeInvitationCounter();\n        service.reconnect();\n        resolve();\n      });\n    });\n  };\n\n  service.stop = function () {\n    $log.info("");\n    $log.info("[roomService] === STOPPING ==="); //destroy listeners\n\n    service.listeners.forEach(function (listener) {\n      listener();\n    }); //clear rooms cache\n\n    service.rooms = {};\n    service.roomsByJids = {};\n    $log.info("[roomService] === STOPPED ===");\n    return $q.when();\n  };\n\n  service.attachHandlers = function () {\n    $log.info("[roomService] attachHandlers");\n\n    if (this.roomPresenceRef) {\n      xmppService.connection.deleteHandler(this.roomPresenceRef);\n      this.roomPresenceRef = null;\n    }\n\n    this.roomPresenceRef = xmppService.connection.addHandler(service.onRoomPresence, "http://jabber.org/protocol/muc#user", "presence");\n\n    if (this.roomMessageRef) {\n      xmppService.connection.deleteHandler(this.roomMessageRef);\n      this.roomMessageRef = null;\n    }\n\n    this.roomMessageRef = xmppService.connection.addHandler(service.onRoomMessage, "jabber:x:conference", "message");\n\n    if (this.roomInfoMessageRef) {\n      xmppService.connection.deleteHandler(this.roomInfoMessageRef);\n      this.roomInfoMessageRef = null;\n    }\n\n    this.roomInfoMessageRef = xmppService.connection.addHandler(service.onRoomInfoMessage, null, "message", "groupchat");\n\n    if (this.roomMessageConfigRef) {\n      xmppService.connection.deleteHandler(this.roomMessageConfigRef);\n      this.roomMessageConfigRef = null;\n    }\n\n    this.roomMessageConfigRef = xmppService.connection.addHandler(service.onRoomMessageConfig, null, "message", "management");\n\n    if (this.roomHistoryInfoRef) {\n      xmppService.connection.deleteHandler(this.roomHistoryInfoRef);\n      this.roomHistoryInfoRef = null;\n    }\n\n    this.roomHistoryInfoRef = xmppService.connection.addHandler(service.onRoomHistoryInfoMessage, "jabber:iq:notification", "message");\n\n    if (this.roomNotificationRef) {\n      xmppService.connection.deleteHandler(this.roomNotificationRef);\n      this.roomNotificationRef = null;\n    }\n\n    this.roomNotificationRef = xmppService.connection.addHandler(service.onRoomNotificationMessage, "jabber:x:bubble:conference", "message"); //destroy listeners\n\n    service.listeners.forEach(function (listener) {\n      listener();\n    });\n    service.listeners.push($rootScope.$on("ON_CONNECTION_STATE_CHANGE_EVENT", service.onConnectionStateChange));\n  };\n\n  service.reconnect = function () {\n    $log.info("[roomService] reconnect");\n    service.attachHandlers();\n    service.getServerRooms().then(function () {\n      service.computeInvitationCounter();\n      service.retrieveOpenInviteData();\n      $log.info("[roomService] reconnect success");\n    })["catch"](function (error) {\n      $log.error("[roomService] reconnect failure -- " + error.message);\n    });\n  };\n\n  service.onConnectionStateChange = function (__event, status) {\n    $log.info("[roomService] onConnectionStateChange status:" + status);\n\n    if (status === "disconnected" && service.rooms) {\n      Object.keys(service.rooms).forEach(function (key) {\n        var room = service.rooms[key];\n\n        if (room) {\n          if (room.initPresInterval) {\n            $log.info("[roomService] onConnectionStateChange cancel initPresence retryer for room: " + room.jid + " " + room.getNameForLogs());\n            $interval.cancel(room.initPresInterval);\n            room.initPresInterval = null;\n          }\n\n          if (room.initPresPromise) {\n            $log.info("[roomService] onConnectionStateChange remove initPresPromise for room: " + room.jid + " " + room.getNameForLogs());\n            room.initPresPromise = null;\n          }\n        }\n      });\n    }\n  };\n  /*********************************************************/\n\n  /**  PUBLIC ACCESSORS                                   **/\n\n  /*********************************************************/\n\n  /**\n   * GET ALL ROOMS\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.getRooms = function () {\n    var roomArray = [];\n    Object.keys(service.rooms).forEach(function (key) {\n      roomArray.push(service.rooms[key]);\n    });\n    return roomArray;\n  };\n\n  service.searchRooms = function (criteria) {\n    var queries = criteria.toLowerCase().trim().normalize("NFD").replace(/[\\u0300-\\u036f]/g, "").split(/[ ]+/);\n    return service.getRooms().filter(function (room) {\n      if (room.status !== "accepted") {\n        return false;\n      }\n\n      room.filterName = room.name.toLowerCase().trim().normalize("NFD").replace(/[\\u0300-\\u036f]/g, "");\n      var names = room.filterName.split(/[ -]+/);\n      return queries.every(function (query) {\n        return names.some(function (name, index) {\n          if (name.length && name.indexOf(query) !== -1) {\n            names[index] = "";\n            return true;\n          }\n\n          return false;\n        });\n      });\n    });\n  };\n  /**\n   * GET MY ROOMS\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.getMyRooms = function () {\n    return service.getRooms().filter(function (room) {\n      return room.owner;\n    });\n  };\n  /**\n   * GET ROOM BY ID\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.getRoomById = function (roomId) {\n    return service.rooms[roomId];\n  };\n\n  service.getRoomByJid = function (jid) {\n    return service.roomsByJids[jid];\n  };\n\n  service.computeInvitationCounter = function () {\n    service.invitationCounter = 0;\n    service.meetingInvitationCounter = 0;\n    Object.keys(service.rooms).forEach(function (key) {\n      var room = service.rooms[key];\n\n      if (room.status === "invited") {\n        if (!room.isMeetingRoom() || !profileService.isFeatureEnabled("CONFERENCE_PARTICIPANT_ALLOWED")) {\n          service.invitationCounter += 1;\n        } else {\n          service.meetingInvitationCounter += 1;\n        }\n      }\n    });\n  };\n  /**\n   * GET ALL ROOMS ORDER BY DATE OR NAME\n   * DEFAULT ORDER IS BY NAME\n   */\n\n\n  service.getOrderedRooms = function (order) {\n    if (order === "lastActivityDate") {\n      return orderByFilter(service.getRooms(), service.getLastActivityDate, true, service.sortByDate);\n    } else if (order === "creationDate") {\n      return orderByFilter(service.getRooms(), service.getCreationDate, true, service.sortByDate);\n    }\n\n    return orderByFilter(service.getRooms(), service.getName, false, service.sortByName);\n  };\n  /**\n   * GET MY ROOMS ORDER BY DATE OR NAME\n   * DEFAULT ORDER IS BY NAME\n   */\n\n\n  service.getMyOrderedRooms = function (order) {\n    if (order === "lastActivityDate") {\n      return orderByFilter(service.getMyRooms(), service.getLastActivityDate, true, service.sortByDate);\n    }\n\n    if (order === "creationDate") {\n      return orderByFilter(service.getMyRooms(), service.getCreationDate, true, service.sortByDate);\n    }\n\n    return orderByFilter(service.getMyRooms(), service.getName, false, service.sortByName);\n  };\n  /*********************************************************/\n\n  /** ROOMS SERVER ACCESSORS                              **/\n\n  /*********************************************************/\n\n\n  service.getServerRoom = function (roomId) {\n    return $q(function (resolve, reject) {\n      $log.info("[roomService] getServerRoom(" + roomId + ")");\n      $http({\n        method: "GET",\n        url: service.portalURL + "rooms/" + roomId + "?format=full",\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function success(response) {\n        var roomData = response.data.data;\n        $log.info("[roomService] getServerRoom(" + roomId + ") successfully");\n        return service.getAllRoomsParticipants([roomData]);\n      }).then(function (roomsData) {\n        var room = service.createRoomFromData(roomsData[0]);\n        resolve(room);\n      }, function failure(response) {\n        var msg = response.data ? response.data.errorDetails : response.data;\n        var errorMessage = "getServerRoom(" + roomId + ") failure: " + msg;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.getServerRoomByJid = function (roomJid) {\n    return $q(function (resolve, reject) {\n      $log.info("[roomService] getServerRoomByJid(" + roomJid + ")");\n      $http({\n        method: "GET",\n        url: service.portalURL + "rooms/jids/" + roomJid + "?format=full",\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function success(response) {\n        var roomData = response.data.data;\n        $log.info("[roomService] getServerRoomByJid(" + roomJid + ") successfully");\n        return service.getAllRoomsParticipants([roomData]);\n      }).then(function (roomsData) {\n        var room = service.createRoomFromData(roomsData[0]);\n        resolve(room);\n      }, function failure(response) {\n        var msg = response.data ? response.data.errorDetails : response.data;\n        var errorMessage = "getServerRoomByJid(" + roomJid + ") failure: " + msg;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.getServerRooms = function () {\n    var getSetOfRooms = function getSetOfRooms(page, max, rooms) {\n      return $q(function (resolve, reject) {\n        $http({\n          method: "GET",\n          headers: authService.getRequestHeader(),\n          url: service.portalURL + "rooms?format=full&userId=" + contactService.userContact.dbId + "&status=invited&status=accepted&status=unsubscribed" + "&offset=" + page + "&limit=" + max\n        }).then(function (response) {\n          rooms = rooms.concat(response.data.data);\n          $log.info("[roomService] getServerRooms retrieved " + response.data.data.length + " rooms, total " + rooms.length + ", existing " + response.data.total);\n          resolve({\n            rooms: rooms,\n            finished: rooms.length === response.data.total\n          });\n        })["catch"](function (err) {\n          reject(err);\n        });\n      });\n    };\n\n    var getAllRooms = function getAllRooms(page, limit, rooms) {\n      return $q(function (resolve, reject) {\n        getSetOfRooms(page, limit, rooms).then(function (response) {\n          if (response.finished) {\n            $log.info("[roomService] getServerRooms no need to loop again. All rooms retrieved...");\n            resolve(response.rooms);\n          } else {\n            page += limit;\n            $log.info("[roomService] getServerRooms need another loop to get more rooms... [" + response.rooms.length + "]");\n            getAllRooms(page, limit, response.rooms).then(function (_rooms) {\n              resolve(_rooms);\n            })["catch"](function (err) {\n              reject(err);\n            });\n          }\n        })["catch"](function (err) {\n          reject(err);\n        });\n      });\n    };\n\n    return $q(function (resolve, reject) {\n      var page = 0;\n      var limit = 1000;\n      getAllRooms(page, limit, []).then(function (response) {\n        var roomsData = response;\n        $log.info("[roomService] getServerRooms successfully: find " + roomsData.length + " room(s)");\n        return service.getAllRoomsParticipants(roomsData);\n      }).then(function (roomsData) {\n        roomsData.forEach(function (roomData) {\n          service.createRoomFromData(roomData);\n        });\n        resolve();\n      })["catch"](function (response) {\n        var msg = response.data ? response.data.errorDetails : response.message;\n        var errorMessage = "getServerRooms failure: " + msg;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.getAllRoomsParticipants = function (roomsData) {\n    var defered = $q.defer();\n\n    var getSetOfUsers = function getSetOfUsers(roomData, page, max, users) {\n      return $q(function (resolve, reject) {\n        $http({\n          method: "GET",\n          headers: authService.getRequestHeader(),\n          url: service.portalURL + "rooms/" + roomData.id + "/users?format=full&offset=" + page + "&limit=" + max\n        }).then(function (response) {\n          users = users.concat(response.data.data);\n          $log.info("[roomService] getAllRoomsParticipants retrieved " + response.data.data.length + " users, total " + users.length + ", existing " + response.data.total);\n          resolve({\n            users: users,\n            finished: users.length === response.data.total\n          });\n        })["catch"](function (err) {\n          reject(err);\n        });\n      });\n    };\n\n    var getAllUsers = function getAllUsers(roomData, page, limit, users) {\n      return $q(function (resolve, reject) {\n        getSetOfUsers(roomData, page, limit, users).then(function (response) {\n          if (response.finished) {\n            $log.info("[roomService] getAllRoomsParticipants no need to loop again. All users retrieved...");\n            resolve(response.users);\n          } else {\n            page += limit;\n            $log.info("[roomService] getAllRoomsParticipants need another loop to get more users... [" + response.users.length + "]");\n            getAllUsers(roomData, page, limit, response.users).then(function (_users) {\n              resolve(_users);\n            })["catch"](function (err) {\n              reject(err);\n            });\n          }\n        })["catch"](function (err) {\n          reject(err);\n        });\n      });\n    };\n\n    var startDate = performance.now(); // Create the participants jids array\n\n    var participantsJids = {};\n    var roomDataPromises = [];\n    roomsData.forEach(function (roomData) {\n      var myProm = $q.defer();\n      roomDataPromises.push(myProm); // Need to get more users as get room data is limited to the first 100 ?\n\n      if (roomData.activeUsersCounter && roomData.users.length < roomData.activeUsersCounter) {\n        var page = 0;\n        var limit = 100;\n        getAllUsers(roomData, page, limit, []).then(function (usr) {\n          // Use the room users list from server\n          roomData.users = usr;\n          myProm.resolve(roomData);\n        })["catch"](function (err) {\n          myProm.reject(err);\n        });\n      } else {\n        // No need to get all users from server\n        myProm.resolve(roomData);\n      }\n\n      myProm.promise.then(function (roomDataFilled) {\n        roomDataFilled.users.forEach(function (userData) {\n          var contact = contactService.getContactByJid(userData.jid_im);\n\n          if (!participantsJids[userData.jid_im] && (!contact || contact.temp)) {\n            participantsJids[userData.jid_im] = userData.jid_im;\n          }\n        });\n      });\n    });\n    $q.all(roomDataPromises).then(function () {\n      var participantsJidsArray = Object.keys(participantsJids);\n\n      if (!participantsJidsArray.length) {\n        $log.info("[roomService] getAllRoomsParticipants - nothing to get, all known.");\n        defered.resolve(roomsData);\n        return;\n      } // Get participants form server\n\n\n      return contactService.getContactsByJids(participantsJidsArray).then(function () {\n        var endDate = performance.now();\n        $log.info("[roomService] getAllRoomsParticipants - get " + participantsJidsArray.length + " participants in " + Math.round(endDate - startDate) + " milliseconds.");\n        defered.resolve(roomsData);\n      });\n    })["catch"](function (error) {\n      var errorMessage = "getAllRoomsParticipants failure: " + error.message;\n      $log.error("[roomService] " + errorMessage);\n      defered.reject(error);\n    });\n    return defered.promise;\n  };\n\n  service.createRoomFromData = function (roomData) {\n    // Create the room object\n    var room = Room.create(roomData.id, roomData.jid, roomData.name, roomData.topic, roomData.creationDate, roomData.confEndpoints, roomData.history, roomData.customData, roomData.conference, roomData.avatar, roomData.isActive, roomData.lastActivityDate, roomData.autoRegister); // Get owner contact\n\n    var owner = contactService.dbContacts[roomData.creator];\n\n    if (!owner) {\n      $log.error("[roomService] createRoomFromData -- failure -- Impossible to find owner of room " + roomData.name + " --- ignored");\n      return room;\n    }\n\n    room.ownerContact = owner;\n    room.owner = owner.jid === contactService.userContact.jid; // Add room participants\n\n    roomData.users.forEach(function (userData) {\n      var contact = contactService.getContactById(userData.userId);\n\n      if (contact) {\n        room.users.push({\n          contact: contact,\n          status: userData.status,\n          date: new Date(userData.additionDate),\n          privilege: userData.privilege\n        });\n\n        if (contactService.isUserContact(contact)) {\n          room.status = userData.status;\n        }\n      }\n    }); // Add room guests\n\n    room.guestEmails = roomData.guestEmails;\n    service.refreshMemberAndOrganizerLists(room);\n    var ownUser = room.getUserByJid(contactService.userContact.jid);\n    room.isModerator = ownUser && ownUser.status !== service.RoomUserStatus.UNSUBSCRIBED && room.isUserModerator(contactService.userContact); // If the room is already created via createRoom API, we should save the promises already\n    //created for this room to avoid loosing them\n\n    if (service.rooms[room.dbId] && service.rooms[room.dbId].initPresPromise) {\n      room.initPresPromise = service.rooms[room.dbId].initPresPromise;\n      room.initPresInterval = service.rooms[room.dbId].initPresInterval;\n    } // Update room avatar\n\n\n    room.updateAvatarInfo();\n\n    if (roomData.lastAvatarUpdateDate) {\n      var url = config.restServerUrl;\n\n      if ($rootScope.cdn) {\n        url = $rootScope.cdnServer;\n      }\n\n      room.avatar = url + "/api/room-avatar/" + roomData.id + "?size=512&update=" + Object(crypto_js__WEBPACK_IMPORTED_MODULE_0__["MD5"])(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Latin1.parse(roomData.lastAvatarUpdateDate)).toString(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Hex);\n    } // Store room in service\n\n\n    service.rooms[room.dbId] = room;\n    service.roomsByJids[room.jid] = room; // Send update event and room initial presence\n\n    $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n\n    if (room.status === "accepted" && room.isActive) {\n      service.sendInitialRoomPresenceSync(room);\n    }\n\n    return room;\n  };\n\n  service.refreshMemberAndOrganizerLists = function (room) {\n    //Clear both lists :\n    room.organizers = [];\n    room.members = [];\n    room.users.forEach(function (user) {\n      if (user.status === service.RoomUserStatus.ACCEPTED || user.status === service.RoomUserStatus.INVITED || user.contact.jid === room.ownerContact.jid) {\n        if (user.privilege === Room.Privilege.MODERATOR) {\n          room.organizers.push(user);\n        } else {\n          room.members.push(user);\n        }\n      }\n    });\n  };\n\n  service.equalContactsArrayByDbId = function (contactsA, contactsB) {\n    if (contactsA === contactsB) {\n      return true;\n    }\n\n    if (contactsA === null || contactsB === null) {\n      return false;\n    }\n\n    if (contactsA.length !== contactsB.length) {\n      return false;\n    }\n\n    for (var i = 0; i < contactsA.length; ++i) {\n      if (contactsA[i].dbId !== contactsB[i].dbId) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  service.getOrCreateRoomWithContacts = function (newContacts, newEmails) {\n    return $q(function (resolve) {\n      // Check first if a room with current participants not already existing\n      var foundRoom = null;\n      var participants = [].concat([contactService.userContact], newContacts).sort(service.sortObjectByProperty("dbId"));\n      service.getMyRooms().some(function (room) {\n        if (room && room.status === service.RoomUserStatus.ACCEPTED && service.equalContactsArrayByDbId(room.users.map(function (user) {\n          return user.contact;\n        }).sort(service.sortObjectByProperty("dbId")), participants)) {\n          foundRoom = room;\n          $log.debug("[roomService] getOrCreateRoomWithContacts - Found Room " + room.getNameForLogs());\n          return true;\n        }\n\n        return false;\n      });\n\n      if (foundRoom) {\n        if (newEmails.length) {\n          service.addRoomUsers(foundRoom, null, newEmails).then(function () {\n            resolve(foundRoom);\n          });\n        } else {\n          resolve(foundRoom);\n        }\n\n        return;\n      }\n\n      var roomNameRoot = contactService.userContact.initials + " " + $filter("translate")("bubble") + " ";\n      var escalatedRooms = service.getMyRooms().filter(function (room) {\n        return room && room.name.indexOf(roomNameRoot) === 0;\n      });\n\n      var compareRoom = function compareRoom(room) {\n        return room && room.name === tempRoomName;\n      };\n\n      var roomName = null;\n      var index = 1;\n\n      while (!roomName) {\n        var tempRoomName = roomNameRoot + index.toString();\n\n        if (!escalatedRooms.sort(service.sortObjectByProperty("name")).some(compareRoom)) {\n          roomName = tempRoomName;\n        }\n\n        index++;\n      } // var topic = participants.map(function(user) { return user.displayName; }).join(", ");\n\n\n      var topic = "";\n      service.createRoomWithContacts(roomName, topic, newContacts, newEmails).then(function (room) {\n        resolve(room);\n      });\n    });\n  };\n\n  service.createRoomWithContacts = function (roomName, topic, contacts, emails) {\n    return $q(function (resolve, reject) {\n      service.createRoom(roomName, topic, true, null, true, null, true).then(function (room) {\n        return service.addRoomUsers(room, contacts, emails);\n      }).then(function (room) {\n        resolve(room);\n      })["catch"](function (error) {\n        var errorMessage = "createRoomWithContacts failure: " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /*********************************************************/\n\n  /** ROOM AVATAR STUFF                                   **/\n\n  /*********************************************************/\n\n  /**\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.setAvatarRoom = function (roomData, roomAvatar) {\n    var defered = $q.defer();\n\n    if (!roomAvatar) {\n      defered.resolve(roomData);\n      return defered.promise;\n    }\n\n    service.resizeImage(roomAvatar, 512, 512).then(function (resizedImage) {\n      var binaryData = service.getBinaryData(resizedImage);\n      $http({\n        method: "POST",\n        url: service.portalURL + "rooms/" + roomData.id + "/avatar",\n        headers: authService.getPostHeader("image/" + binaryData.type),\n        data: binaryData.data,\n        transformRequest: []\n      }).then(function success(result) {\n        $log.info("[roomService] setAvatarRoom success: " + result.data.status);\n        var url = config.restServerUrl;\n\n        if ($rootScope.cdn) {\n          url = $rootScope.cdnServer;\n        }\n\n        roomData.avatar = url + "/api/room-avatar/" + roomData.id + "?size=512&rand=" + helpersService.randomString();\n        defered.resolve(roomData);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[roomService] " + errorHelperService.getErrorFullMessage(response, "setAvatarRoom"));\n        defered.reject(error);\n      });\n    });\n    return defered.promise;\n  };\n  /**\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.deleteAvatarRoom = function (roomId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "rooms/" + roomId + "/avatar",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[roomService] avatar room sucessfully deleted");\n        resolve();\n      })["catch"](function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  service.resizeImage = function (avatarImg, maxWidth, maxHeight) {\n    var defered = $q.defer();\n    var image = new Image();\n    image.src = avatarImg;\n\n    image.onload = function () {\n      var imageWidth = image.width;\n      var imageHeight = image.height;\n\n      if (imageWidth > imageHeight) {\n        if (imageWidth > maxWidth) {\n          imageHeight *= maxWidth / imageWidth;\n          imageWidth = maxWidth;\n        }\n      } else {\n        if (imageHeight > maxHeight) {\n          imageWidth *= maxHeight / imageHeight;\n          imageHeight = maxHeight;\n        }\n      }\n\n      var canvas = document.createElement("canvas");\n      canvas.width = imageWidth;\n      canvas.height = imageHeight;\n      image.width = imageWidth;\n      image.height = imageHeight;\n      var ctx = canvas.getContext("2d");\n      ctx.drawImage(this, 0, 0, imageWidth, imageHeight);\n      var resizedImage = new Image();\n      resizedImage.src = canvas.toDataURL("image/png");\n      defered.resolve(resizedImage);\n    };\n\n    return defered.promise;\n  };\n\n  service.getBinaryData = function (image) {\n    var typeIndex = image.src.indexOf("image/") + 6;\n    var binaryIndex = image.src.indexOf(";base64,");\n    var binaryData = image.src.slice(binaryIndex + 8);\n    var imageType = image.src.slice(typeIndex, binaryIndex);\n    var binary_string = window.atob(binaryData);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      bytes[i] = binary_string.charCodeAt(i);\n    }\n\n    return {\n      type: imageType,\n      data: bytes\n    };\n  };\n  /*********************************************************/\n\n  /** ROOM ADD USER STUFF                                 **/\n\n  /*********************************************************/\n\n\n  service.pushContactInRoom = function (user, room) {\n    return $q(function (resolve) {\n      contactService.getContactByDBId(user.userId).then(function (contact) {\n        room.users.push({\n          contact: contact,\n          status: user.status,\n          date: new Date(user.additionDate),\n          privilege: user.privilege\n        }); // room.updateAvatarInfo();\n\n        if (contactService.isUserContact(contact)) {\n          room.status = user.status;\n        }\n\n        $log.info("[roomService] pushContactInRoom success");\n        resolve();\n      })["catch"](function (error) {\n        $log.info("[roomService] pushContactInRoom failure : " + error.message);\n        resolve();\n      });\n    });\n  };\n  /**\n   * ADD USER TO ROOM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.addRoomUser = function (room, contact, reason, privilege, withoutInvitation) {\n    return $q(function (resolve, reject) {\n      var isUserInvitedOrAccepted = room.users.some(function (user) {\n        if ((user.status === service.RoomUserStatus.INVITED || user.status === service.RoomUserStatus.ACCEPTED || user.status === service.RoomUserStatus.REJECTED) && user.contact.dbId === contact.dbId) {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (isUserInvitedOrAccepted) {\n        $log.debug("[roomService] user: " + contact.dbId + " already invited or accepted, will not be added");\n        resolve(room);\n        return;\n      }\n\n      var roomUsersCurrentNb = room.users.filter(function (user) {\n        return user.status !== service.RoomUserStatus.DELETED;\n      }).length; // Reject not allowed operations\n\n      if (roomUsersCurrentNb >= service.maxRoomsUsers) {\n        var profileError = new Error("addRoomUser failure - Not Allowed : Participants max limit has been reached: " + service.maxRoomsUsers);\n        profileError.status = profileError.errorDetailsCode = "403";\n        $log.error("[roomService] " + profileError.message);\n        reject(profileError);\n        return;\n      } // Manage status invitation\n\n\n      var userStatus = service.RoomUserStatus.INVITED;\n\n      if (typeof withoutInvitation === "boolean" && withoutInvitation) {\n        userStatus = service.RoomUserStatus.ACCEPTED;\n      }\n\n      var userReason = reason ? reason : "JustForFun";\n      var userPrivilege = privilege ? privilege : Room.Privilege.USER;\n      $http({\n        method: "POST",\n        url: service.portalURL + "rooms/" + room.dbId + "/users",\n        headers: authService.getPostHeader(),\n        data: {\n          userId: contact.dbId,\n          privilege: userPrivilege,\n          reason: userReason,\n          status: userStatus\n        }\n      }) // Handle success response\n      .then(function success(response) {\n        $log.info("[roomService] addRoomUser " + contact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        var userData = response.data.data;\n        var user = room.getUserByJid(userData.jid_im);\n\n        if (user) {\n          user.status = userData.status;\n          user.date = new Date();\n          user.privilege = userData.privilege;\n        } else {\n          room.users.push({\n            contact: contact,\n            status: userStatus,\n            date: new Date(),\n            privilege: userPrivilege\n          });\n        }\n\n        service.refreshMemberAndOrganizerLists(room);\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        resolve(room);\n      }, function failure(response) {\n        var errorMessage = "addRoomUser " + contact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.addRoomUsers = function (room, contacts, emails) {\n    return $q(function (resolve, reject) {\n      // Create the add user promises\n      var addRoomUserPromises = [];\n      contacts.forEach(function (contact) {\n        var found = room.users.some(function (user) {\n          if (user.contact.dbId === contact.dbId) {\n            switch (user.status) {\n              case service.RoomUserStatus.UNSUBSCRIBED:\n                addRoomUserPromises.push(service.ownerReinviteRejectedUser(room, contact));\n                break;\n\n              case service.RoomUserStatus.DELETED:\n                addRoomUserPromises.push(service.ownerReinviteDeletedUser(room, contact));\n                break;\n\n              case service.RoomUserStatus.REJECTED:\n                addRoomUserPromises.push(service.ownerReinviteRejectedUser(room, contact));\n                break;\n\n              default:\n                break;\n            }\n\n            return true;\n          }\n\n          return false;\n        });\n\n        if (!found) {\n          addRoomUserPromises.push(service.addRoomUser(room, contact));\n        }\n      });\n      $q.all(addRoomUserPromises).then(function () {\n        $log.info("[roomService] addRoomUsers success");\n        $rootScope.$broadcast(service.ROOM_ADD_USERS_EVENT, room);\n        resolve(room);\n      }).then(function () {\n        service.inviteGuestEmailToJoinRoom(room, emails);\n      })["catch"](function (error) {\n        var errorMessage = "addRoomUsers failure: " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.deleteRoomUsers = function (room, contacts) {\n    return $q(function (resolve, reject) {\n      var deleteRoomUserPromises = [];\n      contacts.forEach(function (contact) {\n        var found = room.users.some(function (user) {\n          if (user.contact.dbId === contact.dbId) {\n            return true;\n          }\n\n          return false;\n        });\n\n        if (found) {\n          deleteRoomUserPromises.push(service.ownerDeletesUserFromRoom(room, contact));\n        }\n      });\n      $q.all(deleteRoomUserPromises).then(function () {\n        $log.info("[roomService] deleteRoomUsers success");\n        $rootScope.$broadcast(service.ROOM_DELETE_USERS_EVENT, room);\n        resolve(room);\n      })["catch"](function (error) {\n        var errorMessage = "deleteRoomUsers failure: " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.addRoomAndroidTVs = function (room, contactAndroidTVs) {\n    return $q(function (resolve, reject) {\n      // Create the add user promises\n      var addRoomAndroidTVPromises = [];\n      contactAndroidTVs.forEach(function (contactAndroidTV) {\n        addRoomAndroidTVPromises.push(service.addRoomAndroidTV(room, contactAndroidTV));\n      });\n      $q.all(addRoomAndroidTVPromises).then(function () {\n        $log.info("[roomService] addRoomAndroidTVs success");\n        $rootScope.$broadcast(service.ROOM_ADD_USERS_EVENT, room);\n        resolve(room);\n      })["catch"](function (error) {\n        var errorMessage = "addRoomAndroidTVs failure: " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.addRoomAndroidTV = function (room, contact) {\n    return $q(function (resolve, reject) {\n      var userReason = "androidtv";\n      var userPrivilege = "moderator";\n      var userStatus = "accepted";\n      $http({\n        method: "POST",\n        url: service.portalURL + "rooms/" + room.dbId + "/users",\n        headers: authService.getPostHeader(),\n        data: {\n          userId: contact.dbId,\n          privilege: userPrivilege,\n          reason: userReason,\n          status: userStatus\n        }\n      }) // Handle success response\n      .then(function success(response) {\n        $log.info("[roomService] addRoomAndroidTV " + contact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        var userData = response.data.data;\n        var user = room.getUserByJid(userData.jid_im);\n\n        if (user) {\n          user.status = userData.status;\n          user.date = new Date();\n          user.privilege = userData.privilege;\n        } else {\n          room.users.push({\n            contact: contact,\n            status: userStatus,\n            date: new Date(),\n            privilege: userPrivilege\n          });\n        }\n\n        service.refreshMemberAndOrganizerLists(room);\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        resolve(room);\n      }, function failure(response) {\n        var errorMessage = "addRoomAndroidTV " + contact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /*********************************************************/\n\n  /** COMMON FUNCTIONS                                     **/\n\n  /*********************************************************/\n\n  /** ROOM XMPP STUFF **/\n\n\n  service.sendInitialRoomPresence = function (room, attempt) {\n    var attemptInfo = attempt ? " -- attempt " + attempt : "";\n    $log.info("[roomService] sendInitialRoomPresence " + attemptInfo + " -- " + room.getNameForLogs() + " -- " + room.dbId);\n    var presenceIq = $pres({\n      to: room.jid + "/" + xmppService.fullJid\n    });\n    presenceIq.c("x", {\n      "xmlns": "http://jabber.org/protocol/muc"\n    }).c("history", {\n      maxchars: "0"\n    });\n    xmppService.send(presenceIq);\n  };\n\n  service.sendInitialRoomPresenceSync = function (room) {\n    if (room.initPresPromise) {\n      return room.initPresPromise.promise;\n    }\n\n    var defered = room.initPresPromise = $q.defer();\n    service.sendInitialRoomPresence(room, "0"); // Retry mechanism\n\n    var maxAttemptNumber = 5;\n    var attemptNumber = 0;\n    room.initPresInterval = $interval(function () {\n      if (attemptNumber < maxAttemptNumber) {\n        // up to <maxAttemptNumber> retries\n        service.sendInitialRoomPresence(room, ++attemptNumber);\n      } else {\n        // if no response after <maxAttemptNumber> retries, we clean the presence promise in the room \n        // (to make it possible for further trials to re-establish presence state and chat history access)\n        $log.error("[roomService] sendInitialRoomPresenceSync : no response after " + attemptNumber + " retries => clean presence promise and interval for " + room.getNameForLogs() + " -- " + room.jid);\n        room.initPresPromise = null; //should sent an update, so that the conversation is updated and we can sent chat messages inside\n\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n      }\n    }, 7500, maxAttemptNumber + 1);\n    return defered.promise;\n  };\n  /**\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.sendPresenceWithResponseWait = function (room) {\n    //if we\'ve already received the first presence, unblock\n    if (room.initPresPromiseReceived) {\n      service.sendInitialRoomPresence(room);\n      return $q.when(room);\n    }\n\n    var defered = room.initPresPromise = $q.defer();\n    service.sendInitialRoomPresence(room);\n    return defered.promise;\n  };\n\n  service.sendUnavailableRoomPresence = function (room) {\n    var presenceIq = $pres({\n      to: room.jid + "/" + contactService.userContact.jid,\n      type: "unavailable"\n    });\n    presenceIq.c("x", {\n      "xmlns": "http://jabber.org/protocol/muc"\n    });\n    xmppService.send(presenceIq);\n  };\n  /*********************************************************/\n\n  /** ADMIN FUNCTIONS                                     **/\n\n  /*********************************************************/\n\n  /**\n   * ROOM CREATION\n   * Used by SDK (public)\n   * Warning when modifying this method\n   * If no disableNotifications given, it is forced to true For Rainbow Web\n   */\n\n\n  service.createRoom = function (roomName, roomDesc, withHistory, roomAvatar, disableNotifications, mediaType) {\n    var roomNameForLogs = roomName.charAt(0) + "***" + roomName.slice(-1);\n    $log.info("[roomService] createRoom \\"" + roomNameForLogs + "\\"");\n    return $q(function (resolve, reject) {\n      if (disableNotifications === undefined || disableNotifications && typeof disableNotifications !== "boolean") {\n        disableNotifications = true;\n      }\n\n      var history = withHistory ? "all" : "none";\n      var data = {\n        name: roomName,\n        topic: roomDesc,\n        history: history,\n        disableNotifications: disableNotifications\n      };\n\n      if (mediaType) {\n        data.mediaType = mediaType;\n      }\n\n      $http({\n        method: "POST",\n        url: service.portalURL + "rooms/",\n        headers: authService.getPostHeader(),\n        data: data\n      }).then(function success(response) {\n        var roomData = response.data.data;\n        return service.setAvatarRoom(roomData, roomAvatar);\n      }).then(function (roomData) {\n        if (service.rooms[roomData.id]) {\n          $log.info("[roomService] createRoom -- room \\"" + roomNameForLogs + "\\" already exists");\n          resolve(service.rooms[roomData.id]);\n        }\n\n        var room = Room.create(roomData.id, roomData.jid, roomData.name, roomData.topic, roomData.creationDate, roomData.confEndpoints, roomData.history, roomData.customData, roomData.conference, roomData.avatar, roomData.isActive);\n        room.ownerContact = contactService.userContact;\n        room.owner = true;\n        room.isModerator = true;\n        room.status = "accepted";\n        service.rooms[room.dbId] = room;\n        service.roomsByJids[room.jid] = room;\n        $log.info("[roomService] createRoom \\"" + roomNameForLogs + "\\" -- success");\n        resolve(service.sendInitialRoomPresenceSync(room));\n      })["catch"](function (error) {\n        var message = error;\n\n        if (error && error.data) {\n          message = error.data.errorDetailsCode + " " + error.data.errorDetails;\n        }\n\n        $log.error("[roomService] createRoom \\"" + roomNameForLogs + "\\" -- failure : " + message);\n        reject(error);\n      });\n    });\n  };\n  /** Update participant in room **/\n\n\n  service.updateRoomUser = function (room, contact, status, privilege) {\n    var data = {};\n\n    if (status) {\n      data.status = status;\n    }\n\n    if (privilege) {\n      data.privilege = privilege;\n    }\n\n    return $q(function (resolve, reject) {\n      $http({\n        method: "PUT",\n        url: service.portalURL + "rooms/" + room.dbId + "/users/" + contact.dbId,\n        headers: authService.getPostHeader(),\n        data: data\n      }).then(function success(response) {\n        $log.info("[roomService] updateRoomUser " + contact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        var userData = response.data.data;\n        room.users.forEach(function (user) {\n          if (user.contact.jid === userData.jid_im) {\n            user.privilege = userData.privilege;\n            user.status = userData.status;\n          }\n        });\n        service.refreshMemberAndOrganizerLists(room);\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        resolve(room);\n      }, function failure(response) {\n        var errorMessage = "updateRoomUser " + contact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /** Archive Room **/\n\n\n  service.ownerArchiveRoom = function (room) {\n    $log.info("[roomService] ownerArchiveRoom");\n    return $q(function (resolve, reject) {\n      //unsubscribe all users\n      var unsubscribeRoomUserPromises = [];\n      room.users.forEach(function (user) {\n        // Only unsubscribe here other users that are not DELETED\n        if (!contactService.isUserContact(user.contact) && user.status !== service.RoomUserStatus.DELETED && user.status !== service.RoomUserStatus.REJECTED) {\n          unsubscribeRoomUserPromises.push(service.unsubscribeUserFromRoom(room, user.contact));\n        }\n      });\n      $q.all(unsubscribeRoomUserPromises).then(function () {\n        $log.info("[roomService] unsubscribe all other users successfully"); //unsubscribe me\n\n        service.unsubscribeMeFromRoom(room).then(function () {\n          $log.info("[roomService] ownerArchiveRoom successfully");\n          resolve(room);\n        });\n      })["catch"](function (error) {\n        var errorMessage = "ownerArchiveRoom failure: " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * UNSUBSCRIBE USER FROM ROOM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.unsubscribeUserFromRoom = function (room, contact) {\n    return service.updateRoomUser(room, contact, service.RoomUserStatus.UNSUBSCRIBED);\n  };\n  /**\n   * DELETE USER FROM ROOM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.ownerDeletesUserFromRoom = function (room, contact) {\n    $log.info("[roomService] ownerDeletesUserFromRoom");\n    return $q(function (resolve, reject) {\n      var userId = contact.dbId;\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "rooms/" + room.dbId + "/users/" + userId,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function success() {\n        $log.info("[roomService] ownerDeletesUserFromRoom " + userId + " from room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        resolve(room);\n      }, function failure(response) {\n        var errorMessage = "ownerDeletesUserFromRoom " + userId + " from room " + room.dbId + "(" + room.getNameForLogs() + ") failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * REINVATE REJECTED USER TO ROOM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.ownerReinviteRejectedUser = function (room, contact, reason, privilege, withoutInvitation) {\n    return $q(function (resolve, reject) {\n      service.ownerDeletesUserFromRoom(room, contact).then(function () {\n        service.addRoomUser(room, contact, reason, privilege, withoutInvitation).then(function () {\n          $log.info("[roomService] ownerReinviteRejectedUser " + contact.dbId + " from room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n          resolve(room);\n        });\n      })["catch"](function (error) {\n        var errorMessage = "ownerReinviteRejectedUser failure: " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * REINVATE DELETED USER TO ROOM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.ownerReinviteDeletedUser = function (room, contact, reason, privilege, withoutInvitation) {\n    return $q(function (resolve, reject) {\n      service.addRoomUser(room, contact, reason, privilege, withoutInvitation).then(function () {\n        $log.info("[roomService] ownerReinviteDeletedUser " + contact.dbId + " from room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        resolve(room);\n      })["catch"](function (error) {\n        var errorMessage = "ownerReinviteDeletedUser failure: " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * OWNER ROOM DELETE\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.ownerDeleteRoom = function (room) {\n    return $q(function (resolve, reject) {\n      var roomId = room.dbId;\n\n      if (!roomId) {\n        $log.error("[roomService] ownerDeleteRoom failure because the roomId is empty ...");\n        return;\n      } //Call the REST WebService\n\n\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "rooms/" + roomId,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function success() {\n        $log.info("[roomService] ownerDeleteRoom " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        delete service.rooms[room.dbId];\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        resolve(room);\n      }, function failure(response) {\n        var errorMessage = "ownerDeleteRoom (" + roomId + ") failure: unknown error occurred";\n\n        if (response && response.data) {\n          errorMessage = "ownerDeleteRoom (" + roomId + ") failure: " + response.data.errorDetails;\n        }\n\n        if (response && response.status === 404) {\n          $log.info("[roomService] ownerDeleteRoom " + room.dbId + "(" + room.getNameForLogs() + ") not found, deleting it from local storage");\n          delete service.rooms[room.dbId];\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        }\n\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * ROOM UPDATE\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.ownerUpdateRoom = function (roomData) {\n    $log.info("[roomService] ownerUpdateRoom");\n    return $q(function (resolve, reject) {\n      var _room = {\n        name: roomData.name,\n        topic: roomData.desc,\n        visibility: roomData.type ? "public" : "private"\n      }; // Call the REST WebService\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "rooms/" + roomData.dbId,\n        headers: authService.getPostHeader(),\n        data: _room\n      }) // Handle success response\n      .then(function success(response) {\n        var room = response.data.data;\n        service.rooms[room.id].desc = room.topic;\n        service.rooms[room.id].type = room.visibility === "private" ? Room.Type.PRIVATE : Room.Type.PUBLIC;\n        $log.info("[roomService] ownerUpdateRoom successfully (" + room.id + ", " + room.jid + ")"); //service.sendRoomTopic(service.rooms[room.id]); // To be implemented server side\n\n        resolve(service.rooms[room.id]);\n      }, function failure(response) {\n        var errorMessage = "ownerUpdateRoom failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * Change Room Owner\n   */\n\n\n  service.changeRoomOwner = function (room, newOwnerContact) {\n    $log.info("[roomService] changeRoomOwner");\n    return $q(function (resolve, reject) {\n      if (!room || !newOwnerContact) {\n        var msg = "changeRoomOwner error: - missing room or new owner";\n        $log.error("[roomService] " + msg);\n        reject(new Error(msg));\n        return;\n      }\n\n      var roomData = {\n        owner: newOwnerContact.dbId\n      }; //if we\'ve an attached conf endpoint, should remove it from the room\n\n      var confEndpointId = room.confEndpoints && room.confEndpoints.length ? room.confEndpoints[0].confEndpointId : ""; //if no confEndpoint or no such endpoint attached to bubble, the execution will continue\n\n      service.deleteRoomConferenceEndPoint(room, confEndpointId).then(function () {\n        // Call the REST WebService\n        $http({\n          method: "PUT",\n          url: service.portalURL + "rooms/" + room.dbId,\n          headers: authService.getPostHeader(),\n          data: roomData\n        }) // Handle success response\n        .then(function success() {\n          room.ownerContact = newOwnerContact;\n          room.owner = newOwnerContact.jid === contactService.userContact.jid;\n          $log.info("[roomService] changeRoomOwner successfully (" + room.dbId + ")");\n          resolve(service.rooms[room.dbId]);\n        }, function failure(response) {\n          var errorMessage = "changeRoomOwner failure: " + response.data.errorDetails;\n          $log.error("[roomService] " + errorMessage);\n          reject(new Error(errorMessage));\n        });\n      })["catch"](function (error) {\n        $log.error("[roomService] changeRoomOwner error");\n        reject(error);\n      });\n    });\n  };\n  /**\n   * ROOM UPDATE CUSTOM DATA\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.ownerUpdateRoomCustomData = function (roomData) {\n    $log.info("[roomService] ownerUpdateRoomCustomData");\n    return $q(function (resolve, reject) {\n      var _customData = {\n        "customData": roomData.customData\n      }; // Call the REST WebService\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "rooms/" + roomData.dbId + "/custom-data",\n        headers: authService.getPostHeader(),\n        data: _customData\n      }) // Handle success response\n      .then(function success(response) {\n        var data = response.data.data;\n        $log.info("[roomService] ownerUpdateRoomCustomData successfully got (" + JSON.stringify(data, null, 4) + ")");\n        resolve(data.customData || {});\n      }, function failure(response) {\n        var errorMessage = "ownerUpdateRoomCustomData failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.ownerUpdateRoomNameAndDescription = function (roomData) {\n    $log.info("[roomService] ownerUpdateRoomNameAndDescription");\n    return $q(function (resolve, reject) {\n      var _room = {\n        name: roomData.name,\n        topic: roomData.desc,\n        visibility: roomData.type ? "public" : "private"\n      }; // Call the REST WebService\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "rooms/" + roomData.dbId,\n        headers: authService.getPostHeader(),\n        data: _room\n      }) // Handle success response\n      .then(function success(response) {\n        var room = response.data.data;\n        service.rooms[room.id].desc = room.topic;\n        service.rooms[room.id].type = room.visibility === "private" ? Room.Type.PRIVATE : Room.Type.PUBLIC; // hack to update conference data from server\n\n        if (room.conference || room.confEndpoints) {\n          service.rooms[room.id].conference = room.conference ? room.conference : null;\n          service.rooms[room.id].confEndpoints = room.confEndpoints ? room.confEndpoints : [];\n        }\n\n        $log.info("[roomService] ownerUpdateRoomNameAndDescription successfully (" + room.id + ", " + room.jid + ")");\n        resolve(service.rooms[room.id]);\n      }, function failure(response) {\n        var errorMessage = "ownerUpdateRoomNameAndDescription failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.ownerUpdateAutoRegister = function (roomData) {\n    $log.info("[roomService] ownerUpdateAutoRegister");\n    return $q(function (resolve, reject) {\n      var _room = {\n        autoRegister: roomData.getAutoRegister()\n      }; // Call the REST WebService\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "rooms/" + roomData.dbId,\n        headers: authService.getPostHeader(),\n        data: _room\n      }) // Handle success response\n      .then(function success(response) {\n        var room = response.data.data;\n        service.rooms[room.id].setAutoRegister(room.autoRegister);\n        service.rooms[room.id].desc = room.topic;\n        service.rooms[room.id].type = room.visibility === "private" ? Room.Type.PRIVATE : Room.Type.PUBLIC; // hack to update conference data from server\n\n        if (room.conference || room.confEndpoints) {\n          service.rooms[room.id].conference = room.conference ? room.conference : null;\n          service.rooms[room.id].confEndpoints = room.confEndpoints ? room.confEndpoints : [];\n        }\n\n        $log.info("[roomService] ownerUpdateAutoRegister successfully (" + room.id + ", " + room.jid + ")");\n        resolve(service.rooms[room.id]);\n      }, function failure(response) {\n        var errorMessage = "ownerUpdateAutoRegister failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /*********************************************************/\n\n  /** PARTICIPANT FUNCTIONS                               **/\n\n  /*********************************************************/\n  //update my status\n\n\n  service.updateMyRoomUser = function (room, status) {\n    return $q(function (resolve, reject) {\n      // reject(new Error("My Testing Error Message"));\n      $http({\n        method: "PUT",\n        url: service.portalURL + "rooms/" + room.dbId + "/users/" + contactService.userContact.dbId,\n        headers: authService.getPostHeader(),\n        data: {\n          status: status\n        }\n      }).then(function success() {\n        $log.info("[roomService] updateMyRoomUser " + contactService.userContact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        resolve(room);\n      }, function failure(response) {\n        var errorMessage = "updateMyRoomUser " + contactService.userContact.displayNameForLog() + " to room " + room.dbId + "(" + room.getNameForLogs() + ") failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * UNSUBSCRIBE ME FROM A ROOM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.unsubscribeMeFromRoom = function (room) {\n    return service.updateMyRoomUser(room, service.RoomUserStatus.UNSUBSCRIBED);\n  };\n  /**\n   * DELETE MYSELF FROM A ROOM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.participantCloseRoom = function (room) {\n    $log.info("[roomService] participantCloseRoom");\n    return $q(function (resolve, reject) {\n      var userId = contactService.userContact.dbId;\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "rooms/" + room.dbId + "/users/" + userId,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function success() {\n        $log.info("[roomService] participantCloseRoom " + userId + " from room " + room.dbId + "(" + room.getNameForLogs() + ") success");\n        delete service.rooms[room.dbId];\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        resolve(room);\n      }, function failure(response) {\n        var errorMessage = "participantCloseRoom " + userId + " from room " + room.dbId + "(" + room.getNameForLogs() + ") failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n   * ACCEPT ROOM INVITATION\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.acceptRoomInvitation = function (room) {\n    return service.updateMyRoomUser(room, service.RoomUserStatus.ACCEPTED).then(function () {\n      return fileStorageService.retrieveReceivedFilesForRoom(room.dbId);\n    }).then(function () {\n      return service.sendInitialRoomPresenceSync(room);\n    });\n  };\n  /**\n   * DECLINE ROOM INVITATION\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.declineRoomInvitation = function (room) {\n    return service.updateMyRoomUser(room, service.RoomUserStatus.REJECTED);\n  };\n  /****************************************************** */\n\n  /*           Room Conference functions                  */\n\n  /****************************************************** */\n\n\n  service.getRoomConferenceEndPoint = function (room, conferenceEndPointId) {\n    $log.info("[roomService] getRoomConferenceEndPoint");\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "rooms/" + room.dbId + "/conference/" + conferenceEndPointId,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function success(response) {\n        var conferenceData = response.data.data;\n        $log.info("[roomService] getRoomConferenceEndPoint " + conferenceEndPointId + " from room " + room.dbId + "success");\n        resolve(conferenceData);\n      }, function failure(response) {\n        var errorMessage = "getRoomConferenceEndPoint " + conferenceEndPointId + " from room " + room.dbId + "failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.addRoomConferenceEndPoint = function (room, conferenceEndPoint, mediaType) {\n    $log.info("[roomService] addRoomConferenceEndPoint"); // Protection against weaird cases when this method is call with undefined or null as second parameter\n\n    if (conferenceEndPoint === null || angular.isUndefined(conferenceEndPoint)) {\n      var err = new Error("No ConferenceEndPoint to associate with Room");\n      return $q.reject(err);\n    }\n\n    return $q(function (resolve, reject) {\n      var alreadyAttached = false; //check if conferenceEndPoint is already attached to this room\n\n      room.confEndpoints.forEach(function (endpoint) {\n        if (endpoint.confEndpointId === conferenceEndPoint.id) {\n          alreadyAttached = true;\n        }\n      });\n\n      if (alreadyAttached) {\n        $log.info("[roomService] addRoomConferenceEndPoint : already attached to room !");\n        resolve(room);\n        return;\n      } // Check that no other room has the instant pstn endpoint attached, if so, detach it.\n\n\n      if (mediaType && mediaType === "pstnAudio") {\n        Object.keys(service.rooms).forEach(function (key) {\n          if (service.rooms[key].conference && !service.rooms[key].conference.scheduled && service.rooms[key].getPstnConfEndpointId() === conferenceEndPoint.id) {\n            service.deleteRoomConferenceEndPoint(service.rooms[key], conferenceEndPoint.id);\n          }\n        });\n      }\n\n      $http({\n        method: "POST",\n        url: service.portalURL + "rooms/" + room.dbId + "/conferences",\n        headers: authService.getPostHeader(),\n        data: {\n          confId: conferenceEndPoint.id\n        }\n      }) // Handle success response\n      .then(function success(response) {\n        var conferenceData = response.data.data;\n        $log.debug("[roomService] addRoomConferenceEndPoint response data:" + JSON.stringify(conferenceData)); //add conference endpoint data to room\'s confendpoints array\n\n        room.confEndpoints.push(conferenceData);\n        $log.info("[roomService] addRoomConferenceEndPoint " + conferenceEndPoint.id + " to room " + room.dbId + "success");\n        $rootScope.$broadcast(service.ROOM_ADD_CONF_ENDPOINT_EVENT, room);\n        resolve(room);\n      }, function failure(errorResponse) {\n        var error = errorHelperService.handleError(errorResponse);\n        $log.error("[roomService] addRoomConferenceEndPoint " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  service.deleteRoomConferenceEndPoint = function (room, conferenceEndPointId) {\n    $log.info("[roomService] deleteRoomConferenceEndPoint");\n    return $q(function (resolve, reject) {\n      // Ignore silently request without parameters\n      if (!room || !conferenceEndPointId) {\n        $log.info("[roomService] deleteRoomConferenceEndPoint : missing parameters ");\n        resolve();\n        return;\n      }\n\n      var roomHasConfEndpoint = false;\n\n      if (room.confEndpoints && room.confEndpoints.length) {\n        for (var i = 0; i < room.confEndpoints.length; i++) {\n          if (room.confEndpoints[i].confEndpointId === conferenceEndPointId) {\n            roomHasConfEndpoint = true;\n            break;\n          }\n        }\n      }\n\n      if (!roomHasConfEndpoint) {\n        $log.info("[roomService] deleteRoomConferenceEndPoint : room has no such conference attached");\n        resolve();\n        return;\n      }\n\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "rooms/" + room.dbId + "/conferences/" + conferenceEndPointId,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function success(response) {\n        var conferenceData = response.data.data;\n        $log.info("[roomService] deleteRoomConferenceEndPoint " + conferenceEndPointId + " from room " + room.dbId + "success");\n        room.confEndpoints = conferenceData;\n        $rootScope.$broadcast(service.ROOM_REMOVE_CONF_ENDPOINT_EVENT, room);\n        resolve();\n      }, function failure(response) {\n        var errorMessage = "deleteRoomConferenceEndPoint " + conferenceEndPointId + " from room " + room.dbId + "failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n\n        if (response.status === 404) {\n          room.confEndpoints = [];\n          $rootScope.$broadcast(service.ROOM_REMOVE_CONF_ENDPOINT_EVENT, room);\n          resolve(response.status);\n        } else {\n          reject(new Error(errorMessage));\n        }\n      });\n    });\n  };\n\n  service.inviteGuestEmailToJoinRoom = function (room, emails) {\n    $log.info("[roomService] inviteGuestEmailToJoinRoom");\n\n    if (!emails || !emails.length) {\n      return $q.resolve(room);\n    }\n\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + "rooms/" + room.dbId + "/invitations",\n        headers: authService.getRequestHeader(),\n        data: {\n          scenario: "chat",\n          emails: emails,\n          lang: authService.userData.language\n        }\n      }).then(function (response) {\n        room.guestEmails = response.data.data.guestEmails;\n        $rootScope.$broadcast("ROOM_UPDATE_EVENT", room);\n        resolve(room);\n      })["catch"](function (errorResponse) {\n        var error = errorHelperService.handleError(errorResponse);\n        $log.error("[roomService] inviteGuestEmailToJoinRoom " + error.message);\n        reject(error);\n      });\n    });\n  };\n  /**\n   * CANCEL GUEST INVITATION FROM ROOM\n   */\n\n\n  service.ownerCancelGuestFromRoom = function (room, emails) {\n    $log.info("[roomService] ownerCancelGuestFromRoom");\n\n    if (!emails || !emails.length) {\n      return $q.resolve(room);\n    }\n\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + "rooms/" + room.dbId + "/invitations/cancel",\n        headers: authService.getRequestHeader(),\n        data: {\n          scenario: "chat",\n          emails: emails,\n          lang: authService.userData.language\n        }\n      }).then(function (response) {\n        room.guestEmails = response.data.guestEmails;\n        $rootScope.$broadcast("ROOM_UPDATE_EVENT", room);\n        resolve(room);\n      })["catch"](function (errorResponse) {\n        var error = errorHelperService.handleError(errorResponse);\n        $log.error("[roomService] ownerCancelGuestFromRoom " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  service.notifyRoomUsersJoinConference = function (room, users, emails, noMail, update) {\n    $log.info("[roomService] notifyRoomUsersJoinConference");\n    noMail = angular.isDefined(noMail) ? noMail : "false";\n    update = angular.isDefined(update) ? update : "false";\n    return $q(function (resolve, reject) {\n      var conferenceEndPointId = room.getPstnConfEndpointId();\n\n      if (!conferenceEndPointId) {\n        resolve(room);\n      } else {\n        var instantMessage = room.desc;\n        $http({\n          method: "POST",\n          url: service.portalURL + "rooms/" + room.dbId + "/invitations",\n          headers: authService.getPostHeader(),\n          data: {\n            scenario: "pstn-conference",\n            confId: conferenceEndPointId,\n            noMail: noMail.toString(),\n            update: update.toString(),\n            users: users ? users.map(function (user) {\n              return user.dbId;\n            }) : undefined,\n            emails: emails,\n            instantMessage: instantMessage,\n            lang: authService.userData.language\n          }\n        }) // Handle success response\n        .then(function success() {\n          $log.info("[roomService] notifyRoomUsersJoinConference " + conferenceEndPointId + " from room " + room.dbId + "success");\n          service.rooms[room.dbId].guestEmails = emails;\n          $rootScope.$broadcast("ROOM_UPDATE_EVENT", service.rooms[room.dbId]);\n          resolve(service.rooms[room.dbId]);\n        }, function failure(response) {\n          var errorMessage = "notifyRoomUsersJoinConference " + conferenceEndPointId + " from room " + room.dbId + "failure: " + response.data.errorDetails;\n          $log.error("[roomService] " + errorMessage);\n          reject(new Error(errorMessage));\n        });\n      }\n    });\n  };\n\n  service.notifyUsersCancelConference = function (room, users, emails, noMail) {\n    $log.debug("[roomService] notifyUsersCancelConference");\n    noMail = angular.isDefined(noMail) ? noMail : "false";\n    return $q(function (resolve, reject) {\n      var conferenceEndPointId = room.getPstnConfEndpointId();\n\n      if (!conferenceEndPointId) {\n        resolve(room);\n      } else {\n        $http({\n          method: "DELETE",\n          url: service.portalURL + "rooms/" + room.dbId + "/invitations",\n          headers: authService.getPostHeader(),\n          data: {\n            scenario: "pstn-conference",\n            confId: conferenceEndPointId,\n            noMail: noMail.toString(),\n            users: users ? users.map(function (user) {\n              return user.dbId;\n            }) : undefined,\n            emails: emails,\n            lang: authService.userData.language\n          }\n        }).then(function success() {\n          $log.info("[roomService] notifyUsersCancelConference " + conferenceEndPointId + " from room " + room.dbId + "success");\n          service.rooms[room.dbId].guestEmails = service.rooms[room.dbId].guestEmails.filter(function (email) {\n            return emails.indexOf(email) === -1;\n          });\n          $rootScope.$broadcast("ROOM_UPDATE_EVENT", service.rooms[room.dbId]);\n          resolve(service.rooms[room.dbId]);\n        }, function failure(response) {\n          var errorMessage = "notifyUsersCancelConference " + conferenceEndPointId + " from room " + room.dbId + "failure: " + response.data.errorDetails;\n          $log.error("[roomService] " + errorMessage);\n          reject(new Error(errorMessage));\n        });\n      }\n    });\n  };\n\n  service.getRoomByConferenceEndpointId = function (conferenceEndpointId) {\n    $log.info("[roomService] getRoomFromConferenceEndpointId");\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "rooms?userId=" + contactService.userContact.dbId + "&confId=" + conferenceEndpointId + "&format=full",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        $log.info("[roomService] getRoomFromConferenceEndpointId -- " + conferenceEndpointId + " -- success");\n        var roomData = response.data.data;\n\n        if (roomData.length) {\n          if (service.getRoomById(roomData[0].id)) {\n            resolve(service.getRoomById(roomData[0].id));\n          } else {\n            service.createRoomFromData(roomData[0]);\n            resolve(service.getRoomById(roomData[0].id));\n          }\n        } else {\n          $log.info("[roomService] getRoomFromConferenceEndpointId -- no room with confId " + conferenceEndpointId);\n          reject();\n        }\n      }, function failure(response) {\n        var errorMessage = "getRoomFromConferenceEndpointId -- " + conferenceEndpointId + " -- failure: " + response.data.errorDetails;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /*********************************************************/\n\n  /** ROOM XMPP EVENT HANDLERS                            **/\n\n  /*********************************************************/\n  //TO BE REMOVED SOON !\n\n\n  service.onRoomMessage = function (stanza) {\n    $log.info("[roomService] onRoomMessage");\n\n    try {\n      // Filter out conferenceAdd and conferenceRemove as it is handled in onRoomInfoMessage\n      //ignore invitation message as already treated in onRoomNotificationMessage\n      // TODO: make it cleaner\n      if (angular.element(stanza).find("event").length > 0 && (angular.element(stanza).find("event").attr("name") === "conferenceAdd" || angular.element(stanza).find("event").attr("name") === "conferenceRemove" || angular.element(stanza).find("event").attr("name") === "invitation")) {\n        return true;\n      }\n\n      var roomId = angular.element(stanza).find("x").attr("thread");\n      service.getServerRoom(roomId).then(function (room) {\n        if (room.isMeetingRoom()) {\n          $rootScope.$broadcast("MEETING_CREATED_EVENT", room);\n        }\n\n        service.computeInvitationCounter();\n        $rootScope.$broadcast(service.ROOM_INVITATION, room);\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n      })["catch"](function (error) {\n        $log.error("[roomService] onRoomMessage failure :  impossible to get associated room : " + error.message);\n      });\n      return true;\n    } catch (error) {\n      $log.error("[roomService] onRoomMessage error " + error);\n      return true;\n    }\n  }; //Will replace onRoomMessage soon\n\n\n  service.onRoomNotificationMessage = function (stanza) {\n    try {\n      var stanzaElem = $(stanza);\n      var xElem = stanzaElem.find("x");\n\n      if (stanzaElem.find("event").length && xElem.length) {\n        var eventName = stanzaElem.find("event").attr("name"); //ignore if not invitation event\n\n        if (!eventName || eventName !== "invitation") {\n          return true;\n        }\n\n        var roomId = $(xElem[0]).attr("roomid"); //ignore if missing data\n\n        if (!roomId) {\n          $log.info("[roomService] onRoomNotificationMessage error -- missing roomId");\n          return true;\n        }\n\n        $log.info("[roomService] onRoomNotificationMessage : room event message with roomId " + roomId + " and event name " + eventName);\n        service.getServerRoom(roomId).then(function (room) {\n          if (room.isMeetingRoom()) {\n            $rootScope.$broadcast("MEETING_CREATED_EVENT", room);\n          }\n\n          if (settingsService.getSetting(\'autoAcceptRoomInvite\') === "true") {\n            service.acceptRoomInvitation(room);\n          } else {\n            service.computeInvitationCounter();\n            $rootScope.$broadcast(service.ROOM_INVITATION, room);\n            $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room); //if this is an invitation, and I\'m already in the room (case of auto-accept)\n            //and there\'s an active conference, we should show ringing incoming popup\n\n            if (room.status === "accepted" && room.confEndpoints && room.confEndpoints.length) {\n              //we\'ve an active conference in this bubble\n              if (room.confEndpoints[0].mediaType === "webrtc") {\n                $rootScope.$broadcast("ON_CONFERENCE_STARTED_INVITATION", room);\n              }\n            }\n\n            $log.info("[roomService] onRoomNotificationMessage -- get server room success for roomId " + room.dbId + " and roomJid" + room.jid_im + " and name " + room.getNameForLogs());\n          }\n        })["catch"](function (error) {\n          $log.error("[roomService] onRoomNotificationMessage failure :  impossible to get associated room : " + error.message);\n        });\n        return true;\n      }\n    } catch (error) {\n      $log.error("[roomService] onRoomNotificationMessage error " + error);\n      return true;\n    }\n  };\n\n  service.onRoomInfoMessage = function (stanza) {\n    $log.info("[roomService] onRoomInfoMessage");\n\n    try {\n      if (angular.element(stanza).find("event").length > 0) {\n        $log.info("[roomService] onRoomInfoMessage : room event message");\n        var fromJid = angular.element(stanza).attr("from");\n        var roomBareJid = xmppService.getBareJidFromJid(fromJid);\n        var userJid = angular.element(stanza).find("event").attr("jid");\n        var eventName = angular.element(stanza).find("event").attr("name");\n        var msgId = angular.element(stanza).attr("id");\n        $log.info("[roomService] onRoomInfoMessage : room event message with parameters " + roomBareJid + " || " + userJid + " || " + eventName + " || " + msgId);\n\n        if (roomBareJid && userJid && eventName && msgId) {\n          var room = service.getRoomByJid(roomBareJid);\n          var user = room.getUserByJid(userJid); // No need to broadcast message for a user that has been deleted\n\n          if (user && user.status !== "deleted") {\n            $rootScope.$broadcast(service.ROOM_ADMIN_MESSAGE_EVENT, roomBareJid, userJid, eventName, msgId);\n          }\n\n          switch (eventName) {\n            case "conferenceAdd":\n              //Workaround for conference start -> To be removed later !!!\n              $interval(function () {\n                service.getServerRoom(room.dbId).then(function (updatedRoom) {\n                  var info = updatedRoom.confEndpoints && updatedRoom.confEndpoints[0] ? updatedRoom.confEndpoints[0].confEndpointId : undefined;\n                  $log.info("[roomService] onRoomInfoMessage : conferenceAdd event with conferenceObject related to room : " + info);\n                  $rootScope.$broadcast("ROOM_UPDATE_CONFID", updatedRoom);\n                  $rootScope.$broadcast("ROOM_ADD_CONF_ENDPOINT_EVENT", updatedRoom);\n                  $rootScope.$broadcast("ON_CONFERENCE_STARTED_INVITATION", updatedRoom, user);\n                });\n              }, 2000, 1);\n              break;\n\n            case "conferenceRemove":\n              $interval(function () {\n                service.getServerRoom(room.dbId).then(function (updatedRoom) {\n                  $log.info("[roomService] onRoomInfoMessage : conferenceRemove event");\n                  $rootScope.$broadcast("ROOM_REMOVE_CONF_ENDPOINT_EVENT", updatedRoom);\n                  $rootScope.$broadcast("ON_CONFERENCE_ENDED_INVITATION", updatedRoom);\n                });\n              }, 2000, 1);\n              break;\n\n            case "invitation":\n              // if we\'re moderator of the bubble and the user is not known to us, we should update the room\n              if (room.isUserModerator(contactService.userContact) && (!user || user.status === service.RoomUserStatus.DELETED)) {\n                service.getServerRoom(room.dbId).then(function (updatedRoom) {\n                  $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, updatedRoom);\n                });\n              }\n\n              break;\n\n            default:\n              break;\n          }\n        }\n      } else if (angular.element(stanza).find("subject").length > 0) {\n        var fromJid = angular.element(stanza).attr("from");\n        var fromBareJid = xmppService.getBareJidFromJid(fromJid);\n        var room = service.getRoomByJid(fromBareJid);\n        var topic = angular.element(stanza).find("subject").text();\n\n        if (room && topic) {\n          $log.info("[roomService] onRoomInfoMessage : update subject of room");\n          room.desc = topic;\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        }\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[roomService] onRoomInfoMessage error " + error);\n      return true;\n    }\n  };\n\n  service.onRoomHistoryInfoMessage = function (stanza) {\n    var stanzaElem = $(stanza);\n    var changedElem = stanzaElem.find("changed");\n\n    if (changedElem.length > 0) {\n      var roomId = changedElem.attr("with");\n      var room = service.getRoomByJid(roomId);\n      $log.debug("[roomService] onRoomHistoryInfoMessage with " + roomId);\n      $rootScope.$broadcast(service.ROOM_HISTORY_UPDATE_EVENT, room);\n    }\n\n    return true;\n  };\n\n  service.onRoomMessageConfig = function (stanza) {\n    try {\n      var stanzaElem = $(stanza);\n      var roomElem = stanzaElem.find("room");\n      var delayElem = stanzaElem.find("delay");\n\n      if (stanzaElem.attr("type") === "management" && roomElem.length > 0) {\n        var roomId = roomElem.attr("roomid");\n        var userId = roomElem.attr("userjid");\n        var status = roomElem.attr("status");\n        var topic = roomElem.attr("topic");\n        var name = roomElem.attr("name");\n        var lastAvatarUpdateDate = roomElem.attr("lastAvatarUpdateDate");\n        var avatarElem = stanzaElem.find("avatar");\n        var avatarType = null;\n\n        if (avatarElem.length > 0) {\n          if (avatarElem.attr("action") === "delete") {\n            avatarType = "delete";\n          } else {\n            avatarType = "update";\n          }\n        }\n\n        var privilege = roomElem.attr("privilege");\n        var customData = roomElem.attr("customData");\n        var room = service.getRoomById(roomId);\n        $log.info("[roomService] onRoomMessageConfig -- management -- " + roomId);\n\n        if (delayElem.length > 0 && delayElem.text() === "Offline Storage") {\n          $log.info("[roomService] onRoomMessageConfig -- management delay msg skipped --");\n          return true;\n        } // Handle room guest (if any)\n\n\n        var guestsElem = roomElem.find("guests");\n\n        if (guestsElem.length > 0) {\n          $log.info("[roomService] onRoomMessageConfig -- " + roomId + " -- update guests list");\n\n          if (guestsElem.attr("action") === "update") {\n            room.guestEmails = [];\n            $(guestsElem).find("email").each(function (__index, emailElem) {\n              room.guestEmails.push(emailElem.textContent);\n            });\n          }\n        }\n\n        if (room && status) {\n          var user = room.getUserByJid(userId);\n\n          if (!user) {\n            $log.info("[roomService] onRoomMessageConfig room exists, but user not. Update the room");\n            service.getServerRoom(roomId).then(function () {\n              room.updateAvatarInfo();\n            });\n          } else if (user) {\n            $log.info("[roomService] onRoomMessageConfig update user status");\n            service.updateUserStatus(room, user, status);\n          }\n        } else if (room && name) {\n          $log.info("[roomService] onRoomMessageConfig update Room name or topic"); //update the name\n\n          room.name = name;\n          room.desc = topic ? topic : "";\n          service.roomsByJids[room.jid].name = name;\n          service.rooms[room.dbId].name = name;\n          service.roomsByJids[room.jid].desc = topic ? topic : "";\n          service.rooms[room.dbId].desc = topic ? topic : "";\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room, "rename");\n        } else if (room && customData) {\n          $log.info("[roomService] onRoomMessageConfig update Room customData");\n          var extractedContent = utilService.extractHtmlContent(customData);\n\n          try {\n            customData = JSON.parse(extractedContent);\n          } catch (err) {\n            $log.error("[roomService] onRoomMessageConfig update Room Parsing error:", err);\n            customData = {};\n          } //update the custom Data\n\n\n          room.customData = customData;\n          service.roomsByJids[room.jid].customData = customData;\n          service.rooms[room.dbId].customData = customData;\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        } else if (room && (lastAvatarUpdateDate || avatarType)) {\n          $log.info("[roomService] onRoomMessageConfig " + avatarType + " avatar");\n          service.getServerRoom(room.dbId).then(function (roomToUpdate) {\n            roomToUpdate.updateAvatarInfo();\n            $rootScope.$broadcast(service.ROOM_AVATAR_UPDATE_EVENT, room);\n          });\n        } else if (room && privilege) {\n          $log.info("[roomService] onRoomMessageConfig update user\'s privilege " + privilege);\n          var user = userId ? room.getUserByJid(userId) : null; // Should only update the privilege of the user if it\'s not me and we do not change the owner\n\n          if (user && user.contact && user.contact.jid !== contactService.userContact.jid && privilege !== "owner") {\n            if (privilege === "moderator") {\n              user.privilege = Room.Privilege.MODERATOR;\n            } else if (privilege === "user") {\n              user.privilege = Room.Privilege.USER;\n            }\n\n            contactService.getVCardByDbId(user.contact.dbId).then(function () {\n              service.refreshMemberAndOrganizerLists(room);\n              $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n            });\n          } else {\n            //should refresh the whole room to get all the pending invitations\n            service.getServerRoom(room.dbId).then(function (roomToUpdate) {\n              service.refreshMemberAndOrganizerLists(roomToUpdate);\n              $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, roomToUpdate);\n            });\n          } //if I\'m the new owner, show a notification\n\n\n          if (privilege === "owner" && user && user.contact && user.contact.jid === contactService.userContact.jid) {\n            var message = $translate.instant("promotedToOwner", {\n              "name": _escape(room.name)\n            });\n            $rootScope.$broadcast("GLOBAL_NOTIFY_MESSAGE_EVENT", message);\n          }\n        } else if (room === undefined && roomId && !service.roomsInProgress[roomId] && status !== "deleted" && status !== "rejected") {\n          //room does not exist\n          service.roomsInProgress[roomId] = true;\n          $log.info("[roomService] onRoomMessageConfig -- room does not exist, create new one");\n          service.getServerRoom(roomId).then(function (newRoom) {\n            delete service.roomsInProgress[roomId];\n            $log.info("[roomService] onRoomMessageConfig -- sendInitialRoomPresence to the new room");\n            service.sendInitialRoomPresence(newRoom);\n\n            if (service.updateLater[roomId]) {\n              delete service.updateLater[roomId];\n              $log.info("[roomService] onRoomMessageConfig -- later update of the new room");\n              service.getServerRoom(roomId).then(function (roomToUpdate) {\n                roomToUpdate.updateAvatarInfo();\n              });\n            }\n          });\n        } else if (service.roomsInProgress[roomId]) {\n          service.updateLater[roomId] = roomId;\n        }\n      }\n\n      var openinviteElem = stanzaElem.find("openinvite");\n\n      if (stanzaElem.attr("type") === "management" && openinviteElem.length > 0) {\n        $log.info("[roomService] onRoomMessageConfig -- openinvite");\n        var openInviteAction = openinviteElem.attr("action");\n        var roomId = openinviteElem.find("roomid").text();\n        var openInviteId = openinviteElem.find("openinviteid").text();\n        var roomType = openinviteElem.find("roomType").text();\n\n        switch (openInviteAction) {\n          case "update":\n            // Cleanup previous roomId / openInviteId association if any\n            Object.keys(service.openInviteIdByRoomId).forEach(function (key) {\n              if (service.openInviteIdByRoomId[key] && service.openInviteIdByRoomId[key].openInviteId === openInviteId && key !== roomId) {\n                $log.info("[roomService] onRoomMessageConfig -- openinviteId removed from " + key);\n                service.openInviteIdByRoomId[key] = {};\n              }\n            });\n\n          case "create":\n            if (roomId && openInviteId) {\n              service.openInviteIdByRoomId[roomId] = {};\n              service.openInviteIdByRoomId[roomId].roomType = roomType;\n              service.openInviteIdByRoomId[roomId].openInviteId = openInviteId;\n              service.openInviteIdByRoomId[roomId].openInviteLink = config.webUrl.replace("web", "meet") + "/" + openInviteId;\n              $log.info("[roomService] onRoomMessageConfig -- openinviteId " + openInviteId + " assigned to room " + roomId);\n              $rootScope.$broadcast("ON_OPEN_INVITE_ID_UPDATED_EVENT", service.rooms[roomId]);\n\n              if (roomType === "personal_audio_room") {\n                if (service.personalAudioRoomId && service.personalAudioRoomId !== roomId) {\n                  service.personalAudioRoomId = roomId;\n                  $log.debug("[roomService] personal audio room bound to openinviteId changed to " + roomId);\n                } else {\n                  $log.debug("[roomService] openinviteId of personal audio room changed to " + openInviteId);\n                  $rootScope.$broadcast("ON_PERSONAL_MEETING_OPEN_INVITE_ID_UPDATED_EVENT");\n                }\n              }\n            }\n\n            break;\n\n          case "delete":\n            // Cleanup previous roomId / openInviteId association if any\n            Object.keys(service.openInviteIdByRoomId).forEach(function (key) {\n              if (service.openInviteIdByRoomId[key] && service.openInviteIdByRoomId[key].openInviteId === openInviteId && key === roomId) {\n                $log.info("[roomService] onRoomMessageConfig -- openinviteId removed from " + key);\n                service.openInviteIdByRoomId[key] = {};\n                $rootScope.$broadcast("ON_OPEN_INVITE_ID_DELETED_EVENT", service.rooms[roomId]);\n              }\n            });\n            break;\n\n          default:\n            $log.info("[roomService] onRoomMessageConfig -- openinviteId - unkown action : " + openInviteAction);\n            break;\n        }\n      }\n\n      return true;\n    } catch (error) {\n      $log.info("[roomService] onRoomMessageConfig  -- failure -- " + error.message);\n      return true;\n    }\n  };\n\n  service.onRoomPresence = function (stanza) {\n    try {\n      var stanzaElem = angular.element(stanza);\n      var fromJid = stanzaElem.attr("from");\n      var fromRoomBareJid = xmppService.getBareJidFromJid(fromJid);\n      var fromUserJid = xmppService.getResourceFromJid(fromJid); // Get xmpp status\n\n      var statusElems = stanzaElem.find("status");\n      var statusCode = null;\n      statusElems.each(function (__index, statusElem) {\n        if ($(statusElem).attr("code") === "332") {\n          statusCode = "332";\n        }\n\n        if ($(statusElem).attr("code") === "338") {\n          statusCode = "338";\n        }\n\n        if ($(statusElem).attr("code") === "339") {\n          statusCode = "339";\n        }\n      }); // Get the associated room\n\n      var room = service.getRoomByJid(fromRoomBareJid);\n\n      if (room) {\n        if (statusCode === "338") {\n          $log.info("[roomService] onRoomPresence - " + room.dbId + "- Deactivated");\n          room.isActive = false;\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        } else if (statusCode === "339") {\n          $log.info("[roomService] onRoomPresence - " + room.dbId + "- Reactivated");\n          service.sendInitialRoomPresenceSync(room);\n          room.isActive = true;\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n        } else {\n          $log.info("[roomService] onRoomPresence -- " + room.dbId);\n\n          if (fromUserJid.indexOf("/") !== -1) {\n            fromUserJid = xmppService.getBareJidFromJid(fromUserJid);\n          } // Handle presence from myself\n\n\n          if (contactService.isUserContactJid(fromUserJid)) {\n            if (statusCode === "332") {\n              $log.error("[roomService] disconnected from room " + room.getNameForLogs() + " because of a system shutdown");\n              service.sendInitialRoomPresenceSync(room);\n            } else {\n              if (room.initPresPromise) {\n                $log.info("[roomService] onRoomPresence - initPresPromise resolved");\n                room.initPresPromise.resolve(room);\n\n                if (room.initPresInterval) {\n                  $interval.cancel(room.initPresInterval);\n                }\n\n                room.initPresPromise = null;\n                $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room); // Mark room as already received first presence\n\n                room.initPresPromiseReceived = true;\n              }\n            }\n          } // Handle presence for other participant\n          else if (room.dbId && !service.rooms[room.dbId]) {\n              service.getServerRoom(room.dbId);\n            }\n        }\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[roomService] onRoomPresence error " + error);\n      return true;\n    }\n  };\n  /*********************************************************/\n\n  /** ROOM HELPER FUNC                                    **/\n\n  /*********************************************************/\n\n\n  service.updateUserStatus = function (room, user, status) {\n    $log.info("[roomService] " + user.status + " || " + status);\n\n    if (contactService.isUserContactJid(user.contact.jid) && user.status !== status) {\n      // Handle presence from myself\n      $log.info("[roomService] my new status " + status);\n\n      switch (status) {\n        case "deleted":\n          delete service.roomsByJids[room.jid];\n          delete service.rooms[room.dbId];\n          $log.info("[roomService] deleteRoom successfully (" + room.dbId + ")"); //remove my presence from the room\n\n          service.sendUnavailableRoomPresence(room); //reset the counter\n\n          service.computeInvitationCounter();\n\n          if (room.isMeetingRoom()) {\n            $rootScope.$broadcast("MEETING_DELETE_EVENT", room);\n          }\n\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room, "remove");\n          break;\n\n        case "unsubscribed":\n          $log.info("[roomService] unsubscribed successfully (" + room.dbId + ")");\n          service.sendUnavailableRoomPresence(room);\n          room.status = service.RoomUserStatus.UNSUBSCRIBED;\n          user.status = status;\n          room.updateAvatarInfo();\n          room.isModerator = false; //reset the counter\n\n          service.computeInvitationCounter();\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n          break;\n\n        case "accepted":\n          //User has accepted the invitation\n          fileStorageService.retrieveReceivedFilesForRoom(room.dbId).then(function () {\n            service.sendInitialRoomPresence(room);\n            room.status = service.RoomUserStatus.ACCEPTED;\n            user.status = status;\n            room.updateAvatarInfo();\n            service.computeInvitationCounter();\n            $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room); //refresh the room for any updates between the invite and the accept\n\n            service.getServerRoom(room.dbId).then(function (room) {\n              $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room); //if there\'s an active conference, we should show ringing incoming popup\n\n              if (room.confEndpoints && room.confEndpoints.length) {\n                //we\'ve an active conference in this bubble\n                if (room.confEndpoints[0].mediaType === "webrtc") {\n                  $rootScope.$broadcast("ON_CONFERENCE_STARTED_INVITATION", room);\n                }\n              }\n            })["catch"](function () {\n              $log.warn("[roomService] getServerRoom " + room.dbId + " failed");\n            });\n          });\n          break;\n\n        case "rejected":\n          //User has rejected the invitation\n          delete service.roomsByJids[room.jid];\n          delete service.rooms[room.dbId];\n          room.status = service.RoomUserStatus.REJECTED;\n          user.status = status;\n          service.computeInvitationCounter();\n          $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n          break;\n\n        default:\n          break;\n      }\n    } // Handle presence for other participant\n    else if (user && !contactService.isUserContactJid(user.contact.jid)) {\n        $log.info("[roomService] Update user with status " + status);\n\n        if (user.status === service.RoomUserStatus.DELETED && status === service.RoomUserStatus.ACCEPTED) {\n          user.date = new Date(); //remove user\'s moderator rights\n\n          if (user.privilege === Room.Privilege.MODERATOR) {\n            user.privilege = Room.Privilege.USER;\n          }\n        }\n\n        user.status = status;\n        room.updateAvatarInfo();\n        service.refreshMemberAndOrganizerLists(room);\n        $rootScope.$broadcast(service.ROOM_UPDATE_EVENT, room);\n      }\n  };\n\n  service.findRoomsWithConfId = function (confId) {\n    var rooms = service.getRooms().filter(function (room) {\n      if (room.confEndpoints && room.confEndpoints.length) {\n        return room.confEndpoints.some(function (confEndpoint) {\n          return confEndpoint.confEndpointId === confId;\n        });\n      }\n\n      return false;\n    });\n    return rooms;\n  };\n\n  service.removeConfIdInAllRooms = function (rooms) {\n    var actionPromises = [];\n    rooms.forEach(function (room) {\n      if (room.confEndpoints && room.confEndpoints.length > 0) {\n        actionPromises.push(service.deleteRoomConferenceEndPoint(room, room.confEndpoints[0].confEndpointId));\n      }\n    });\n    return $q.all(actionPromises);\n  };\n\n  service.getCreationDate = function (room) {\n    if (room.creationDate) {\n      return moment(room.creationDate);\n    }\n\n    return moment();\n  };\n\n  service.getLastActivityDate = function (room) {\n    if (room.lastActivityDate) {\n      return moment(room.lastActivityDate);\n    }\n\n    if (room.creationDate) {\n      return moment(room.creationDate);\n    }\n\n    return moment();\n  };\n\n  service.sortByDate = function (dateA, dateB) {\n    var res = 1;\n\n    if (dateA && dateB) {\n      res = dateA.value - dateB.value;\n    }\n\n    return res;\n  };\n  /***************************************************************/\n\n  /**  OPENINVITEID STUFF                                       **/\n\n  /***************************************************************/\n\n\n  service.resetOpenInviteId = function (roomId) {\n    return new Promise(function (resolve, reject) {\n      // Send request\n      var serverUrl = service.portalURL + "users/" + contactService.userContact.dbId + "/public-links/reset";\n      $http({\n        method: "PUT",\n        url: serverUrl,\n        headers: authService.getRequestHeader(),\n        data: {\n          roomId: roomId\n        }\n      }).then(function (response) {\n        var openInviteData = response.data.data;\n\n        if (openInviteData && openInviteData.openInviteId && openInviteData.roomId) {\n          $log.info("[roomService] resetOpenInviteId success - openinviteId " + openInviteData.openInviteId + " bound to room " + roomId);\n          service.openInviteIdByRoomId[openInviteData.roomId] = {};\n          service.openInviteIdByRoomId[openInviteData.roomId].roomType = openInviteData.roomType;\n          service.openInviteIdByRoomId[openInviteData.roomId].openInviteId = openInviteData.openInviteId;\n          service.openInviteIdByRoomId[openInviteData.roomId].openInviteLink = config.webUrl.replace("web", "meet") + "/" + openInviteData.openInviteId;\n\n          if (openInviteData.roomType === "personal_audio_room") {\n            service.personalAudioRoomId = openInviteData.roomId;\n          }\n        }\n\n        resolve(openInviteData.openInviteId);\n      }, function failure() {\n        var errorMessage = "resetOpenInviteId failure";\n        $log.error("[contactService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.bindOpenInviteIdToRoom = function (room) {\n    return new Promise(function (resolve, reject) {\n      var url = service.portalURL + "users/" + room.ownerContact.dbId + "/public-links/bind";\n      var data = {\n        roomId: room.dbId\n      };\n      $http({\n        method: "POST",\n        url: url,\n        headers: authService.getPostHeader(),\n        data: data\n      }).then(function (response) {\n        var openInviteData = response.data.data;\n\n        if (openInviteData && openInviteData.roomId && openInviteData.roomType && openInviteData.openInviteId) {\n          $log.info("[roomService] createRoomOpenInviteId -- SUCCESS - room " + openInviteData.roomId + " with type " + openInviteData.roomType + " bound to openInviteId " + openInviteData.openInviteId);\n          service.openInviteIdByRoomId[openInviteData.roomId] = {};\n          service.openInviteIdByRoomId[openInviteData.roomId].roomType = openInviteData.roomType;\n          service.openInviteIdByRoomId[openInviteData.roomId].openInviteId = openInviteData.openInviteId;\n          service.openInviteIdByRoomId[openInviteData.roomId].openInviteLink = config.webUrl.replace("web", "meet") + "/" + openInviteData.openInviteId;\n\n          if (openInviteData.roomType === "personal_audio_room") {\n            service.personalAudioRoomId = openInviteData.roomId;\n          }\n        } // For the moment, resolve anyway to avoid potential issue. To be reviewed after some tests \n\n\n        resolve(service.rooms[room.dbId]);\n      })["catch"](function (error) {\n        var errorMessage = "createRoomOpenInviteId -- FAILURE -- " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.unbindOpenInviteFromRoom = function (roomId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "PUT",\n        url: service.portalURL + "users/" + contactService.userContact.dbId + "/public-links/unbind",\n        headers: authService.getRequestHeader(),\n        data: {\n          roomId: roomId\n        }\n      }).then(function () {\n        $log.info("[roomService] openInvite successfully unbound");\n        resolve();\n      }, function failure() {\n        var errorMessage = "unbindOpenInvite failure";\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.joinRoomUsingOpenInviteId = function (openInviteId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/rooms/open-invites",\n        headers: authService.getRequestHeader(),\n        data: {\n          openInviteId: openInviteId\n        }\n      }).then(function success(response) {\n        // Should we do something with "hasAlreadyJoinThisRoom" ?\n        var openInvitesData = response.data.data;\n\n        if (openInvitesData && openInvitesData.roomId) {\n          resolve(openInvitesData.roomId);\n        } else {\n          reject();\n        }\n      })["catch"](function (err) {\n        var error = errorHelperService.handleError(err);\n        $log.error("[roomService] Error retrieveRoomFromOpenInvite");\n        reject(error);\n      });\n    });\n  };\n\n  service.retrieveOpenInviteData = function (type, roomId) {\n    $log.debug("[roomService] retrieveOpenInviteData - type: " + type + " - roomId: " + roomId);\n    return new Promise(function (resolve, reject) {\n      var urlParams = "";\n\n      if (roomId) {\n        urlParams += "?roomId=" + roomId;\n      }\n\n      if (type) {\n        urlParams += urlParams ? "&type=" + type : "?type=" + type;\n      }\n\n      var url = service.portalURL + "users/" + contactService.userContact.dbId + "/public-links" + urlParams;\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getPostHeader()\n      }).then(function (response) {\n        var openInviteData = response.data.data;\n\n        if (openInviteData && openInviteData.length) {\n          $log.debug("[roomService] retrieveOpenInviteData -- SUCCESS - found " + openInviteData.length); //openInviteIdByRoomId\n\n          openInviteData.forEach(function (openInvitePair) {\n            if (openInvitePair.roomId) {\n              service.openInviteIdByRoomId[openInvitePair.roomId] = {};\n              service.openInviteIdByRoomId[openInvitePair.roomId].roomType = openInvitePair.roomType;\n              service.openInviteIdByRoomId[openInvitePair.roomId].openInviteId = openInvitePair.openInviteId;\n              service.openInviteIdByRoomId[openInvitePair.roomId].openInviteLink = config.webUrl.replace("web", "meet") + "/" + openInvitePair.openInviteId;\n              $log.debug("[roomService] retrieveOpenInviteData - openInviteId " + openInvitePair.openInviteId + " set for room " + openInvitePair.roomId);\n\n              if (openInvitePair.roomType === "personal_audio_room") {\n                service.personalAudioRoomId = openInvitePair.roomId;\n              }\n            }\n          });\n          resolve(openInviteData);\n        } else {\n          $log.debug("[roomService] retrieveOpenInviteData -- FAILURE - none found");\n          reject();\n        }\n      })["catch"](function (error) {\n        var errorMessage = "retrieveOpenInviteData -- FAILURE -- " + error.message;\n        $log.error("[roomService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.retrievePersonalAudioRoom = function () {\n    $log.debug("[roomService] retrievePersonalAudioRoom");\n    return $q(function (resolve, reject) {\n      if (service.personalAudioRoomId) {\n        if (service.rooms[service.personalAudioRoomId]) {\n          resolve(service.rooms[service.personalAudioRoomId]);\n        } else {\n          $log.warn("[roomService] retrievePersonalAudioRoom - unknown room");\n          service.unbindOpenInviteFromRoom(service.personalAudioRoomId)["finally"](function () {\n            service.personalAudioRoomId = "";\n            reject();\n          });\n        }\n      } else {\n        service.retrieveOpenInviteData("personal_audio_room").then(function (openInviteData) {\n          // Note: method may return multiple entries but only the first one is used, warning is raised to inform that more than one is available\n          if (openInviteData.length > 1) {\n            $log.warn("[roomService] retrievePersonalAudioRoom - more than one personal audio room found");\n          }\n\n          var roomId = openInviteData[0].roomId;\n\n          if (roomId) {\n            service.personalAudioRoomId = roomId;\n            var room = service.getRoomById(roomId);\n\n            if (room) {\n              resolve(room);\n              return;\n            }\n\n            $log.warn("[roomService] retrievePersonalAudioRoom - room with openInvite not found locally, retrieving it from server.");\n            service.getServerRoom(roomId).then(function (serverRoom) {\n              resolve(serverRoom);\n              return;\n            })["catch"](function () {\n              $log.warn("[roomService] retrievePersonalAudioRoom - no room attached");\n              reject(new Error("[roomService] retrievePersonalAudioRoom - no room attached"));\n            });\n          } else {\n            $log.warn("[roomService] retrievePersonalAudioRoom - no room attached");\n            reject(new Error("[roomService] retrievePersonalAudioRoom - no room attached"));\n          }\n        })["catch"](function () {\n          $log.warn("[roomService] retrievePersonalAudioRoom - no room attached");\n          reject(new Error("[roomService] retrievePersonalAudioRoom - no room attached"));\n        });\n      }\n    });\n  };\n\n  service.getPersonalAudioRoomOpenInviteIdLink = function () {\n    return service.getOpenInviteIdLinkForRoom(service.personalAudioRoomId);\n  };\n\n  service.getOpenInviteIdLinkForRoom = function (roomId) {\n    if (service.openInviteIdByRoomId[roomId]) {\n      return service.openInviteIdByRoomId[roomId].openInviteLink;\n    }\n\n    return null;\n  };\n\n  service.getOpenInviteIdForRoom = function (roomId) {\n    if (service.openInviteIdByRoomId[roomId]) {\n      return service.openInviteIdByRoomId[roomId].openInviteId;\n    }\n\n    return null;\n  };\n\n  service.getName = function (room) {\n    return room.name;\n  };\n\n  service.sortByName = function (nameA, nameB) {\n    if (nameA && nameB && nameA.type === "string" && nameB.type === "string") {\n      if (nameA.value && nameB.value) {\n        return nameA.value.localeCompare(nameB.value);\n      }\n    }\n\n    return -1;\n  };\n\n  service.sortObjectByProperty = function (property_name) {\n    return function (a, b) {\n      if (a[property_name] < b[property_name]) {\n        return -1;\n      }\n\n      if (a[property_name] > b[property_name]) {\n        return 1;\n      }\n\n      return 0;\n    };\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/roomService.js?')},function(module,exports){eval('(function () {\n  "use strict";\n\n  angular.module("rainbow").service("groupService", ["$q", "$rootScope", "$log", "$http", "authService", "contactService", "xmppService", "Group", "usersService", "utilService", function ($q, $rootScope, $log, $http, authService, contactService, xmppService, Group, usersService, utilService) {\n    /*********************************************************************/\n\n    /** LIFECYCLE STUFF                                                 **/\n\n    /*********************************************************************/\n    var service = this;\n    this.started = false; // Events\n\n    service.ON_REMOVE_GROUP_USER_EVENT = "ON_REMOVE_GROUP_USER_EVENT"; // Triggered from XMPP + internal\n\n    service.ON_ADD_GROUP_USER_EVENT = "ON_ADD_GROUP_USER_EVENT"; // Triggered from XMPP\n\n    service.ON_GROUP_USERS_UPDATE_EVENT = "ON_GROUP_USERS_UPDATE_EVENT"; // Sent internal\n\n    service.ON_CREATED_GROUP_EVENT = "ON_CREATED_GROUP_EVENT"; // Triggered from XMPP (group created) \n\n    service.ON_UPDATE_GROUP_EVENT = "ON_UPDATE_GROUP_EVENT"; // Triggered from XMPP (group name/comment/Favorite updated) \n\n    service.ON_REMOVED_GROUP_EVENT = "ON_REMOVED_GROUP_EVENT"; // Triggered from XMPP (group removed) \n\n    this.start = function () {\n      $log.info("");\n      $log.info("[groupService] === STARTING ===");\n      service.portalURL = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + authService.userId + "/"; // Create the defered object\n\n      var defered = $q.defer();\n      service.$q = $q;\n      service.groups = null;\n\n      if (contactService.userContact.isCPaaSGuest()) {\n        // CPaas guest, no channels !\n        return defered.resolve();\n      } // Register to xmpp and call events\n\n\n      this.attachHandlers();\n      this.getGroups(); // Consider service as started\n\n      service.started = true;\n      $log.info("[groupService] === STARTED ===");\n      defered.resolve();\n      return defered.promise;\n    };\n\n    this.stop = function () {\n      $log.info("[groupService] === STOPPING ===");\n      service.conversations = null;\n      service.groups = null; // Remove all handlers\n\n      if (this.groupMessageHandlerRef) {\n        xmppService.deleteHandler(this.groupMessageHandlerRef);\n        this.groupMessageHandlerRef = null;\n      }\n\n      this.started = false;\n      $log.info("[groupService] === STOPPED ===");\n      return $q.when();\n    };\n    /*********************************************************************/\n\n    /** PUBLIC METHODS                                                  **/\n\n    /*********************************************************************/\n\n\n    this.getGroups = function () {\n      if (service.groups) {\n        return $q.when(service.groups);\n      }\n\n      return service.getRemoteGroups();\n    };\n    /**\n     * GET ALL GROUPS\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n\n\n    service.getGroupsAsArray = function () {\n      var groupsArray = [];\n\n      for (var key in service.groups) {\n        if (service.groups.hasOwnProperty(key)) {\n          groupsArray.push(service.groups[key]);\n        }\n      }\n\n      return groupsArray;\n    };\n\n    this.searchGroups = function (criteria) {\n      var queries = criteria.toLowerCase().trim().split(/[ ]+/);\n      return service.groups.filter(function (group) {\n        var names = group.name.toLowerCase().trim().split(/[ ]+/);\n        var match = queries.every(function (query) {\n          return names.some(function (name, index) {\n            if (name.length && utilService.removeDiacritis(name).indexOf(utilService.removeDiacritis(query)) === 0) {\n              names[index] = "";\n              group._displayName = utilService.removeDiacritis(group.name);\n              return true;\n            }\n\n            return false;\n          });\n        });\n        return match;\n      });\n    };\n\n    this.getRemoteGroups = function () {\n      $log.info("[groupService] getGroups");\n      var defered = $q.defer(); // Call the REST WebService\n\n      $http({\n        method: "GET",\n        url: service.portalURL + "groups?format=full",\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function successCallback(response) {\n        var data = response.data.data;\n        $log.info("[groupService] getGroups success (find " + response.data.total + " group(s))");\n        service.groups = [];\n        var usersPromises = [];\n        data.forEach(function (groupData) {\n          var group = Group.createFromData(groupData);\n          service.groups.push(group); // Add users to group\n\n          angular.forEach(groupData.users, function (user_id) {\n            usersPromises = contactService.getContactByDBId(user_id).then(function (contact) {\n              if (contact) {\n                group.users.push(contact);\n              }\n            });\n          });\n          service.logGroupUsers(group);\n          service.sortUsersInGroup(group);\n        });\n        return $q.all(usersPromises);\n      }, function errorCallback(response) {\n        var errorMessage = "getGroups" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      }).then(function () {\n        defered.resolve(service.groups);\n      });\n      return defered.promise;\n    };\n\n    var addGroupUserAct = function addGroupUserAct(group_id, user_id) {\n      return $q(function (resolve) {\n        var res = service.groups.some(function (group) {\n          if (group.id === group_id) {\n            //is user already in group\n            var result = group.users.some(function (user) {\n              if (user_id === user.dbId) {\n                // Update not requested\n                return true;\n              }\n\n              return false;\n            });\n\n            if (result) {\n              resolve(group);\n              $rootScope.$broadcast(service.ON_ADD_GROUP_USER_EVENT, group_id, user_id);\n              return true;\n            }\n\n            contactService.getContactByDBId(user_id).then(function (contact) {\n              group.users.push(contact);\n              service.sortUsersInGroup(group);\n              var Wgroups = [group];\n              contact.getGroups() ? contact.getGroups().push(group) : contact.setGroups(Wgroups);\n              $rootScope.$broadcast(service.ON_ADD_GROUP_USER_EVENT, group_id, user_id); //CR_#17526\n\n              resolve(group);\n            });\n            return true;\n          }\n\n          return false;\n        });\n\n        if (!res) {\n          $rootScope.$broadcast(service.ON_ADD_GROUP_USER_EVENT, group_id, user_id); //CR_#17526\n\n          resolve();\n        }\n      });\n    };\n\n    this.getGroup = function (group_id) {\n      $log.info("[groupService] getGroup  for " + group_id);\n      var defered = $q.defer();\n      var group = null; // Call the REST WebService\n\n      $http({\n        method: "GET",\n        url: service.portalURL + "groups/" + group_id,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function successCallback(response) {\n        var groupData = response.data.data;\n        var usersPromises = [];\n        group = Group.createFromData(groupData);\n        $log.info("[groupService] getGroup success for " + group.name + " : " + group.id);\n        var result = service.groups.some(function (item, index) {\n          if (item.id === groupData.id) {\n            service.groups[index] = group; //add users to group and update existing group \n\n            angular.forEach(groupData.users, function (user) {\n              usersPromises = contactService.getContactByDBId(user.id).then(function (contact) {\n                if (contact) {\n                  service.groups[index].users.push(contact);\n                  service.sortUsersInGroup(service.groups[index]);\n                }\n              });\n            });\n            return true;\n          }\n\n          return false;\n        });\n\n        if (!result) {\n          service.groups.push(group); // Add users to group\n\n          angular.forEach(groupData.users, function (user) {\n            usersPromises = contactService.getContactByDBId(user.id).then(function (contact) {\n              if (contact) {\n                group.users.push(contact);\n                service.sortUsersInGroup(group);\n                var Wgroups = [group];\n                contact.getGroups() ? contact.getGroups().push(group) : contact.setGroups(Wgroups);\n              }\n            });\n          });\n        }\n\n        return $q.all(usersPromises);\n      }, function errorCallback(response) {\n        var errorMessage = "getGroup" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      }).then(function () {\n        defered.resolve(group);\n      });\n      return defered.promise;\n    };\n\n    this.addGroup = function (group) {\n      $log.info("[groupService] addGroup : " + group.name);\n      var defered = $q.defer(); // Call the REST WebService\n\n      $http({\n        method: "POST",\n        url: service.portalURL + "groups",\n        headers: authService.getPostHeader(),\n        data: {\n          "name": group.name,\n          "comment": group.comment,\n          "isFavorite": group.isFavorite\n        }\n      }) // Handle success response\n      .then(function successCallback(response) {\n        $log.info("[groupService] addGroup success for : " + group.name);\n        var groupData = response.data.data;\n        var new_group = Group.createFromData(groupData);\n        /*service.groups.push(new_group);*/\n\n        defered.resolve(new_group);\n      }, function errorCallback(response) {\n        var errorMessage = "addGroup" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      });\n      return defered.promise;\n    };\n\n    var removeGroupAct = function removeGroupAct(group_id) {\n      angular.forEach(service.groups, function (group, index) {\n        if (group.id === group_id) {\n          service.groups.splice(index, 1);\n        }\n      });\n    };\n\n    this.removeGroup = function (group_id) {\n      $log.info("[groupService] removeGroup : " + group_id);\n      var defered = $q.defer(); // Call the REST WebService\n\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "groups/" + group_id,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function successCallback() {\n        $log.info("[groupService] removeGroup success for : " + group_id);\n        removeGroupAct(group_id);\n        defered.resolve();\n      }, function errorCallback(response) {\n        var errorMessage = "removeGroup" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      });\n      return defered.promise;\n    };\n\n    this.updateGroup = function (group) {\n      $log.info("[groupService] updateGroup for : " + group.name);\n      var defered = $q.defer(); // Call the REST WebService\n\n      $http({\n        method: "PUT",\n        url: service.portalURL + "groups/" + group.id,\n        headers: authService.getRequestHeader(),\n        data: {\n          "name": group.name,\n          "comment": group.comment,\n          "isFavorite": group.isFavorite\n        }\n      }) // Handle success response\n      .then(function successCallback() {\n        $log.info("[groupService] updateGroup success for : " + group.name);\n        defered.resolve();\n      }, function errorCallback(response) {\n        var error = service.handleErrorMessage(response, "updateGroup");\n        defered.reject(error);\n        $log.error("[groupService] " + error.message);\n      });\n      return defered.promise;\n    };\n\n    this.getGroupUsers = function (group_id) {\n      $log.info("[groupService] getGroupUsers : " + group_id);\n      var defered = $q.defer(); // Call the REST WebService\n\n      $http({\n        method: "GET",\n        url: service.portalURL + "groups/" + group_id + "/users",\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function successCallback(response) {\n        var data = response.data.data;\n        $log.info("[groupService] getGroupUsers success for " + group_id + " (find " + response.data.total + " users(s))");\n        defered.resolve(data.users);\n      }, function errorCallback(response) {\n        var errorMessage = "getGroupUsers" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      });\n      return defered.promise;\n    };\n\n    this.addGroupUser = function (group, user) {\n      $log.info("[groupService] addGroupUser");\n      var defered = service.$q.defer(); // Check if the contact is not already under group\n\n      var found = group.users.some(function (item) {\n        return user.dbId === item.dbId;\n      });\n\n      if (found) {\n        $log.info("[groupService] addGroupUser - user: " + user.id + " already exist in group: " + group.name + " - no remote action");\n        defered.resolve();\n        return;\n      } // Call the REST WebService\n\n\n      $http({\n        method: "POST",\n        url: service.portalURL + "groups/" + group.id + "/users/" + user.dbId,\n        headers: authService.getPostHeader()\n      }) // Handle success response\n      .then(function successCallback(response) {\n        $log.info("[groupService] addGroupUser success: " + user.id + "/" + group.name);\n        addGroupUserAct(group.id, user.dbId).then(function (updatedGroup) {\n          if (updatedGroup) {\n            defered.resolve(updatedGroup);\n          } else {\n            var groupData = response.data.data;\n            var newGroup = Group.createFromData(groupData);\n            defered.resolve(newGroup);\n          }\n        });\n        $rootScope.$broadcast(service.ON_GROUP_USERS_UPDATE_EVENT);\n      }, function errorCallback(response) {\n        var errorMessage = "addGroupUser" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      });\n      return defered.promise;\n    };\n\n    var removeGroupUserAct = function removeGroupUserAct(group_id, user_id) {\n      angular.forEach(service.groups, function (group) {\n        if (group.id === group_id) {\n          angular.forEach(group.users, function (user_item, index) {\n            if (user_item.dbId === user_id) {\n              group.users.splice(index, 1);\n\n              if (user_item.getGroups()) {\n                angular.forEach(user_item.getGroups(), function (user_group_item, g_index) {\n                  if (user_group_item.id === group_id) {\n                    user_item.getGroups().splice(g_index, 1);\n                  }\n                });\n              }\n            }\n          });\n          service.sortUsersInGroup(group);\n        }\n      });\n    };\n\n    this.getGroupById = function (group_id) {\n      var result = null;\n      angular.forEach(service.groups, function (group) {\n        if (group.id === group_id) {\n          result = group;\n        }\n      });\n      return result;\n    };\n\n    this.removeGroupUser = function (group_id, user) {\n      $log.info("[groupService] removeGroupUser : " + group_id + "/" + user.id);\n      var defered = $q.defer(); // Call the REST WebService\n\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "groups/" + group_id + "/users/" + user.dbId,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function successCallback() {\n        $log.info("[groupService] removeGroupUser success : " + group_id + "/" + user.id);\n        removeGroupUserAct(group_id, user.dbId);\n        var group = service.getGroupById(group_id);\n        $rootScope.$broadcast(service.ON_GROUP_USERS_UPDATE_EVENT);\n        defered.resolve(group);\n      }, function errorCallback(response) {\n        var errorMessage = "removeGroupUser" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      });\n      return defered.promise;\n    };\n\n    this.getUserGroups = function (user) {\n      if (!user) {\n        $log.info("[groupService] getUserGroups for unknown user !");\n        return $q.when();\n      }\n\n      $log.info("[groupService] getUserGroups for user : " + user.id);\n      var defered = $q.defer(); //Neutralize until solution of pb "groups for user not in roster not updated"\n\n      var userGroups = user.getGroups();\n\n      if (userGroups) {\n        return $q.when(userGroups);\n      } //\n      // Call the REST WebService\n\n\n      $http({\n        method: "GET",\n        url: service.portalURL + "groups?userId=" + user.dbId,\n        headers: authService.getRequestHeader()\n      }) // Handle success response\n      .then(function successCallback(response) {\n        var data = response.data.data;\n        $log.info("[groupService] getUserGroups success (find " + response.data.total + " group(s))");\n        var groups = [];\n        data.forEach(function (groupData) {\n          var group = Group.createFromData(groupData);\n          groups.push(group);\n        });\n        user.setGroups(groups);\n        service.logUserGroups(user.displayNameForLog(), groups);\n        defered.resolve(groups);\n      }, function errorCallback(response) {\n        var errorMessage = "getUserGroups" + service.handleErrorMessage(response);\n        defered.reject(new Error(errorMessage));\n        $log.error("[groupService] " + errorMessage);\n      });\n      return defered.promise;\n    };\n\n    this.getGroupFromName = function (group_name) {\n      $log.info("[groupService] getGroupFromName : " + group_name);\n      var defered = $q.defer();\n      this.getGroups().then(function successCallback(groups) {\n        var group = null;\n        groups.forEach(function (item) {\n          if (item.name === group_name) {\n            group = item;\n          }\n        });\n        defered.resolve(group);\n      });\n      return defered.promise;\n    };\n\n    this.sortUsersInGroup = function (group) {\n      if (group) {\n        group.sortedUserList = usersService.getFilterAndOrderUsersGroupedByOrderLabelAndUpdateActivity(group.users, $rootScope.orderType, $rootScope.filterType, true);\n      }\n    };\n\n    this.searchLocalGroup = function (searchText) {\n      var groupNamesMatches = [];\n      $log.info("[groupService] searchLocalGroup with text " + searchText);\n\n      if (searchText) {\n        service.groups.forEach(function (gr) {\n          if (gr.name.toLowerCase().indexOf(searchText.toLowerCase().toString()) >= 0) {\n            groupNamesMatches.push(gr);\n          }\n        });\n      }\n\n      return groupNamesMatches;\n    };\n\n    this.extractStanzaData = function (stanza) {\n      var defered = $q.defer(); // Extract message sender info\n\n      var stanzaData = {};\n      stanzaData.outgoingMessage = false;\n      stanzaData.body = angular.element(stanza)[0].firstChild;\n      stanzaData.messageId = angular.element(stanza).attr("id");\n      defered.resolve(stanzaData);\n      return defered.promise;\n    };\n\n    this.onGroupMessageReceived = function (stanza) {\n      try {\n        this.extractStanzaData(stanza).then(function (stanzaData) {\n          if (stanzaData.body) {\n            if (stanzaData.body.tagName === "group") {\n              var action = stanzaData.body.getAttribute("action");\n              var scope = stanzaData.body.getAttribute("scope");\n              var group_id = stanzaData.body.getAttribute("id");\n\n              switch (scope) {\n                case "group":\n                  {\n                    switch (action) {\n                      case "create":\n                        service.getGroup(group_id);\n                        $rootScope.$broadcast(service.ON_CREATED_GROUP_EVENT, group_id);\n                        break;\n\n                      case "update":\n                        var name = stanzaData.body.getAttribute("name");\n                        var comment = stanzaData.body.getAttribute("comment");\n                        var isFavorite = stanzaData.body.getAttribute("isFavorite") === "true";\n                        $rootScope.$broadcast(service.ON_UPDATE_GROUP_EVENT, group_id, name, comment, isFavorite);\n                        break;\n\n                      case "delete":\n                        removeGroupAct(group_id);\n                        $rootScope.$broadcast(service.ON_REMOVED_GROUP_EVENT, group_id);\n                        break;\n\n                      default:\n                        break;\n                    }\n                  }\n                  break;\n\n                case "user":\n                  {\n                    var user_id = stanzaData.body.getAttribute("userId");\n\n                    switch (action) {\n                      case "create":\n                        addGroupUserAct(group_id, user_id);\n                        break;\n\n                      case "delete":\n                        removeGroupUserAct(group_id, user_id);\n                        $rootScope.$broadcast(service.ON_REMOVE_GROUP_USER_EVENT, group_id, user_id); //CR_#17526\n\n                        break;\n\n                      default:\n                        break;\n                    }\n                  }\n                  break;\n\n                default:\n                  break;\n              }\n            }\n          }\n        });\n        return true;\n      } catch (error) {\n        return true;\n      }\n    };\n\n    this.attachHandlers = function () {\n      service.removeHandlers(); // Attach messages handler\t\t\t\n\n      if (!service.groupMessageHandlerRef) {\n        service.groupMessageHandlerRef = xmppService.addHandler(function (stanza) {\n          return service.onGroupMessageReceived(stanza);\n        }, null, "message", "management");\n      }\n    };\n\n    this.removeHandlers = function () {\n      //remove all handlers\n      if (service.groupMessageHandlerRef) {\n        xmppService.deleteHandler(service.groupMessageHandlerRef);\n        service.groupMessageHandlerRef = null;\n      }\n    };\n\n    this.handleBadRequest = function (message, response) {\n      if (response.status === 400) {\n        if (response.data.errorDetails && response.data.errorDetails.length > 0) {\n          var fieldErrors = {};\n          response.data.errorDetails.forEach(function (details) {\n            fieldErrors[details.param] = details.msg;\n          });\n          var error = new Error(message + " failure: BadRequest");\n          error.fieldErrors = fieldErrors;\n          return error;\n        }\n      }\n\n      return null;\n    };\n\n    this.handleErrorMessage = function (response) {\n      var errorMessage = " failure: ";\n\n      if (response.status === 500) {\n        errorMessage += "Internal server error";\n      }\n\n      if (response.status === 403) {\n        errorMessage += "Access is forbidden for the current user";\n      } else if (response.status === 404) {\n        errorMessage += response.data.errorMsg;\n      } else if (response.data && response.data.errorDetails) {\n        errorMessage += response.data.errorDetails;\n      }\n\n      return errorMessage;\n    };\n\n    this.logUserGroups = function (ownername, groups) {\n      var groupsNameContent = "";\n\n      if (!groups || groups.length === 0) {\n        return;\n      }\n\n      groups.forEach(function (gr) {\n        if (gr.name) {\n          groupsNameContent += " " + gr.name;\n        }\n      });\n      $log.info("[groupService] logUserGroups for " + ownername + ":" + groupsNameContent);\n    };\n\n    this.logGroupUsers = function (group) {\n      var UserNameContent = "";\n\n      if (!group || !group.users || group.users.length === 0) {\n        return;\n      }\n\n      UserNameContent = group.users.map(function (user) {\n        return user.displayNameForLog();\n      }).join(" / ");\n      $log.info("[groupService] logGroupUsers for " + group.name + ": " + UserNameContent);\n    };\n  }]);\n})();\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/groupService.js?')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst call_model_1 = __webpack_require__(0);\n/**\n * @ngdoc service\n * @module rainbow\n * @name WebrtcGatewayService\n * @requires $q\n * @requires $rootScope\n * @requires $log\n * @requires $http\n * @requires authService\n * @requires $interval\n * @requires xmppService\n * @requires videoService\n * @description Rainbow WebrtcGatewayService provides Media Pillar services\n */\n/// <reference path="../serviceInterface.ts" />\n/// <reference path="../../models/common/httpResult.ts" />\nconst TO_PILLAR_POLLING_MIN = 300000;\nconst TO_PILLAR_POLLING_MAX = 900000;\nconst TO_PILLAR_POLLING_STEP = TO_PILLAR_POLLING_MAX / 500;\nvar MPCallState;\n(function (MPCallState) {\n    MPCallState[MPCallState["Unknow"] = 0] = "Unknow";\n    MPCallState[MPCallState["Free"] = 1] = "Free";\n    MPCallState[MPCallState["WaitWebrtc"] = 2] = "WaitWebrtc";\n    MPCallState[MPCallState["WaitTelephony"] = 3] = "WaitTelephony";\n    MPCallState[MPCallState["CallOffer"] = 4] = "CallOffer";\n    MPCallState[MPCallState["CallOnGoing"] = 5] = "CallOnGoing";\n    MPCallState[MPCallState["CallActive"] = 6] = "CallActive";\n    MPCallState[MPCallState["CallActiveNoWebMedia"] = 7] = "CallActiveNoWebMedia";\n    MPCallState[MPCallState["TelCallReleasing"] = 8] = "TelCallReleasing";\n    MPCallState[MPCallState["WebCallReleasing"] = 9] = "WebCallReleasing";\n    MPCallState[MPCallState["RemoteControled"] = 10] = "RemoteControled";\n    MPCallState[MPCallState["AnomalyCCS"] = 11] = "AnomalyCCS";\n})(MPCallState || (MPCallState = {}));\n;\nclass WebrtcGatewayService {\n    /************************************************************/\n    /** LIFECYCLE STUFF                                        **/\n    /************************************************************/\n    constructor($q, $rootScope, $log, $http, authService, $interval, xmppService, videoService, errorHelperService, contactService, profileService, uuid4, telephonyService, settingsService) {\n        this.$q = $q;\n        this.$rootScope = $rootScope;\n        this.$log = $log;\n        this.$http = $http;\n        this.authService = authService;\n        this.$interval = $interval;\n        this.xmppService = xmppService;\n        this.videoService = videoService;\n        this.errorHelperService = errorHelperService;\n        this.contactService = contactService;\n        this.profileService = profileService;\n        this.uuid4 = uuid4;\n        this.telephonyService = telephonyService;\n        this.settingsService = settingsService;\n        this.started = false;\n        this.listeners = [];\n        this.myContact = null;\n        this.mediaPillarContact = null; // 1PCC CPaaS\n        this.mediaPillarConfigured = false;\n        this.mediaPillarAlive = false;\n        this.mediaPillarJid = "";\n        this.evtQueue = [];\n        this.SEM = 0;\n        this.fakeMediaPillarJid = "00a241586a984a869c73719007b27921@demo-all-in-one-dev-1.opentouch.cloud";\n        this.TO_transition = 15000; //Time Out transition for debug set to 3600000 //CRRAINB-3271 pass from 10s to 15s\n        this.TO_transition_long = 30000; //Time Out transition for long case //CRRAINB-3271\n        this.TO_NoWebMedia = 60000; //Time Out for webmedia lost 1mn //CRRAINB-3500\n        this.TO_NoWebMediaNotel = 5000; //Time Out for webmedia lost 5s //CRRAINB-6895    \n        this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN; //Polling timer \n        this.mediaPillarKeepAliveSuspend = false; //Polling trigger CRRAINB-3757\n    }\n    start(stats) {\n        let startDate = performance.now();\n        this.mediaPillarConfigured = false;\n        this.mediaPillarAlive = false;\n        this.portalURL = config.restServerUrl + "/api/rainbow/mediapillar/v1.0/mediapillars";\n        this.myContact = this.contactService.userContact;\n        this.mediaPillarContact = null; // 1PCC CPaaS\n        this.mediaPillarCallContext = {\n            callState: MPCallState.Free,\n            keepAlive_TO: null,\n            callState_TO: null,\n            isOutgoingCall3PCC: false,\n            telephonyCallRefs: [],\n            webrtcCallRef: null,\n            mediaPillarJid: "",\n            rainbowPhoneNumber: "",\n            remoteExtension: "",\n            previousCallConnectionId: null,\n            previousCallStatus: null,\n            updateContactFlag: false\n        };\n        // Start the service only if the media pillar feature is available\n        if (this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.TELEPHONY_WEBRTC_PSTN_CALLING)) {\n            this.$log.info("[WebrtcGatewayService] === STARTING ===");\n            this.started = true;\n            this.SEM = 0;\n            this.resetEvtAutomaton();\n            // Get the mediaPillar JID\n            this.getMediaPillarData()\n                .then((mediaPillarJid) => {\n                this.mediaPillarContact = this.createMediaPillarContact(mediaPillarJid); // 1PCC CPaaS\n                this.mediaPillarCallContext.mediaPillarJid = mediaPillarJid;\n                this.$log.info("[WebrtcGatewayService] Pillar remoteExtension used : " + this.mediaPillarCallContext.remoteExtension);\n                if (this.mediaPillarCallContext.remoteExtension !== "") {\n                    this.mediaPillarConfigured = true;\n                }\n                else {\n                    this.$log.warn("[WebrtcGatewayService] no remoteExtention available ");\n                    this.mediaPillarConfigured = false;\n                }\n                //temporary : pseudo register ++\n                if (this.mediaPillarConfigured) {\n                    this.dummyRegisterMediaPillarCall()\n                        .then(() => {\n                        this.mediaPillarAlive = true;\n                        this.$log.info("[WebrtcGatewayService] Pseudo media pillar register OK with extension " + this.mediaPillarCallContext.remoteExtension);\n                        this.$rootScope.$broadcast("ON_WEBRTCGATEWAY_STATE_CHG", this.mediaPillarAlive);\n                    })\n                        .catch((error) => {\n                        this.mediaPillarAlive = false;\n                        this.$log.info("[WebrtcGatewayService] Pseudo media pillar register KO");\n                        this.$log.info("[WebrtcGatewayService] Initial polling activated on starting issue");\n                        this.mediaPillarKeepAlivePolling("START", TO_PILLAR_POLLING_MIN);\n                        this.$rootScope.$broadcast("ON_WEBRTCGATEWAY_STATE_CHG", this.mediaPillarAlive);\n                    });\n                }\n                //temporary : pseudo register --\n                //CRRAINB-3757 subscribe to xmpp ON_CONNECTION_STATE_CHANGE_EVENT\n                this.listeners.push(this.$rootScope.$on("ON_CONNECTION_STATE_CHANGE_EVENT", (event, status) => {\n                    if (status === "disconnected") {\n                        this.$log.info("[WebrtcGatewayService] onConnectionStateChangeEvent : disconnected then MP keepalive suspended");\n                        this.mediaPillarKeepAliveSuspend = true;\n                    }\n                    else if (status === "connected") {\n                        this.$log.info("[WebrtcGatewayService] onConnectionStateChangeEvent : connected then keepalive as necessary");\n                        this.mediaPillarKeepAliveSuspend = false;\n                        this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN; //switch to MIn keepalive polling\n                    }\n                }));\n                // Subscribe to call events\n                this.listeners.push(this.$rootScope.$on("ON_CALL_UPDATED_EVENT", (event, call, infoEvt) => { this.onCallEvent(event, call, infoEvt); }));\n                // Subscribe to call remotly controlled event (controled by another ressource)\n                this.listeners.push(this.$rootScope.$on("ON_MEDIAPILLAR_CALL_REMOTE_CTRL_EVENT", (event, call) => { this.onRemoteCtrlCall(event, call); }));\n                var startDuration = Math.round(performance.now() - startDate);\n                stats.push({ service: "WebrtcGatewayService", startDuration: startDuration });\n                this.$log.info("[WebrtcGatewayService] === STARTED (" + startDuration + " ms) ===");\n            })\n                .catch((error) => {\n                this.mediaPillarCallContext.mediaPillarJid = "";\n                this.mediaPillarCallContext.rainbowPhoneNumber = "";\n                this.mediaPillarCallContext.remoteExtension = "";\n                this.mediaPillarConfigured = false;\n                this.mediaPillarAlive = false;\n                this.$log.info("[WebrtcGatewayService] === STARTING FAILURE === " + error.message);\n            });\n        }\n        else {\n            this.$log.info("[WebrtcGatewayService] === NO WEBRTCGATEWAY ENVOLVED === ");\n        }\n        return this.$q.when();\n    }\n    stop() {\n        this.$log.info("[WebrtcGatewayService] === STOPPING ===");\n        this.started = false;\n        this.mediaPillarConfigured = false;\n        this.mediaPillarAlive = false;\n        this.mediaPillarKeepAlivePolling("STOP", 0);\n        // If previous service fails to start, no object and stop services is called\n        if (this.mediaPillarCallContext) {\n            this.releaseMediaPillarCallContext();\n            this.mediaPillarCallContext.callState = MPCallState.Unknow;\n            this.mediaPillarCallContext.mediaPillarJid = "";\n            this.mediaPillarCallContext.rainbowPhoneNumber = "";\n            this.mediaPillarCallContext.remoteExtension = "";\n        }\n        // Unregister event listeners\n        if (this.listeners) {\n            this.listeners.forEach((unregisterListener) => { unregisterListener(); });\n        }\n        this.$log.info("[WebrtcGatewayService] === STOPPED ===");\n        return this.$q.resolve();\n    }\n    /**************************************************************/\n    /** CALL EVENT HANDLER                                       **/\n    /**************************************************************/\n    /**\n      * Method onCallEvent\n      * @private\n      * @memberof WebrtcGatewayService\n      * Manage call events (but only if media pillar situation)\n      */\n    onCallEvent(__event, call, infoEvt) {\n        if (this.isMediaPillarCallCase()) {\n            this.SEM++;\n            this.$log.info("[WebrtcGatewayService] onCallEvent IN(" + this.SEM + ") state = " + this.mediaPillarCallContext.callState);\n            this.$log.info("[WebrtcGatewayService] onCallEvent " + this.mediaPillarCallContext.callState + " --- " + call.type.value + "(" + call.id + "," + call.status.value + ")");\n            //CRRAINB-5710++\n            if (infoEvt && infoEvt !== null) {\n                this.$log.info("[WebrtcGatewayService] onCallEvent tel infoEvt : Evt = " + infoEvt.actionElemName + " / cause = " + infoEvt.cause);\n                //CRRAINB-5196++\n                if (infoEvt.actionElemName === "updatecall") {\n                    this.mediaPillarCallContext.updateContactFlag = true;\n                    this.$log.info("[WebrtcGatewayService] updateContactFlag = true");\n                } //CRRAINB-5196--\n            } //CRRAINB-5710--\n            //debounce filter (to avoid double evt on same call id) //CRRAINB-5710=>do not debounce when updatecall\n            if (call.connectionId === this.mediaPillarCallContext.previousCallConnectionId && call.status === this.mediaPillarCallContext.previousCallStatus && !this.mediaPillarCallContext.updateContactFlag) {\n                this.mediaPillarCallContext.previousCallConnectionId = call.connectionId;\n                this.mediaPillarCallContext.previousCallStatus = call.status;\n                this.$log.info("[WebrtcGatewayService] onCallEvent | DEBOUNCE EVT");\n                this.SEM--;\n                this.$log.info("[WebrtcGatewayService] onCallEvent OUT(" + this.SEM + ")");\n                return;\n            }\n            //filter phone call null (error case)\n            if (call.type.value === call_model_1.Call.Type.PHONE.value && call.id === null) {\n                this.mediaPillarCallContext.previousCallConnectionId = call.connectionId;\n                this.mediaPillarCallContext.previousCallStatus = call.status;\n                this.$log.info("[WebrtcGatewayService] onCallEvent | FILTER EVT null/error");\n                this.SEM--;\n                this.$log.info("[WebrtcGatewayService] onCallEvent OUT(" + this.SEM + ")");\n                return;\n            }\n            this.mediaPillarCallContext.previousCallConnectionId = call.connectionId;\n            this.mediaPillarCallContext.previousCallStatus = call.status;\n            this.evtQueue.push(call); //push in eventing queue\n            if (this.evtQueue.length > 1) { //Meaning reentrancy case\n                this.SEM--;\n                this.$log.info("[WebrtcGatewayService] onCallEvent OUT(" + this.SEM + ") evt pushed = " + call.status.value);\n                return;\n            }\n            while (this.evtQueue.length) {\n                try {\n                    this.processEvt(this.evtQueue[0]);\n                }\n                catch (error) {\n                    this.$log.error("[WebrtcGatewayService] onCallEvent queue processing | call : " + this.evtQueue[0].status.value + " Error : " + error);\n                }\n                this.evtQueue.splice(0, 1);\n            }\n            this.SEM--;\n            this.$log.info("[WebrtcGatewayService] onCallEvent OUT(" + this.SEM + ") state = " + this.mediaPillarCallContext.callState);\n            if (this.SEM !== 0) {\n                this.$log.error("[WebrtcGatewayService] onCallEvent OUT | Unmanaged Eventing Reentrancy Situation");\n                this.resetEvtAutomaton();\n                this.SEM = 0;\n            }\n        }\n    }\n    ;\n    /**\n      * Method processEvt\n      * @private\n      * @param {object} Call call evt\n      * @memberof WebrtcGatewayService\n      * Event processing\n      */\n    processEvt(call) {\n        this.$log.info("[WebrtcGatewayService] processEvt | process " + call.type.value + "(" + call.id + "," + call.status.value + ") in MPcontextCallstate = " + this.mediaPillarCallContext.callState);\n        if (call.type.value === call_model_1.Call.Type.PHONE.value) {\n            // Tel case\n            //From mediaPillar automat point of view only the 1st(resp last) tel call ref is relevant\n            //All evt associated to 2nd or nth telcall situation are ignored except the releases active incomming queued\n            var telCallsNumber = this.telephonyService.getCalls().length;\n            let evtToBeIgnored = (() => {\n                let ignoreEvt = false;\n                //NEW_MP1++\n                if (call.status === call_model_1.Call.Status.DIALING) {\n                    call.isSecondary = true;\n                }\n                if (!call.isSecondary) {\n                    this.$log.info("[WebrtcGatewayService] processEvt | NOT SECONDARY then ignore");\n                    ignoreEvt = true;\n                    return ignoreEvt;\n                }\n                //NEW_MP1--\n                //NEW_MP2++\n                if (call.status === call_model_1.Call.Status.UNKNOWN ||\n                    call.status === call_model_1.Call.Status.RINGING_INCOMMING ||\n                    call.status === call_model_1.Call.Status.QUEUED_INCOMMING ||\n                    call.status === call_model_1.Call.Status.ACTIVE) {\n                    this.addTelCallRefs(call); //add this telcallref in telephonyCallRefs                         \n                    ignoreEvt = false; //when secondary never ignore those cases \n                    return ignoreEvt;\n                }\n                if (this.mediaPillarCallContext.callState === MPCallState.RemoteControled) {\n                    this.$log.info("[WebrtcGatewayService] processEvt |  RemoteControled state for call : " + call.id + " then ignore");\n                    ignoreEvt = true; //ignore remote situation\n                    return ignoreEvt;\n                }\n                //check if it is 2nd or nth call situation //NEW_MP1\n                this.addTelCallRefs(call); //Before checking, add this telcallref in telephonyCallRefs               \n                if (this.mediaPillarCallContext.telephonyCallRefs.length > 1) {\n                    this.$log.info("[WebrtcGatewayService] processEvt |  nthCall : " + this.mediaPillarCallContext.telephonyCallRefs.length + " then ignore");\n                    ignoreEvt = true; //ignore 2nd/nth call\n                    return ignoreEvt;\n                }\n                return ignoreEvt;\n                //NEW_MP2--\n            })();\n            if (!evtToBeIgnored) { //process only the not ignored evt\n                //this.addTelCallRefs(call); // systematically add this telcallref in telephonyCallRefs //NEW_MP2\n                this.$log.info("[WebrtcGatewayService] processEvt |  call(" + call.id + " / SEC " + call.isSecondary + ", " + call.status.value + ") -> EVT PROCESSED");\n                this.$log.info("[WebrtcGatewayService] processEvt |  telephonyCallRefs.length = " + this.mediaPillarCallContext.telephonyCallRefs.length);\n                this.$log.info("[WebrtcGatewayService] processEvt |  calls.length = " + telCallsNumber);\n                switch (call.status) {\n                    case call_model_1.Call.Status.RINGING_INCOMMING:\n                        this.onTelCallIncomming(call);\n                        break;\n                    case call_model_1.Call.Status.DIALING:\n                        this.onTelCallDialling(call);\n                        break;\n                    case call_model_1.Call.Status.RINGING_OUTGOING:\n                        this.onTelCallOutgoing(call);\n                        break;\n                    case call_model_1.Call.Status.ACTIVE:\n                        this.onTelCallActive(call);\n                        break;\n                    case call_model_1.Call.Status.UNKNOWN:\n                        this.onTelCallReleasing(call);\n                        break;\n                    default: break;\n                }\n            }\n            else { // ignored evt\n                this.$log.info("[WebrtcGatewayService] processEvt |  call(" + call.id + " / SEC " + call.isSecondary + ", " + call.status.value + ") -> EVT IGNORED");\n                this.$log.info("[WebrtcGatewayService] processEvt |  telephonyCallRefs.length = " + this.mediaPillarCallContext.telephonyCallRefs.length);\n                this.$log.info("[WebrtcGatewayService] processEvt |  calls.length = " + telCallsNumber);\n            }\n        }\n        // Webrtc case\n        else if (this.isMediaPillarJid(this.xmppService.getBareJidFromJid(call.fullJid))) {\n            switch (call.status) {\n                case call_model_1.Call.Status.RINGING_INCOMMING:\n                    this.onWebrtcCallIncomming(call);\n                    break;\n                case call_model_1.Call.Status.CONNECTING:\n                    this.onWebrtcCallConnecting(call);\n                    break;\n                case call_model_1.Call.Status.ACTIVE:\n                    this.onWebrtcCallActive(call);\n                    break;\n                case call_model_1.Call.Status.ANSWERING:\n                    this.onWebrtcCallAnswering(call);\n                    break;\n                case call_model_1.Call.Status.UNKNOWN:\n                    this.onWebrtcCallReleasing(call);\n                    break;\n                default: break;\n            }\n        }\n        else {\n            this.$log.info("[WebrtcGatewayService] processEvt | process call(" + call.id + "," + call.status.value + ")" + " -> Not a webrtcgateway case");\n        }\n    }\n    ;\n    /**\n      * Method releaseMediaPillarCallContext\n      * @public\n      * @memberof WebrtcGatewayService\n      * Allow to free the media pillar call context (all field except mediaPillarJid)\n      * but do not check the associated calls (tel and webrtc)\n      */\n    releaseMediaPillarCallContext() {\n        this.mediaPillarCallContext.callState = MPCallState.Free;\n        this.stopCallStateTimeOut();\n        this.mediaPillarCallContext.isOutgoingCall3PCC = false;\n        this.mediaPillarCallContext.updateContactFlag = false; //CCRAINB-4634\n        if (this.mediaPillarCallContext.telephonyCallRefs.length > 0) {\n            this.$log.warn("[WebrtcGatewayService] releaseMediaPillarCallContext | reset context but telephonyCallRefs not empty !");\n        }\n        if (this.mediaPillarCallContext.webrtcCallRef !== null) {\n            this.$log.warn("[WebrtcGatewayService] releaseMediaPillarCallContext | reset context but webrtcCallRef not null !");\n        }\n        this.mediaPillarCallContext.telephonyCallRefs = [];\n        this.mediaPillarCallContext.webrtcCallRef = null;\n        this.mediaPillarCallContext.previousCallConnectionId = null;\n        this.mediaPillarCallContext.previousCallStatus = "";\n        this.$log.log("[WebrtcGatewayService] releaseMediaPillarCallContext | =====  mediaPillarCallContext RELEASED  ===== ");\n    }\n    ;\n    /**\n      * Method resetEvtAutomaton\n      * @public\n      * @memberof WebrtcGatewayService\n      * Allow to reset the eventing automaton\n      * linked to onCallEvent\n      */\n    resetEvtAutomaton() {\n        this.evtQueue = [];\n    }\n    ;\n    /**\n       * Method stopCallStateTimeOut\n       * @private\n       * @memberof WebrtcGatewayService\n       *\n       */\n    stopCallStateTimeOut() {\n        if (this.mediaPillarCallContext.callState_TO) {\n            this.$interval.cancel(this.mediaPillarCallContext.callState_TO);\n        }\n        this.mediaPillarCallContext.callState_TO = null;\n    }\n    ;\n    /**\n       * Method onRemoteCtrlCall\n       * @private\n       * @memberof WebrtcGatewayService\n       * Traitment of multi ressources case when other ressource manage the call\n       */\n    onRemoteCtrlCall(__event, call) {\n        this.$log.info("[WebrtcGatewayService] onRemoteCtrlCall for call " + call.id + " in previous state: " + this.mediaPillarCallContext.callState + ": => Becomes REMOTECONTROLED");\n        this.mediaPillarCallContext.callState = MPCallState.RemoteControled;\n        this.stopCallStateTimeOut();\n    }\n    ;\n    /**\n       * Method addTelCallRefs\n       * @private\n       * @memberof WebrtcGatewayService\n       * add/push telcall ref in telephonyCallRefs if not already in\n       */\n    addTelCallRefs(callRef) {\n        //Warning basic implementation with indexOf doesn\'t suit!\n        if (typeof (callRef) === "undefined" || callRef === null) {\n            this.$log.warn("[WebrtcGatewayService] addTelCallRefs | ANOMALY callRef not valid");\n            return;\n        }\n        let alreadyIn = false;\n        for (var i = 0; i < this.mediaPillarCallContext.telephonyCallRefs.length; i++) {\n            if (this.mediaPillarCallContext.telephonyCallRefs.length && (this.mediaPillarCallContext.telephonyCallRefs[i].id === callRef.id)) {\n                alreadyIn = true;\n            }\n        }\n        if (!alreadyIn) {\n            this.mediaPillarCallContext.telephonyCallRefs.push(callRef);\n        }\n    }\n    ;\n    /**\n       * Method removeTelCallRefs\n       * @private\n       * @memberof WebrtcGatewayService\n       * remove telcall ref in telephonyCallRefs\n       */\n    removeTelCallRefs(callRef) {\n        //Warning basic implementation with indexOf doesn\'t suit!\n        if (typeof (callRef) === "undefined" || callRef === null) {\n            this.$log.warn("[WebrtcGatewayService] removeTelCallRefs | ANOMALY callRef not valid");\n            return;\n        }\n        let i = 0;\n        while (i < this.mediaPillarCallContext.telephonyCallRefs.length) {\n            if (this.mediaPillarCallContext.telephonyCallRefs[i].id === callRef.id) {\n                this.mediaPillarCallContext.telephonyCallRefs.splice(i, 1);\n                if (i === 0 && this.mediaPillarCallContext.telephonyCallRefs.length) {\n                    this.mediaPillarCallContext.telephonyCallRefs[0].setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context\n                    this.$log.log("[WebrtcGatewayService] removeTelCallRefs | master MP call becomes : " + this.mediaPillarCallContext.telephonyCallRefs[0].id);\n                }\n            }\n            else {\n                i++;\n            }\n        }\n    }\n    ;\n    /**\n       * Method putAsMasterTelCallRefs\n       * @private\n       * @memberof WebrtcGatewayService\n       * The telephonyCallRefs[0] is intended to be the main telcall ref\n       * usually the one which was handled as 1st to mediaPillaryse the call\n       */\n    putAsMasterTelCallRefs(callRef) {\n        //Warning basic implementation with indexOf doesn\'t suit!\n        if (typeof (callRef) === "undefined" || callRef === null) {\n            this.$log.warn("[WebrtcGatewayService] putAsMasterTelCallRefs | ANOMALY callRef not valid");\n            return;\n        }\n        let i = -1;\n        for (var j = 0; j < this.mediaPillarCallContext.telephonyCallRefs.length; j++) {\n            if (this.mediaPillarCallContext.telephonyCallRefs[j].id === callRef.id) {\n                i = j;\n            }\n        }\n        this.$log.log("[WebrtcGatewayService] putAsMasterTelCallRefs | master MP call is : " + callRef.id);\n        if (i === 0) {\n            return;\n        } //already done\n        if (i !== -1) {\n            let replace = this.mediaPillarCallContext.telephonyCallRefs[0]; //current [0] value\n            this.mediaPillarCallContext.telephonyCallRefs[0] = callRef;\n            this.mediaPillarCallContext.telephonyCallRefs[i] = replace;\n            callRef.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context            \n        }\n        else {\n            this.$log.warn("[WebrtcGatewayService] putAsMasterTelCallRefs | Anomaly call not in telephonyCallRefs");\n        }\n    }\n    ;\n    /**\n       * Method isMasterTelCallRefs\n       * @public\n       * @memberof WebrtcGatewayService\n       * return true if callRef is the master telcallref\n       */\n    isMasterTelCallRefs(callRef) {\n        if (typeof (callRef) === "undefined" || callRef === null) {\n            this.$log.warn("[WebrtcGatewayService] isMasterTelCallRefs | ANOMALY callRef not valid");\n            return false;\n        }\n        if (this.mediaPillarCallContext.telephonyCallRefs.length === 0) {\n            return false;\n        }\n        return (this.mediaPillarCallContext.telephonyCallRefs[0].id === callRef.id);\n    }\n    ;\n    /**\n        * Method isInTelCallRefs\n        * @private\n        * @memberof WebrtcGatewayService\n        * return true if callRef is in telephonyCallRefs\n        */\n    isInTelCallRefs(callRef) {\n        //return (this.mediaPillarCallContext.telephonyCallRefs.indexOf(callRef) !== -1);\n        //Warning basic implementation with indexOf doesn\'t suit!\n        if (typeof (callRef) === "undefined" || callRef === null) {\n            this.$log.warn("[WebrtcGatewayService] isInTelCallRefs | ANOMALY callRef not valid");\n            return;\n        }\n        let i = -1;\n        for (var j = 0; j < this.mediaPillarCallContext.telephonyCallRefs.length; j++) {\n            if (this.mediaPillarCallContext.telephonyCallRefs[j].id === callRef.id) {\n                i = j;\n            }\n        }\n        return (i !== -1);\n    }\n    ;\n    /**\n    * Method replaceCallRefs\n    * @private\n    * @memberof WebrtcGatewayService\n    *  replace one callref with another\n    */\n    replaceCallRefs(newCallRef, oldCallRef) {\n        if (typeof (newCallRef) === "undefined" || newCallRef === null || typeof (oldCallRef) === "undefined" || oldCallRef === null) {\n            this.$log.warn("[WebrtcGatewayService] replaceCallRefs | ANOMALY callRef not valid");\n            return;\n        }\n        //before to replace oldCallRef check if newCallRef not already existing\n        let flagNewAlreadyExist = false;\n        let flagNewLinked = newCallRef.isMediaPillarCall();\n        let flagOldLinked = oldCallRef.isMediaPillarCall();\n        if (this.isInTelCallRefs(newCallRef)) { //if existing remove it !!!!\n            flagNewAlreadyExist = true;\n            this.$log.warn("[WebrtcGatewayService] replaceCallRefs | ANOMALY newcallRef already existing");\n            this.removeTelCallRefs(newCallRef);\n        }\n        let i = -1;\n        //Warning basic implementation with indexOf doesn\'t suit!\n        for (var j = 0; j < this.mediaPillarCallContext.telephonyCallRefs.length; j++) {\n            if (this.mediaPillarCallContext.telephonyCallRefs[j].id === oldCallRef.id) {\n                i = j;\n            }\n        }\n        if (i !== -1) { //oldCallRef found then replace\n            this.mediaPillarCallContext.telephonyCallRefs[i] = newCallRef;\n            if (flagOldLinked) { //replicate the former link situation\n                newCallRef.setMediaPillarCall(this.getMediaPillarCallContext()); //link the newcall to MP context\n            }\n            oldCallRef.setMediaPillarCall(null); //remove link from old callref to MP context \n            if (i === 0) {\n                this.$log.log("[WebrtcGatewayService] replaceCallRefs | master MP call becomes : " + this.mediaPillarCallContext.telephonyCallRefs[0].id);\n            }\n        }\n        else {\n            this.$log.warn("[WebrtcGatewayService] replaceCallRefs | ANOMALY oldCallRef not found");\n            if (flagNewAlreadyExist) { //if newCallRef was removed restore it\n                this.addTelCallRefs(newCallRef);\n                if (flagNewLinked) { //was linked\n                    newCallRef.setMediaPillarCall(this.getMediaPillarCallContext()); //link the newcall to MP context\n                }\n            }\n        }\n    }\n    ;\n    /**\n        * Method automatonDefenseTimout\n        * @private\n        * @memberof WebrtcGatewayService\n        *\n        */\n    automatonDefenseTimout(call) {\n        //Situation evaluation\n        let actionLevel = 0; // default low level action\n        if (call !== undefined && call !== null) {\n            //telcall point of view\n            if (call.type.value === call_model_1.Call.Type.PHONE.value) {\n                this.$log.log("[WebrtcGatewayService] automatonDefenseTimout | transition telcall call=" + call.id + " evt=" + call.status.value + " then timout");\n                switch (call.status) {\n                    case call_model_1.Call.Status.RINGING_OUTGOING:\n                    case call_model_1.Call.Status.RINGING_INCOMMING:\n                        break;\n                    default:\n                        if (this.mediaPillarCallContext.callState !== MPCallState.CallActive\n                            && this.mediaPillarCallContext.callState !== MPCallState.CallActiveNoWebMedia\n                            && this.mediaPillarCallContext.callState !== MPCallState.CallOffer\n                            && this.mediaPillarCallContext.callState !== MPCallState.CallOnGoing) {\n                            actionLevel = 2;\n                        }\n                        break;\n                }\n            }\n            // Webrtc call point of view\n            else if (this.isMediaPillarJid(this.xmppService.getBareJidFromJid(call.fullJid))) {\n                this.$log.log("[WebrtcGatewayService] automatonDefenseTimout | transition webrtc " + call.status.value + " then timout");\n                switch (call.status) {\n                    case call_model_1.Call.Status.ACTIVE:\n                        break;\n                    default:\n                        if (this.mediaPillarCallContext.callState !== MPCallState.CallActive\n                            && this.mediaPillarCallContext.callState !== MPCallState.CallActiveNoWebMedia\n                            && this.mediaPillarCallContext.callState !== MPCallState.CallOffer\n                            && this.mediaPillarCallContext.callState !== MPCallState.CallOnGoing) {\n                            actionLevel = 3; //CRRAINB-3500\n                        }\n                        break;\n                }\n            }\n            else {\n                this.$log.warn("[WebrtcGatewayService] automatonDefenseTimout | anomaly transition webrtc call but Not a webrtcgateway case");\n                actionLevel = 2;\n            }\n        }\n        else { // no call evt\n            if (this.mediaPillarCallContext.callState !== MPCallState.CallActive\n                && this.mediaPillarCallContext.callState !== MPCallState.CallActiveNoWebMedia\n                && this.mediaPillarCallContext.callState !== MPCallState.RemoteControled\n                && this.mediaPillarCallContext.callState !== MPCallState.CallOffer\n                && this.mediaPillarCallContext.callState !== MPCallState.CallOnGoing) {\n                this.$log.log("[WebrtcGatewayService] automatonDefenseTimout | anomaly timout in unexpected state");\n                actionLevel = 2;\n            }\n        }\n        //Actions\n        if (actionLevel !== 0) {\n            this.$log.warn("[WebrtcGatewayService] automatonDefenseTimout | actionlevel " + actionLevel);\n        }\n        switch (actionLevel) {\n            case 0: // do nothing\n                break;\n            case 1: //Min keepalive polling\n                this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN; //switch to MIn keepalive polling\n                if (!this.mediaPillarAlive) {\n                    this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n                }\n                break;\n            case 2: // free mediapillar call context + Min keepalive polling\n                this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN;\n                if (!this.mediaPillarAlive) {\n                    this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n                }\n                this.releaseMediaPillarCallContext(); // free mediapillar call context                 \n                break;\n            case 3: // release webrtc call + free mediapillar call context + Min keepalive polling\n                this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN;\n                if (!this.mediaPillarAlive) {\n                    this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n                }\n                this.MediaPillarReleaseWebrtcCall(); //Free web call\n                this.releaseMediaPillarCallContext(); // free mediapillar call context  \n                break;\n            default:\n                this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN;\n                if (!this.mediaPillarAlive) {\n                    this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n                }\n                this.MediaPillarCallTerminator();\n                break; // major or unknow anomaly => call terminator\n        }\n        //if MPCallState not FREE rearm Timout for survey\n        if (this.mediaPillarCallContext.callState !== MPCallState.Free) {\n            this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(null); }, this.TO_transition, 1);\n        }\n    }\n    ;\n    /** ======================================================================================== **/\n    /** ==================================== TELEPHONY EVENT =================================== **/\n    /** ======================================================================================== **/\n    /**\n     * Method onTelCallIncomming\n     * @private\n     * @param {call} call [required] the call\n     * @memberof WebrtcGatewayService\n     */\n    onTelCallIncomming(call) {\n        //nth (multiple calls)\n        if (this.mediaPillarCallContext.telephonyCallRefs.length > 1 &&\n            this.mediaPillarCallContext.callState !== MPCallState.Free &&\n            this.mediaPillarCallContext.callState !== MPCallState.WaitTelephony &&\n            this.mediaPillarCallContext.callState !== MPCallState.WaitWebrtc) {\n            this.$log.info("[WebrtcGatewayService] onTelCallIncomming | nth calls BUT trig the GUI & link the call");\n            call.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context\n            this.$log.info("[WebrtcGatewayService] onTelCallIncomming | ON_CONVERSATION_CALL_UPDATED_EVENT for call = " + call.id);\n            this.mediaPillarCallContext.updateContactFlag = true; //CCRAINB-4634\n            this.$rootScope.$broadcast("ON_CONVERSATION_CALL_UPDATED_EVENT", {\n                conversation: null,\n                call: call\n            });\n            return;\n        }\n        //else \n        this.$log.info("[WebrtcGatewayService] onTelCallIncomming | mediapilaryse as necessary for call " + call.id);\n        //mediaPillaryse the call and link it to the mediaPillar Call context\n        switch (this.mediaPillaryseTheCall(call, null)) {\n            case "Ok":\n                //call.setMediaPillarCall(this.getMediaPillarCallContext());\n                this.stopCallStateTimeOut();\n                this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n                if (!this.isMediaPillarOutgoingCall() && this.mediaPillarCallContext.callState === MPCallState.CallOffer && this.mediaPillarCallContext.webrtcCallRef) {\n                    for (var i = 0; i < this.mediaPillarCallContext.telephonyCallRefs.length; i++) {\n                        if (this.mediaPillarCallContext.telephonyCallRefs[i].status === call_model_1.Call.Status.RINGING_INCOMMING ||\n                            this.mediaPillarCallContext.telephonyCallRefs[i].status === call_model_1.Call.Status.QUEUED_INCOMMING) {\n                            this.$log.info("[WebrtcGatewayService] onTelCallIncomming | ON_CONVERSATION_CALL_UPDATED_EVENT for call = " + call.id);\n                            this.mediaPillarCallContext.updateContactFlag = true; //CCRAINB-4634\n                            this.$rootScope.$broadcast("ON_CONVERSATION_CALL_UPDATED_EVENT", {\n                                conversation: null,\n                                call: this.mediaPillarCallContext.telephonyCallRefs[i]\n                            });\n                        }\n                    }\n                }\n                break;\n            case "Update":\n                this.stopCallStateTimeOut(); //CRRAINB-6167\n                if (!this.isMediaPillarOutgoingCall() && this.mediaPillarCallContext.webrtcCallRef\n                    && (call.status === call_model_1.Call.Status.RINGING_INCOMMING || call.status === call_model_1.Call.Status.QUEUED_INCOMMING)) {\n                    this.$rootScope.$broadcast("ON_CONVERSATION_CALL_UPDATED_EVENT", {\n                        conversation: null,\n                        call: call\n                    });\n                    this.$log.info("[WebrtcGatewayService] onTelCallIncomming | update call");\n                }\n                else {\n                    this.$log.info("[WebrtcGatewayService] onTelCallIncomming | ignore update call");\n                }\n                break;\n            case "Ignore":\n                this.$log.info("[WebrtcGatewayService] onTelCallIncomming | ignore evt");\n                break;\n            default:\n                this.$log.error("[WebrtcGatewayService] onTelCallIncomming | media Pillar call anomaly " + status);\n                //this.MediaPillarCallTerminator(); //CRRAINB-5196\n                break;\n        }\n    }\n    /**\n     * Method onTelCallDialling\n     * @private\n     * @param {call} call [required] the tel call\n     * @memberof WebrtcGatewayService\n     */\n    onTelCallDialling(call) {\n        if (this.mediaPillarCallContext.callState === MPCallState.Free\n            || this.mediaPillarCallContext.callState === MPCallState.WaitTelephony) { //check if mediapillar context is ready for the incoming 3PCC call\n            this.mediaPillarCallContext.isOutgoingCall3PCC = true; //flag as outgoing 3PCC call\n            this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n            //mediaPillaryse the call and link it to the mediaPillar Call context\n            switch (this.mediaPillaryseTheCall(call, null)) {\n                case "Ok":\n                    if (this.mediaPillarCallContext.webrtcCallRef && this.mediaPillarCallContext.callState === MPCallState.CallOffer) { // web part ready                     \n                        //then auto answer to the webrtc part \n                        this.videoService.answerCall(this.mediaPillarCallContext.webrtcCallRef, "audio");\n                        this.$log.info("[WebrtcGatewayService] onTelCallDialling | outgoing3PCC then send webrtc proceed");\n                    }\n                    this.stopCallStateTimeOut();\n                    this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n                    break;\n                case "Ignore":\n                case "Update":\n                    this.$log.info("[WebrtcGatewayService] onTelCallDialling | ignore evt");\n                    break;\n                default:\n                    this.$log.error("[WebrtcGatewayService] onTelCallDialling | media Pillar call anomaly " + status);\n                    this.MediaPillarCallTerminator();\n                    break;\n            }\n        }\n        else {\n            if (this.mediaPillarCallContext.callState === MPCallState.CallOffer || this.mediaPillarCallContext.callState === MPCallState.CallOnGoing) { //CRRAINB-3952\n                this.$log.warn("[WebrtcGatewayService] onTelCallDialling | media Pillar call anomaly, on state : " + this.mediaPillarCallContext.callState);\n                this.$log.info("[WebrtcGatewayService] onTelCallDialling | ignored , on state : " + this.mediaPillarCallContext.callState);\n            }\n            else {\n                this.$log.warn("[WebrtcGatewayService] onTelCallDialling | media Pillar call anomaly, MP context not compatible");\n                this.MediaPillarCallTerminator();\n            }\n        }\n    }\n    /**\n     * Method onTelCallOutgoing\n     * @private\n     * @param {call} call [required] the tel call\n     * @memberof WebrtcGatewayService\n     */\n    onTelCallOutgoing(call) {\n        if (!this.isMediaPillarOutgoingCall()) { //check if it is not a 1st outgoing call\n            this.$log.warn("[WebrtcGatewayService] onTelCallOutgoing | media Pillar, not a 1st 3PCC outgoing call then ignore & release MP CallContext");\n            this.releaseMediaPillarCallContext();\n        }\n        else { //CRRAINB-3271\n            //re-arm tempo\n            this.stopCallStateTimeOut();\n            this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition_long, 1);\n        }\n    }\n    /**\n      * Method onTelCallActive\n      * @private\n      * @param {call} call [required] the tel call\n      * @memberof WebrtcGatewayService\n      */\n    onTelCallActive(call) {\n        switch (this.mediaPillarCallContext.callState) {\n            case MPCallState.CallOnGoing: //normal case\n                this.stopCallStateTimeOut();\n                this.mediaPillarCallContext.callState = MPCallState.CallActive;\n                break;\n            case MPCallState.TelCallReleasing: //probably a CONF case or other tel complexe case\n                this.$log.warn("[WebrtcGatewayService] onTelCallActive | media Pillar recv tel active on state = " + this.mediaPillarCallContext.callState);\n                this.$log.info("[WebrtcGatewayService] onTelCallActive | media Pillar , RE-ACTIVATION");\n                this.stopCallStateTimeOut();\n                call.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context  : MP_BIG_BUG\n                this.mediaPillarCallContext.callState = MPCallState.CallActive;\n                break;\n            case MPCallState.CallActive:\n                this.$log.info("[WebrtcGatewayService] onTelCallActive | media Pillar , ignore tel active on state CallActive ");\n                break;\n            case MPCallState.WebCallReleasing:\n                this.$log.info("[WebrtcGatewayService] onTelCallActive | media Pillar recv tel active on state WebCallReleasing then releaseMediaPillarCallContext");\n                this.releaseMediaPillarCallContext(); // probably call taken by multidevice side\n                break;\n            case MPCallState.Free:\n                this.$log.info("[WebrtcGatewayService] onTelCallActive | media Pillar recv tel active on state = 1 ; probably call taken on deskphone ; ignore active & release call context ");\n                this.releaseMediaPillarCallContext();\n                break;\n            default:\n                this.$log.info("[WebrtcGatewayService] onTelCallActive | Anomaly media Pillar recv tel active on state = " + this.mediaPillarCallContext.callState);\n                break;\n        }\n    }\n    /**\n      * Method onTelCallReleasing\n      * @private\n      * @param {call} call [required] the tel call\n      * @memberof WebrtcGatewayService\n      */\n    onTelCallReleasing(call) {\n        var callsNumber = this.telephonyService.getCalls().length;\n        if (this.mediaPillarCallContext.telephonyCallRefs.length > 1) { //CCRAINB-3750\n            call.setMediaPillarCall(null); //remove link from call to MP context\n            this.removeTelCallRefs(call); //remove link from MP context to call\n            this.$log.info("[WebrtcGatewayService] onTelCallReleasing -- " + call.id + " -- postpone mediaPillarCallContext release ;  remaining calls = " + this.mediaPillarCallContext.telephonyCallRefs.length);\n            return;\n        }\n        if (this.isMediaPillarReleasableCall()) { //check if MP call state is compatible\n            call.setMediaPillarCall(null); //remove link from call to MP context\n            this.removeTelCallRefs(call); //remove link from MP context to call\n            if (this.mediaPillarCallContext.webrtcCallRef && this.mediaPillarCallContext.callState !== MPCallState.WebCallReleasing && this.mediaPillarCallContext.callState !== MPCallState.RemoteControled) {\n                if (this.mediaPillarCallContext.callState !== MPCallState.TelCallReleasing) {\n                    this.mediaPillarCallContext.callState = MPCallState.TelCallReleasing;\n                    this.stopCallStateTimeOut();\n                    this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n                    this.$log.info("[WebrtcGatewayService] onTelCallReleasing -- " + call.id + " -- wait web release: state = " + this.mediaPillarCallContext.callState);\n                }\n                else {\n                    this.$log.info("[WebrtcGatewayService] onTelCallReleasing -- " + call.id + " -- ignore telrelease on state = " + this.mediaPillarCallContext.callState);\n                }\n                /* WARNING REENTRANCY PB on call of this.xxxx.releaseCall() */\n                //this.videoService.releaseCall(this.mediaPillarCallContext.webrtcCallRef); //CLAMERDE cas de reentrance!!!\n            }\n            else { //directly release MP call context exept if MPCallState.Free\n                if (this.mediaPillarCallContext.callState !== MPCallState.Free) {\n                    this.releaseMediaPillarCallContext(); //free mediapillar call context\n                    this.$log.info("[WebrtcGatewayService] onTelCallReleasing -- " + call.id + " -- release MP context");\n                }\n            }\n        }\n        else {\n            this.$log.warn("[WebrtcGatewayService] onTelCallReleasing | media Pillar call release anomaly on state = " + this.mediaPillarCallContext.callState);\n            this.MediaPillarCallTerminator();\n        }\n    }\n    /** ======================================================================================== **/\n    /** ====================================  WEBRTC EVENT  ==================================== **/\n    /** ======================================================================================== **/\n    /**\n     * Method onWebrtcCallIncomming\n     * @private\n     * @param {call} call [required] the call\n     * @memberof WebrtcGatewayService\n     */\n    onWebrtcCallIncomming(call) {\n        if (this.mediaPillarCallContext.webrtcCallRef) {\n            this.$log.info("[WebrtcGatewayService] onWebrtcCallIncomming -- " + call.id + " --- ignored other incomming");\n            return;\n        }\n        //RQRAINB-1548++\n        if (this.mediaPillarCallContext.callState === MPCallState.WebCallReleasing && this.mediaPillarCallContext.telephonyCallRefs.length !== 0\n            && this.mediaPillarCallContext.telephonyCallRefs[0].status !== call_model_1.Call.Status.UNKNOWN) {\n            //webCall re-propose (following previous webref released) while tel call still established : \n            //special OXE case when double call with second call releasing and then 1st call use new a webrtc media\n            this.$log.info("[WebrtcGatewayService] onWebrtcCallIncomming -- " + call.id + " --- re propose during established tel call");\n            this.mediaPillarCallContext.webrtcCallRef = call;\n            this.videoService.answerCall(this.mediaPillarCallContext.webrtcCallRef, "audio");\n            this.stopCallStateTimeOut();\n            this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n            this.mediaPillarCallContext.callState = MPCallState.CallOnGoing;\n            return;\n        } //RQRAINB-1548--\n        //mediaPillaryse the call and link it to the mediaPillar Call context\n        switch (this.mediaPillaryseTheCall(null, call)) {\n            case "Ok":\n                this.stopCallStateTimeOut();\n                this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n                //call.setMediaPillarCall(this.getMediaPillarCallContext());\n                if (this.isMediaPillarOutgoingCall()) { //if outgoing 3PCC call\n                    //then answer to the webrtc part \n                    this.videoService.answerCall(this.mediaPillarCallContext.webrtcCallRef, "audio");\n                    this.$log.info("[WebrtcGatewayService] onWebrtcCallIncomming | outgoing3PCC then send webrtc proceed");\n                }\n                else { //if incomming call Synchronyse the GUI conversation mng (present the ringing tel call)\n                    if (this.mediaPillarCallContext.callState === MPCallState.CallOffer) {\n                        for (var i = 0; i < this.mediaPillarCallContext.telephonyCallRefs.length; i++) {\n                            if (this.mediaPillarCallContext.telephonyCallRefs[i].status === call_model_1.Call.Status.RINGING_INCOMMING ||\n                                this.mediaPillarCallContext.telephonyCallRefs[i].status === call_model_1.Call.Status.QUEUED_INCOMMING) {\n                                this.$log.info("[WebrtcGatewayService] onWebrtcCallIncomming | ON_CONVERSATION_CALL_UPDATED_EVENT for call = " + this.mediaPillarCallContext.telephonyCallRefs[i].id);\n                                this.$rootScope.$broadcast("ON_CONVERSATION_CALL_UPDATED_EVENT", {\n                                    conversation: null,\n                                    call: this.mediaPillarCallContext.telephonyCallRefs[i]\n                                });\n                            }\n                        }\n                    }\n                }\n                break;\n            case "Ignore": break;\n            default:\n                this.$log.error("[WebrtcGatewayService] onWebrtcCallIncomming | media Pillar call anomaly " + status);\n                break;\n        }\n    }\n    /**\n      * Method onWebrtcCallConnecting\n      * @private\n      * @param {call} call [required] the webrtc call\n      * @memberof WebrtcGatewayService\n      */\n    onWebrtcCallConnecting(call) {\n        if (this.mediaPillarCallContext.callState === MPCallState.CallActive) {\n            this.$log.info("[WebrtcGatewayService] onWebrtcCallConnecting -- media Pillar call reconnecting attempts");\n            this.mediaPillarCallContext.callState = MPCallState.CallActiveNoWebMedia;\n            //CRRAINB-3500 //arm tempo\n            this.stopCallStateTimeOut();\n            this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.timeOutCallActiveNoWebMedia(); }, this.TO_NoWebMedia, 1);\n            //CRRAINB-3500\n            return;\n        }\n        if (this.mediaPillarCallContext.callState === MPCallState.TelCallReleasing) { //CRRAINB-6895\n            this.$log.info("[WebrtcGatewayService] onWebrtcCallConnecting -- media Pillar webrtc call reconnecting while TelCallReleasing");\n            this.mediaPillarCallContext.callState = MPCallState.CallActiveNoWebMedia;\n            this.stopCallStateTimeOut();\n            this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.timeOutCallActiveNoWebMedia(); }, this.TO_NoWebMediaNotel, 1);\n            return;\n        }\n    }\n    /**\n    * Method onWebrtcCallActive\n    * @private\n    * @param {call} call [required] the webrtc call\n    * @memberof WebrtcGatewayService\n    */\n    onWebrtcCallActive(call) {\n        if (this.mediaPillarCallContext.callState === MPCallState.CallActiveNoWebMedia) {\n            this.$log.info("[WebrtcGatewayService] onWebrtcCallConnecting -- media Pillar call reconnected");\n            this.mediaPillarCallContext.callState = MPCallState.CallActive;\n            //CRRAINB-3500 //stop tempo\n            this.stopCallStateTimeOut();\n            //CRRAINB-3500\n        }\n    }\n    /**\n       * Method onWebrtcCallAnswering\n       * @private\n       * @param {call} call [required] the webrtc call\n       * @memberof WebrtcGatewayService\n       */\n    onWebrtcCallAnswering(call) {\n        this.mediaPillarCallContext.callState = MPCallState.CallOnGoing;\n        this.stopCallStateTimeOut();\n        this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n    }\n    /**\n       * Method onWebrtcCallReleasing\n       * @private\n       * @param {call} call [required] the webrtc call\n       * @memberof WebrtcGatewayService\n       */\n    onWebrtcCallReleasing(call) {\n        if (this.isMediaPillarReleasableCall()) { //check if MP call state is compatible\n            call.setMediaPillarCall(null); //remove link from call to MP context\n            this.mediaPillarCallContext.webrtcCallRef = null; //remove link from MP context to call\n            if ((this.mediaPillarCallContext.telephonyCallRefs.length !== 0) && this.mediaPillarCallContext.callState !== MPCallState.TelCallReleasing\n                && this.mediaPillarCallContext.callState !== MPCallState.RemoteControled) { //RQRAINB-1548+\n                if (this.mediaPillarCallContext.callState !== MPCallState.WebCallReleasing) {\n                    this.mediaPillarCallContext.callState = MPCallState.WebCallReleasing;\n                    this.stopCallStateTimeOut();\n                    this.mediaPillarCallContext.callState_TO = this.$interval(() => { this.automatonDefenseTimout(call); }, this.TO_transition, 1);\n                    this.releasePbxCallIfPbxConnectionDown();\n                    this.$log.info("[WebrtcGatewayService] onWebrtcCallReleasing -- " + call.id + " -- wait tel release: state = " + this.mediaPillarCallContext.callState);\n                }\n                else {\n                    this.$log.info("[WebrtcGatewayService] onWebrtcCallReleasing -- " + call.id + " -- ignore webrelease on state = " + this.mediaPillarCallContext.callState);\n                }\n                /* WARNING REENTRANCY PB on call of this.videoService.releaseCall() */\n            }\n            else { //directly release MP call context\n                this.releaseMediaPillarCallContext(); //free mediapillar call context\n                this.$log.info("[WebrtcGatewayService] onWebrtcCallReleasing -- " + call.id + " -- release MP context");\n            }\n        }\n        else {\n            this.$log.warn("[WebrtcGatewayService] onWebrtcCallReleasing | media Pillar call release anomaly on state = " + this.mediaPillarCallContext.callState);\n            this.MediaPillarCallTerminator();\n        }\n    }\n    /**\n       * Method releasePbxCallIfPbxConnectionDown\n       * @private\n       * @memberof WebrtcGatewayService\n       * release the active pbx call if the pbx connection is down: this is called when we receive the session termination on the mp webrtc call\n       */\n    releasePbxCallIfPbxConnectionDown() {\n        let activePbxCall = this.getActivePbxCall();\n        if (activePbxCall && activePbxCall.pbxConnectionDown) {\n            this.$log.info("[WebrtcGatewayService] releasePbxCallIfPbxConnectionDown | release call" + activePbxCall);\n            this.telephonyService.releaseCall(activePbxCall); //remove pbx call\n            activePbxCall.mediaPillarCall = null; //and the link from this pbx call to the mediapillar call context\n        }\n    }\n    /*******************************************************************/\n    /** ACTION FUNCTIONS                                              **/\n    /*******************************************************************/\n    /**\n    * Method mediaPillarMakeCall\n    * @private\n    * @param {Number} phoneNumber [required] the number to join by mediaPillar\n    * @param {contact}  [optional]  the called contact if available\n    * @memberof WebrtcGatewayService\n    * make a media pillar call to the phoneNumber\n    */\n    mediaPillarMakeCall(phoneNumber, contact) {\n        this.$log.info("[WebrtcGatewayService] mediaPillarMakeCall");\n        let mediaPillarJid = this.getMyMediaPillarJid();\n        //DEMO MODE++\n        if (phoneNumber.length > 6 && contact) {\n            phoneNumber = contact.phonePbx;\n        }\n        //DEMO MODE--\n        //we\'re making a webrtc call right now\n        this.videoService.makingCall = true;\n        if (mediaPillarJid !== "") {\n            //this.videoService.makeCall(calledContact, "WebRTCAudio", mediaPillarJid, phoneNumber);\n            var id = "web_" + this.uuid4.generate();\n            if (!contact || contact === null) { //no contact provided then use predefined mediaPillarContact\n                // 1PCC CPaaS ++\n                //Create the call object\n                var call = call_model_1.Call.create(call_model_1.Call.Status.DIALING, id, call_model_1.Call.Type.WEBRTC, this.mediaPillarContact);\n                call.fullJid = mediaPillarJid;\n                this.mediaPillarStartCall(call, phoneNumber, mediaPillarJid);\n                // 1PCC CPaaS --\n            }\n            else {\n                //Create the call object\n                var call = call_model_1.Call.create(call_model_1.Call.Status.DIALING, id, call_model_1.Call.Type.WEBRTC, contact);\n                call.fullJid = mediaPillarJid;\n                this.mediaPillarStartCall(call, phoneNumber, mediaPillarJid);\n            }\n        }\n        else {\n            this.$log.info("[WebrtcGatewayService] mediaPillarMakeCall ANOMALY no mediaPillarJid");\n        }\n    }\n    /**\n    * Method mediaPillarStartCall\n    * @private\n    * @param {call} call [required] the call to abort\n    * @param {Number} phoneNumber [required] the number to join by mediaPillar\n    * @param {mediaPillarJid} mediaPillarJid [required]\n    * @memberof WebrtcGatewayService\n    */\n    mediaPillarStartCall(call, phoneNumber, mediaPillarJid) {\n        this.$log.info("[WebrtcGatewayService] mediaPillarStartCall for phone number " + phoneNumber);\n        this.initiateMediaPillarCall(call)\n            .then(() => {\n            this.dummyRegisterMediaPillarCall()\n                .then(() => {\n                this.$log.info("[WebrtcGatewayService] mediaPillarMakeCall for number " + phoneNumber);\n                this.videoService.makeJingleCall(call, mediaPillarJid, phoneNumber);\n            })\n                .catch((error) => {\n                this.$log.info("[WebrtcGatewayService] mediaPillarMakeCall ANOMALY dummyRegisterMediaPillarCall then abort call");\n                this.abortCall(call);\n            });\n        })\n            .catch((error) => {\n            this.$log.info("[WebrtcGatewayService] mediaPillarMakeCall ANOMALY initiateMediaPillarCall then abort call");\n            this.abortCall(call);\n        });\n    }\n    /**\n    * Method abortCall\n    * @private\n    * @param {call} call [required] the call to abort\n    * @memberof WebrtcGatewayService\n    */\n    abortCall(call) {\n        //free the mackingCall flag\n        this.videoService.makingCall = false;\n        if (call) {\n            this.videoService.removeCallObject(call);\n        }\n        this.videoService.resetToSafeState();\n    }\n    /**\n    * Method initiateMediaPillarCall\n    * @private\n    * @memberof WebrtcGatewayService\n    * inspired by VideoServiceEventHandler.prototype.sendProposition\n    */\n    initiateMediaPillarCall(call) {\n        return this.$q((resolve, reject) => {\n            this.$log.info("[WebrtcGatewayService] initiateMediaPillarCall");\n            var mediaToGet = ["audio"];\n            this.videoService.getBrowserMedia(mediaToGet)\n                .then((stream) => {\n                call.isInitiator = true;\n                this.videoService.localStreams.push(stream);\n                this.videoService.calls[call.id] = call;\n                call.localMedia = call.localMedia | call_model_1.Call.Media.AUDIO; //replace setLocalTypeMedia(mediaToGet, call);\n                // Update presence\n                this.contactService.setBusyState("dnd", this.videoService.calculatePresenceMessage(call));\n                // Send event\n                this.$rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n                resolve();\n            })\n                .catch((error) => {\n                this.$log.info("[WebrtcGatewayService]   | initate call failure : " + JSON.stringify({ error: error.message }));\n                if (!(mediaToGet.indexOf("sharing") >= 0) && error.toString().indexOf("getUserMedia") !== -1) {\n                    this.videoService.openErrorPopup();\n                }\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method dummyRegisterMediaPillarCall\n    * @private\n    * @memberof WebrtcGatewayService\n    */\n    dummyRegisterMediaPillarCall() {\n        // provisoire simulation d\'un register sur le media Pillar\n        //var defered = this.$q.defer(); \n        return this.$q((resolve, reject) => {\n            var xmppIq = $iq({ from: this.myContact.fullJid, to: this.mediaPillarCallContext.mediaPillarJid, type: "set" })\n                .c("mediapillar", { xmlns: \'urn:xmpp:janus:1\' })\n                .c("register")\n                .c("jidIm").t(this.contactService.userContact.jid).up()\n                .c("jidTel").t(this.contactService.userContact.jidtel).up()\n                .c(\'number\').t(this.mediaPillarCallContext.rainbowPhoneNumber).up()\n                .c(\'displayName\').t(this.myContact.displayName).up()\n                .c(\'secret\').t(this.mediaPillarCallContext.rainbowPhoneNumber).up();\n            this.xmppService.sendIQ(xmppIq)\n                .then((data) => {\n                resolve();\n            })\n                .catch((error) => {\n                if (this.IsMediaPillarUserSelected()) {\n                    this.$log.warn("[WebrtcGatewayService] dummyRegisterMediaPillarCall -- register failure -- " + error.message);\n                }\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method getMediaPillarData\n    * @public\n    * @returns {ng.IPromise<{string}>} the mediaPillarJid data associated to the system & user\n    * @memberof WebrtcGatewayService\n    */\n    getMediaPillarData() {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "GET", url: this.portalURL + "/data", headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.log("[WebrtcGatewayService] getMediaPillarData success");\n                if (response.data && response.data["data"]) {\n                    let prefix = response.data["data"]["prefix"];\n                    let rainbowPhoneNumber = response.data["data"]["rainbowPhoneNumber"];\n                    if (prefix && rainbowPhoneNumber) {\n                        this.mediaPillarCallContext.rainbowPhoneNumber = rainbowPhoneNumber;\n                        this.mediaPillarCallContext.remoteExtension = prefix + rainbowPhoneNumber;\n                    }\n                    let jid = response.data["data"]["jid_im"];\n                    // Add MP ressource, if missing\n                    if (jid && jid.indexOf("/") === -1) {\n                        jid += "/mediapillar";\n                    }\n                    resolve(jid);\n                }\n                else {\n                    // Missing data in the response\n                    this.$log.error("[WebrtcGatewayService] getMediaPillarData success -- missing data");\n                    reject(new Error("[WebrtcGatewayService] getMediaPillarData -- missing data in response"));\n                }\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                this.$log.info("[WebrtcGatewayService] getMediaPillarData error -- " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method mediaPillarKeepAlivePolling\n    * @private\n    * @param {cmd} cmd [required] the keep alive command\n    * @param {timer} timer [required] the keep alive timer\n    * @memberof WebrtcGatewayService\n    */\n    mediaPillarKeepAlivePolling(cmd, timer) {\n        if (this.started) {\n            switch (cmd) {\n                case "START":\n                    if (this.mediaPillarCallContext && this.mediaPillarCallContext.keepAlive_TO) {\n                        this.$interval.cancel(this.mediaPillarCallContext.keepAlive_TO);\n                        this.mediaPillarCallContext.keepAlive_TO = null;\n                    }\n                    this.mediaPillarCallContext.keepAlive_TO = this.$interval(() => { this.mediaPillarKeepAlive(); }, timer, 1);\n                    break;\n                case "STOP":\n                    if (this.mediaPillarCallContext && this.mediaPillarCallContext.keepAlive_TO) {\n                        this.$interval.cancel(this.mediaPillarCallContext.keepAlive_TO);\n                    }\n                    this.mediaPillarCallContext.keepAlive_TO = null;\n                    break;\n                default:\n                    this.$log.error("[WebrtcGatewayService] mediaPillarKeepAlivePolling cmd error : " + cmd);\n                    break;\n            }\n        }\n    }\n    /**\n    * Method mediaPillarUserSelectAndPolling\n    * @public\n    * @param {boolean} selected [required] selected, true if MP is selected in nomadic menu\n    * @memberof WebrtcGatewayService\n    */\n    mediaPillarUserSelectAndPolling(selected) {\n        if (this.started) {\n            this.$log.log("[WebrtcGatewayService] mediaPillarUserSelectAndPolling : " + selected);\n            if (selected) { //media pillar selected in user menu\n                this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n                this.mediaPillarKeepAlive();\n            }\n            else {\n                if (this.mediaPillarAlive) { //stop polling only if MP is alive\n                    this.mediaPillarKeepAlivePolling("STOP", 0);\n                }\n            }\n        }\n    }\n    /**\n    * Method mediaPillarKeepAlive\n    * @private\n\n    * @memberof WebrtcGatewayService\n    */\n    mediaPillarKeepAlive() {\n        this.$log.info("[WebrtcGatewayService] mediaPillarKeepAlive");\n        if (!this.mediaPillarKeepAliveSuspend) { //CRRAINB-3757\n            let newSampleMediaPillarState = false;\n            this.dummyRegisterMediaPillarCall()\n                .then(() => {\n                newSampleMediaPillarState = true;\n                this.$log.info("[WebrtcGatewayService] mediaPillarKeepAlive webrtcgateway is UP");\n            })\n                .catch((error) => {\n                newSampleMediaPillarState = false;\n                this.$log.info("[WebrtcGatewayService] mediaPillarKeepAlive webrtcgateway is DOWN");\n            })\n                .finally(() => {\n                if (this.mediaPillarAlive !== newSampleMediaPillarState) {\n                    this.mediaPillarAlive = newSampleMediaPillarState;\n                    this.$rootScope.$broadcast("ON_WEBRTCGATEWAY_STATE_CHG", this.mediaPillarAlive);\n                    this.$log.info("[WebrtcGatewayService] mediaPillarKeepAlive ON_WEBRTCGATEWAY_STATE_CHG");\n                }\n                if (this.mediaPillarAlive) {\n                    if (this.TO_PILLAR_POLLING < TO_PILLAR_POLLING_MAX) {\n                        this.TO_PILLAR_POLLING += TO_PILLAR_POLLING_STEP;\n                    }\n                    else {\n                        this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MAX;\n                    }\n                }\n                else { //not Alive\n                    this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN;\n                    this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n                }\n                if (this.IsMediaPillarUserSelected() && this.mediaPillarAlive) {\n                    this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n                }\n            });\n        }\n        else {\n            this.$log.info("[WebrtcGatewayService] KeepAlive suspended");\n        }\n    }\n    /**\n     * Method forceMPpooling\n     * @public\n     * @memberof WebrtcGatewayService\n     */\n    forceMPpooling() {\n        if (this.started) {\n            this.$log.log("[WebrtcGatewayService] forceMPpooling ");\n            this.TO_PILLAR_POLLING = TO_PILLAR_POLLING_MIN;\n            this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n            this.$rootScope.$broadcast("ON_WEBRTCGATEWAY_STATE_CHG", this.mediaPillarAlive);\n        }\n    }\n    /*******************************************************************/\n    /** HELPER FUNCTIONS                                              **/\n    /*******************************************************************/\n    /**\n    * Method getMyMediaPillarJid\n    * @public\n    * @returns {string} my mediaPillar Jid ("" if not already obtained from server )\n    * @memberof WebrtcGatewayService\n    */\n    getMyMediaPillarJid() {\n        this.$log.info("[WebrtcGatewayService] getMyMediaPillarJid : " + this.mediaPillarCallContext.mediaPillarJid);\n        return this.mediaPillarCallContext.mediaPillarJid;\n    }\n    /**\n    * Method getMyMediaPillarRemoteExtension\n    * @public\n    * @returns {string} my mediaPillar remote extension ("" if not already obtained from server )\n    * @memberof WebrtcGatewayService\n    */\n    getMyMediaPillarRemoteExtension() {\n        return this.mediaPillarCallContext.remoteExtension;\n    }\n    /**\n    * Method shouldUseMediaPillar\n    * @public\n    * @returns {boolean} true if media pillar should be used for PBX calls\n    * @memberof WebrtcGatewayService\n    */\n    shouldUseMediaPillar() {\n        var should = this.isMediaPillarAvailable() && this.IsMediaPillarUserSelected();\n        if (typeof config.devMediaPillarEnabled === "undefined" || !config.devMediaPillarEnabled) {\n            should = false;\n        }\n        //return should;\n        return false; //former 1PCC way\n    }\n    /**\n     * Method isMediaPillarConfigured\n     * @public\n     * @returns {boolean} true if media pillar is configured for this user (configuration + rights)\n     * @memberof WebrtcGatewayService\n     */\n    isMediaPillarConfigured() {\n        var configured = (this.mediaPillarConfigured && this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.TELEPHONY_WEBRTC_PSTN_CALLING));\n        return (configured);\n    }\n    /**\n    * Method isMediaPillarAvailable\n    * @public\n    * @returns {boolean} true if media pillar is available for this user (configuration + infra Up)\n    * @memberof WebrtcGatewayService\n    */\n    isMediaPillarAvailable() {\n        var available = this.isMediaPillarConfigured();\n        //available = available && this.telephonyService.started; //&& this.isMediaPillarEnabled;\n        available = available && this.mediaPillarAlive;\n        return (available);\n    }\n    /**\n    * Method IsMediaPillarUserSelected\n    * @public\n    * @returns {boolean} true if media pillar is selected (through Nomadic) for this user\n    * @memberof WebrtcGatewayService\n    */\n    IsMediaPillarUserSelected() {\n        var selected = (!this.telephonyService.nomadicObject.makeCallInitiatorIsMain && (this.telephonyService.getNomadicDestination() === this.getMyMediaPillarRemoteExtension()));\n        return selected;\n    }\n    /**\n     * Method isMediaPillarJid\n     * @public\n     * @param {string} fromJid the from jid\n     * @returns {boolean} true if it is the media pillar Jid\n     * @memberof WebrtcGatewayService\n     */\n    isMediaPillarJid(fromJid) {\n        let indexMPinJid = -1; // presence&pos of "mp_" in jid\n        //no jid provided!\n        if (!fromJid) {\n            return false;\n        }\n        indexMPinJid = fromJid.search("mp_"); //"mp_" must be at position 0\n        return (indexMPinJid === 0);\n    }\n    /**\n     * Method isMediaPillarCallCase\n     * @public\n     * @returns {boolean} true if Media pillar call\n     * @memberof WebrtcGatewayService\n     * check only the media pillar profile\n     */\n    isMediaPillarCallCase() {\n        var MP_callCase = this.isMediaPillarAvailable() && this.IsMediaPillarUserSelected();\n        return (MP_callCase);\n    }\n    /**\n     * Method isMediaPillarSituation\n     * @public\n     * @param {object} call a call\n     * @returns {boolean} true if Media pillar call situation\n     * @memberof WebrtcGatewayService\n     * In all cases test profile and Media pilar availability\n     * If call provided check also that the call is linked to the centralized media pillar context\n     * or if from jid is media pillar\n     */\n    isMediaPillarCallSituation(call) {\n        var MP_situation = this.isMediaPillarCallCase();\n        if (call) {\n            if (call.type === call_model_1.Call.Type.WEBRTC) {\n                MP_situation = MP_situation && this.isMediaPillarJid(call.fullJid);\n            }\n            else { //Call.Type.PHONE\n                if (this.telephonyService.getCalls().length <= 1 && this.mediaPillarCallContext.telephonyCallRefs.length <= 1) { //mono call case\n                    switch (call.status) {\n                        case call_model_1.Call.Status.RINGING_INCOMMING:\n                        case call_model_1.Call.Status.RINGING_OUTGOING:\n                        case call_model_1.Call.Status.QUEUED_INCOMMING:\n                        case call_model_1.Call.Status.DIALING:\n                        case call_model_1.Call.Status.RELEASING:\n                            break;\n                        default:\n                            if (call.mediaPillarCall) {\n                                MP_situation = MP_situation && this.isInTelCallRefs(call);\n                            }\n                            else {\n                                MP_situation = false;\n                            }\n                            break;\n                    }\n                }\n                else { //multi calls case\n                    switch (call.status) {\n                        case call_model_1.Call.Status.RINGING_INCOMMING:\n                        case call_model_1.Call.Status.RINGING_OUTGOING:\n                        case call_model_1.Call.Status.QUEUED_INCOMMING:\n                        //case Call.Status.QUEUED_OUTGOING:\n                        case call_model_1.Call.Status.DIALING:\n                        case call_model_1.Call.Status.RELEASING:\n                            break;\n                        default:\n                            if (call.mediaPillarCall) {\n                                MP_situation = MP_situation && (call.mediaPillarCall.telephonyCallRefs.length >= 1);\n                                MP_situation = MP_situation && this.isInTelCallRefs(call);\n                            }\n                            else {\n                                MP_situation = false;\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n        return (MP_situation);\n    }\n    /**\n     * Method mediaPillaryseTheCall\n     * @public\n     * @param {object} telephonyCall the telephonic call ref\n     * @param {object} webrtcCall  the web rtc call ref\n     * @returns {string} operation status\n     * @memberof WebrtcGatewayService\n     */\n    mediaPillaryseTheCall(telephonyCall, webrtcCall) {\n        if (this.mediaPillarCallContext.callState !== MPCallState.Free) {\n            if (telephonyCall && this.mediaPillarCallContext.updateContactFlag) { //CCRAINB-4634\n                this.$log.info("[WebrtcGatewayService] mediaPillaryseTheCall | only Update"); //CRRAINB-5196\n                telephonyCall.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context //CRRAINB-6167\n                return "Update";\n            }\n            //CRRAINB-6167++\n            if (telephonyCall && this.mediaPillarCallContext.callState === MPCallState.TelCallReleasing && telephonyCall.status === call_model_1.Call.Status.RINGING_INCOMMING) { //CCRAINB-6167\n                this.$log.info("[WebrtcGatewayService] mediaPillaryseTheCall |  transfer managed as Update");\n                telephonyCall.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context \n                this.mediaPillarCallContext.callState = MPCallState.CallOffer;\n                return "Update";\n            } //CRRAINB-6167--          \n            if (webrtcCall && this.mediaPillarCallContext.callState !== MPCallState.WaitWebrtc) {\n                this.$log.info("[WebrtcGatewayService] mediaPillaryseTheCall | only Ignore"); //CRRAINB-5196                 \n                return "Ignore";\n            }\n        }\n        var status = "";\n        if (!telephonyCall && !webrtcCall) {\n            return "NoCallRef";\n        }\n        if (telephonyCall && webrtcCall) { //normally one ref at a time\n            return "toManyCallRef";\n        }\n        if (telephonyCall) {\n            switch (this.mediaPillarCallContext.callState) {\n                case MPCallState.Free:\n                    this.mediaPillarCallContext.callState = MPCallState.WaitWebrtc;\n                    status = "Ok";\n                    break;\n                case MPCallState.WaitTelephony:\n                    this.mediaPillarCallContext.callState = MPCallState.CallOffer;\n                    status = "Ok";\n                    break;\n                case MPCallState.WaitWebrtc: //CRRAINB-6251++\n                    if (this.mediaPillarCallContext.telephonyCallRefs.length > 1) {\n                        this.$log.info("[WebrtcGatewayService] mediaPillaryseTheCall but 2nd incomming in WaitWebrtc| only Ignore");\n                        telephonyCall.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context \n                        status = "Ignore";\n                    }\n                    else {\n                        this.mediaPillarCallContext.callState = MPCallState.AnomalyCCS;\n                        status = "Ano_inTel_contextCallState_" + this.mediaPillarCallContext.callState;\n                        this.$log.info("[WebrtcGatewayService] mediaPillaryseTheCall again in WaitWebrtc");\n                    }\n                    break; //CRRAINB-6251--                 \n                default: //anomaly\n                    this.mediaPillarCallContext.callState = MPCallState.AnomalyCCS;\n                    status = "Ano_inTel_contextCallState_" + this.mediaPillarCallContext.callState;\n                    break;\n            }\n            if (status === "Ok") {\n                this.putAsMasterTelCallRefs(telephonyCall); //set as main telcallref\n                telephonyCall.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context\n            }\n        }\n        else if (webrtcCall) {\n            this.mediaPillarCallContext.webrtcCallRef = webrtcCall;\n            switch (this.mediaPillarCallContext.callState) {\n                case MPCallState.Free:\n                    this.mediaPillarCallContext.callState = MPCallState.WaitTelephony;\n                    status = "Ok";\n                    break;\n                case MPCallState.WaitWebrtc:\n                    this.mediaPillarCallContext.callState = MPCallState.CallOffer;\n                    status = "Ok";\n                    break;\n                default: //anomaly\n                    this.mediaPillarCallContext.callState = MPCallState.AnomalyCCS;\n                    status = "Ano_inWrtc_contextCallState_" + this.mediaPillarCallContext.callState;\n                    break;\n            }\n            if (status === "Ok") {\n                webrtcCall.setMediaPillarCall(this.getMediaPillarCallContext()); //link the call to MP context\n            }\n        }\n        return status;\n    }\n    /**\n    * Method getMediaPillarCallContext\n    * @public\n    * @returns {object} the media pillar call context\n    * @memberof WebrtcGatewayService\n    * Allow to link a call (tel or webrtc) to the media pillar call context\n    */\n    getMediaPillarCallContext() {\n        return this.mediaPillarCallContext;\n    }\n    /**\n    * Method isMediaPillarOutgoingCall\n    * @public\n    * @param\n    * @returns {boolean} true if outgoing 3PCC call\n    * @memberof WebrtcGatewayService\n    * return true if the mediaPillarCallContext is used for an outgoing 3PCC call\n    */\n    isMediaPillarOutgoingCall() {\n        var compatibleCallState;\n        switch (this.mediaPillarCallContext.callState) {\n            case MPCallState.WaitWebrtc:\n            case MPCallState.WaitTelephony:\n            case MPCallState.CallOffer:\n            case MPCallState.CallOnGoing:\n            case MPCallState.CallActive:\n            case MPCallState.CallActiveNoWebMedia:\n            case MPCallState.TelCallReleasing: //???\n            case MPCallState.WebCallReleasing: //???            \n                compatibleCallState = true;\n                break;\n            default:\n                compatibleCallState = false;\n                break;\n        }\n        return (compatibleCallState && this.mediaPillarCallContext.isOutgoingCall3PCC);\n    }\n    ;\n    /**\n    * Method isMediaPillarActivableCall\n    * @private\n    * @param\n    * @returns {boolean} true if\n    * @memberof WebrtcGatewayService\n    * return true if\n    */\n    /*\n    private isMediaPillarActivableCall() {\n        var compatibleCallState: boolean;\n        switch (this.mediaPillarCallContext.callState) {\n            case MPCallState.WaitWebrtc:\n            case MPCallState.CallOffer:\n                compatibleCallState = true;\n                break;\n            default:\n                compatibleCallState = false;\n                break;\n        }\n        return (compatibleCallState);\n    };\n    */\n    /**\n    * Method isMediaPillarReleasableCall\n    * @private\n    * @param\n    * @returns {boolean} true if\n    * @memberof WebrtcGatewayService\n    * return true if\n    */\n    isMediaPillarReleasableCall() {\n        var compatibleCallState;\n        switch (this.mediaPillarCallContext.callState) {\n            case MPCallState.AnomalyCCS:\n            case MPCallState.Unknow:\n                compatibleCallState = false;\n                break;\n            default:\n                compatibleCallState = true;\n                break;\n        }\n        return (compatibleCallState);\n    }\n    ;\n    /**\n      * Method MediaPillarReleaseWebrtcCall\n      * @public\n      * @memberof WebrtcGatewayService\n      * release only webrtc call (not tel part)\n      */\n    MediaPillarReleaseWebrtcCall() {\n        //Free web call //CRRAINB-3500\n        if (this.mediaPillarCallContext.webrtcCallRef) {\n            this.mediaPillarCallContext.webrtcCallRef.mediaPillarCall = null; //cut the link from call to mediapillar call context\n            this.videoService.releaseCall(this.mediaPillarCallContext.webrtcCallRef);\n        }\n    }\n    ;\n    /**\n      * Method timeOutCallActiveNoWebMedia\n      * @public\n      * @memberof WebrtcGatewayService\n      */\n    timeOutCallActiveNoWebMedia() {\n        //CRRAINB-3500\n        this.$log.info("[WebrtcGatewayService] timeOutCallActiveNoWebMedia");\n        if (this.mediaPillarCallContext.callState === MPCallState.CallActiveNoWebMedia) {\n            this.MediaPillarCallTerminator();\n            this.mediaPillarKeepAlive();\n            this.$log.info("[WebrtcGatewayService] timeOutCallActiveNoWebMedia noWebMedia then release calls if existing & force keepalive");\n        }\n    }\n    ;\n    /**\n      * Method MediaPillarCallTerminator\n      * @public\n      * @memberof WebrtcGatewayService\n      * Deep release of media pillar context including release of associated calls\n      */\n    MediaPillarCallTerminator() {\n        //Free the tel calls\n        if (this.mediaPillarCallContext.telephonyCallRefs.length !== 0) {\n            this.mediaPillarCallContext.telephonyCallRefs.forEach((callRef) => {\n                if (callRef !== null && callRef.type.value === call_model_1.Call.Type.PHONE.value) {\n                    callRef.mediaPillarCall = null; //cut the link from associated call to this mediapillar call context\n                    this.telephonyService.releaseCall(callRef); //and release call\n                    this.$log.info("[WebrtcGatewayService] MediaPillarCallTerminator | release call" + callRef);\n                }\n            });\n        }\n        this.MediaPillarReleaseWebrtcCall(); //Free web call\n        this.releaseMediaPillarCallContext(); //free mediapillar call context\n        this.resetEvtAutomaton(); //reset eventing automaton\n        this.TO_PILLAR_POLLING += TO_PILLAR_POLLING_MIN;\n        this.mediaPillarKeepAlivePolling("START", this.TO_PILLAR_POLLING);\n        this.$log.warn("[WebrtcGatewayService] MediaPillarCallTerminator | Full cleaning");\n    }\n    ;\n    /*************************************************************/\n    /** MEDIAPILLAR USER                                        **/\n    /*************************************************************/\n    createMediaPillarContact(jid) {\n        this.$log.info("[webrtcGatewayService] createMediaPillarContact -- " + jid);\n        let contact = this.contactService.createBasicContact(jid);\n        contact.displayName = "mediaPillar";\n        contact.avatar = new Image();\n        contact.avatar.src = "/resources/skins/rainbow/images/conversations/unknownContact.png";\n        return contact;\n    }\n    ;\n    /*************************************************************/\n    /** MEDIA ACCESS                                            **/\n    /*************************************************************/\n    // private muteWebRTCAudio(muted) {\n    //     let webrtcCall = this.mediaPillarCallContext.webrtcCallRef;\n    //     let audioElem = angular.element("#largevideo")[0];\n    //     if (webrtcCall && audioElem) {\n    //         var session = this.xmppService.connection.jingle.sessions[webrtcCall.id];\n    //         if (session) {\n    //             session.muteAudio(muted);\n    //             audioElem["muted"] = muted;\n    //             this.$log.error("[webrtcGatewayService] muteWebRTCAudio -- " + muted ? "mute" : "unumute");\n    //         }\n    //         else {\n    //             this.$log.error("[webrtcGatewayService] muteWebRTCAudio -- failure");\n    //         }\n    //     };\n    // };\n    muteAudio(pbxCall, muted, conversation) {\n        if (!pbxCall) {\n            this.$log.error("[webrtcGatewayService] muteAudio - trying to mute a non existing call !");\n            return;\n        }\n        if (this.isMediaPillarCallSituation(pbxCall)) {\n            let webrtcCall = this.mediaPillarCallContext.webrtcCallRef;\n            if (webrtcCall) {\n                var session = this.xmppService.connection.jingle.sessions[webrtcCall.id];\n                if (session) {\n                    session.muteAudio(muted);\n                    pbxCall.isMuted = muted;\n                    if (conversation) {\n                        conversation.isMutedAudio = muted;\n                    }\n                    this.$log.info("[webrtcGatewayService] muteAudio conversation: " + (conversation ? conversation.id : "undefined") + " / call: " + pbxCall.id + "-- " + (muted ? "mute" : "unumute"));\n                    //send event\n                    let eventData = { call: pbxCall };\n                    if (conversation) {\n                        eventData["conversation"] = conversation;\n                    }\n                    this.$rootScope.$broadcast("ON_CONVERSATION_CALL_MUTED_UPDATED_EVENT", eventData);\n                }\n                else {\n                    this.$log.error("[webrtcGatewayService] muteAudio " + pbxCall.id + " -- failure: no session");\n                }\n            }\n        }\n    }\n    ;\n    getActivePbxCall() {\n        if (this.isMediaPillarCallCase() && this.mediaPillarCallContext) {\n            var activePbxCall = this.mediaPillarCallContext.telephonyCallRefs.find((pxbCall) => {\n                return pxbCall.status === call_model_1.Call.Status.ACTIVE;\n            });\n            return activePbxCall;\n        }\n        return null;\n    }\n    ;\n}\nWebrtcGatewayService.$inject = ["$q", "$rootScope", "$log", "$http", "authService", "$interval", "xmppService", "videoService", "errorHelperService", "contactService", "profileService", "uuid4", "telephonyService", "settingsService"];\nangular.module("rainbow").service("webrtcGatewayService", WebrtcGatewayService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/webrtcGateway/webrtcGatewayService.ts?')},function(module,exports){eval('angular.module("rainbow").service("callLogService", ["$q", "$log", "$rootScope", "$interval", "contactService", "xmppService", "CallLog", "orderByFilter", "profileService", "$injector", "telephonyService", "webrtcGatewayService", "utilService", function ($q, $log, $rootScope, $interval, contactService, xmppService, CallLog, orderByFilter, profileService, $injector, telephonyService, webrtcGatewayService, utilService) {\n  "use strict";\n  /*********************************************************/\n\n  /**                 LIFECYCLE STUFF                     **/\n\n  /*********************************************************/\n\n  var that = this;\n  this.started = false;\n  this.callLogs = [];\n  this.orderByNameCallLogs = [];\n  this.orderByDateCallLogs = [];\n  this.orderByDateCallLogsBruts = [];\n  this.simplifiedCallLogs = [];\n  this.callLogsPromises = []; //this.callLogRequestNS = "jabber:iq:webrtc:call:log";\n\n  this.callLogNamespace = "jabber:iq:telephony:call_log";\n  this.callLogAckNamespace = "urn:xmpp:telephony:call_log:receipts";\n  this.callLogNotificationsNamespace = "jabber:iq:notification:telephony:call_log";\n  this.callLogHandlerRef = null;\n  this.callLogMessageAckRef = null;\n  this.callLogNotificationRef = null;\n  this.numberMissedCalls = 0;\n  this.lastTimestamp = null;\n  this.callLogsHistory = [];\n  this.telephonyCallLog = {};\n  this.telephonyCallLogHistory = {};\n  this.deferedObject = null;\n  this.callLogComplete = false;\n  this.callLogIndex = -1;\n\n  this.start = function (stats) {\n    $log.info("");\n    $log.info("[callLogService] === STARTING ===");\n    this.attachHandlers();\n    $interval(function () {\n      var startDate = performance.now();\n      that.getCallLogHistoryPage().then(function () {\n        var startDuration = Math.round(performance.now() - startDate);\n        stats.push({\n          service: "callLogService",\n          startDuration: startDuration\n        });\n        $log.info("[callLogService] === STARTED (" + startDuration + " ms) ===");\n        that.started = true;\n      })["catch"](function () {\n        $log.error("[callLogService] === STARTING FAILURE ===");\n      });\n    }, 3000, 1, true);\n    return $q.when();\n  };\n\n  this.stop = function () {\n    $log.info("[callLogService] Stopping"); //remove all saved call logs\n\n    this.started = false;\n    this.callLogs = [];\n    this.callLogsPromises = [];\n    this.callLogHandlerRef = null;\n    this.callLogMessageAckRef = null;\n    this.orderByNameCallLogs = [];\n    this.orderByDateCallLogs = [];\n    this.orderByDateCallLogsBruts = [];\n    this.simplifiedCallLogs = [];\n    this.numberMissedCalls = 0;\n    this.lastTimestamp = null;\n    this.telephonyCallLog = {};\n    this.telephonyCallLogHistory = {};\n    this.callLogComplete = false;\n    this.callLogIndex = -1;\n    this.callLogsHistory = [];\n    $log.info("[callLogService] Stopped");\n    return $q.when();\n  };\n\n  this.attachHandlers = function () {\n    $log.info("[callLogService] attachHandlers");\n\n    if (that.callLogHandlerRef) {\n      xmppService.connection.deleteHandler(that.callLogHandlerRef);\n      that.callLogHandlerRef = null;\n    }\n\n    if (that.callLogMessageAckRef) {\n      xmppService.connection.deleteHandler(that.callLogMessageAckRef);\n      that.callLogMessageAckRef = null;\n    }\n\n    if (that.callLogNotificationRef) {\n      xmppService.connection.deleteHandler(that.callLogNotificationRef);\n      that.callLogNotificationRef = null;\n    }\n\n    that.callLogHandlerRef = xmppService.connection.addHandler(that.onCallLogMessageReceived, that.callLogNamespace, null, null);\n    that.callLogMessageAckRef = xmppService.connection.addHandler(that.onCallLogAckReceived, that.callLogAckNamespace, null, null);\n    that.callLogNotificationRef = xmppService.connection.addHandler(that.callLogNotificationReceived, that.callLogNotificationsNamespace, null, null); //if reconnection, update the call-logs\n\n    if (that.started && that.lastTimestamp) {\n      $interval(function () {\n        that.getCallLogHistoryPage(that.lastTimestamp);\n      }, 1000, 1, true);\n    }\n  };\n  /*********************************************************/\n\n  /**       MAM REQUESTS                                  **/\n\n  /*********************************************************/\n\n\n  this.getCallLogHistoryPage = function (useAfter) {\n    $log.info("[callLogService] getCallLogHistoryPage"); // Get the user contact\n\n    var userContact = contactService.userContact;\n    var useMax = 75;\n    var useBefore = ""; //add empty before in order to get the most recent messages\n    //var useAfter;\n\n    var message = $iq({\n      from: userContact.jid,\n      type: "set"\n    });\n    var msg = message.c("query", {\n      xmlns: this.callLogNamespace\n    });\n\n    if (useMax || useBefore || useAfter) {\n      msg.c("set", {\n        xmlns: "http://jabber.org/protocol/rsm"\n      });\n\n      if (useMax) {\n        msg.c("max").t(useMax).up();\n      }\n\n      if (useAfter) {\n        msg.c("after").t(useAfter).up();\n      } else {\n        msg.c("before").t(useBefore).up();\n      }\n\n      msg.up();\n    }\n\n    msg.up();\n    xmppService.sendIQ(msg);\n    return $q.when();\n  };\n\n  this.deleteOneCallLog = function (id) {\n    $log.info("[callLogService] deleteOneCallLog " + id); // Get the user contact\n\n    var userContact = contactService.userContact;\n    var message = $iq({\n      from: userContact.jid,\n      to: userContact.jid,\n      type: "set"\n    });\n    var msg = message.c("delete", {\n      xmlns: this.callLogNamespace,\n      call_id: id\n    });\n    xmppService.sendIQ(msg);\n  };\n\n  this.deleteCallLogsForContact = function (jid) {\n    $log.info("[callLogService] deleteCallLogsForContact " + jid); // Get the user contact\n\n    var userContact = contactService.userContact;\n    var message = $iq({\n      from: userContact.jid,\n      to: userContact.jid,\n      type: "set"\n    });\n    var msg = message.c("delete", {\n      xmlns: this.callLogNamespace,\n      peer: jid\n    });\n    xmppService.sendIQ(msg);\n  };\n\n  this.deleteAllCallLogs = function () {\n    $log.info("[callLogService] deleteAllCallLogs"); // Get the user contact\n\n    var userContact = contactService.userContact;\n    var message = $iq({\n      from: userContact.jid,\n      to: userContact.jid,\n      type: "set"\n    });\n    var msg = message.c("delete", {\n      xmlns: this.callLogNamespace\n    });\n    xmppService.sendIQ(msg);\n  };\n\n  this.markCallLogAsRead = function (id) {\n    $log.info("[callLogService] markCallLogAsRead " + id); // Get the user contact\n\n    var userContact = contactService.userContact;\n    var message = $msg({\n      from: userContact.jid,\n      to: userContact.jid\n    });\n    var msg = message.c("read", {\n      xmlns: this.callLogAckNamespace,\n      call_id: id\n    });\n    xmppService.sendIQ(msg);\n  };\n\n  this.markAllCallsLogsAsRead = function () {\n    $log.info("[callLogService] markAllCallsLogsAsRead ");\n    var userContact = contactService.userContact;\n\n    for (var i = 0; i < that.callLogs.length; i++) {\n      if (!that.callLogs[i].read) {\n        var message = $msg({\n          from: userContact.jid,\n          to: userContact.jid\n        });\n        var msg = message.c("read", {\n          xmlns: this.callLogAckNamespace,\n          call_id: that.callLogs[i].id\n        });\n        xmppService.sendIQ(msg);\n      }\n    }\n  };\n  /*********************************************************/\n\n  /**                  EVENT HANDLERS                     **/\n\n  /*********************************************************/\n\n\n  this.onCallLogMessageReceived = function (stanza) {\n    try {\n      //$log.info("[callLogService] onCallLogMessageReceived");\n      //console.log(stanza);\n      //handle message\n      if ($(stanza).find("call_log").length > 0) {\n        that.callLogsPromises.push(that.createCallLogFromMessage(stanza));\n      } //handle end of logs\n      else if ($(stanza).find("count").length > 0 && $(stanza).find("query").length > 0) {\n          //save last message timestamp\n          that.lastTimestamp = $(stanza).find("last").text();\n          $log.info("[callLogService] onCallLogMessageReceived : all call logs received");\n          $q.all(that.callLogsPromises)["finally"](function () {\n            $log.info("[callLogService] onCallLogMessageReceived : all call logs are ready");\n            that.callLogsPromises = [];\n            that.orderCallLogsFunction();\n            $rootScope.$broadcast("ON_CALL_LOG_UPDATED");\n            var num = that.getMissedCallLogCounter();\n\n            if (num !== that.numberMissedCalls) {\n              that.numberMissedCalls = num;\n              $rootScope.$broadcast("ON_CALL_LOG_ACK_UPDATED");\n            }\n          });\n        } //handle other messages\n        else {\n            $log.info("[callLogService] onCallLogMessageReceived : ignored !");\n          }\n    } catch (error) {\n      $log.error("[callLogService] onCallLogMessageReceived " + error);\n      return true;\n    }\n\n    return true;\n  };\n\n  this.onCallLogAckReceived = function (stanza) {\n    try {\n      $log.info("[callLogService] onCallLogAckReceived"); //console.log(stanza);\n\n      if ($(stanza).find("read").length > 0) {\n        var msgId = $(stanza).find("read").attr("call_id");\n        that.callLogAckUpdate(msgId);\n        var num = that.getMissedCallLogCounter();\n\n        if (num !== that.numberMissedCalls) {\n          that.numberMissedCalls = num;\n          $rootScope.$broadcast("ON_CALL_LOG_ACK_UPDATED");\n        }\n      }\n    } catch (error) {\n      $log.error("[callLogService] onCallLogAckReceived " + error);\n      return true;\n    }\n\n    return true;\n  };\n\n  this.callLogNotificationReceived = function (stanza) {\n    $log.info("[callLogService] callLogNotificationReceived"); //console.log(stanza);\n\n    try {\n      if ($(stanza).find("deleted_call_log").length > 0) {\n        $log.info("[callLogService] callLogNotificationReceived : deleted IQ");\n        var peer = $(stanza).find("deleted_call_log").attr("peer"); //no given user JID, reset all call-logs\n\n        if (!peer) {\n          that.resetCallLogs();\n        } else {\n          that.removeCallLogsForUser(peer);\n        }\n      } else if ($(stanza).find("updated_call_log").length > 0) {\n        $log.info("[callLogService] callLogNotificationReceived : Update call-logs");\n        that.callLogsPromises.push(that.createCallLogFromMessage(stanza));\n        $q.all(that.callLogsPromises)["finally"](function () {\n          $log.info("[callLogService] callLogNotificationReceived : update is done");\n          that.callLogsPromises = [];\n          that.orderCallLogsFunction();\n          $rootScope.$broadcast("ON_CALL_LOG_UPDATED");\n          var num = that.getMissedCallLogCounter();\n\n          if (num !== that.numberMissedCalls) {\n            that.numberMissedCalls = num;\n            $rootScope.$broadcast("ON_CALL_LOG_ACK_UPDATED");\n          }\n        });\n      }\n    } catch (error) {\n      $log.error("[callLogService] callLogNotificationReceived ERROR " + error);\n      return true;\n    }\n\n    return true;\n  };\n  /*********************************************************/\n\n  /**                  HELPER FUNCTIONS                   **/\n\n  /*********************************************************/\n\n\n  this.removeCallLogsForUser = function (jid) {\n    if (jid.endsWith("@_")) {\n      // Ticket 2629 : remove @_ from jid added by server for JIDisation...\n      jid = jid.substring(0, jid.length - 2);\n    }\n\n    $log.info("[callLogService] removeCallLogsForUser with jid: " + jid);\n    var newLogs = [];\n\n    for (var i = 0; i < that.callLogs.length; i++) {\n      if (!that.callLogs[i].contact || that.callLogs[i].contact.jid !== jid && that.callLogs[i].contact.id !== jid) {\n        newLogs.push(that.callLogs[i]);\n      }\n    }\n\n    that.callLogs = newLogs;\n    that.orderCallLogsFunction();\n    $rootScope.$broadcast("ON_CALL_LOG_UPDATED");\n    var num = that.getMissedCallLogCounter();\n\n    if (num !== that.numberMissedCalls) {\n      that.numberMissedCalls = num;\n      $rootScope.$broadcast("ON_CALL_LOG_ACK_UPDATED");\n    }\n  };\n\n  this.createCallLogFromMessage = function (message) {\n    // $log.info("[callLogService] createCallLogFromMessage"); MCO really verbose....\n    var defered = $q.defer();\n    var messageElem = $(message);\n    var otherParticipantJid = null;\n    var otherParticipantNumber = null;\n    var direction = "";\n    var id = messageElem.find("call_id").text();\n    var callerJid = messageElem.find("caller").text();\n    var calleeJid = messageElem.find("callee").text();\n    var state = messageElem.find("state").text();\n    var duration = parseInt(messageElem.find("duration").text(), 10);\n    var callSubject = messageElem.find("subject").text();\n    var foundidentity = "";\n    var identityFirstName = "";\n    var identityLastName = "";\n    var type = "webrtc";\n\n    if (callerJid && callerJid.indexOf("janusgateway") !== -1 || calleeJid && calleeJid.indexOf("janusgateway") !== -1) {\n      $log.info("[callLogService] createCallLogFromMessage ignore janusgateway call-logs");\n      $q.when();\n      return;\n    }\n\n    if (callerJid && webrtcGatewayService.isMediaPillarJid(callerJid) || calleeJid && webrtcGatewayService.isMediaPillarJid(calleeJid)) {\n      $log.info("[callLogService] createCallLogFromMessage ignore janusgateway call-logs");\n      $q.when();\n      return;\n    }\n\n    var typeCall = messageElem.find("call_log").attr("type"); //compatibility with the old method\n\n    if (!typeCall) {\n      typeCall = messageElem.find("type").text();\n    }\n\n    var read = messageElem.find("ack").attr("read") === "true";\n    var date = messageElem.find("delay").attr("stamp");\n    var conference = messageElem.find("call_log").attr("service") === "conference"; //check if phonebook search is allowed by profile else no result\n\n    if (profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_PHONE_BOOK) || config.permitSearchFromPhoneBook) {\n      foundidentity = messageElem.find("identity");\n    }\n\n    if (duration > 0) {\n      duration = moment.duration(duration, "ms").format("h[H] mm[m] ss[s]");\n    } else {\n      duration = 0;\n    }\n\n    if (date) {\n      date = new Date(date);\n    }\n\n    if (conference) {\n      otherParticipantJid = callerJid;\n      type = "conference";\n      direction = contactService.isUserContactJid(callerJid) ? "outgoing" : "incoming";\n\n      if (otherParticipantJid.indexOf("@") === -1) {\n        //telephone number\n        otherParticipantNumber = otherParticipantJid;\n        otherParticipantJid = null;\n      }\n    } else {\n      if (typeCall === "phone") {\n        type = "telephone";\n      }\n\n      if (contactService.isUserContactJid(callerJid)) {\n        otherParticipantJid = calleeJid;\n        direction = "outgoing";\n      } else {\n        otherParticipantJid = callerJid;\n        direction = "incoming";\n      }\n\n      if (otherParticipantJid.indexOf("@") === -1) {\n        //telephone number\n        otherParticipantNumber = otherParticipantJid;\n        otherParticipantJid = null;\n        type = "telephone";\n      }\n    }\n\n    if (otherParticipantJid || otherParticipantNumber) {\n      contactService.getOrCreateContact(otherParticipantJid, otherParticipantNumber).then(function (contact) {\n        $log.info("[callLogService] createCallLogFromMessage otherParticipant jid:" + otherParticipantJid + "  Number:" + utilService.anonymizePhoneNumber(otherParticipantNumber) + " => contact retrieved (temp:" + contact.temp + ")");\n\n        if (!conference && !otherParticipantJid && contact.temp) {\n          //only in case of temp contact\n          //find Xnames from directories\n          if (foundidentity && foundidentity.length) {\n            var foundFirstName = foundidentity.attr("firstName");\n            var foundLastName = foundidentity.attr("lastName");\n            var foundDisplayName = foundidentity.attr("displayName");\n            identityFirstName = foundFirstName ? foundFirstName : "";\n            identityLastName = foundLastName ? foundLastName : "";\n\n            if (identityLastName === "" && identityFirstName === "" && foundDisplayName && foundDisplayName.length !== 0 && foundDisplayName !== otherParticipantNumber) {\n              identityLastName = foundDisplayName; //hack to use displayName instead of lastName (when lastName not available)\n            }\n\n            if (identityFirstName.length || identityLastName.length) {\n              //update contact\n              $log.debug("[callLogService] createCallLogFromMessage  xNames updated from directories for contact " + contact.id);\n              contact.updateName(identityFirstName, identityLastName);\n            }\n          } else {\n            //try to find in outlook\n            try {\n              var centralizedService = $injector.get("centralizedService");\n              var reload = true;\n              centralizedService.outlook.updateContactFromOutlookInfos(contact, otherParticipantNumber, reload).then(function successCallback(updateStatus) {\n                if (updateStatus) {\n                  $log.debug("[callLogService] createCallLogFromMessage  xNames updated from outlook for contact " + contact.id);\n                } else {\n                  $log.debug("[callLogService] createCallLogFromMessage no update from outlook for contact :" + contact.id);\n                }\n              }, function errorCallback() {\n                $log.debug("[callLogService] createCallLogFromMessage  no Outlook search available");\n              });\n            } catch (error) {\n              /* for SDK */\n            }\n          } //#29830++\n          //if displayNmane is a phone number (and only for contact.temp)\n          //then use phoneProcan as displayName and display only that in calllog (done in callLogsCell.html)\n\n\n          var displayNameisAPhoneNumber = false;\n          var phone_number_regex = /^[0-9A-D #\\-\\+\\*\\(\\)\\./]{1,32}$/;\n\n          if (telephonyService.started) {\n            var matchAsNumber = contact.displayName.match(phone_number_regex);\n            displayNameisAPhoneNumber = matchAsNumber && telephonyService.startAsPhoneNumber(contact.displayName);\n          }\n\n          if (displayNameisAPhoneNumber) {\n            if (contact.phoneProCan && contact.phoneProCan !== "") {\n              contact.displayName = contact.phoneProCan; //use phoneProCan as displayName\n            }\n          } //#29830--\n\n        }\n\n        var callLog = CallLog.create(id, contact, state, duration, type, read, date, direction, callSubject); //do not push up duplicates\n\n        if (!that.logAlreadyExists(callLog) && state !== "failed" && state !== "ongoing") {\n          that.callLogs.push(callLog);\n        } else {\n          $log.info("[callLogService] createCallLogFromMessage ignore call log with id: " + id + ", state: " + state);\n        }\n\n        $log.info("[callLogService] createCallLogFromMessage success");\n        defered.resolve(callLog);\n      })["catch"](function (error) {\n        $log.error("[callLogService] createCallLogFromMessage error " + error);\n        defered.resolve();\n      });\n    } else {\n      $log.info("[callLogService] createCallLogFromMessage  No jid or no phoneNumber ");\n      defered.resolve();\n    }\n\n    return defered.promise;\n  };\n\n  this.getOrderByNameCallLogs = function () {\n    return that.orderByNameCallLogs;\n  };\n\n  this.getOrderByDateCallLogs = function () {\n    if (that.orderByDateCallLogs.length !== 0) {\n      that.orderByDateCallLogs[0].isLatestCall = true; //update the latest callLog to show its subject next to the contact name.\n\n      if (that.orderByDateCallLogs[1]) {\n        that.orderByDateCallLogs[1].isLatestCall = false;\n      }\n    }\n\n    return that.orderByDateCallLogs;\n  };\n\n  this.getOrderByDateCallLogsBruts = function () {\n    return that.orderByDateCallLogsBruts;\n  }; //call logs where the contact is replaced by his JID or telephone number\n\n\n  this.getSimplifiedCallLogs = function () {\n    return that.simplifiedCallLogs;\n  };\n\n  this.orderCallLogsFunction = function () {\n    $log.info("[callLogService] orderByFunction");\n    that.orderByNameCallLogs = orderByFilter(that.callLogs, CallLog.getNames, false, CallLog.sortByContact);\n    that.orderByDateCallLogsBruts = orderByFilter(that.callLogs, CallLog.getDate, false, CallLog.sortByDate);\n    that.simplifiedCallLogs = that.simplifyCallLogs(that.orderByDateCallLogsBruts);\n    that.orderByNameCallLogs = that.fusionInformation(that.orderByNameCallLogs);\n    that.orderByDateCallLogs = that.fusionInformation(that.orderByDateCallLogsBruts);\n  };\n\n  this.simplifyCallLogs = function (callLogs) {\n    var result = [];\n\n    for (var i = 0; i < callLogs.length; i++) {\n      result[i] = {};\n      result[i].contact = callLogs[i].contact.id;\n      result[i].contactDisplayName = callLogs[i].contact.displayName;\n      result[i].contactInitials = callLogs[i].contact.initials;\n      result[i].id = callLogs[i].id;\n      result[i].state = callLogs[i].state;\n      result[i].duration = callLogs[i].duration;\n      result[i].direction = callLogs[i].direction;\n      result[i].type = callLogs[i].type;\n      result[i].read = callLogs[i].read;\n      result[i].date = callLogs[i].date;\n    }\n\n    return result;\n  };\n\n  this.fusionInformation = function (callLogs) {\n    var passed = {};\n    var current = 0;\n    var fusion = [];\n\n    for (var i = 0; i < callLogs.length; i++) {\n      var log = callLogs[i];\n      var jid = log.contact.jid;\n\n      if (!log.contact.jid) {\n        jid = log.contact.id;\n      } //if conference log\n\n\n      if (log.type === "conference") {\n        if (i !== 0) {\n          current++;\n        }\n\n        fusion[current] = log;\n        fusion[current].count = 1;\n        fusion[current].editable = false;\n        continue;\n      } //first element\n\n\n      if (i === 0) {\n        passed[jid] = 1;\n        fusion[current] = log;\n        fusion[current].count = 1;\n        fusion[current].editable = true;\n\n        if (log.state === "missed" && log.direction === "incoming") {\n          fusion[current].isMissed = true;\n        } else if (log.state === "missed" && log.direction === "outgoing") {\n          fusion[current].isNotAnswered = true;\n        }\n\n        continue;\n      } //if we already have this element\n\n\n      if (passed[jid]) {\n        var index = passed[jid];\n        var element = fusion[index - 1];\n\n        if (element.editable) {\n          if (element.isMissed && log.state === "missed" && log.direction === "incoming") {\n            element.count++;\n          } else if (element.isNotAnswered && log.state === "missed" && log.direction === "outgoing") {\n            element.count++;\n          } else {\n            element.editable = false;\n          }\n        }\n      } //new element\n      else {\n          current++;\n          passed[jid] = current + 1;\n          fusion[current] = log;\n          fusion[current].count = 1;\n          fusion[current].editable = true;\n\n          if (log.state === "missed" && log.direction === "incoming") {\n            fusion[current].isMissed = true;\n          } else if (log.state === "missed" && log.direction === "outgoing") {\n            fusion[current].isNotAnswered = true;\n          }\n\n          continue;\n        }\n    }\n\n    return fusion;\n  }; //update ACK for call log with ID\n\n\n  this.callLogAckUpdate = function (id) {\n    that.callLogs.forEach(function (callLog) {\n      if (callLog.id === id) {\n        callLog.read = true;\n        return;\n      }\n    });\n  }; //get number of non-ack missed calls\n\n\n  this.getMissedCallLogCounter = function () {\n    var num = 0;\n    that.callLogs.forEach(function (callLog) {\n      if (!callLog.read && callLog.state === "missed" && callLog.direction === "incoming") {\n        num++;\n      }\n    });\n    return num;\n  };\n\n  this.getNumberMissedCalls = function () {\n    return that.numberMissedCalls;\n  };\n\n  this.resetCallLogs = function () {\n    $log.info("[callLogService] resetCallLogs");\n    that.callLogs = [];\n    that.getCallLogHistoryPage();\n  };\n\n  this.logAlreadyExists = function (log) {\n    var i;\n\n    for (i = 0; i < that.callLogs.length; i++) {\n      if (that.callLogs[i].id === log.id) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/callLogService.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__);\n\nangular.module("rainbow").service("videoService", ["$q", "$rootScope", "$window", "$log", "$http", "$interval", "xmppService", "contactService", "browserService", "gRTCStatsService", "fRTCStatsService", "platformService", "gaService", "settingsService", "authService", "VideoServiceEventHandler", "extensionSharingService", function ($q, $rootScope, $window, $log, $http, $interval, xmppService, contactService, browserService, gRTCStatsService, fRTCStatsService, platformService, gaService, settingsService, authService, VideoServiceEventHandler, extensionSharingService) {\n  "use strict"; // Save context\n\n  var that = this; // Public parameters\n\n  this.started = false;\n  this.connected = false;\n  this.RTC = null;\n  this.videoEventHandler = null;\n  this.config = null;\n  this.calls = {};\n  this.localStream = null;\n  this.autoreleaseTimeout = null;\n  this.callsStats = {};\n  this.localStreams = [];\n  this.makingCall = false;\n  this.reconnectCall = false;\n  this.statsInterval = null;\n  this.audioProfileChanging = false;\n  this.reverseAudioCallInitiated = false;\n  this.alreadyAttaching = false;\n  var listeners = [];\n  this.callsStatsSimplified = {};\n\n  this.allowDesktopSharing = function () {\n    return false;\n  };\n\n  this.allowAdvancedDesktopSharing = function () {\n    return false;\n  };\n\n  this.getDesktopSharingSource = function () {\n    return null;\n  };\n\n  this.askToAddSharing = function (__conversation_id) {\n    return false;\n  };\n\n  this.askToStartSharing = function (__contact_id, __media) {\n    return false;\n  };\n\n  this.isNativeApplication = function () {\n    return false;\n  };\n  /*************************************************************/\n\n  /**              SERVICE LIFECYCLE STUFF                    **/\n\n  /*************************************************************/\n\n\n  this.start = function (stats) {\n    $log.webrtc("[videoService] SERVICE | === STARTING ===");\n    var startDate = performance.now();\n    this.RTC = that.getBrowserMethodHandler();\n\n    if (!this.RTC) {\n      $log.error("[videoService] SERVICE | === STARTING FAILURE ===  webRTC capable browser is really required !");\n    } else {\n      // Set RTC configuration\n      that.started = true;\n      that.connected = true;\n      that.setWebrtcConfiguration();\n      var startDuration = Math.round(performance.now() - startDate);\n      stats.push({\n        service: "videoService",\n        startDuration: startDuration\n      });\n      $log.info("[videoService] SERVICE | === STARTED (" + startDuration + " ms) ===");\n    }\n\n    listeners.push($rootScope.$on("ON_CONNECTION_STATE_CHANGE_EVENT", that.onConnectionStateChangeEvent));\n    listeners.push($rootScope.$on("ON_INPUT_DEVICE_CHANGED_EVENT", that.onAudioProfileChangeEvent));\n    listeners.push($rootScope.$on("ON_VIDEO_INPUT_DEVICE_CHANGED_EVENT", that.onVideoInputChangeEvent));\n    this.attachHandlers();\n    return $q.when();\n  };\n\n  this.stop = function () {\n    try {\n      if (this.started) {\n        $log.webrtc("[videoService] SERVICE | === STOPPING ===");\n        this.started = false; // Remove listeners\n\n        var listener;\n\n        while (listener = listeners.pop()) {\n          listener();\n        }\n\n        that.removeHandlers();\n        that.config = null;\n\n        for (var key in that.calls) {\n          if (that.calls.hasOwnProperty(key)) {\n            var call = that.calls[key];\n            that.removeCallObject(call);\n          }\n        } // Terminate the session\n\n\n        xmppService.connection.jingle.terminate();\n        that.connected = false;\n        that.reconnectCall = false;\n        that.makingCall = false;\n\n        if (that.statsInterval) {\n          window.clearInterval(that.statsInterval);\n        }\n\n        $log.webrtc("SERVICE | === STOPPED ===");\n      }\n\n      return $q.when();\n    } catch (error) {\n      $log.webrtc("[videoService] SERVICE | === STOPPING ERROR : " + error);\n      return $q.when();\n    }\n  };\n\n  this.attachHandlers = function () {\n    this.removeHandlers();\n    $log.info("[videoService] attachHandlers");\n    this.videoEventHandler = VideoServiceEventHandler.create(this);\n  };\n\n  this.removeHandlers = function () {\n    $log.info("[videoService] removeHandlers"); //remove conversation handlers\n\n    if (this.videoEventHandler) {\n      this.videoEventHandler = null;\n    }\n  };\n\n  this.setWebrtcConfiguration = function () {\n    $log.webrtc("[videoService] setWebrtcConfiguration");\n    return $q(function (resolve, reject) {\n      if (that.config) {\n        $log.webrtc("[videoService] setWebrtcConfiguration from stored variable");\n        xmppService.connection.jingle.ice_config = that.config;\n        resolve();\n      } else {\n        $log.webrtc("[videoService] setWebrtcConfiguration from server");\n        that.getIceConfig().then(function (config) {\n          that.config = config; // that.config["rtcpMuxPolicy"] = "require";\n\n          /*if (adapter.default.browserDetails.browser === "chrome") {\n              //Don\'t use max-bundle on chrome (fix screensharing with firefox)\n              $log.info("Max-bundle disabled on chrome");\n              that.config["bundlePolicy"] = "balanced";\n          }*/\n          // that.config["bundlePolicy"] = "max-bundle";\n          //enable DSCP values if settings is set\n\n          var enableDSCP = settingsService.getSetting("enableDSCP") === "true";\n\n          if (enableDSCP) {\n            $log.webrtc("[videoService] setWebrtcConfiguration - DSCP is enabled");\n            that.config.enableDSCP = true;\n          }\n\n          var filterIce = settingsService.getSetting("filterIce") === "true";\n\n          if (filterIce) {\n            $log.webrtc("[videoService] setWebrtcConfiguration - filterIce is enabled");\n            that.config.filterIce = true;\n          }\n\n          var DTX = settingsService.getSetting("dtx") === "true";\n\n          if (DTX) {\n            $log.webrtc("[videoService] setWebrtcConfiguration - DTX is enabled");\n            that.config.dtx = true;\n          }\n\n          var simulcast = settingsService.getSetting("simulcast") === "true";\n\n          if (simulcast) {\n            $log.webrtc("[videoService] setWebrtcConfiguration - Simulcasting is enabled");\n            that.config.simulcast = true;\n          }\n\n          var unifiedPlan = settingsService.getSetting("unifiedPlan") === "true";\n\n          if (unifiedPlan) {\n            $log.webrtc("[videoService] setWebrtcConfiguration - unifiedPlan is enabled");\n            that.config.unifiedPlan = true;\n          }\n\n          var debugWeRTC = settingsService.getSetting("debugWebRTC") === "true";\n\n          if (debugWeRTC) {\n            $log.webrtc("[videoService] setWebrtcConfiguration - unifiedPlan is enabled");\n            that.config.debugWeRTC = true;\n          }\n\n          xmppService.connection.jingle.ice_config = that.config;\n          settingsService.setIceConfig(that.config);\n          $log.webrtc("[videoService] setWebrtcConfiguration from server success !");\n          resolve();\n        })["catch"](function (error) {\n          $log.error("[videoService] setWebrtcConfiguration from server ERROR : " + error);\n\n          if (error.status !== -1) {\n            that.openErrorPopup("IceConfigurationFailed");\n          }\n\n          reject();\n        });\n      }\n    });\n  };\n\n  this.onConnectionStateChangeEvent = function (__event, status) {\n    try {\n      if (status === "disconnected") {\n        $log.info("MEDIA   | onConnectionStateChangeEvent : disconnected");\n        that.connected = false; //remove ICE configuration\n\n        that.config = null;\n\n        for (var key in that.calls) {\n          if (that.calls.hasOwnProperty(key)) {\n            var call = that.calls[key]; //should reconnect the call after reconnection\n\n            that.reconnectCall = true;\n\n            if (call && call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN) {\n              $log.webrtc("INFO    | onConnectionStateChangeEvent : disconnected -> call goes to connecting state");\n              call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.CONNECTING);\n              $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n            }\n\n            if (that.statsInterval) {\n              window.clearInterval(that.statsInterval);\n            }\n          }\n        }\n      } else if (status === "connected") {\n        $log.info("MEDIA   | onConnectionStateChangeEvent : connected");\n        that.attachHandlers();\n        that.setWebrtcConfiguration();\n        that.connected = true;\n\n        if (that.statsInterval) {\n          window.clearInterval(that.statsInterval);\n          that.statsinterval = null;\n        }\n\n        for (var key in that.calls) {\n          if (that.calls.hasOwnProperty(key)) {\n            var call = that.calls[key];\n            var session = xmppService.connection.jingle.sessions[call.id];\n\n            if (that.reconnectCall && session && session.peerconnection) {\n              $log.info("MEDIA   | onConnectionStateChangeEvent : connected - start reconnection on session " + call.id); // session.connection = xmppService.connection.jingle.connection;\n\n              session.me = contactService.userContact.fullJid;\n\n              if (session.isInitiator) {\n                session.initiator = session.me;\n              }\n\n              session.connection = xmppService.connection;\n              contactService.setBusyState("dnd", that.calculatePresenceMessage(call));\n              session.reconnectSession();\n            }\n          }\n        }\n\n        that.reconnectCall = false;\n      }\n    } catch (error) {\n      $log.info("MEDIA   | onConnectionStateChangeEvent : disconnected error : " + error);\n    }\n  };\n\n  that.isUserContactInCall = function () {\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  this.getCurrentActiveSession = function () {\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN) {\n          return xmppService.connection.jingle.sessions[call.id];\n        }\n      }\n    }\n\n    return null;\n  };\n  /* \n  * return the mediapillar audio webrtc call\n  */\n\n\n  that.getMediaPillarAudioCall = function () {\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN && call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO && call.isMediaPillarCall()) {\n          return call;\n        }\n      }\n    }\n\n    return null;\n  };\n  /* \n  * return the audio webrtc call\n  */\n\n\n  that.getWebrtcAudioCall = function () {\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN && call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO && !call.isMediaPillarCall()) {\n          return call;\n        }\n      }\n    }\n\n    return null;\n  };\n  /* \n  * return the mediapillar session\n  */\n\n\n  that.getMediaPillarSession = function () {\n    var mediaPillarAudioCall = that.getMediaPillarAudioCall();\n\n    if (mediaPillarAudioCall) {\n      return xmppService.connection.jingle.sessions[mediaPillarAudioCall.id];\n    }\n\n    return null;\n  };\n  /* \n  * return the current pure sharing webrtc call\n  */\n\n\n  that.getCurrentSharingCall = function () {\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN && (call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING || call.remoteMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING)) {\n          return call;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  that.endAllCallsForContact = function (contact) {\n    if (!contact) {\n      return;\n    }\n\n    $log.webrtc("[videoService] endAllCallsForContact " + contact.jid);\n\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN && call.contact && call.contact.jid === contact.jid) {\n          that.releaseCall(call);\n        }\n      }\n    }\n  };\n\n  that.onVideoInputChangeEvent = function () {\n    $log.webrtc("MEDIA   | onVideoInputChangeEvent");\n\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n        var session = xmppService.connection.jingle.sessions[call.id]; //check current call type\n\n        if (session && call.localMedia && call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO + _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n          //audio + video\n          $log.webrtc("MEDIA   | audio + video call, renegotiate the profile");\n          that.escalateToVideoCall(call, true);\n        }\n      }\n    }\n  };\n\n  that.onAudioProfileChangeEvent = function () {\n    $log.webrtc("MEDIA   | onAudioProfileChangeEvent");\n\n    if (that.audioProfileChanging) {\n      $log.webrtc("MEDIA   | onAudioProfileChangeEvent -- already changing");\n      return;\n    }\n\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n        var session = xmppService.connection.jingle.sessions[call.id]; //check current call type\n\n        if (session && call.localMedia) {\n          that.audioProfileChanging = true;\n          $interval(function (currentCall) {\n            that.audioProfileChanging = false;\n            that.renegotiateCurrentCall(currentCall);\n          }, 500, 1, true, call);\n        }\n      }\n    }\n  };\n\n  this.renegotiateCurrentCall = function (call) {\n    if (call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO || call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO + _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n      $log.webrtc("MEDIA   | renegotiate the audio profile");\n      that.addAudioToCall(call, true);\n    } //audio + video or audio + video + sharing\n    else if (call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO + _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO || call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO + _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING + _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n        $log.webrtc("MEDIA   | audio + video call, renegotiate the profile");\n        that.addVideoToCall(call, true);\n      }\n  };\n\n  this.getCallByJid = function (jid) {\n    var result = null;\n\n    if (!jid) {\n      return result;\n    }\n\n    $log.webrtc("[videoService] getCallByJid " + jid);\n\n    for (var key in that.calls) {\n      if (that.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.contact && call.contact.jid === jid) {\n          result = call;\n          break;\n        }\n      }\n    }\n\n    return result;\n  };\n\n  this.resetAudioOutputElement = function () {\n    if (!platformService.allowDevicesManagement() || this.audioProfileChanging) {\n      return;\n    }\n\n    if (!$("#globalAudioTag").length) {\n      $log.warn("[videoService] resetAudioOutputElement -- missing global audio tag !");\n      return;\n    }\n\n    $log.webrtc("[videoService] resetAudioOutputElement");\n    this.audioProfileChanging = true;\n    platformService.getCurrentSpeaker().then(function (device) {\n      var sinkId = "default";\n\n      if (device && device.id) {\n        sinkId = device.id;\n      } //find another output device to set the sink to it \n\n\n      var anotherSink = "default";\n\n      if (sinkId !== "default") {\n        DetectRTC.audioOutputDevices.forEach(function (output) {\n          if (output.deviceId !== "default" && output.deviceId !== "communications" && output.deviceId !== sinkId) {\n            anotherSink = output.deviceId;\n          }\n        });\n      } //sink his ID\n\n\n      $("#globalAudioTag")[0].setSinkId(anotherSink).then(function () {\n        $log.webrtc("[videoService] resetAudioOutputElement sinkId is " + $("#globalAudioTag")[0].sinkId);\n\n        if (sinkId !== "default") {\n          $("#globalAudioTag")[0].setSinkId(sinkId).then(function () {\n            $log.webrtc("[videoService] resetAudioOutputElement sinkId is " + $("#globalAudioTag")[0].sinkId);\n            that.audioProfileChanging = false;\n\n            if ($("#globalAudioTag")[0].load) {\n              $("#globalAudioTag")[0].load();\n            }\n          })["catch"](function () {\n            that.audioProfileChanging = false;\n          });\n        } else {\n          that.audioProfileChanging = false;\n        }\n      })["catch"](function (error) {\n        $log.warn("[videoService] resetAudioOutputElement globalAudioTag error " + error);\n        that.audioProfileChanging = false;\n      });\n      $interval(function () {\n        if ($("#largevideo")[0]) {\n          $("#largevideo")[0].setSinkId(anotherSink).then(function () {\n            $log.webrtc("[videoService] resetAudioOutputElement largevideo " + $("#largevideo")[0].sinkId);\n\n            if (sinkId !== "default") {\n              $("#largevideo")[0].setSinkId(sinkId).then(function () {\n                $log.webrtc("[videoService] resetAudioOutputElement largevideo " + $("#largevideo")[0].sinkId);\n              })["catch"](function (error) {\n                $log.warn("[videoService] resetAudioOutputElement largevideo error " + error);\n              });\n            }\n          })["catch"](function (error) {\n            $log.warn("[videoService] resetAudioOutputElement largevideo error " + error);\n          });\n        }\n\n        if ($("#p2pSecondVideo")[0]) {\n          $("#p2pSecondVideo")[0].setSinkId(anotherSink).then(function () {\n            if (sinkId !== "default") {\n              $("#p2pSecondVideo")[0].setSinkId(sinkId).then(function () {\n                $log.webrtc("[videoService] resetAudioOutputElement p2pSecondVideo " + $("#p2pSecondVideo")[0].sinkId);\n              })["catch"](function (error) {\n                $log.warn("[videoService] resetAudioOutputElement p2pSecondVideo error " + error);\n              });\n            }\n          })["catch"](function (error) {\n            $log.warn("[videoService] resetAudioOutputElement p2pSecondVideo error " + error);\n          });\n        }\n      }, 3000, 1);\n    })["catch"](function () {\n      $log.webrtc("[videoService] resetAudioOutputElement getCurrentSpeaker error");\n      that.audioProfileChanging = false;\n    });\n  };\n  /*************************************************************/\n\n  /* VIDEO CONTROL STUFF                                       */\n\n  /*************************************************************/\n\n\n  this.disableAudioVideoMedia = function (session, sessionId) {\n    if (session) {\n      $log.webrtc("MEDIA   | disableAudioVideoMedia for session " + JSON.stringify({\n        sid: session.sid\n      }));\n    } else if (sessionId) {\n      $log.webrtc("MEDIA   | disableAudioVideoMedia no session, sessionId: " + sessionId);\n    } else {\n      $log.webrtc("MEDIA   | disableAudioVideoMedia no session, no session Id");\n    }\n\n    if (!session && !sessionId) {\n      //used when we want to force a safe state:\n      var localStreamsLength = that.localStreams.length;\n\n      if (that.localStreams.length > 0) {\n        //We stop all the localStreams\n        that.localStreams.forEach(function (stream) {\n          stream.getTracks().forEach(function (track) {\n            track.enabled = false;\n            track.stop();\n            track = null;\n          });\n\n          if (stream.stop) {\n            stream.stop();\n          }\n\n          stream = null;\n        }); //We remove all the localStreams\n\n        while (that.localStreams.length > 0) {\n          var temp = that.localStreams.pop();\n          temp = null;\n        }\n      }\n\n      $log.webrtc("MEDIA   | disableAudioVideoMedia : All local streams stopped and removed: " + localStreamsLength);\n    }\n\n    if (session) {\n      if (session.localStreams.length > 0) {\n        //We stop the streams of this session\n        var sessionStreamsLength = session.localStreams.length;\n        session.localStreams.forEach(function (stream) {\n          stream.getTracks().forEach(function (track) {\n            track.enabled = false;\n            track.stop();\n            track = null;\n          });\n\n          if (stream.stop) {\n            stream.stop();\n          }\n\n          stream = null;\n        }); //remove session\'s streams from localStreams global object\n\n        that.localStreams = that.localStreams.filter(function (localStream) {\n          return !session.localStreams.includes(localStream);\n        }); //remove session\'s streams\n\n        while (session.localStreams.length > 0) {\n          var temp = session.localStreams.pop();\n          temp = null;\n        }\n\n        $log.webrtc("MEDIA   | disableAudioVideoMedia : Session streams stopped and removed: " + sessionStreamsLength + ". Remaining local streams: " + that.localStreams.length);\n      }\n    } else if (sessionId) {\n      //no session anymore (session has already been terminated)\n      //we just have to stop and remove the localStreams saved for this sessionId\n      var streams = that.localStreams.filter(function (localStream) {\n        return localStream.callId === sessionId;\n      });\n\n      if (streams) {\n        var sessionStreamsLength = streams.length;\n        streams.forEach(function (stream) {\n          stream.getTracks().forEach(function (track) {\n            track.enabled = false;\n            track.stop();\n            track = null;\n          });\n\n          if (stream.stop) {\n            stream.stop();\n          } // remove from localStreams global object, the local stream for this sessionId \n\n\n          that.localStreams.splice(that.localStreams.indexOf(stream), 1);\n          stream = null;\n        });\n        $log.webrtc("MEDIA   | disableAudioVideoMedia : Locals streams for sessionId " + sessionId + " stopped and removed: " + sessionStreamsLength + ". Remaining local streams: " + that.localStreams.length);\n      }\n    }\n\n    if (that.statsInterval) {\n      window.clearInterval(that.statsInterval);\n      that.statsinterval = null;\n    }\n  };\n\n  this.clearSrcObjectsFromElements = function () {\n    this.RTC.clearMediaStream(angular.element("#largevideo"), null);\n    this.RTC.clearMediaStream(angular.element("#globalVideoTag"), null);\n    this.RTC.clearMediaStream(angular.element("#globalAudioTag"), null);\n  };\n\n  this.attachDistantMediaStreamsUnifiedPlan = function (call) {\n    console.error("attachDistantMediaStreamsUnifiedPlan");\n    var sess = xmppService.connection.jingle.sessions[call.id]; // audio\n\n    if (sess.remoteStreamsObject["0"]) {\n      $log.webrtc("attachDistantMediaStreams audio track for element globalAudioTag " + sess.remoteStreamsObject["0"].id);\n      this.RTC.attachMediaStream(angular.element("#globalAudioTag"), sess.remoteStreamsObject["0"]);\n    } // video & sharing\n\n\n    if (sess.remoteStreamsObject["1"] && sess.remoteStreamsObject["2"]) {\n      this.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), sess.remoteStreamsObject["2"], sess.remoteStreamsObject["2"].id);\n\n      if (angular.element("#largevideo")[0]) {\n        angular.element("#largevideo")[0].muted = true;\n        angular.element("#largevideo")[0].volume = 0;\n      }\n\n      this.RTC.attachMediaStreamIfNeeded(angular.element("#p2pSecondVideo"), sess.remoteStreamsObject["1"], sess.remoteStreamsObject["2"].id);\n\n      if (angular.element("#p2pSecondVideo")[0]) {\n        angular.element("#p2pSecondVideo")[0].muted = true;\n        angular.element("#p2pSecondVideo")[0].volume = 0;\n      }\n    } // video\n    else if (sess.remoteStreamsObject["1"]) {\n        this.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), sess.remoteStreamsObject["1"], sess.remoteStreamsObject["1"].id);\n\n        if (angular.element("#largevideo")[0]) {\n          angular.element("#largevideo")[0].muted = true;\n          angular.element("#largevideo")[0].volume = 0;\n        }\n      } // sharing\n      else if (sess.remoteStreamsObject["2"]) {\n          this.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), sess.remoteStreamsObject["2"], sess.remoteStreamsObject["2"].id);\n\n          if (angular.element("#largevideo")[0]) {\n            angular.element("#largevideo")[0].muted = true;\n            angular.element("#largevideo")[0].volume = 0;\n          }\n        }\n  };\n\n  this.attachDistantMediaStreams = function (attach, call) {\n    if (attach) {\n      if (that.alreadyAttaching) {\n        return;\n      }\n\n      that.alreadyAttaching = true;\n\n      if (call.unifiedPlanActivated) {\n        that.attachDistantMediaStreamsUnifiedPlan(call);\n        that.alreadyAttaching = false;\n        return;\n      }\n\n      var sess = xmppService.connection.jingle.sessions[call.id];\n\n      if (sess.remoteStreams) {\n        if (sess.remoteStreams.length > 1) {\n          //we\'ve two incoming media streams\n          var mainRemoteTrack;\n          var secondRemoteTrack; //video is in bundle with audio, so set main session to sharing\n\n          if (sess.remoteStreams[0].getAudioTracks().length) {\n            secondRemoteTrack = sess.remoteStreams[0];\n            mainRemoteTrack = sess.remoteStreams[1];\n          } else {\n            mainRemoteTrack = sess.remoteStreams[0];\n            secondRemoteTrack = sess.remoteStreams[1];\n          }\n\n          if (mainRemoteTrack.getVideoTracks().length > 0) {\n            $log.webrtc("attachDistantMediaStreams video track for element largevideo " + mainRemoteTrack.id);\n            that.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), mainRemoteTrack, mainRemoteTrack.id);\n\n            if (angular.element("#largevideo")[0]) {\n              angular.element("#largevideo")[0].muted = true;\n              angular.element("#largevideo")[0].volume = 0;\n            }\n          }\n\n          if (mainRemoteTrack.getAudioTracks().length > 0) {\n            $log.webrtc("attachDistantMediaStreams audio track for element globalAudioTag " + mainRemoteTrack.id);\n            that.RTC.attachMediaStream(angular.element("#globalAudioTag"), mainRemoteTrack);\n          }\n\n          if (secondRemoteTrack.getVideoTracks().length > 0) {\n            $log.webrtc("attachDistantMediaStreams video track for element p2pSecondVideo " + secondRemoteTrack.id);\n            that.RTC.attachMediaStreamIfNeeded(angular.element("#p2pSecondVideo"), secondRemoteTrack, secondRemoteTrack.id);\n\n            if (angular.element("#p2pSecondVideo")[0]) {\n              angular.element("#p2pSecondVideo")[0].muted = true;\n              angular.element("#p2pSecondVideo")[0].volume = 0;\n            }\n          }\n\n          if (secondRemoteTrack.getAudioTracks().length > 0) {\n            $log.webrtc("attachDistantMediaStreams audio track for element globalAudioTag " + secondRemoteTrack.id);\n            that.RTC.attachMediaStream(angular.element("#globalAudioTag"), secondRemoteTrack);\n          }\n        } else {\n          //we\'ve only one incoming media stream\n          sess.remoteStreams.forEach(function (track) {\n            if (track.getVideoTracks().length > 0) {\n              $log.webrtc("attachDistantMediaStreams video track");\n              that.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), track, track.id);\n\n              if (angular.element("#largevideo")[0]) {\n                angular.element("#largevideo")[0].muted = true;\n                angular.element("#largevideo")[0].volume = 0;\n              }\n\n              that.RTC.attachMediaStreamIfNeeded(angular.element("#p2pSecondVideo"), track, track.id);\n\n              if (angular.element("#p2pSecondVideo")[0]) {\n                angular.element("#p2pSecondVideo")[0].muted = true;\n                angular.element("#p2pSecondVideo")[0].volume = 0;\n              }\n            }\n\n            if (track.getAudioTracks().length > 0) {\n              $log.webrtc("attachDistantMediaStreams audio track");\n              that.RTC.attachMediaStream(angular.element("#globalAudioTag"), track);\n            }\n          });\n        }\n\n        that.alreadyAttaching = false;\n      }\n    } else {\n      if (!that.isUserContactInCall()) {\n        this.RTC.clearMediaStream(angular.element("#largevideo"), null);\n        this.RTC.clearMediaStream(angular.element("#globalVideoTag"), null);\n        this.RTC.clearMediaStream(angular.element("#globalAudioTag"), null);\n      }\n    }\n  };\n\n  this.attachLocalMediaStreams = function (attach) {\n    $log.webrtc("attachLocalMediaStreams " + attach);\n\n    if (attach) {\n      if (this.localStreams && this.localStreams.length) {\n        var firstVideoStream = false;\n        this.localStreams.forEach(function (track) {\n          //if audio/video track\n          if (track.getVideoTracks().length && track.getAudioTracks().length) {\n            if (!firstVideoStream) {\n              firstVideoStream = true;\n              that.RTC.attachMediaStreamIfNeeded($("#minivideo"), track, track.id);\n            } else {\n              that.RTC.attachMediaStreamIfNeeded($("#minivideo2"), track, track.id);\n            }\n\n            that.RTC.attachMediaStreamIfNeeded($("#callVideoPip"), track, track.id);\n          } //if sharing track\n          else if (track.getVideoTracks().length) {\n              if (!firstVideoStream) {\n                firstVideoStream = true;\n                that.RTC.attachMediaStreamIfNeeded($("#minivideo"), track, track.id);\n              } else {\n                that.RTC.attachMediaStreamIfNeeded($("#minivideo2"), track, track.id);\n              }\n\n              that.RTC.attachMediaStreamIfNeeded($("#callSharingPip"), track, track.id);\n            }\n        });\n      } //mute local videos -> bug Firefox\n\n\n      if ($("#callVideoPip")[0]) {\n        $("#callVideoPip")[0].volume = 0;\n      }\n\n      if ($("#minivideo")[0]) {\n        $("#minivideo")[0].volume = 0;\n      }\n\n      if ($("#minivideo2")[0]) {\n        $("#minivideo2")[0].volume = 0;\n      }\n\n      if ($("#callSharingPip")[0]) {\n        $("#callSharingPip")[0].volume = 0;\n      }\n    } else {\n      this.RTC.clearMediaStream($("#minivideo"), null);\n      this.RTC.clearMediaStream($("#minivideo2"), null);\n      this.RTC.clearMediaStream($("#callVideoPip"), null);\n      this.RTC.clearMediaStream($("#callSharingPip"), null);\n    }\n  };\n\n  this.pushInLocalStreams = function (stream, callId) {\n    stream.callId = callId;\n    that.localStreams.push(stream);\n  };\n  /*************************************************************/\n\n  /* ERROR POPUP                                               */\n\n  /*************************************************************/\n\n\n  this.openErrorPopup = function (msg) {\n    if (!msg) {\n      msg = "cameraNotAvailable";\n    }\n\n    $rootScope.$broadcast("ON_WEBRTC_CALL_ERROR_EVENT", msg);\n  };\n  /*************************************************************/\n\n  /* CALENDAR BUSY POPUP                                               */\n\n  /*************************************************************/\n\n\n  this.openCalendarBusyPopup = function (id) {\n    $rootScope.$broadcast("ON_WEBRTC_CALENDAR_BUSY_EVENT", id);\n  };\n  /*************************************************************/\n\n  /* ACTION BUTTONS                                            */\n\n  /*************************************************************/\n\n\n  this.makeVideoCall = function (contact) {\n    that.makeCall(contact, "videoOnly");\n  };\n  /**\n   * MAKE CALL\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.makeCall = function (contact, theMedia, message) {\n    $log.webrtc("MEDIA   | makeCall to " + JSON.stringify({\n      displayName: contact.displayNameForLog(),\n      resources: contact.resources\n    }));\n\n    if (that.makingCall) {\n      $log.info("MEDIA   | makeCall already making a call !");\n      return;\n    } //we\'re making a call right now\n\n\n    that.makingCall = true; //ACTIVATE XEP 0353\n\n    this.videoEventHandler.sendProposition(contact, theMedia, message);\n  };\n  /**\n    * MAKE Jingle Call (public)\n    * @param {call}  [required]  the call ref\n    * @param {mediaPillarJid}  [optional]  the media Pillar Jid only in case of webrtc gateway media Pillar \n    * @param {phoneNumber}  [optional] the number to join by mediaPillar  \n    */\n\n\n  this.makeJingleCall = function (call, mediaPillarJid, phoneNumber) {\n    $log.webrtc("MEDIA   | makeJingleCall");\n    that.setWebrtcConfiguration().then(function () {\n      var localType = "";\n\n      if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO) {\n        localType = "audio";\n      }\n\n      if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n        localType = localType ? "audio+video" : "video";\n      }\n\n      if (mediaPillarJid && mediaPillarJid !== "") {\n        $log.webrtc("MEDIA   | makeJingleCall in mediaPillar case for number : " + phoneNumber);\n      } // Initiate the call\n\n\n      if (mediaPillarJid && mediaPillarJid !== "" && phoneNumber && phoneNumber !== "") {\n        //Media pillar case\n        localType = "sip";\n        xmppService.connection.jingle.initiate(mediaPillarJid, xmppService.connection.jid, localType, that.localStreams, call.id, null, phoneNumber);\n      } else {\n        //Normal case\n        xmppService.connection.jingle.initiate(call.fullJid, xmppService.connection.jid, localType, that.localStreams, call.id, null, null, call.unifiedPlanActivated);\n      } // Update the call status\n\n\n      call.status = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.CONNECTING; // Send event\n\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n    })["catch"](function (error) {\n      $log.webrtc("MEDIA   | makeCall failure : " + JSON.stringify({\n        error: error.message\n      })); //call is already made\n\n      that.makingCall = false;\n\n      if (call) {\n        that.removeCallObject(call);\n      }\n\n      that.resetToSafeState();\n    });\n  };\n\n  this.makeJingleSharingCall = function (call) {\n    $log.webrtc("MEDIA   | makeJingleSharingCall - make desktop sharing call");\n    var type = "sharing";\n\n    if (call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n      type = "sharing-only";\n    }\n\n    that.setWebrtcConfiguration().then(function () {\n      $log.webrtc("SHARING | getUserMedia success"); // Prepare the call streams:\n      // We take the callStreams from that.localStreams, but we exclude the mediapillar audio stream\n\n      var mediaPillarSession = that.getMediaPillarSession();\n      var callStreams = !mediaPillarSession ? that.localStreams : that.localStreams.filter(function (localStream) {\n        return !(mediaPillarSession.localStreams && mediaPillarSession.localStreams.includes(localStream));\n      }); // Initiate the call\n\n      xmppService.connection.jingle.initiate(call.fullJid, xmppService.connection.jid, type, callStreams, call.id, null, null, call.unifiedPlanActivated); // Update the call status\n\n      call.status = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.CONNECTING; // Send event\n\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n    })["catch"](function (error) {\n      //call is already made\n      that.makingCall = false;\n\n      if (call) {\n        that.removeCallObject(call);\n      }\n\n      that.resetToSafeState();\n      $log.webrtc("MEDIA   | makeJingleSharingCall failure : " + JSON.stringify({\n        error: error.message\n      }));\n    });\n  };\n\n  this.startDesktopSharing = function (contact, media) {\n    if (that.makingCall) {\n      $log.info("MEDIA   | startDesktopSharing already making a call !");\n      return;\n    } //we\'re making a call right now\n\n\n    that.makingCall = true; //function used by the desktop client in order to define the screen to be taken\n    //return TRUE if the action will be taken into account, otherwise FALSE;\n\n    var proceed = !that.askToStartSharing(contact.jid, media);\n\n    if (proceed) {\n      that.makeDesktopSharingCall(contact, media);\n    }\n  };\n\n  this.startSharingCancelled = function () {\n    that.makingCall = false;\n  };\n\n  this.makeDesktopSharingCall = function (contact, media) {\n    //by default, we make sharing + audio call\n    if (!media) {\n      media = "sharing";\n    } //we\'re making a call right now\n\n\n    that.makingCall = true;\n    $log.webrtc("MEDIA   | makeDesktopSharingCall - trying to start a desktop sharing call with media " + media);\n    this.videoEventHandler.sendProposition(contact, media);\n  };\n\n  this.answerJingleCall = function (call) {\n    $log.webrtc("MEDIA   | answerJingleCall " + call.id); // Create the incomming call\n\n    var mediaToGet = [];\n    var localType = "audio"; //audio call\n\n    if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO) {\n      mediaToGet.push("audio");\n    } //audio + video call\n\n\n    if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n      mediaToGet.push("video");\n      localType = "audio+video";\n    } //video only call\n\n\n    if (call.localMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n      localType = "video";\n    } //if in conversation with mobile, limit the video quality\n\n\n    var mediaConstraints = {};\n\n    if (call.isInConversationWithMobile()) {\n      mediaConstraints = that.getMobileMediaConstraints("video");\n    }\n\n    that.setWebrtcConfiguration().then(function () {\n      that.getBrowserMedia(mediaToGet, mediaConstraints.fixedVideoWidth, mediaConstraints.fixedVideoHeight, mediaConstraints.fixedFrameRate).then(function (stream) {\n        var session = xmppService.connection.jingle.sessions[call.id];\n\n        if (stream) {\n          that.pushInLocalStreams(stream, call.id);\n          session.addStream(that.localStreams[0]);\n          session.localStreams.push(that.localStreams[0]);\n        } else {\n          localType = null;\n        }\n\n        session.localType = localType;\n        session.sendAnswer();\n        session.accept(); // Send event\n\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n      })["catch"](function (error) {\n        $log.webrtc("MEDIA   | answerJingleCall failure for : " + call + " failure : " + error.message);\n\n        if (error.toString().indexOf("getUserMedia") !== -1) {\n          that.releaseCall(call); //error when trying to get camera stream\n\n          that.openErrorPopup();\n        }\n\n        that.resetToSafeState();\n      });\n    });\n  };\n  /**\n   * ANSWER CALL\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.answerCall = function (call, type) {\n    //ACTIVATE XEP-0353\n    this.videoEventHandler.acceptProposition(call, type);\n  };\n  /**\n   * REJECT CALL\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.rejectCall = function (call, __reason) {\n    if (!call) {\n      $log.webrtc("MEDIA   | rejectCall - trying to rejectCall a non existing call !");\n      return;\n    }\n\n    that.makingCall = false;\n\n    if (that.autoreleaseTimeout) {\n      $interval.cancel(that.autoreleaseTimeout);\n    }\n\n    var session = xmppService.connection.jingle.sessions[call.id];\n\n    if (session) {\n      //should release the session\n      that.releaseCall(call);\n    } else {\n      // XEP-0353\n      if (call.isInitiator) {\n        this.videoEventHandler.retractProposition(call);\n      } else {\n        this.videoEventHandler.rejectProposition(call, __reason);\n      }\n    }\n  };\n  /**\n   * RELEASE CALL\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.releaseCall = function (call, reason, text) {\n    if (!call) {\n      $log.webrtc("MEDIA   | releaseCall - trying to release a non existing call !");\n      return;\n    } //clear the makingCall just in case\n\n\n    that.makingCall = false;\n    this.execute("releaseCall", function () {\n      // Log method call\n      $log.webrtc("MEDIA   | releaseCall : " + call);\n\n      try {\n        // Release the call\n        var session = xmppService.connection.jingle.sessions[call.id];\n        that.disableAudioVideoMedia(session);\n        contactService.resetBusyState(); // Disable autoReleaseTimeout\n\n        if (that.autoreleaseTimeout) {\n          $interval.cancel(that.autoreleaseTimeout);\n        }\n\n        that.createOrUpdateStatisticsForCall(call.id);\n\n        if (that.callsStats[call.id]) {\n          delete that.callsStats[call.id];\n        }\n\n        if (that.callsStatsSimplified[call.id]) {\n          delete that.callsStatsSimplified[call.id];\n        }\n\n        that.removeCallObject(call, reason, text);\n        that.displayWebRTCStats(call.id);\n\n        if (!that.isUserContactInCall()) {\n          that.clearSrcObjectsFromElements();\n        }\n      } catch (error) {\n        $log.webrtc("MEDIA   | releaseCall ERROR");\n        $log.error(error);\n        that.createOrUpdateStatisticsForCall(call.id);\n\n        if (that.callsStats[call.id]) {\n          delete that.callsStats[call.id];\n        }\n\n        if (that.callsStatsSimplified[call.id]) {\n          delete that.callsStatsSimplified[call.id];\n        }\n\n        that.resetToSafeState();\n        that.displayWebRTCStats(call.id);\n        that.removeCallObject(call);\n      }\n    });\n  };\n  /*************************************************************/\n\n  /* ESCALATION ACTION BUTTONS                                 */\n\n  /*************************************************************/\n\n\n  this.askToAddDesktopSharing = function (conversation) {\n    $log.webrtc("MEDIA   | askToAddDesktopSharing - Desktop sharing escalation"); //function used by the desktop client in order to define the screen to be taken\n    //return TRUE if the action will be taken into account, otherwise FALSE;\n\n    var proceed = !that.askToAddSharing(conversation.id);\n\n    if (proceed) {\n      that.addSharingToCall(conversation.videoCall);\n    }\n  };\n\n  this.addAudioToCall = function (call, mediaModify) {\n    $log.webrtc("MEDIA   | addAudioToCall");\n    var session = xmppService.connection.jingle.sessions[call.id];\n    session.isRenegotiating = true;\n    var mediaToGet = ["audio"];\n    this.getBrowserMedia(mediaToGet).then(function (stream) {\n      that.stopActiveAudioVideoStreams(session);\n      that.pushInLocalStreams(stream, call.id); //remove streams from the session\n\n      for (var i = 0; i < that.localStreams.length; i++) {\n        session.removeStream(that.localStreams[i]);\n      }\n\n      var type = mediaModify ? "contentModify" : "contentAdd";\n      that.updateCurrentCall(call, session, "audio", type);\n    })["catch"](function (error) {\n      $log.webrtc("MEDIA   | addAudioToCall failure : " + error);\n      that.releaseCall(call);\n      that.resetToSafeState();\n    });\n  }; //Escalate to Sharing call\n\n\n  this.addSharingToCall = function (call) {\n    $log.webrtc("MEDIA   | addSharingToCall - Desktop sharing escalation");\n    var session = xmppService.connection.jingle.sessions[call.id];\n    session.isRenegotiating = true;\n    var mediaToGet = ["sharing"]; //if in conversation with mobile, limit the video quality\n\n    var mediaConstraints = {};\n\n    if (call.isInConversationWithMobile()) {\n      mediaConstraints = that.getMobileMediaConstraints("sharing");\n    }\n\n    this.getBrowserMedia(mediaToGet, null, null, mediaConstraints.fixedFrameRate).then(function (stream) {\n      for (var i = 0; i < that.localStreams.length; i++) {\n        session.removeStream(that.localStreams[i]);\n        session.localStreams[i] = null;\n      }\n\n      session.localStreams = [];\n      that.pushInLocalStreams(stream, call.id); //remove streams from the session\n\n      for (var i = 0; i < that.localStreams.length; i++) {\n        session.removeStream(that.localStreams[i]);\n      }\n\n      that.updateCurrentCall(call, session, "sharing", "contentAdd");\n    })["catch"](function (error) {\n      $log.webrtc("MEDIA   | addSharingToCall failure : " + error);\n      session.isRenegotiating = false;\n\n      if (error.toString().indexOf("getUserMedia") !== -1) {\n        //error when trying to get camera stream\n        that.openErrorPopup();\n      }\n    });\n  };\n\n  this.addVideoToCall = function (call, mediaModify) {\n    $log.webrtc("MEDIA   | addVideoToCall");\n    var session = xmppService.connection.jingle.sessions[call.id];\n    var mediaToGet = ["audio", "video"];\n    session.isRenegotiating = true; //if in conversation with mobile, limit the video quality\n\n    var mediaConstraints = {};\n\n    if (call.isInConversationWithMobile()) {\n      mediaConstraints = that.getMobileMediaConstraints("video");\n    }\n\n    that.getBrowserMedia(mediaToGet, mediaConstraints.fixedVideoWidth, mediaConstraints.fixedVideoHeight, mediaConstraints.fixedFrameRate).then(function (stream) {\n      that.stopActiveAudioVideoStreams(session);\n      that.pushInLocalStreams(stream, call.id); //remove streams from the session\n\n      for (var i = 0; i < that.localStreams.length; i++) {\n        session.removeStream(that.localStreams[i]);\n      }\n\n      var type = mediaModify ? "contentModify" : "contentAdd";\n      that.updateCurrentCall(call, session, "video", type);\n    })["catch"](function (error) {\n      $log.webrtc("MEDIA   | addVideoToCall failure for : " + call + " failure : " + error.message);\n\n      if (error.toString().indexOf("getUserMedia") !== -1) {\n        //error when trying to get camera stream\n        $log.info("addVideoToCall impossible, no webcam plugged");\n        that.openErrorPopup();\n      } else {\n        //Another kind of error will lead to call end\n        that.releaseCall(call);\n        that.resetToSafeState();\n      }\n    });\n  };\n  /*************************************************************/\n\n  /* REMOVING MEDIAS FUNCTIONS                                 */\n\n  /*************************************************************/\n\n\n  this.removeSharingFromCall = function (call) {\n    $log.webrtc("MEDIA   | removeSharingFromCall");\n    var session = xmppService.connection.jingle.sessions[call.id];\n    this.stopAllActiveStreams(session);\n    var mediaToGet = ["audio"];\n\n    if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n      mediaToGet.push("video");\n    }\n\n    session.isRenegotiating = true;\n    that.getBrowserMedia(mediaToGet).then(function (stream) {\n      that.pushInLocalStreams(stream, call.id); // for (var i = 0; i < that.localStreams.length; i++) {\n      //     session.localStreams.push(that.localStreams[i]);\n      // }\n\n      that.updateCurrentCall(call, session, "sharing", "contentRemove");\n    })["catch"](function (error) {\n      $log.webrtc("MEDIA   | removeSharingFromCall failure for : " + call + " failure : " + error.message);\n\n      if (error.toString().indexOf("getUserMedia") !== -1) {\n        //error when trying to get camera stream\n        that.openErrorPopup();\n      }\n\n      that.releaseCall(call);\n      that.resetToSafeState();\n    });\n  };\n\n  this.removeVideoFromCall = function (call) {\n    $log.webrtc("MEDIA   | removeVideoFromCall"); //Check to avoid calling reverseToAudioCall twice (onStreamEnd event)\n\n    this.reverseAudioCallInitiated = true;\n    var session = xmppService.connection.jingle.sessions[call.id];\n    this.stopActiveAudioVideoStreams(session); //remove all streams from the session before adding the new ones\n\n    this.localStreams.forEach(function (stream) {\n      session.removeStream(stream);\n    }); //GET AUDIO\n\n    var mediaToGet = ["audio"];\n    session.isRenegotiating = true;\n    that.getBrowserMedia(mediaToGet).then(function (stream) {\n      that.pushInLocalStreams(stream, call.id);\n      that.updateCurrentCall(call, session, "video", "contentRemove");\n    })["catch"](function (error) {\n      $log.webrtc("MEDIA   | removeVideoFromCall failure for : " + call + " failure : " + error);\n\n      if (error.toString().indexOf("getUserMedia") !== -1) {\n        //error when trying to get camera stream\n        that.openErrorPopup();\n      }\n\n      that.releaseCall(call);\n      that.resetToSafeState();\n    });\n  };\n  /*************************************************************/\n\n  /* PRIVATE METHODS                                           */\n\n  /*************************************************************/\n\n\n  this.calculatePresenceMessage = function (call) {\n    var message = "audio";\n\n    if (call && call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n      message = "video";\n    }\n\n    if (call && call.remoteMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n      message = "video";\n    }\n\n    if (call && call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n      message = "sharing";\n    }\n\n    if (call && call.remoteMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n      message = "sharing";\n    }\n\n    return message;\n  };\n\n  this.calculateAudioState = function (data) {\n    var audioState = 0;\n\n    if (data.availableIncomingAudioBandwidth) {\n      if (data.availableIncomingAudioBandwidth < 15 && data.availableIncomingAudioBandwidth > 0) {\n        audioState = 1;\n      } else if (data.availableIncomingAudioBandwidth >= 15 && data.availableIncomingAudioBandwidth < 30) {\n        audioState = 2;\n      } else {\n        audioState = 3;\n      }\n    }\n\n    return audioState;\n  };\n\n  this.calculateVideoState = function (data) {\n    var videoState = 0;\n\n    if (data.availableIncomingVideoBandwidth) {\n      if (data.availableIncomingVideoBandwidth < 300) {\n        videoState = 1;\n      } else if (data.availableIncomingVideoBandwidth >= 300 && data.availableIncomingVideoBandwidth < 500) {\n        videoState = 2;\n      } else {\n        videoState = 3;\n      }\n    }\n\n    return videoState;\n  };\n\n  this.execute = function (action, actionHandler, parameter) {\n    if (this.started || action === "releaseCall") {\n      actionHandler(parameter);\n    } else {\n      $log.webrtc("MEDIA   | " + action + " failure : videoService is not started");\n    }\n  };\n\n  this.getOrCreateCallByCallId = function (callId) {\n    var call = that.calls[callId];\n\n    if (!call) {\n      // Get associated contact\n      var sess = xmppService.connection.jingle.sessions[callId];\n      var peerJid = xmppService.getBareJidFromJid(sess.peerjid);\n      var contact = contactService.getContactByJid(peerJid); // Create the call object\n\n      call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN, callId, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.WEBRTC, contact);\n      that.calls[call.id] = call;\n    }\n\n    return call;\n  };\n\n  this.getCallByContact = function (contact) {\n    for (var key in this.calls) {\n      if (this.calls.hasOwnProperty(key)) {\n        var call = that.calls[key];\n\n        if (call.contact && contact.jid === call.contact.jid) {\n          return call;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  this.removeCallObject = function (call, reason, text) {\n    try {\n      if (call) {\n        $log.debug("removeCallObject Call id: " + call.id); // Update call object\n\n        call.status = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN;\n        var session = xmppService.connection.jingle.sessions ? xmppService.connection.jingle.sessions[call.id] : null;\n        that.disableAudioVideoMedia(session, call.id); // Remove this call from call stack\n\n        delete that.calls[call.id];\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n\n        if (session) {\n          xmppService.connection.jingle.terminate(call.id, reason, text);\n        }\n      }\n    } catch (error) {\n      $log.error("removeCallObject error " + error);\n    }\n  };\n\n  this.updateRemoteTypeMedia = function (remoteType, call) {\n    switch (remoteType) {\n      case "audio":\n        call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n        break;\n\n      case "video":\n        call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO;\n        break;\n\n      case "audio+video":\n        call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO;\n        break;\n\n      case "sharing":\n        call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n        break;\n\n      case "sharing-only":\n        call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING;\n        break;\n\n      default:\n        call.remoteMedia = null;\n    }\n\n    $log.debug("REMOTE TYPE || REMOTE MEDIA  " + call.remoteMedia);\n  };\n\n  this.checkStreamAndStatus = function (stream, contact) {\n    if (stream && (stream.getAudioTracks().length === 0 && stream.getVideoTracks().length === 0 || stream.active === false)) {\n      that.openErrorPopup();\n      return false;\n    }\n\n    if (contact.capabilities && !contact.capabilities.webRTC) {\n      $log.webrtc("MEDIA   | initSharedDesktop failure : remote contact is no more available");\n\n      if (stream.stop) {\n        stream.stop();\n      }\n\n      that.openErrorPopup("remoteUserNoMoreAvailable");\n      return false;\n    }\n\n    return true;\n  };\n  /*************************************************************/\n\n  /* GOOGLE ANALYTICS STUFF                                    */\n\n  /*************************************************************/\n\n\n  this.displayWebRTCStats = function (callId) {\n    try {\n      var streams = null;\n      var i = 0;\n\n      if (gRTCStatsService.hasStatsForCall(callId)) {\n        // Bundle Policy\n        $log.webrtc("STATS   | Bundle policy used: " + gRTCStatsService.getBundlePolicyForCall(callId)); // Streams\n\n        streams = gRTCStatsService.getStreamsDetailsFromCall(callId);\n\n        if (streams.length === 0) {\n          $log.webrtc("STATS   | No channel information available for call " + callId);\n        } else {\n          for (i = 0; i < streams.length; i++) {\n            $log.webrtc("STATS   | " + streams[i].id + ": " + JSON.stringify(streams[i].streams));\n          }\n        } // Codecs used\n\n\n        var codecs = gRTCStatsService.getCodecDetailsFromCall(callId);\n        $log.webrtc("STATS   | codecs used: " + JSON.stringify(codecs));\n        gaService.trackCodecsUsed(codecs.codec.audio, codecs.codec.video);\n      } else if (fRTCStatsService.hasStatsForCall(callId)) {\n        // Bundle Policy\n        $log.webrtc("STATS   | Bundle policy used: " + fRTCStatsService.getBundlePolicyForCall(callId)); // Streams\n\n        streams = fRTCStatsService.getStreamsDetailsFromCall(callId);\n\n        if (streams.length === 0) {\n          $log.webrtc("STATS   | No channel information available for call " + callId);\n        } else {\n          for (i = 0; i < streams.length; i++) {\n            $log.webrtc("STATS   | " + streams[i].id + ": " + JSON.stringify(streams[i].streams));\n          }\n        }\n      }\n    } catch (error) {\n      $log.error("[videoService] displayWebRTCStats error : " + error);\n    }\n  };\n  /*************************************************************/\n\n  /* MUTE / UNMUTE ACTION BUTTONS                              */\n\n  /*************************************************************/\n\n  /**\n   * MUTE AUDIO\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.muteAudio = function (conversation, state) {\n    var call = conversation.videoCall;\n\n    if (!call) {\n      $log.webrtc("MEDIA   | muteAudio - trying to mute a non existing call !");\n      return;\n    } // Log method call\n\n\n    $log.webrtc("MEDIA   | mute audio: " + call + " | state: " + state);\n    conversation.isMutedAudio = state;\n    call.isMuted = state;\n    var session = xmppService.connection.jingle.sessions[call.id];\n\n    if (session) {\n      session.muteAudio(state);\n    } else {\n      $log.webrtc("MEDIA   | muteAudio - trying to mute a non existing session !");\n      return;\n    }\n\n    $rootScope.$broadcast("ON_CONVERSATION_CALL_MUTED_UPDATED_EVENT", {\n      conversation: conversation,\n      call: call\n    });\n  };\n  /**\n   * MUTE VIDEO\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.muteVideo = function (conversation, state) {\n    var call = conversation.videoCall;\n\n    if (!call) {\n      $log.webrtc("MEDIA   | muteVideo - trying to mute a non existing call !");\n      return;\n    }\n\n    $log.webrtc("MEDIA   | muteVideo: " + call);\n    var session = xmppService.connection.jingle.sessions[call.id];\n\n    if (session) {\n      session.muteVideo(state);\n      session.sendMute(state);\n    }\n\n    $rootScope.$broadcast("ON_CONVERSATION_CALL_MUTED_UPDATED_EVENT", {\n      conversation: conversation,\n      call: call\n    });\n  };\n  /*************************************************************/\n\n  /* STOP AUDIO/VIDEO Streams                                  */\n\n  /*************************************************************/\n\n\n  this.stopAllActiveStreams = function (session) {\n    //STOP ALL ACTIVE AUDIO + VIDEO FLUX\n    this.stopActiveAudioVideoStreams(session, true);\n  }; //STOP ALL ACTIVE AUDIO / VIDEO STREAMS (NOT SHARING)\n  //if flag stopAll, stop all streams\n\n\n  this.stopActiveAudioVideoStreams = function (session, stopAll) {\n    if (that.localStreams.length > 0) {\n      that.localStreams.forEach(function (stream) {\n        if (stream.getAudioTracks().length || stopAll) {\n          stream.getTracks().forEach(function (track) {\n            track.enabled = false;\n            track.stop();\n            track = null;\n          });\n\n          if (stream.stop) {\n            stream.stop();\n          }\n\n          stream = null;\n        }\n      });\n\n      if (stopAll) {\n        while (that.localStreams.length) {\n          var temp = that.localStreams.pop();\n          temp = null;\n        }\n      } else {\n        for (var i = 0; i < that.localStreams.length; i++) {\n          if (that.localStreams[i] && that.localStreams[i].getAudioTracks().length) {\n            var temp = that.localStreams.splice(i, 1);\n            temp = null;\n          }\n        }\n      }\n    }\n\n    if (session && session.localStreams) {\n      session.localStreams.forEach(function (stream) {\n        if (stream.getAudioTracks().length || stopAll) {\n          stream.getTracks().forEach(function (track) {\n            track.enabled = false;\n            track.stop();\n            track = null;\n          });\n\n          if (stream.stop) {\n            stream.stop();\n          }\n\n          session.removeStream(stream);\n        }\n      });\n\n      if (stopAll) {\n        while (session.localStreams.length) {\n          var temp = session.localStreams.pop();\n          temp = null;\n        }\n      }\n\n      session.localStreams = [];\n    }\n\n    if (session && xmppService.connection.jingle.localStream) {\n      session.removeStream(xmppService.connection.jingle.localStream);\n    }\n  };\n\n  this.resetToSafeState = function () {\n    $log.webrtc("MEDIA   | resetToSafeState"); // Disable autoReleaseTimeout if present\n\n    if (that.autoreleaseTimeout) {\n      $interval.cancel(that.autoreleaseTimeout);\n    } //disable all active flux\n\n\n    if (that.localStream || that.localStreams.length) {\n      that.disableAudioVideoMedia();\n    } //reset state\n\n\n    contactService.resetBusyState();\n  };\n  /*************************************************************/\n\n  /* WEBRTC CONFIGURATION METHODS                              */\n\n  /*************************************************************/\n\n\n  this.vidRes = {\n    "1080": [1920, 1080],\n    "720": [1280, 720],\n    "360": [640, 360],\n    "180": [320, 180],\n    "960": [960, 720],\n    "640": [640, 480],\n    "320": [320, 240]\n  };\n\n  this.getMobileMediaConstraints = function (type) {\n    var result = {};\n\n    if (type === "sharing") {\n      result.fixedFrameRate = 3;\n    } else if (type === "video") {\n      result.fixedFrameRate = 20;\n      result.fixedVideoWidth = 640;\n      result.fixedVideoHeight = 480;\n    }\n\n    return result;\n  };\n\n  this.minFirefoxWebRTCVersion = 45;\n  this.minChromeWebRTCVersion = 42;\n  this.minEdgeWebRTCVersion = 25;\n  this.firefoxPreferedSharing = "screen";\n\n  this.getBrowserMedia = function (userMedia, fixedVideoWidth, fixedVideoHeight, fixedFrameRate) {\n    if (!userMedia || userMedia.length === 0) {\n      return $q.when();\n    }\n\n    return new Promise(function (resolve, reject) {\n      // Create the media constraints object\n      var deferred = $q.defer();\n      var shouldGetDisplayMedia = false;\n      var constraints = {\n        audio: false,\n        video: false\n      };\n      var width = fixedVideoWidth ? fixedVideoWidth : 1280;\n      var height = fixedVideoHeight ? fixedVideoHeight : 720;\n      var promises = []; //video constraints\n\n      if (platformService.allowDevicesManagement()) {\n        if (userMedia.indexOf("audio") >= 0) {\n          var microphoneDeferred = $q.defer();\n          platformService.getCurrentMicrophone().then(function (microphone) {\n            if (microphone) {\n              constraints.audio = {\n                optional: [{\n                  sourceId: microphone.id\n                }]\n              };\n            } else {\n              constraints.audio = true;\n            }\n\n            microphoneDeferred.resolve(constraints);\n            var mic = "default";\n\n            if (microphone) {\n              mic = "id - " + microphone.id + " and label " + microphone.label;\n            }\n\n            $log.info("[VideoService] GetUserMedia for microphone " + mic);\n          });\n          promises.push(microphoneDeferred.promise);\n        }\n\n        if (userMedia.indexOf("video") >= 0) {\n          var frameRate = fixedFrameRate ? fixedFrameRate : 30;\n          var cameraDeferred = $q.defer();\n          platformService.getCurrentCamera().then(function (camera) {\n            if (camera && camera.id !== "default") {\n              constraints.video = {\n                width: width,\n                height: height,\n                frameRate: frameRate,\n                deviceId: {\n                  exact: camera.id\n                }\n              };\n            } else {\n              constraints.video = {\n                width: width,\n                height: height,\n                frameRate: frameRate\n              };\n            }\n\n            cameraDeferred.resolve(constraints);\n            var cam = "default";\n\n            if (camera) {\n              cam = "id - " + camera.id + " and label " + camera.label;\n            }\n\n            $log.info("[VideoService] GetUserMedia for camera " + cam);\n          });\n          promises.push(cameraDeferred.promise);\n        }\n      } else {\n        if (userMedia.indexOf("audio") >= 0) {\n          constraints.audio = true;\n        }\n\n        if (userMedia.indexOf("video") >= 0) {\n          constraints.video = {\n            width: width,\n            height: height\n          };\n        }\n      } //sharing constraints\n\n\n      if (userMedia.indexOf("sharing") >= 0) {\n        var frameRate = fixedFrameRate ? fixedFrameRate : 8; //Chrome + extension\n\n        if (extensionSharingService.extensionFound) {\n          constraints.video = {\n            mandatory: {\n              chromeMediaSource: "desktop",\n              maxWidth: 1920,\n              maxHeight: 1080,\n              maxFrameRate: frameRate\n            }\n          }; // add promise to get the stream id thought the chrome extension\n\n          promises.push(extensionSharingService.getStreamToShareFromExtension(constraints));\n        } //no need for extension\n        else if (!that.isNativeApplication() && adapter["default"].browserDetails.browser === "chrome" && adapter["default"].browserDetails.version >= 73) {\n            shouldGetDisplayMedia = true;\n            constraints = {};\n            constraints = {\n              video: {\n                chromeMediaSource: "desktop",\n                width: 1920,\n                height: 1080,\n                frameRate: frameRate\n              }\n            };\n          } //Firefox\n          else if (adapter["default"].browserDetails.browser === "firefox") {\n              constraints.video = {\n                mediaSource: that.firefoxPreferedSharing\n              };\n            } //Otherwise\n            else {\n                //desktop app \n                var sharingSources = that.getDesktopSharingSource();\n                var chromeMediaSource = sharingSources && sharingSources.chromeMediaSource ? sharingSources.chromeMediaSource : "desktop";\n                var chromeMediaSourceId = sharingSources && sharingSources.chromeMediaSourceId ? sharingSources.chromeMediaSourceId : null;\n                constraints.video = {\n                  mandatory: {\n                    chromeMediaSource: chromeMediaSource,\n                    maxWidth: 1920,\n                    minWidth: 1920,\n                    maxHeight: 1080,\n                    minHeight: 1080,\n                    maxFrameRate: frameRate\n                  }\n                };\n\n                if (chromeMediaSourceId) {\n                  constraints.video.mandatory.chromeMediaSourceId = chromeMediaSourceId;\n                }\n              }\n      }\n\n      $q.all(promises).then(function () {\n        deferred.resolve(constraints);\n      })["catch"](function () {\n        deferred.resolve();\n      });\n      deferred.promise.then(function (constraint) {\n        $log.info("[VideoService] GetUserMedia with constraint " + JSON.stringify(constraint));\n\n        if (!constraint) {\n          reject({\n            message: "getUserMedia cancelled"\n          });\n        } else {\n          try {\n            if (shouldGetDisplayMedia) {\n              navigator.mediaDevices.getDisplayMedia(constraint).then(function (stream) {\n                $log.webrtc("MEDIA   | getDisplayMedia success");\n\n                if (stream.getVideoTracks().length) {\n                  $log.info("[videoService] getDisplayMedia video stream kind " + stream.getVideoTracks()[0].kind + ", id " + stream.getVideoTracks()[0].id + ", label " + stream.getVideoTracks()[0].label + ", readyState " + stream.getVideoTracks()[0].readyState + ", enabled " + stream.getVideoTracks()[0].enabled);\n                }\n\n                if (stream && (stream.getAudioTracks().length === 0 && stream.getVideoTracks().length === 0 || stream.active === false)) {\n                  $log.webrtc("Stream has no active audio or video tracks"); // GA track GetUserMedia error\n\n                  gaService.trackGetUserMediaErrorNoTrack();\n                  reject(new Error("getDisplayMedia failure : Stream has no active audio or video tracks"));\n                } //Add eventHandler for chrome stop sharing button\n\n\n                stream.getVideoTracks()[0].onended = function () {\n                  $log.info("Stop screensharing in chrome has been triggered");\n                  $rootScope.$broadcast("ON_CHROME_STOP_SCREEN_SHARING_TRIGGERED");\n                };\n\n                resolve(stream); // GA track GetUserMedia success\n\n                gaService.trackGetUserMediaSuccess();\n              })["catch"](function (error) {\n                $log.webrtc("MEDIA   | getDisplayMedia failure: " + error); // GA track GetUserMedia error\n\n                gaService.trackGetUserMediaError();\n                $rootScope.$broadcast("ON_WEBRTC_GETUSERMEDIA_ERROR", error);\n                reject(new Error("getDisplayMedia failure " + error));\n              });\n            } else {\n              navigator.mediaDevices.getUserMedia(constraint).then(function (stream) {\n                $log.webrtc("MEDIA   | getUserMedia success"); //add logs\n\n                if (stream.getAudioTracks().length) {\n                  $log.info("[videoService] getUserMedia audio stream kind " + stream.getAudioTracks()[0].kind + ", id " + stream.getAudioTracks()[0].id + ", label " + stream.getAudioTracks()[0].label + ", readyState " + stream.getAudioTracks()[0].readyState + ", enabled " + stream.getAudioTracks()[0].enabled);\n                }\n\n                if (stream.getVideoTracks().length) {\n                  $log.info("[videoService] getUserMedia video stream kind " + stream.getVideoTracks()[0].kind + ", id " + stream.getVideoTracks()[0].id + ", label " + stream.getVideoTracks()[0].label + ", readyState " + stream.getVideoTracks()[0].readyState + ", enabled " + stream.getVideoTracks()[0].enabled);\n                }\n\n                if (stream && (stream.getAudioTracks().length === 0 && stream.getVideoTracks().length === 0 || stream.active === false)) {\n                  $log.webrtc("Stream has no active audio or video tracks"); // GA track GetUserMedia error\n\n                  gaService.trackGetUserMediaErrorNoTrack();\n                  reject(new Error("getUserMedia failure : Stream has no active audio or video tracks"));\n                } //Add eventHandler for chrome stop sharing button\n\n\n                if (extensionSharingService.extensionFound && userMedia.indexOf("sharing") >= 0) {\n                  stream.getVideoTracks()[0].onended = function () {\n                    $log.info("Stop screensharing in chrome has been triggered");\n                    $rootScope.$broadcast("ON_CHROME_STOP_SCREEN_SHARING_TRIGGERED");\n                  };\n                }\n\n                if (stream && stream.getAudioTracks().length) {\n                  stream.getAudioTracks()[0].onended = function (event) {\n                    $log.error("audio stream track ended");\n                    console.log(this);\n                    console.log(event);\n                  };\n                }\n\n                resolve(stream); // GA track GetUserMedia success\n\n                gaService.trackGetUserMediaSuccess();\n              })["catch"](function (error) {\n                $log.webrtc("MEDIA   | getUserMedia failure: " + error); // GA track GetUserMedia error\n\n                gaService.trackGetUserMediaError();\n                $rootScope.$broadcast("ON_WEBRTC_GETUSERMEDIA_ERROR", error);\n                reject(new Error("getUserMedia failure " + error));\n              });\n            }\n          } catch (err) {\n            $log.webrtc("MEDIA   | getUserMedia failure: " + err); // GA track GetUserMedia error\n\n            gaService.trackGetUserMediaError();\n            reject(new Error("getUserMedia failure " + err));\n          }\n        }\n      });\n    });\n  };\n\n  this.getBrowserMethodHandler = function () {\n    var version = "";\n    var returnValue = null; // Handle firefox navigators\n\n    if (navigator.mozGetUserMedia && $window.mozRTCPeerConnection) {\n      version = browserService.extractBrowserVersion(navigator.userAgent, /Firefox\\/([0-9]+)\\./, 1);\n      $log.webrtc("BROWSER | Detect Firefox navigator (version " + version + ")");\n\n      if (version < this.minFirefoxWebRTCVersion) {\n        $log.webrtc("BROWSER | Firefox navigator is not WebRTC capable before version " + this.minFirefoxWebRTCVersion);\n        return returnValue;\n      }\n\n      returnValue = {\n        browser: "firefox",\n        attachMediaStream: function attachMediaStream(element, stream) {\n          if (element && element[0]) {\n            element[0].mozSrcObject = stream;\n            element[0].srcObject = stream;\n            element[0].play();\n          }\n        },\n        pc_constraints: {},\n        clearMediaStream: function clearMediaStream(element) {\n          try {\n            if (angular.isDefined(element[0])) {\n              element[0].pause();\n              element[0].mozSrcObject = null;\n              element[0].srcObject = null;\n              element[0].uniqueId = null;\n            }\n          } catch (err) {\n            $log.webrtc("BROWSER | clearMediaStream failure " + err);\n          }\n        },\n        attachMediaStreamIfNeeded: function attachMediaStreamIfNeeded(element, stream, uniqueId) {\n          $log.webrtc("BROWSER | attachMediaStreamIfNeeded for ID " + uniqueId);\n\n          if (element && element[0] && (element[0].uniqueId !== uniqueId || !element[0].mozSrcObject && !element[0].srcObject)) {\n            element[0].uniqueId = uniqueId;\n            that.RTC.attachMediaStream(element, stream);\n          }\n        }\n      };\n    } // Handle chrome familly navigators\n    else if (navigator.webkitGetUserMedia && $window.webkitRTCPeerConnection) {\n        version = browserService.extractBrowserVersion(navigator.userAgent, /Chrom(e|ium)\\/([0-9]+)\\./, 2);\n        $log.webrtc("BROWSER | Detect Chrome navigator (version " + version + ")");\n\n        if (version < this.minChromeWebRTCVersion) {\n          $log.webrtc("BROWSER | Chrome navigator is not WebRTC capable before version " + this.minChromeWebRTCVersion);\n          return returnValue;\n        }\n\n        returnValue = {\n          browser: "chrome",\n          attachMediaStream: function attachMediaStream(element, stream) {\n            $log.webrtc("BROWSER | attachMediaStream to element");\n\n            if (element && element[0]) {\n              element[0].srcObject = stream;\n            } //Delay load to avoid black screen\n\n\n            $interval(function () {\n              if (element && element[0] && element[0].load) {\n                element[0].load();\n              }\n            }, 1000, 1);\n          },\n          pc_constraints: {},\n          clearMediaStream: function clearMediaStream(element) {\n            if (angular.isDefined(element[0])) {\n              element[0].pause(); //element.attr("src", "");\n\n              element[0].srcObject = null;\n              element[0].uniqueId = null;\n            }\n          },\n          attachMediaStreamIfNeeded: function attachMediaStreamIfNeeded(element, stream, uniqueId) {\n            $log.webrtc("BROWSER | attachMediaStreamIfNeeded for ID " + uniqueId);\n\n            if (element && element[0] && (element[0].uniqueId !== uniqueId || !element[0].srcObject)) {\n              element[0].uniqueId = uniqueId;\n              that.RTC.attachMediaStream(element, stream);\n            }\n          }\n        };\n      } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        returnValue = {\n          browser: "safari",\n          attachMediaStream: function attachMediaStream(element, stream) {\n            if (element && element[0]) {\n              element[0].setAttribute("playsinline", true);\n              element[0].srcObject = stream;\n              element[0].play();\n            }\n          },\n          pc_constraints: {},\n          clearMediaStream: function clearMediaStream(element) {\n            try {\n              if (angular.isDefined(element[0])) {\n                element[0].pause();\n                element[0].srcObject = null;\n                element[0].uniqueId = null;\n              }\n            } catch (err) {\n              $log.webrtc("BROWSER | clearMediaStream failure " + err);\n            }\n          },\n          attachMediaStreamIfNeeded: function attachMediaStreamIfNeeded(element, stream, uniqueId) {\n            $log.webrtc("BROWSER | attachMediaStreamIfNeeded for ID " + uniqueId);\n\n            if (element && element[0] && (element[0].uniqueId !== uniqueId || !element[0].srcObject)) {\n              element[0].uniqueId = uniqueId;\n              that.RTC.attachMediaStream(element, stream);\n            }\n          }\n        };\n      }\n\n    return returnValue;\n  };\n\n  this.getIceConfig = function () {\n    return $q(function (resolve, reject) {\n      // Get and store portalURL\n      var portalURL = config.restServerUrl + "/api/rainbow/geolocation/v1.0/";\n      $http({\n        method: "GET",\n        url: portalURL + "settings/iceservers?nbServers=2",\n        headers: authService.getRequestHeader()\n      }).then(function (result) {\n        $log.info("[videoService] getIceConfig success");\n        var iceServers = result.data.data;\n        iceServers.forEach(function (element) {\n          delete element.id;\n        }, this); // if (adapter.default.browserDetails.browser === "chrome") {\n        //     iceServers = iceServers.filter(function(element) {\n        //         if (element.urls.indexOf("turn:") === 0) {\n        //             return false;\n        //         }\n        //         return true;\n        //     });\n        // }\n\n        resolve({\n          iceServers: iceServers\n        });\n      })["catch"](function (error) {\n        $log.error("[videoService] getIceConfig failure -- " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  this.calculateNewCallType = function (call, session, type, action) {\n    var result = session.localType; //we add new media to the call\n\n    if (action === "contentAdd") {\n      if (type === "video") {\n        if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n          result = "sharing+video";\n        } else {\n          result = "video";\n        }\n\n        call.localMedia = call.localMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO;\n      } else if (type === "sharing") {\n        if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n          result = "sharing+video";\n        } else {\n          result = "sharing";\n        }\n\n        call.localMedia = call.localMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING;\n      } else if (type === "audio") {\n        if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n          result = "sharing";\n          call.localMedia = call.localMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n        } else {\n          result = "audio";\n          call.localMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n        }\n      }\n    }\n\n    if (action === "contentRemove") {\n      if (type === "video") {\n        if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n          result = "sharing";\n          call.localMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING;\n        } else {\n          result = "audio";\n          call.localMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n        }\n      } else if (type === "sharing") {\n        if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n          result = "video";\n          call.localMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO;\n        } else {\n          result = "audio";\n          call.localMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n        }\n      }\n    }\n\n    if (action === "contentModify") {\n      if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO && !(call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING)) {\n        result = "video";\n      }\n    }\n\n    $log.info("[videoService] calculateNewCallType for type " + type + " and action " + action + " with result " + result);\n    return result;\n  };\n\n  this.updateCurrentCall = function (call, session, type, action) {\n    $log.info("[videoService] updateCurrentCall for type " + type + " and action " + action);\n    var newType = this.calculateNewCallType(call, session, type, action);\n\n    for (var i = 0; i < that.localStreams.length; i++) {\n      if (adapter["default"].browserDetails.browser === "chrome") {\n        session.addStream(that.localStreams[i]);\n      } else {\n        session.replaceStream(that.localStreams[i]);\n      }\n\n      session.localStreams.push(that.localStreams[i]);\n    }\n\n    switch (action) {\n      case "contentAdd":\n        session.contentAdd(newType);\n        break;\n\n      case "contentRemove":\n        session.contentRemove(newType);\n        break;\n\n      case "contentModify":\n        session.contentModify(newType);\n        break;\n\n      default:\n        break;\n    } // Update presence\n\n\n    contactService.setBusyState("dnd", that.calculatePresenceMessage(call)); //Send events\n\n    $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n    $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION", call);\n  };\n\n  this.createOrUpdateStatisticsForCall = function (callId) {\n    var call = this.calls[callId];\n\n    if (!call) {\n      $log.warn("[videoService] createOrUpdateStatisticsForCall -- missing call " + callId);\n      return;\n    }\n\n    var metrics = []; //check if statistics already exist\n\n    if (this.callsStats[callId]) {\n      if (this.callsStats[callId].RainMetrics) {\n        this.callsStats[callId].push(this.callsStats[callId].RainMetrics);\n      }\n\n      metrics.push({\n        connectionId: callId,\n        stats: this.callsStats[callId]\n      });\n      this.updateStatisticsForCall(this.callsStats[callId].id, callId, call.contact.dbId, "ended", metrics);\n      return;\n    }\n\n    $log.info("[videoService] createOrUpdateStatisticsForCall " + callId);\n    this.callsStats[callId] = {};\n    metrics.push({\n      connectionId: callId,\n      stats: this.callsStats[callId]\n    });\n    this.createStatisticsForSession(callId, call.contact.dbId, "pending", metrics).then(function (id) {\n      that.callsStats[callId].id = id;\n      $log.info("[videoService] createOrUpdateStatisticsForCall success for session " + callId + " with id " + id);\n    })["catch"](function (error) {\n      $log.error("[videoService] createOrUpdateStatisticsForCall " + error.message);\n    });\n  };\n\n  this.createStatisticsForSession = function (callId, peerId, callState, metrics) {\n    return $q(function (resolve, reject) {\n      $log.info("[videoService] createStatisticsForSession " + callId);\n      var portalURL = config.restServerUrl + "/api/rainbow/metrics/v1.0/";\n      $http({\n        method: "POST",\n        url: portalURL + "webrtcmetrics",\n        headers: authService.getRequestHeader(),\n        data: {\n          callId: callId,\n          peerId: peerId,\n          callState: callState,\n          metrics: metrics\n        }\n      }).then(function success(response) {\n        $log.info("[videoService] createStatisticsForSession success");\n\n        if (response && response.data && response.data.data && response.data.data.id && that.callsStats[callId]) {\n          //FIXMEDOBY\n          resolve(response.data.data.id);\n        }\n      }, function failure(response) {\n        $log.error("[videoService] createStatisticsForSession failure " + response.errorMsg);\n        reject(new Error(response.errorMsg));\n      });\n    });\n  };\n\n  this.updateStatisticsForCall = function (id, callId, peerId, callState, metrics) {\n    $log.info("[videoService] updateStatisticsForCall " + callId);\n\n    if (!id) {\n      $log.warn("[videoService] updateStatisticsForCall -- missing id for callId " + callId);\n      return;\n    }\n\n    var portalURL = config.restServerUrl + "/api/rainbow/metrics/v1.0/";\n    $http({\n      method: "POST",\n      url: portalURL + "webrtcmetrics/" + id + "/metrics",\n      headers: authService.getRequestHeader(),\n      data: {\n        metrics: metrics\n      }\n    }).then(function success() {\n      $log.info("[videoService] updateStatisticsForCall success");\n\n      if (callState === "ended") {\n        $log.info("[videoService] updateStatisticsForCall -- update call state with " + callState);\n        $http({\n          method: "PUT",\n          url: portalURL + "webrtcmetrics/" + id,\n          headers: authService.getRequestHeader(),\n          data: {\n            callState: callState\n          }\n        }).then(function success() {\n          $log.info("[videoService] updateStatisticsForCall -- update call state success");\n        }, function failure(response) {\n          $log.error("[videoService] updateStatisticsForCall failure " + response.errorMsg);\n        });\n      }\n    }, function failure(response) {\n      $log.error("[videoService] updateStatisticsForCall failure " + response.errorMsg);\n    });\n  };\n\n  this.sendDTMF = function (dialString, call, skipHandle) {\n    var session = xmppService.connection.jingle.sessions[call.id];\n\n    if (session && session.peerconnection) {\n      var senders = session.peerconnection.getSenders(); //find audio sender with dtmf sending capability\n\n      var audioDtmfSender = senders.find(function (sender) {\n        return sender.dtmf && sender.track && sender.track.enabled && sender.track.kind === "audio";\n      });\n      var dtmfSender = audioDtmfSender ? audioDtmfSender.dtmf : null;\n\n      if (dtmfSender) {\n        $log.debug("[videoService] sendDTMF: dtmf sender found on webrtc session for call id " + call.id + " dialstring: " + dialString); //set tone event callback\n\n        if (!skipHandle) {\n          dtmfSender.ontonechange = this.handleToneChangeEvent;\n        } else {\n          dtmfSender.ontonechange = this.silentToneChangeEventHandle;\n        } //insert dtmf payload packet in audio rtp stream\n\n\n        dtmfSender.insertDTMF(dialString);\n      } else {\n        $log.error("[videoService] sendDTMF: no dtmf sender found on webrtc session for call id " + call.id);\n      }\n    } else {\n      $log.error("[videoService] sendDTMF: no webrtc session found for call id " + call.id);\n    }\n  };\n\n  this.handleToneChangeEvent = function (event) {\n    if (event.tone !== "") {\n      $log.debug("[videoService] Dtmf Tone played: " + event.tone);\n      $rootScope.$broadcast("ON_DTMF_SENT", event.tone);\n    }\n  };\n\n  this.silentToneChangeEventHandle = function (event) {\n    $log.debug("[videoService] Dtmf Tone played: " + event.tone);\n  };\n  /*************************************************************/\n\n  /* JINGLE EVENT HANDLERS                                     */\n\n  /*************************************************************/\n  // Incomming video call event handler\n\n\n  angular.element(document).bind("transportreplace.jingle", function (__event, callId) {\n    $log.webrtc("JINGLE  | transportreplace.jingle " + callId);\n    var sess = xmppService.connection.jingle.sessions[callId];\n\n    if (sess) {\n      sess.sendAnswer(undefined, "transport-accept");\n    } else {\n      $log.warn("JINGLE  | transportreplace.jingle no such session !");\n    }\n  }); // Active video call event handler\n\n  angular.element(document).bind("callactive.jingle", function (__event, callId) {\n    $log.webrtc("JINGLE  | callactive " + callId); // that.videoEventHandler.activeCall(callId);\n  });\n  angular.element(document).bind("remotestreamadded.jingle", function (__event, sid, hasAudioTracks) {\n    $log.webrtc("JINGLE  | remoteStreamadded " + sid);\n    var sess = xmppService.connection.jingle.sessions[sid]; //ignore web conference sessions\n\n    if (sess && sess.remoteStreams && !sess.confId) {\n      var call = that.calls[sid];\n\n      if (call) {\n        that.attachDistantMediaStreams(true, call);\n      }\n\n      $rootScope.$broadcast("ON_WEBRTC_REMOTE_STREAM_ADDED", sess.remoteStreams);\n    }\n\n    if (hasAudioTracks) {\n      that.resetAudioOutputElement();\n    }\n  });\n  angular.element(document).bind("remotestreamremoved.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | remotestreamremoved " + sid);\n  });\n  angular.element(document).bind("callaccepted.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | callaccepted " + sid);\n    var call = that.calls[sid];\n    var sess = xmppService.connection.jingle.sessions[sid];\n\n    if (call && sess) {\n      //start webrtc stats\n      if (that.statsInterval) {\n        $log.webrtc("JINGLE  | remove getStats interval");\n        window.clearInterval(that.statsInterval);\n        that.statsinterval = null;\n      }\n\n      that.createOrUpdateStatisticsForCall(call.id);\n      $log.webrtc("JINGLE  | start getStats interval");\n      that.statsInterval = sess.getStats(5000);\n    }\n\n    if (call && call.status.key !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE.key) {\n      $log.webrtc("INFO    | call has been accepted. Set current call to ACTIVE state"); // var el = angular.element("<video autoplay=\'autoplay\' style=\'display:none\'/>").attr("id", "largevideo_" + sid);\n\n      angular.element(document).trigger("callactive.jingle", [sid]);\n    }\n  });\n  angular.element(document).bind("nostuncandidates.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | nostuncandidates " + sid); // GA track when No STUN Candidate\n\n    gaService.trackICENoSTUNCandidate();\n  });\n  angular.element(document).bind("ringing.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | callremoteringing " + sid);\n  });\n  angular.element(document).bind("mediafailure.jingle", function () {\n    $log.webrtc("JINGLE  | callmediafailure");\n  });\n  angular.element(document).bind("mute.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | mute " + sid);\n    var call = that.calls[sid];\n    call.isRemoteVideoMuted = true;\n    $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n  });\n  angular.element(document).bind("unmute.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | unmute " + sid);\n    var call = that.calls[sid];\n    call.isRemoteVideoMuted = false;\n    $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n  });\n  angular.element(document).bind("hold.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | hold " + sid); // mute audio to stop sending media\n\n    var session = xmppService.connection.jingle.sessions[sid];\n\n    if (session) {\n      session.muteAudio(true);\n    } else {\n      $log.webrtc("MEDIA   | hold - received on a non existing session !");\n      return;\n    } //play hold music/tone\n\n\n    $rootScope.$broadcast("ON_HOLD_TONE_EVENT", "hold");\n  });\n  angular.element(document).bind("unhold.jingle", function (__event, sid) {\n    $log.webrtc("JINGLE  | unhold " + sid); // unmute audio\n\n    var session = xmppService.connection.jingle.sessions[sid];\n\n    if (session) {\n      session.muteAudio(false);\n    } else {\n      $log.webrtc("MEDIA   | unhold - received on a non existing session !");\n      return;\n    } //stop playing hold music/tone\n\n\n    $rootScope.$broadcast("ON_HOLD_TONE_EVENT", "unhold");\n  });\n  angular.element(document).bind("remoteIceFailed.jingle", function (sid) {\n    $log.webrtc("JINGLE  | remoteIceFailed " + sid);\n    that.openErrorPopup("IceConnectionFailed");\n  });\n  angular.element(document).bind("mediamodified.jingle", function (__event, sid, mediaType) {\n    $log.webrtc("JINGLE  | mediamodified " + sid);\n    that.videoEventHandler.mediaModified(sid, mediaType);\n  });\n  /*************************************************************/\n\n  /* JINGLE EVENT STATISTICS HANDLERS                          */\n\n  /*************************************************************/\n\n  angular.element(document).bind("statsChrome.jingle", function (__event, sid, items) {\n    for (var i = 0; i < items.length; ++i) {\n      switch (items[i].type) {\n        case "googComponent":\n          gRTCStatsService.addStreamToCall(sid, items[i]);\n          break;\n\n        case "ssrc":\n          gRTCStatsService.addSSRCToStream(sid, items[i]);\n          break;\n\n        default:\n          break;\n      }\n    }\n  });\n  angular.element(document).bind("statsFirefox.jingle", function (__event, sid, items) {\n    for (var i = 0; i < items.length; ++i) {\n      switch (items[i].type) {\n        case "inboundrtp":\n          fRTCStatsService.addStreamToCall(sid, items[i]);\n          break;\n\n        case "outboundrtp":\n          fRTCStatsService.addStreamToCall(sid, items[i]);\n          break;\n\n        case "candidatepair":\n          fRTCStatsService.addCandidatePairToCall(sid, items[i]);\n          break;\n\n        default:\n          break;\n      }\n    }\n  });\n  angular.element(document).bind("webrtcFirefoxStats.jingle", function (__event, sid, data) {\n    if (!that.callsStats.sid) {\n      that.callsStats.sid = {};\n    }\n\n    if (!that.callsStats[sid]) {\n      that.callsStats[sid] = {};\n    }\n\n    var call = that.calls[sid];\n\n    if (call) {\n      //Firefox stats, should divide Audio and Video\n      var currentStats = that.callsStats[sid];\n\n      if (currentStats) {\n        if (data.videoReceived) {\n          //if video data, replace only the video data\n          currentStats.video = data;\n        } else {\n          //replace only audio stats\n          currentStats.audio = data;\n        }\n\n        that.callsStats[sid] = currentStats;\n      }\n    }\n  });\n  angular.element(document).bind("webrtcConnectionType.jingle", function (__event, sid, connectionType) {\n    var activeCall = that.calls[sid]; //update the connection type stats\n\n    if (connectionType) {\n      $log.webrtc("STATS   | Local candidate (" + connectionType.localAddress + ") type is " + connectionType.localCandidateType);\n      $log.webrtc("STATS   | Remote candidate  (" + connectionType.remoteAddress + ") type is " + connectionType.remoteCandidateType); // GA track ICE used\n\n      if (activeCall && activeCall.isInitiator) {\n        gaService.trackICEUsed(connectionType.localCandidateTypee, connectionType.remoteCandidateType);\n      }\n\n      if (connectionType.networkType) {\n        $log.webrtc("STATS   | Network type is " + connectionType.networkType); // GA track ICE topology\n\n        if (activeCall && activeCall.isInitiator) {\n          gaService.trackICETopology(connectionType.networkType);\n        }\n      }\n    }\n  });\n  angular.element(document).bind("webrtcSessionStats.jingle", function (__event, sid, data) {\n    if (!that.callsStats.sid) {\n      that.callsStats.sid = {};\n    }\n\n    if (!that.callsStats[sid]) {\n      that.callsStats[sid] = {};\n    } //update the stats for this call, but save the ID\n\n\n    var id = that.callsStats[sid].id;\n    that.callsStats[sid] = data;\n    that.callsStats[sid].id = id;\n  }); // OBSOLETE FUNCTIONS\n  //Escalate to Sharing call\n\n  /*this.escalateToSharingCall = function(call, mediaModify) {\n      $log.webrtc("MEDIA   | escalateToSharingCall - Desktop sharing escalation");\n       var session = xmppService.connection.jingle.sessions[call.id];\n       session.isRenegotiating = true;\n       var mediaToGet = ["sharing"];\n       this.getBrowserMedia(mediaToGet)\n          .then(function(stream) {\n              session.removeStream(that.localStreams[0]);\n              session.localStreams[0] = null;\n              session.localStreams = [];\n               that.pushInLocalStreams(stream, call.id);\n               that.updateCurrentSharingCall(call, session, mediaModify);\n          })\n          .catch(function(error) {\n              $log.webrtc("MEDIA   | escalateToSharingCall failure : " + error);\n              session.isRenegotiating = false;\n               if (error.toString().indexOf("getUserMedia") !== -1) {\n                  //error when trying to get camera stream\n                  that.openErrorPopup();\n              }\n          });\n  };\n   //MAKE VIDEO ESCALATION\n  this.escalateToVideoCall = function(call, mediaModify) {\n      $log.webrtc("MEDIA   | Escalate to video call");\n       var session = xmppService.connection.jingle.sessions[call.id];\n      var mediaToGet = ["audio", "video"];\n       session.isRenegotiating = true;\n       that.getBrowserMedia(mediaToGet)\n          .then(function(stream) {\n              that.stopActiveAudioVideoStreams(session);\n              that.pushInLocalStreams(stream, call.id);\n               for (var i = 0; i < that.localStreams.length; i++) {\n                  session.localStreams.push(that.localStreams[i]);\n              }\n               that.updateCurrentAudioOrVideoCall(call, session, "video", mediaModify);\n          })\n          .catch(function(error) {\n              $log.webrtc("MEDIA   | escalateToVideoCall failure for : " + call + " failure : " + error.message);\n               if (error.toString().indexOf("getUserMedia") !== -1) {\n                  //error when trying to get camera stream\n                  $log.info("Escalation to video impossible, no webcam plugged");\n                  that.openErrorPopup();\n              }\n              else {\n                  //Another kind of error will lead to call end\n                  that.releaseCall(call);\n                  that.resetToSafeState();\n              }\n          });\n  };\n   this.addAudioToSharingCall = function(call) {\n      $log.webrtc("MEDIA   | addAudioToSharingCall");\n       var session = xmppService.connection.jingle.sessions[call.id];\n       session.isRenegotiating = true;\n       if (that.localStreams.length) {\n          session.removeStream(that.localStreams[0]);\n      }\n       session.localStreams[0] = null;\n      session.localStreams = [];\n       var mediaToGet = ["audio"];\n       this.getBrowserMedia(mediaToGet)\n          .then(function(stream) {\n              that.pushInLocalStreams(stream, call.id);\n              that.updateCurrentSharingCall(call, session);\n          })\n          .catch(function(error) {\n              $log.webrtc("MEDIA   | addAudioToSharingCall failure : " + error);\n              that.releaseCall(call);\n              that.resetToSafeState();\n          });\n  };\n   this.reverseToAudioCall = function(call, mediaModify) {\n      $log.webrtc("MEDIA   | reverseToAudioCall");\n      //Check to avoid calling reverseToAudioCall twice (onStreamEnd event)\n      this.reverseAudioCallInitiated = true;\n       var session = xmppService.connection.jingle.sessions[call.id];\n       this.stopActiveAudioVideoStreams(session);\n       //GET AUDIO\n      var mediaToGet = ["audio"];\n       session.isRenegotiating = true;\n       that.getBrowserMedia(mediaToGet)\n          .then(function(stream) {\n              that.pushInLocalStreams(stream, call.id);\n               for (var i = 0; i < that.localStreams.length; i++) {\n                  session.localStreams.push(that.localStreams[i]);\n              }\n               that.updateCurrentAudioOrVideoCall(call, session, "audio", mediaModify);\n          })\n          .catch(function(error) {\n              $log.webrtc("MEDIA   | reverseToAudioCall failure for : " + call + " failure : " + error.message);\n               if (error.toString().indexOf("getUserMedia") !== -1) {\n                  //error when trying to get camera stream\n                  that.openErrorPopup();\n              }\n              that.releaseCall(call);\n              that.resetToSafeState();\n          });\n  };\n   that.updateCurrentSharingCall = function(call, session, mediaModify) {\n      $log.webrtc("MEDIA   | updateCurrentSharingCall | Add new streams to the current session");\n      if (!session || !xmppService.connection.jingle.sessions[call.id]) {\n          that.disableAudioVideoMedia();\n          that.resetToSafeState();\n          that.removeCallObject(call);\n           return;\n      }\n       var type = "audio";\n      if (adapter.default.browserDetails.browser === "chrome") {\n          session.localStreams.push(that.localStreams[0]);\n          session.addStream(that.localStreams[0]);\n          // call.localMedia = Call.Media.AUDIO;\n           if (that.localStreams[1]) {\n              if (call.localMedia === Call.Media.AUDIO || call.localMedia === Call.Media.SHARING) {\n                  type = "sharing";\n              }\n              else {\n                  type = "sharing+video";\n              }\n               call.localMedia = (call.localMedia | Call.Media.SHARING) | Call.Media.AUDIO;\n              session.localStreams.push(that.localStreams[1]);\n              session.addStream(that.localStreams[1]);\n               session.localStreams.push(that.localStreams[1]);\n              session.addStream(that.localStreams[1]);\n          }\n      } else {\n          call.localMedia = Call.Media.AUDIO;\n          session.replaceStream(that.localStreams[0]);\n      }\n       if (mediaModify) {\n          session.contentModify(type);\n      } else {\n          session.contentAdd(type);\n      }\n       // Update presence\n      contactService.setBusyState("dnd", that.calculatePresenceMessage(call));\n       $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n      $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION", call);\n  };\n   this.updateCurrentAudioOrVideoCall = function(call, session, type, mediaModify) {\n      $log.webrtc("MEDIA   | updateCurrentAudioOrVideoCall | Add new stream to the current session");\n       for (var i = 0; i < that.localStreams.length; i++) {\n          if (adapter.default.browserDetails.browser === "chrome") {\n              session.addStream(that.localStreams[i]);\n          } else {\n              session.replaceStream(that.localStreams[i]);\n          }\n      }\n       if (mediaModify) {\n          session.contentModify(session.localType);\n      }\n      else if (type === "audio") {\n          if (call.localMedia & Call.Media.SHARING) {\n              session.contentRemove("sharing");\n              session.localType = "sharing";\n              call.localMedia = Call.Media.AUDIO | Call.Media.SHARING;\n          }\n          else {\n              session.contentRemove("audio");\n              session.localType = "audio";\n              call.localMedia = Call.Media.AUDIO;\n          }\n      } else if (type === "video") {\n          if (call.localMedia & Call.Media.SHARING) {\n              session.contentAdd("sharing+video");\n              session.localType = "sharing+video";\n          }\n          else {\n              session.contentAdd("video");\n              session.localType = "audio+video";\n          }\n           call.localMedia = call.localMedia | Call.Media.VIDEO;\n      }\n       // Update presence\n      contactService.setBusyState("dnd", that.calculatePresenceMessage(call));\n       $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n      $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION", call);\n  };\n  */\n\n  /**\n   * ATTACH LOCAL MEDIA STREAM\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n  // this.attachLocalMediaStream = function(attach) {\n  //     if (attach) {\n  //         if (this.localStreams && this.localStreams.length && this.localStreams[0].getVideoTracks().length) {\n  //             this.RTC.attachMediaStream($("#minivideo"), this.localStreams[0]);\n  //         }\n  //         if ($("#minivideo")[0]) {\n  //             $("#minivideo")[0].volume = 0;\n  //         }\n  //     } else {\n  //         this.RTC.clearMediaStream($("#minivideo"), null);\n  //     }\n  // };\n  // /**\n  //  * ATTACH DISTANT MEDIA STREAM\n  //  * Used by SDK (public)\n  //  * Warning when modifying this method\n  //  */\n  // this.attachDistantMediaStream = function(attach, call) {\n  //     if (attach) {\n  //         var sess = xmppService.connection.jingle.sessions[call.id];\n  //         if (sess.remoteStreams) {\n  //             sess.remoteStreams.forEach(function(track) {\n  //                 if (track.getVideoTracks().length > 0) {\n  //                     $log.webrtc("attachDistantMediaStream video track");\n  //                     that.RTC.attachMediaStream(angular.element("#largevideo"), track);\n  //                     if (angular.element("#largevideo")[0]) {\n  //                         angular.element("#largevideo")[0].muted = true;\n  //                         angular.element("#largevideo")[0].volume = 0;\n  //                     }\n  //                 }\n  //                 if (track.getAudioTracks().length > 0) {\n  //                     $log.webrtc("attachDistantMediaStream audio track");\n  //                     that.RTC.attachMediaStream(angular.element("#globalAudioTag"), track);\n  //                 }\n  //             });\n  //         } else if (sess.remoteStream) {\n  //             if (sess.remoteStream.getVideoTracks().length > 0) {\n  //                 $log.error("attachDistantMediaStream NOT GOOD !!! video track");\n  //                 //that.RTC.attachMediaStream(angular.element("#globalVideoTag"), sess.remoteStream);\n  //                 that.RTC.attachMediaStream(angular.element("#largevideo"), sess.remoteStream);\n  //                 if (angular.element("#largevideo")[0]) {\n  //                     angular.element("#largevideo")[0].muted = true;\n  //                     angular.element("#largevideo")[0].volume = 0;\n  //                 }\n  //             }\n  //             if (sess.remoteStream.getAudioTracks().length > 0) {\n  //                 $log.error("attachDistantMediaStream NOT GOOD !!! audio track");\n  //                 that.RTC.attachMediaStream(angular.element("#globalAudioTag"), sess.remoteStream);\n  //             }\n  //         }\n  //     } else {\n  //         if (!that.isUserContactInCall()) {\n  //             this.RTC.clearMediaStream(angular.element("#largevideo"), null);\n  //             this.RTC.clearMediaStream(angular.element("#globalVideoTag"), null);\n  //             this.RTC.attachMediaStream(angular.element("#globalAudioTag"), null);\n  //         }\n  //     }\n  // };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/video/videoService.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__);\n\nangular.module("rainbow").factory("VideoServiceEventHandler", ["$log", "$rootScope", "$interval", "contactService", "xmppService", "gaService", "uuid4", function ($log, $rootScope, $interval, contactService, xmppService, gaService, uuid4) {\n  "use strict";\n  /*********************************************************************/\n\n  /** PUBLIC STATIC FACTORY                                           **/\n\n  /*********************************************************************/\n\n  VideoServiceEventHandler.create = function (videoService) {\n    return new VideoServiceEventHandler(videoService);\n  };\n  /*********************************************************************/\n\n  /** PRIVATE CONSTRUCTOR                                             **/\n\n  /*********************************************************************/\n\n\n  function VideoServiceEventHandler(videoService) {\n    this.videoService = videoService;\n    this.nameSpace = "urn:xmpp:jingle-message:0";\n  }\n  /*************************************************************/\n\n  /*          HELPER FUNCTIONS                                 */\n\n  /*************************************************************/\n\n\n  VideoServiceEventHandler.prototype.setRemoteTypeMedia = function (remoteType, call) {\n    call.remoteMedia = 0;\n\n    for (var i = 0; i < remoteType.length; i++) {\n      switch (remoteType[i]) {\n        case "audio":\n          call.remoteMedia = call.remoteMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n          break;\n\n        case "video":\n          call.remoteMedia = call.remoteMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO;\n          break;\n\n        case "sharing":\n          call.remoteMedia = call.remoteMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING;\n          break;\n\n        default:\n          call.remoteMedia = null;\n      }\n    }\n\n    $log.debug("REMOTE TYPE || REMOTE MEDIA  " + call.remoteMedia);\n  };\n\n  VideoServiceEventHandler.prototype.setLocalTypeMedia = function (localType, call) {\n    call.localMedia = 0;\n\n    for (var i = 0; i < localType.length; i++) {\n      switch (localType[i]) {\n        case "audio":\n          call.localMedia = call.localMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n          break;\n\n        case "video":\n          call.localMedia = call.localMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO;\n          break;\n\n        case "sharing":\n          call.localMedia = call.localMedia | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING;\n          break;\n\n        default:\n          call.localMedia = null;\n      }\n    }\n\n    $log.debug("LOCAL TYPE || LOCAL MEDIA  " + call.localMedia);\n  };\n  /*************************************************************/\n\n  /* XMPP XEP 0353 - JINGLE MULTI CLIENT ACTIONS               */\n\n  /*************************************************************/\n\n\n  VideoServiceEventHandler.prototype.sendProposition = function (contact, media, message) {\n    $log.info("[VideoServiceEventHandler]   | sendProposition to " + JSON.stringify({\n      displayName: contact.displayNameForLog(),\n      resources: contact.resources\n    }));\n    var that = this;\n    var mediaToGet = ["audio"];\n    var secondMediaToGet = [];\n\n    if (media === "video") {\n      mediaToGet.push("video");\n    } else if (media === "videoOnly") {\n      mediaToGet = ["video"];\n    } else if (media === "sharing") {\n      mediaToGet = ["sharing"];\n      secondMediaToGet = ["audio"];\n    } else if (media === "sharingOnly") {\n      mediaToGet = ["sharing"];\n    }\n\n    var id = "web_" + uuid4.generate(); // Create the call object\n\n    var call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING, id, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.WEBRTC, contact);\n    this.videoService.getBrowserMedia(mediaToGet).then(function (stream) {\n      that.videoService.getBrowserMedia(secondMediaToGet).then(function (extraStream) {\n        //Check if the call still should be done !\n        if (that.videoService.makingCall && that.videoService.started) {\n          call.isInitiator = true;\n          stream.callId = id;\n          that.videoService.localStreams.push(stream);\n\n          if (extraStream) {\n            extraStream.callId = id;\n            that.videoService.localStreams.push(extraStream);\n            mediaToGet.push(secondMediaToGet.pop());\n          }\n\n          that.videoService.calls[call.id] = call;\n          that.setLocalTypeMedia(mediaToGet, call);\n          var idPropose = "web_" + uuid4.generate();\n          var xmppMessage = $msg({\n            from: contactService.userContact.fullJid,\n            to: contact.jid,\n            id: idPropose\n          });\n          xmppMessage.c("propose", {\n            "xmlns": that.nameSpace,\n            "id": id\n          });\n\n          if (message) {\n            xmppMessage.c("subject", {\n              "xmlns": "urn:xmpp:jingle-subject:0"\n            }).t(message).up();\n          }\n\n          xmppMessage.c("description", {\n            "xmlns": "urn:xmpp:jingle:apps:rtp:1",\n            "media": mediaToGet[0]\n          }).up();\n\n          if (mediaToGet[1]) {\n            xmppMessage = xmppMessage.c("description", {\n              "xmlns": "urn:xmpp:jingle:apps:rtp:1",\n              "media": mediaToGet[1]\n            }).up();\n          }\n\n          xmppService.send(xmppMessage); //call is already made\n\n          that.videoService.makingCall = false; // Update presence\n\n          contactService.setBusyState("dnd", that.videoService.calculatePresenceMessage(call)); // Send event\n\n          $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call); // Disable autoReleaseTimeout\n\n          if (that.videoService.autoreleaseTimeout) {\n            $interval.cancel(that.videoService.autoreleaseTimeout);\n          } //set autoreleaseTimeout\n\n\n          that.videoService.autoreleaseTimeout = $interval(function (_call) {\n            $log.webrtc("MEDIA   | send proposition : no response after 30 seconds : release the call");\n\n            if (call) {\n              that.videoService.rejectCall(_call);\n            }\n          }, 30000, 1, true, call);\n        } else {\n          $log.warn("[VideoServiceEventHandler]   | sendProposition -- call should no longer be made !");\n          that.videoService.makingCall = false; //we should stop this call and free all streams\n\n          stream.getTracks().forEach(function (track) {\n            track.enabled = false;\n            track.stop();\n            track = null;\n          });\n\n          if (stream.stop) {\n            stream.stop();\n          }\n\n          stream = null;\n\n          if (extraStream) {\n            extraStream.getTracks().forEach(function (track) {\n              track.enabled = false;\n              track.stop();\n              track = null;\n            });\n\n            if (extraStream.stop) {\n              extraStream.stop();\n            }\n\n            extraStream = null;\n          }\n        }\n      })["catch"](function (error) {\n        $log.info("[VideoServiceEventHandler]   | sendProposition failure : " + JSON.stringify({\n          error: error.message\n        })); //call is already made\n\n        that.videoService.makingCall = false;\n\n        if (error.toString().indexOf("getUserMedia") !== -1) {\n          that.videoService.openErrorPopup();\n        }\n\n        that.videoService.removeCallObject(call);\n\n        if (!that.videoService.isUserContactInCall()) {\n          that.videoService.resetToSafeState();\n        }\n\n        if (that.videoService.autoreleaseTimeout) {\n          $interval.cancel(that.videoService.autoreleaseTimeout);\n        }\n      });\n    })["catch"](function (error) {\n      $log.info("[VideoServiceEventHandler]   | sendProposition failure : " + JSON.stringify({\n        error: error.message\n      })); //call is already made\n\n      that.videoService.makingCall = false;\n\n      if (!(mediaToGet.indexOf("sharing") >= 0) && error.toString().indexOf("getUserMedia") !== -1) {\n        that.videoService.openErrorPopup();\n      }\n\n      that.videoService.removeCallObject(call);\n\n      if (!that.videoService.isUserContactInCall()) {\n        that.videoService.resetToSafeState();\n      }\n    });\n  };\n\n  VideoServiceEventHandler.prototype.retractProposition = function (call) {\n    $log.info("[VideoServiceEventHandler]   | retractProposition for call " + call.id);\n    var idRetract = "web_" + uuid4.generate();\n    var xmppMessage = $msg({\n      from: contactService.userContact.fullJid,\n      to: call.contact.jid,\n      id: idRetract\n    }).c("retract", {\n      "xmlns": this.nameSpace,\n      "id": call.id\n    });\n    xmppService.send(xmppMessage);\n    contactService.resetBusyState();\n    this.videoService.removeCallObject(call);\n  };\n\n  VideoServiceEventHandler.prototype.acceptProposition = function (call, type) {\n    if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ANSWERING) {\n      $log.warn("[VideoServiceEventHandler]   | acceptProposition for call " + call.id + " -- ignored! Already answering"); //ignore\n\n      return;\n    }\n\n    $log.info("[VideoServiceEventHandler]   | acceptProposition for call " + call.id); //put in answering state\n\n    call.status = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ANSWERING; //send accept to my ressources\n\n    var idAccept = "web_" + uuid4.generate();\n    var xmppMessage = $msg({\n      from: contactService.userContact.fullJid,\n      to: contactService.userContact.jid,\n      id: idAccept\n    }).c("accept", {\n      "xmlns": this.nameSpace,\n      "id": call.id\n    });\n    xmppService.send(xmppMessage);\n    var idProceed = "web_" + uuid4.generate(); //send proceed to other participant full jid\n\n    xmppMessage = $msg({\n      from: contactService.userContact.fullJid,\n      to: call.fullJid,\n      id: idProceed\n    }).c("proceed", {\n      "xmlns": this.nameSpace,\n      "id": call.id\n    });\n    xmppService.send(xmppMessage); //update local type media \n\n    var mediaToGet = ["audio"];\n\n    if (type && type === "video") {\n      mediaToGet.push("video");\n    } //video only call\n\n\n    if (call.remoteMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n      mediaToGet = ["video"];\n    } //sharing w/o audio\n\n\n    if (call.remoteMedia === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n      mediaToGet = [];\n    }\n\n    this.setLocalTypeMedia(mediaToGet, call);\n    contactService.setBusyState("dnd", this.videoService.calculatePresenceMessage(call));\n    $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n    var that = this;\n\n    if (that.videoService.autoreleaseTimeout) {\n      $interval.cancel(that.videoService.autoreleaseTimeout);\n    }\n\n    that.videoService.autoreleaseTimeout = $interval(function (_call) {\n      if (_call) {\n        if (call.getMediaPillarCall() !== null) {\n          $log.warn("[webrtcgateway/VideoServiceEventHandler] | acceptProposition autoreleaseTimeout after 45 s : remove the call :" + _call.id);\n        } else {\n          $log.webrtc("[VideoServiceEventHandler] | acceptProposition autoreleaseTimeout after 45 s : remove the call " + _call.id);\n        }\n\n        that.videoService.removeCallObject(_call);\n        contactService.resetBusyState();\n      }\n    }, 45000, 1, true, call);\n  };\n\n  VideoServiceEventHandler.prototype.rejectProposition = function (call, __reason) {\n    $log.info("[VideoServiceEventHandler]   | rejectProposition for call " + call.id); // Send reject to my ressources\n\n    var idRejectToMe = "web_" + uuid4.generate();\n    var xmppMessage = $msg({\n      from: contactService.userContact.fullJid,\n      to: contactService.userContact.jid,\n      id: idRejectToMe\n    }).c("reject", {\n      "xmlns": this.nameSpace,\n      "id": call.id\n    });\n    xmppService.send(xmppMessage); // Send reject to other participant\n\n    var mediaPillarContext = call.getMediaPillarCall();\n    var otherJid = mediaPillarContext && mediaPillarContext.mediaPillarJid ? mediaPillarContext.mediaPillarJid : call.contact.jid;\n    var idRejectToDistant = "web_" + uuid4.generate();\n\n    if (otherJid) {\n      xmppMessage = $msg({\n        from: contactService.userContact.fullJid,\n        to: otherJid,\n        id: idRejectToDistant\n      }).c("reject", {\n        "xmlns": this.nameSpace,\n        "id": call.id,\n        "reason": __reason\n      });\n      xmppService.send(xmppMessage);\n    } else {\n      $log.error("[VideoServiceEventHandler] | rejectProposition -- missing other JID !");\n    } //remove call object from current device\n    //this.videoService.removeCallObject(call); //THIS ACTION RELEASE WRONGLY THE CURRENT Media\n    // Instead Update call object\n\n\n    if (call) {\n      call.status = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN; // Remove this call from call stack\n\n      delete this.videoService.calls[call.id];\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n    } //set the webrtc configuration\n\n\n    this.videoService.setWebrtcConfiguration();\n\n    if (this.videoService.autoreleaseTimeout) {\n      $interval.cancel(this.videoService.autoreleaseTimeout);\n    }\n  };\n  /*************************************************************/\n\n  /* XMPP XEP 0353 - JINGLE MULTI CLIENT EVENT FUNCTIONS       */\n\n  /*************************************************************/\n  //all messages are received here, this function is used as a distributor\n\n\n  VideoServiceEventHandler.prototype.onMessageReceived = function (stanza) {\n    var that = this;\n\n    try {\n      $rootScope.$apply(function () {\n        $log.info("[VideoServiceEventHandler]   | onMessageReceived");\n        var temp = $(stanza);\n\n        if (temp.find("error").length > 0 || temp.find("delay").length > 0 || $(stanza).find("service-unavailable").length > 0) {\n          that.onMessageReceivedError();\n        } else if (temp.find("propose").length > 0) {\n          that.onPropositionReceived(stanza);\n        } else if (temp.find("retract").length > 0) {\n          that.onRetractReceived(stanza);\n        } else if (temp.find("reject").length > 0) {\n          that.onRejectReceived(stanza);\n        } else if (temp.find("accept").length > 0) {\n          that.onAcceptReceived(stanza);\n        } else if (temp.find("proceed").length > 0) {\n          that.onProceedReceived(stanza);\n        }\n      });\n    } catch (error) {\n      $log.error("[VideoServiceEventHandler]   | onMessageReceived error " + error);\n      return true;\n    }\n\n    return true;\n  };\n\n  VideoServiceEventHandler.prototype.onMessageReceivedError = function (stanza) {\n    $log.info("[VideoServiceEventHandler]   | onMessageReceivedError");\n    var id = $(stanza).find("propose").attr("id");\n    var call = this.videoService.calls[id]; //if call is still in DIALING state, stop it\n\n    if (call) {\n      $log.error("[VideoServiceEventHandler]   | onMessageReceivedError call is in " + call.status.value + " state"); // this.retractProposition(call);\n    }\n  }; //on new proposition received\n\n\n  VideoServiceEventHandler.prototype.onPropositionReceived = function (stanza) {\n    var id = $(stanza).find("propose").attr("id");\n    $log.info("[VideoServiceEventHandler]   | onPropositionReceived for ID " + id);\n    var call = this.videoService.calls[id];\n    var that = this;\n\n    if (!call) {\n      var jid = $(stanza).attr("from");\n      var remoteMedia = [];\n      var peerJid = xmppService.getBareJidFromJid(jid); //CRRAINB-5227++\n\n      call = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].create(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN, id, _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Type.WEBRTC);\n      call.fullJid = jid;\n      that.videoService.calls[call.id] = call; //CRRAINB-5227--\n      //get info for unified plan\n      // TO DO !!!\n\n      if (that.videoService.config.unifiedPlan) {\n        call.unifiedPlanActivated = true;\n      }\n\n      contactService.getOrCreateContact(peerJid).then(function (contact) {\n        var length = $(stanza).find("description").length;\n\n        for (var i = 0; i < length; i++) {\n          var description = $(stanza).find("description")[i];\n          remoteMedia.push($(description).attr("media"));\n        } //CRRAINB-5227++ Call.create moved before getOrCreateContact\n\n\n        if (!that.videoService.calls[call.id]) {\n          return; //no more call (probably cleared by others client accept)\n        }\n\n        call.contact = contact; //CRRAINB-5227--\n\n        if ($(stanza).find("subject").length > 0) {\n          var subject = $(stanza).find("subject")[0];\n          $log.debug("[VideoServiceEventHandler]   | onPropositionReceived subject Detected: " + subject.textContent);\n          call.setSubject(subject.textContent);\n        }\n\n        call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING);\n        that.setRemoteTypeMedia(remoteMedia, call);\n        $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call); // Disable autoReleaseTimeout\n\n        if (that.videoService.autoreleaseTimeout) {\n          $interval.cancel(that.videoService.autoreleaseTimeout);\n        }\n\n        that.videoService.autoreleaseTimeout = $interval(function (_call) {\n          if (_call) {\n            $log.webrtc("[VideoServiceEventHandler]   | onPropositionReceived autoreleaseTimeout after 2 min : remove the call " + _call.id);\n            that.videoService.removeCallObject(_call);\n          }\n        }, 120000, 1, true, call);\n      })["catch"](function (error) {\n        $log.error("[VideoServiceEventHandler]   | onPropositionReceived error " + error);\n        that.videoService.removeCallObject(call);\n      });\n    } else {\n      if ($(stanza).find("subject").length > 0) {\n        var subject = $(stanza).find("subject")[0];\n        $log.debug("[VideoServiceEventHandler]   | onPropositionReceived subject Detected: " + subject.textContent);\n        call.setSubject(subject.textContent);\n      }\n\n      call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING); //get info for unified plan\n      // TO DO !!!\n\n      if (that.videoService.config.unifiedPlan) {\n        call.unifiedPlanActivated = true;\n      }\n\n      var remoteMedia = [];\n      var length = $(stanza).find("description").length;\n\n      for (var i = 0; i < length; i++) {\n        var description = $(stanza).find("description")[i];\n        remoteMedia.push($(description).attr("media"));\n      }\n\n      this.setRemoteTypeMedia(remoteMedia, call);\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call); // Disable autoReleaseTimeout\n\n      if (that.videoService.autoreleaseTimeout) {\n        $interval.cancel(that.videoService.autoreleaseTimeout);\n      }\n\n      that.videoService.autoreleaseTimeout = $interval(function (_call) {\n        if (_call) {\n          $log.webrtc("[VideoServiceEventHandler]   | onPropositionReceived autoreleaseTimeout after 2 min : remove the call " + _call.id);\n          that.videoService.removeCallObject(_call);\n        }\n      }, 120000, 1, true, call);\n    }\n  }; //on retract received\n\n\n  VideoServiceEventHandler.prototype.onRetractReceived = function (stanza) {\n    $log.info("[VideoServiceEventHandler]   | onRetractReceveid");\n    var id = $(stanza).find("retract").attr("id");\n    var call = this.videoService.calls[id];\n\n    if (call) {\n      //if already answering the call, reset the online state        \n      if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ANSWERING) {\n        contactService.resetBusyState();\n      }\n\n      this.videoService.removeCallObject(call);\n    } // Disable autoReleaseTimeout\n\n\n    if (this.videoService.autoreleaseTimeout) {\n      $interval.cancel(this.videoService.autoreleaseTimeout);\n    }\n  }; //one of my ressources has rejected the call\n\n\n  VideoServiceEventHandler.prototype.onRejectReceived = function (stanza) {\n    $log.info("[VideoServiceEventHandler]   | onRejectReceived");\n    var id = $(stanza).find("reject").attr("id");\n    var call = this.videoService.calls[id];\n    var fullJid = $(stanza).attr("from");\n    var calendarBusy = $(stanza).find("reject").attr("reason") === "calendarBusy"; // Disable autoReleaseTimeout\n\n    if (this.videoService.autoreleaseTimeout) {\n      $interval.cancel(this.videoService.autoreleaseTimeout);\n    }\n\n    if (call) {\n      //if call has been rejected by one of my other ressources\n      if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RINGING_INCOMMING) {\n        if (call.getMediaPillarCall() !== null) {\n          //webrtcGateway situation\n          $rootScope.$broadcast("ON_MEDIAPILLAR_CALL_REMOTE_CTRL_EVENT", call);\n        }\n\n        this.videoService.removeCallObject(call);\n      } //if call has been rejected by other party\n\n\n      if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.DIALING) {\n        contactService.resetBusyState();\n        this.videoService.removeCallObject(call);\n      } //ignore the call\n\n\n      if (call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE || call.status === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.CONNECTING) {\n        //if reject from the same ressource that answered the call\n        if (call.fullJid && call.fullJid === fullJid) {\n          contactService.resetBusyState();\n          this.videoService.removeCallObject(call);\n        }\n      }\n    }\n\n    if (calendarBusy) {\n      this.videoService.openCalendarBusyPopup(call.contact.id);\n    }\n  }; //one of my ressources has accepted the call\n\n\n  VideoServiceEventHandler.prototype.onAcceptReceived = function (stanza) {\n    $log.info("[VideoServiceEventHandler]   | onAcceptReceived");\n    var id = $(stanza).find("accept").attr("id");\n    var call = this.videoService.calls[id];\n    var fullJid = $(stanza).attr("from"); //if accepted call from another ressource\n\n    if (call && fullJid !== contactService.userContact.fullJid) {\n      if (call.getMediaPillarCall() !== null) {\n        //webrtcGateway situation\n        $rootScope.$broadcast("ON_MEDIAPILLAR_CALL_REMOTE_CTRL_EVENT", call);\n      }\n\n      this.videoService.removeCallObject(call);\n    } //if call was accepted on another device, cut the autorelease timeout\n\n\n    if (fullJid !== contactService.userContact.fullJid && this.videoService.autoreleaseTimeout) {\n      $interval.cancel(this.videoService.autoreleaseTimeout);\n    }\n  }; //the call has been accepted from the other participant\n\n\n  VideoServiceEventHandler.prototype.onProceedReceived = function (stanza) {\n    $log.info("[VideoServiceEventHandler]   | onProceedReceived"); // Disable autoReleaseTimeout\n\n    if (this.videoService.autoreleaseTimeout) {\n      $interval.cancel(this.videoService.autoreleaseTimeout);\n    }\n\n    var id = $(stanza).find("proceed").attr("id");\n    var call = this.videoService.calls[id];\n    var fullJid = $(stanza).attr("from");\n    call.fullJid = fullJid; //TO DO MANAGE HERE\n\n    if (this.videoService.config.unifiedPlan) {\n      call.unifiedPlanActivated = true;\n    } //if mobile answerred the call\n\n\n    if (call.isInConversationWithMobile() && call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n      var that = this;\n      var mediaToGet = [];\n      var mediaConstraints = that.videoService.getMobileMediaConstraints("video");\n      mediaToGet = ["audio", "video"]; //if video only call (pbx case)\n\n      if (!(call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO)) {\n        mediaToGet = ["video"];\n      }\n\n      that.videoService.getBrowserMedia(mediaToGet, mediaConstraints.fixedVideoWidth, mediaConstraints.fixedVideoHeight, mediaConstraints.fixedFrameRate).then(function (stream) {\n        $log.info("[VideoServiceEventHandler]   | onProceedReceived --\x3e renegociate video quality");\n\n        if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO) {\n          that.videoService.stopActiveAudioVideoStreams(null, true);\n        }\n\n        that.videoService.localStreams.push(stream); //make the jingle call\n\n        that.videoService.makeJingleCall(call);\n      })["catch"](function (error) {\n        $log.info("[VideoServiceEventHandler]   | onProceedReceived " + call + " failure : " + error.message);\n\n        if (error.toString().indexOf("getUserMedia") !== -1) {\n          //error when trying to get camera stream\n          $log.info("onProceedReceived impossible, no webcam plugged");\n          that.videoService.openErrorPopup();\n        } else {\n          //Another kind of error will lead to call end\n          that.videoService.releaseCall(call);\n          that.videoService.resetToSafeState();\n        }\n      });\n    } else {\n      if (call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING) {\n        this.videoService.makeJingleSharingCall(call);\n      } else {\n        //make the jingle call\n        this.videoService.makeJingleCall(call);\n      }\n    }\n  };\n  /*************************************************************/\n\n  /* CALL EVENT HANDLERS                                     */\n\n  /*************************************************************/\n  // Incomming call event handler\n\n\n  VideoServiceEventHandler.prototype.incomingCall = function (callId) {\n    $log.info("[VideoServiceEventHandler] incomingCall " + callId);\n    var that = this;\n    var call = null;\n    var sess = xmppService.connection.jingle.sessions[callId];\n\n    if (sess && sess.peerjid) {\n      // Get associated contact\n      var peerJid = xmppService.getBareJidFromJid(sess.peerjid);\n      var contact = contactService.getContactByJid(peerJid);\n      call = this.videoService.getCallByJid(contact.jid);\n    }\n\n    if (call) {\n      sess.sendRinging();\n      $interval(function (_call) {\n        that.videoService.answerJingleCall(_call);\n      }, 350, 1, true, call);\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n\n      if (this.videoService.autoreleaseTimeout) {\n        $interval.cancel(this.videoService.autoreleaseTimeout);\n      }\n\n      if (this.videoService.statsInterval) {\n        $log.info("[VideoServiceEventHandler] remove getStats interval");\n        window.clearInterval(this.videoService.statsInterval);\n        this.videoService.statsinterval = null;\n      }\n\n      that.videoService.createOrUpdateStatisticsForCall(call.id);\n      $log.info("[VideoServiceEventHandler] start getStats interval");\n      this.videoService.statsInterval = sess.getStats(5000);\n    } else {\n      $log.warn("[VideoServiceEventHandler] incomingCall no such call ! Terminate the session ");\n      contactService.resetBusyState();\n\n      if (sess) {\n        sess.terminate();\n      }\n    }\n\n    return;\n  }; // Active video call event handler\n\n\n  VideoServiceEventHandler.prototype.activeCall = function (callId) {\n    $log.info("[VideoServiceEventHandler] activeCall " + callId);\n    var sess = xmppService.connection.jingle.sessions[callId]; // Disable autoReleaseTimeout\n\n    if (this.videoService.autoreleaseTimeout) {\n      $interval.cancel(this.videoService.autoreleaseTimeout);\n    }\n\n    var call = this.videoService.calls[callId];\n    this.videoService.updateRemoteTypeMedia(sess.remoteType, call);\n\n    if (call && call.status.key !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.RELEASING.key && call.status.key !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN.key) {\n      call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE);\n      $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n    }\n\n    if (call.isInitiator) {\n      // Track the number of success call\n      gaService.trackCallSuccessNumber(sess.localType);\n    }\n  }; // Terminate video call event handler\n\n\n  VideoServiceEventHandler.prototype.terminatedCall = function (callId, callReason) {\n    if (Object.keys(xmppService.connection.jingle.sessions).length === 0) {\n      $log.webrtc("INFO    | all calls terminated");\n    }\n\n    var call = this.videoService.calls[callId]; //if the terminated call does not exist, but we still have other calls, do nothing\n\n    if (!call && this.videoService.calls.length !== 0) {\n      $log.webrtc("INFO    | terminatedCall : no call with " + callId + " exists.");\n      return;\n    }\n\n    if (callReason === "busy") {\n      this.videoService.openErrorPopup("remoteUserNoMoreAvailable");\n    } // Disable autoReleaseTimeout\n\n\n    if (this.videoService.autoreleaseTimeout) {\n      $interval.cancel(this.videoService.autoreleaseTimeout);\n    } //release media resources\n\n\n    this.videoService.disableAudioVideoMedia(null, callId); //session is null because it does not exist anymore (removed by strophe layer)\n\n    this.videoService.createOrUpdateStatisticsForCall(callId);\n\n    if (this.videoService.callsStats[callId]) {\n      delete this.videoService.callsStats[callId];\n    }\n\n    if (call) {\n      if (callReason !== "cancel") {\n        //Track call duration\n        gaService.trackCallDuration(new Date().getTime() - call.startDate.getTime());\n      }\n\n      this.videoService.removeCallObject(call);\n    }\n\n    $interval(function () {\n      //wait 1 sec, because sometimes the busy presence arrives later and the user stays blocked in busy state\n      //because his presence state is online at that exact moment\n      contactService.resetBusyState();\n    }, 1000, 1, true); // Disable autoReleaseTimeout\n\n    if (this.videoService.statsInterval) {\n      window.clearInterval(this.videoService.statsInterval);\n      this.videoService.statsinterval = null;\n    }\n\n    this.videoService.displayWebRTCStats(callId);\n\n    if (!this.videoService.isUserContactInCall()) {\n      this.videoService.clearSrcObjectsFromElements();\n    }\n  };\n\n  VideoServiceEventHandler.prototype.onJingleError = function (sid) {\n    var that = this;\n\n    if (sid && that.videoService.calls[sid] && that.videoService.calls[sid].status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE) {\n      that.videoService.removeCallObject(that.calls[sid]);\n      that.videoService.resetToSafeState();\n      that.videoService.openErrorPopup("IceConnectionFailed");\n    }\n  }; // ICE state change event handler\n\n\n  VideoServiceEventHandler.prototype.iceConnectionStateChange = function (sid, sess) {\n    $log.info("[VideoServiceEventHandler] iceConnectionStateChange for " + sid);\n    var that = this;\n    var activeCall = null;\n    var call = that.videoService.calls[sess.sid];\n\n    try {\n      if (sess.peerconnection && sess.peerconnection.signalingState === "stable" && sess.peerconnection.iceConnectionState === "connected") {\n        $log.webrtc("INFO    | ICE Connection established successfully");\n\n        if (angular.element("#globalAudioTag")[0]) {\n          $log.info("[VideoServiceEventHandler] sinkId for globalAudioTag is " + angular.element("#globalAudioTag")[0].sinkId);\n        }\n\n        that.videoService.reconnectCall = false;\n        activeCall = that.videoService.calls[sid];\n\n        if (activeCall && activeCall.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE) {\n          // angular.element("<video autoplay=\'autoplay\' style=\'display:none\'/>").attr("id", "largevideo_" + sid);\n          $log.webrtc("INFO    | ICE Connection : call is active now !");\n          this.activeCall(sid);\n        } //if renegotiation\n\n\n        if (sess.isRenegotiating) {\n          $log.webrtc("INFO    | Renegotiating done");\n          sess.isRenegotiating = false;\n          $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION", activeCall); // Warning: specific event for SDK\n\n          $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION_SUCCESS", activeCall);\n        } //disable timer\n\n\n        if (sess.autoReconnectTimer) {\n          $interval.cancel(sess.autoReconnectTimer);\n          sess.autoReconnectTimer = null;\n        } // Compute the negotiation time\n\n\n        gaService.endNegotiationTime(); //GA track Negotiation time\n\n        var negotiationTime = gaService.negotiationTime();\n\n        if (negotiationTime) {\n          $log.webrtc("INFO    | negotiation time: " + negotiationTime + "ms");\n          gaService.trackNegotiationTime();\n        } // GA track ICE Success - only on one side\n\n\n        if (activeCall && activeCall.isInitiator) {\n          gaService.trackICESuccess(sid);\n        }\n      }\n\n      if (sess.peerconnection && sess.peerconnection.signalingState === "stable" && sess.peerconnection.iceConnectionState === "completed") {\n        $log.webrtc("INFO    | ICE Connection completed successfully");\n        that.videoService.reconnectCall = false;\n        activeCall = that.videoService.calls[sid];\n\n        if (activeCall && activeCall.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE) {\n          // angular.element("<video autoplay=\'autoplay\' style=\'display:none\'/>").attr("id", "largevideo_" + sid);\n          $log.webrtc("INFO    | ICE Connection : call is active now !");\n          this.activeCall(sid);\n        } //if renegotiation\n\n\n        if (sess.isRenegotiating) {\n          $log.webrtc("INFO    | Renegotiating done");\n          sess.isRenegotiating = false;\n          $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION", activeCall); // Warning: specific event for SDK\n\n          $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION_SUCCESS", activeCall);\n        }\n      }\n\n      if (sess.peerconnection && sess.peerconnection.signalingState === "stable" && sess.peerconnection.iceConnectionState === "disconnected") {\n        $log.webrtc("INFO    | signalingState disconnected");\n\n        if (call && call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN) {\n          $log.webrtc("INFO    | iceConnectionStateChange go to connecting state");\n          call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.CONNECTING);\n          $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n        }\n\n        if (!that.videoService.connected) {\n          that.videoService.reconnectCall = true;\n        }\n\n        if (!sess.autoReconnectTimer) {\n          console.error("arm autoReconnectTimer");\n          sess.autoReconnectTimer = $interval(function (session) {\n            console.error("autoReconnectTimer -- execute");\n\n            if (that.videoService.connected) {\n              console.error("autoReconnectTimer -- network OK, proceed with reconnect");\n              session.reconnectSession();\n            }\n          }, 1000, 1, true, sess);\n        }\n      }\n\n      if (sess.peerconnection && sess.peerconnection.signalingState === "stable" && sess.peerconnection.iceConnectionState === "failed") {\n        $log.webrtc("INFO    | signalingState FAILED");\n\n        if (call && call.status !== _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.UNKNOWN) {\n          $log.webrtc("INFO    | iceConnectionStateChange go to connecting state");\n          call.setStatus(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.CONNECTING);\n          $rootScope.$broadcast("ON_CALL_UPDATED_EVENT", call);\n          $rootScope.$broadcast("ON_RECORDING_CNXLOST_EVENT");\n        }\n\n        if (!that.videoService.connected) {\n          that.videoService.reconnectCall = true;\n        }\n\n        if (that.videoService.connected) {\n          //try to reconnect session\n          console.error("[videoServiceEventHandler] signalingState FAILED -- network OK, proceed with reconnect");\n          session.reconnectSession();\n        }\n      }\n    } catch (error) {\n      try {\n        $log.error("JINGLE  | iceconnectionstatechange error " + error);\n\n        if (call) {\n          that.videoService.removeCallObject(call, "unsupported-applications");\n        } else {\n          xmppService.connection.jingle.terminate(null, "unsupported-applications");\n        }\n\n        contactService.resetBusyState();\n      } catch (err) {\n        $log.error("JINGLE  | iceconnectionstatechange error " + err);\n        contactService.resetBusyState();\n      }\n    }\n  }; // media modified call event handler\n\n\n  VideoServiceEventHandler.prototype.mediaModified = function (sid, mediaType) {\n    $log.info("[VideoServiceEventHandler] mediaModified " + sid);\n    var call = this.videoService.calls[sid];\n    var sess = xmppService.connection.jingle.sessions[sid];\n    sess.isRenegotiating = true;\n\n    if (mediaType === "sharing") {\n      call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING;\n    } else if (mediaType === "video") {\n      call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO;\n    } else if (mediaType === "sharing+video") {\n      call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.VIDEO | _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.SHARING;\n    } else {\n      call.remoteMedia = _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO;\n    }\n\n    contactService.setBusyState("dnd", this.videoService.calculatePresenceMessage(call));\n    $rootScope.$broadcast("ON_WEBRTC_CALL_ESCALATION", call);\n  };\n\n  return VideoServiceEventHandler;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/video/videoServiceEventHandler.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _src_models_call_model__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_models_call_model__WEBPACK_IMPORTED_MODULE_0__);\n\nangular.module("rainbow").service("webrtcServiceEventHandler", ["$log", "$q", "$rootScope", "videoService", "webConferenceService", "xmppService", "contactService", function ($log, $q, $rootScope, videoService, webConferenceService, xmppService, contactService) {\n  "use strict";\n\n  var service = this;\n  /* xep-0353 (jingle multi-ressource) variables */\n\n  this.nameSpace = "urn:xmpp:jingle-message:0";\n  this.messageHandlerRef = null;\n  this.started = false;\n\n  this.start = function () {\n    this.started = true;\n    this.attachHandlers();\n    return $q.when();\n  };\n\n  this.stop = function () {\n    this.started = false;\n    service.removeHandlers();\n    return $q.when();\n  };\n\n  this.attachHandlers = function () {\n    this.removeHandlers();\n    $log.info("[webrtcServiceEventHandler] attachHandlers"); // Attach messages handler\n\n    if (!this.messageHandlerRef) {\n      this.messageHandlerRef = xmppService.addHandler(function (stanza) {\n        try {\n          service.onMessageReceived(stanza);\n          return true;\n        } catch (err) {\n          $log.error("[webrtcServiceEventHandler] caught error " + err);\n          return true;\n        }\n      }, service.nameSpace, "message");\n    }\n  };\n\n  this.removeHandlers = function () {\n    $log.info("[webrtcServiceEventHandler] removeHandlers"); //remove all handlers\n\n    if (this.messageHandlerRef) {\n      xmppService.deleteHandler(this.messageHandlerRef);\n      this.messageHandlerRef = null;\n    }\n  };\n  /*\n  * All XEP 0353 messages are received here\n  * They should be separated for Conference and P2P cases \n  */\n\n\n  this.onMessageReceived = function (stanza) {\n    var fromJid = $(stanza).attr("from");\n    var bareJid = xmppService.getBareJidFromJid(fromJid);\n    var proposeNode = $(stanza).find("propose");\n    var conferenceNode = proposeNode.find("conference");\n    var conferenceSessionId = conferenceNode.attr("id");\n    var conferenceSession = webConferenceService.getConferenceSessionById(conferenceSessionId);\n\n    if (conferenceSession) {\n      // handle internally messages from janusgateway\n      try {\n        $log.info("[webrtcServiceEventHandler]   | onMessageReceived");\n        var temp = $(stanza);\n\n        if (temp.find("propose").length > 0) {\n          var id = $(stanza).find("propose").attr("id"); //send accept to my ressources\n\n          var xmppMessage = $msg({\n            from: contactService.userContact.fullJid,\n            to: contactService.userContact.jid\n          }).c("accept", {\n            "xmlns": this.nameSpace,\n            "id": id\n          });\n          xmppService.send(xmppMessage); //send proceed \n\n          var xmppMessage = $msg({\n            from: contactService.userContact.fullJid,\n            to: bareJid\n          }).c("proceed", {\n            "xmlns": this.nameSpace,\n            "id": id\n          });\n          xmppService.send(xmppMessage);\n          return true;\n        }\n      } catch (error) {\n        // Let videoEventHandler handle errors\n        return videoService.videoEventHandler.onMessageReceived(stanza);\n      }\n    }\n\n    return videoService.videoEventHandler.onMessageReceived(stanza);\n  };\n\n  this.checkSessionAudioSentHealthStatus = function (sid) {\n    $log.info("[webrtcServiceEventHandler]   | checkSessionAudioSentHealthStatus --- 0 audio packets sent !");\n    var call = videoService.calls[sid];\n\n    if (call && !call.isInCallWithMediaPillar()) {\n      //if we\'ve audio in the call\n      if (call.status.key === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE.key && call.localMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO && !call.isMuted) {\n        videoService.callsStatsSimplified[sid].numberOfErrorAudioSent += 1;\n\n        if (videoService.callsStatsSimplified[sid].numberOfErrorAudioSent % 2) {\n          $log.info("[webrtcServiceEventHandler]   | checkSessionAudioSentHealthStatus --- ingore");\n          return;\n        }\n\n        var session = xmppService.connection.jingle.sessions[call.id];\n\n        if (session && !session.isRenegotiating) {\n          $log.info("[webrtcServiceEventHandler]   | checkSessionAudioSentHealthStatus --- renego P2P call");\n          videoService.renegotiateCurrentCall(call);\n        } //notify the user that there\'s an issue with his audio\n\n\n        $rootScope.$broadcast("ON_WEBRTC_CALL_AUDIO_ISSUE", true);\n      }\n    } else {\n      var confSession = webConferenceService.getActiveConferenceSession();\n\n      if (confSession && confSession.id && confSession.active && confSession.status === "connected") {\n        var audioSession = webConferenceService.getRemoteAudioSession(confSession.id);\n\n        if (audioSession && audioSession.sid === sid) {\n          videoService.callsStatsSimplified[sid].numberOfErrorAudioSent += 1;\n\n          if (videoService.callsStatsSimplified[sid].numberOfErrorAudioSent % 2) {\n            $log.info("[webrtcServiceEventHandler]   | checkSessionAudioSentHealthStatus --- ingore");\n            return;\n          }\n\n          $log.info("[webrtcServiceEventHandler]   | checkSessionAudioSentHealthStatus --- renego SFU conference");\n          webConferenceService.onAudioProfileChangeEvent();\n        }\n      }\n    }\n  };\n\n  this.checkSessionAudioReceivedHealthStatus = function (sid) {\n    $log.info("[webrtcServiceEventHandler]   | checkSessionAudioReceivedHealthStatus --- user hears nothing !");\n    var call = videoService.calls[sid];\n\n    if (call && !call.isInCallWithMediaPillar()) {\n      //if we\'ve audio in the call\n      if (call.status.key === _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Status.ACTIVE.key && call.remoteMedia & _src_models_call_model__WEBPACK_IMPORTED_MODULE_0__["Call"].Media.AUDIO) {\n        videoService.callsStatsSimplified[sid].errorAudioReceived = 1;\n        $log.info("[webrtcServiceEventHandler]   | checkSessionAudioReceivedHealthStatus --- reset output device");\n        videoService.resetAudioOutputElement();\n      }\n    } else {\n      var confSession = webConferenceService.getActiveConferenceSession();\n\n      if (confSession && confSession.id && confSession.active && confSession.status === "connected") {\n        var audioSession = webConferenceService.getRemoteAudioSession(confSession.id);\n\n        if (audioSession && audioSession.sid === sid) {\n          videoService.callsStatsSimplified[sid].errorAudioReceived = 1;\n          $log.info("[webrtcServiceEventHandler]   | checkSessionAudioReceivedHealthStatus --- renego SFU conference");\n          videoService.resetAudioOutputElement();\n        }\n      }\n    }\n  };\n\n  angular.element(document).bind("callincoming.jingle", function (__event, sessId) {\n    $log.webrtc("webrtcServiceEventHandler  | callincoming.jingle " + sessId);\n    var session = xmppService.connection.jingle.sessions[sessId]; //check if the session is related to a web conference\n\n    if (session && session.confId) {\n      webConferenceService.onIncomingCall(sessId);\n    } else {\n      videoService.videoEventHandler.incomingCall(sessId);\n    }\n  }); // Clear video call event handler\n\n  angular.element(document).bind("callterminated.jingle", function (__event, sessId, reason) {\n    $rootScope.$apply(function () {\n      var callReason = reason ? reason : "";\n      $log.webrtc("webrtcServiceEventHandler  | callterminated " + sessId + " reason: " + callReason);\n\n      if (reason === "multi-device") {\n        webConferenceService.onConferenceCallSwitched(sessId);\n      } else {\n        var call = videoService.calls[sessId];\n\n        if (call) {\n          videoService.videoEventHandler.terminatedCall(sessId, callReason);\n        } else {\n          webConferenceService.onTerminatedCall(sessId);\n        }\n      }\n    });\n  });\n  angular.element(document).bind("iceconnectionstatechange.jingle", function (__event, sid, sess) {\n    if (!sess.peerconnection) {\n      $log.webrtc("JINGLE  | iceconnectionstatechange - peerConnection does not exist anymore !!!");\n      return;\n    }\n\n    $log.webrtc("JINGLE  | iceconnectionstatechange " + sid + " " + sess.peerconnection.iceConnectionState + "|" + sess.peerconnection.signalingState);\n    var call = videoService.calls[sid];\n\n    if (call) {\n      videoService.videoEventHandler.iceConnectionStateChange(sid, sess);\n    } else {\n      webConferenceService.onIceConnectionStateChange(sid, sess);\n    }\n  });\n  angular.element(document).bind("error.jingle", function (__event, obj) {\n    $log.error("JINGLE  | callerror");\n\n    if (obj && obj.error) {\n      $log.error(JSON.stringify(obj.error));\n    }\n\n    var sid = obj.sid;\n\n    if (sid) {\n      var call = videoService.calls[sid];\n\n      if (call) {\n        videoService.videoEventHandler.onJingleError(sid);\n      } else {\n        webConferenceService.onJingleError(sid);\n      }\n    }\n  });\n  angular.element(document).bind("webrtcSessionBitRate.jingle", function (__event, sid, data) {\n    $rootScope.$broadcast("ON_WEBRTC_CALL_BITRATE", sid, data);\n  });\n  angular.element(document).bind("webrtcSessionStatsSimplyfied.jingle", function (__event, sid, data) {\n    if (!videoService.callsStatsSimplified[sid]) {\n      videoService.callsStatsSimplified[sid] = {};\n      videoService.callsStatsSimplified[sid].numberOfErrorAudioSent = 0;\n      videoService.callsStatsSimplified[sid].errorAudioReceived = 0;\n    } //save the current number of times there\'re no audio packages\n\n\n    data.numberOfErrorAudioSent = videoService.callsStatsSimplified[sid].numberOfErrorAudioSent;\n    data.errorAudioReceived = videoService.callsStatsSimplified[sid].errorAudioReceived;\n    videoService.callsStatsSimplified[sid] = data;\n    $log.info("[videoService] on webrtcSessionStatsSimplyfied for session " + sid + " : " + JSON.stringify(data)); //ignore these stats in case of Chrome, version >= 71\n\n    if (adapter["default"].browserDetails.browser === "chrome" && adapter["default"].browserDetails.version < 71) {\n      //check if sent audio packages is 0\n      if (data.packetsAudioSent === 0 || data.audioInputLevel === 0) {\n        service.checkSessionAudioSentHealthStatus(sid);\n      } else {\n        if (videoService.callsStatsSimplified[sid].numberOfErrorAudioSent) {\n          //notify the user that there\'s no longer an issue with his audio\n          $rootScope.$broadcast("ON_WEBRTC_CALL_AUDIO_ISSUE", false);\n        }\n\n        videoService.callsStatsSimplified[sid].numberOfErrorAudioSent = 0;\n      }\n    } //if audio pakets are received, but the output is still 0\n    //we should reset the output devices\n    // NB !! When the micro is muted, we will go inside this case, so we should not do it too often\n    //so the audio settings will be reset only once, the first time we detect this issue\n\n\n    if (data.packetsAudioReceived && data.audioOutputLevel === 0 && data.errorAudioReceived === 0) {\n      service.checkSessionAudioReceivedHealthStatus(sid);\n    }\n  });\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/video/webrtcServiceEventHandler.js?')},function(module,exports){eval('angular.module("rainbow").service("settingsService", ["$rootScope", "$translate", "$localStorage", function ($rootScope, $translate, $localStorage) {\n  "use strict"; // Store context\n\n  var service = this;\n  /*****************************************************/\n\n  /**  INITIALIZATION STUFF                           **/\n\n  /*****************************************************/\n\n  service.initialize = function () {\n    $localStorage.get(["redirectVoIP"]).then(function (result) {\n      if (result.redirectVoIP !== null) {\n        service.redirectVoIP = result.redirectVoIP === "true";\n      } else {\n        service.setRedirectVoIP(false);\n        service.redirectVoIP = false;\n      }\n    }); // Available languages\n\n    service.defaultLanguage = {\n      label: "English",\n      settingCode: "en",\n      code: "en",\n      isoCode: "en",\n      codeMoment: "en",\n      unicode: "1f1ec-1f1e7",\n      beta: false\n    };\n    service.languages = [service.defaultLanguage, {\n      label: "Français",\n      settingCode: "fr",\n      code: "fr",\n      isoCode: "fr",\n      codeMoment: "fr",\n      unicode: "1f1eb-1f1f7",\n      beta: false\n    }, {\n      label: "Deutsch",\n      settingCode: "de",\n      code: "de",\n      isoCode: "de",\n      codeMoment: "de",\n      unicode: "1f1e9-1f1ea",\n      beta: false\n    }, {\n      label: "Español",\n      settingCode: "es-es",\n      code: "es-es",\n      isoCode: "es-ES",\n      codeMoment: "es",\n      unicode: "1f1ea-1f1f8",\n      beta: false\n    }, {\n      label: "Suomi",\n      settingCode: "fi",\n      code: "fi",\n      isoCode: "fi",\n      codeMoment: "fi",\n      unicode: "1f1eb-1f1ee",\n      beta: true\n    }, {\n      label: "Italiano",\n      settingCode: "it",\n      code: "it",\n      isoCode: "it",\n      codeMoment: "it",\n      unicode: "1f1ee-1f1f9",\n      beta: false\n    }, {\n      label: "עברית",\n      settingCode: "he",\n      code: "he",\n      isoCode: "he",\n      codeMoment: "he",\n      unicode: "1f1ee-1f1f1",\n      beta: false\n    }, {\n      label: "日本語",\n      settingCode: "ja",\n      code: "ja",\n      isoCode: "ja",\n      codeMoment: "ja",\n      unicode: "1f1ef-1f1f5",\n      beta: false\n    }, {\n      label: "한국어",\n      settingCode: "ko",\n      code: "ko",\n      isoCode: "ko",\n      codeMoment: "ko",\n      unicode: "1f1f0-1f1f7",\n      beta: false\n    }, {\n      label: "Nederlands",\n      settingCode: "nl",\n      code: "nl",\n      isoCode: "nl",\n      codeMoment: "nl",\n      unicode: "1F1F3-1F1F1",\n      beta: false\n    }, {\n      label: "Nynorsk",\n      settingCode: "no",\n      code: "no",\n      isoCode: "no",\n      codeMoment: "nn",\n      unicode: "1F1F3-1F1F4",\n      beta: true\n    }, {\n      label: "Português do Brasil",\n      settingCode: "pt-br",\n      code: "pt-BR",\n      isoCode: "pt-BR",\n      codeMoment: "pt-br",\n      unicode: "1F1E7-1F1F7",\n      beta: false\n    }, {\n      label: "Português",\n      settingCode: "pt-pt",\n      code: "pt-PT",\n      isoCode: "pt-PT",\n      codeMoment: "pt",\n      unicode: "1F1F5-1F1F9",\n      beta: false\n    }, {\n      label: "Polski",\n      settingCode: "pl",\n      code: "pl",\n      isoCode: "pl",\n      codeMoment: "pl",\n      unicode: "1F1F5-1F1F1",\n      beta: true\n    }, {\n      label: "Svenskt",\n      settingCode: "sv-se",\n      code: "sv-SE",\n      isoCode: "sv-SE",\n      codeMoment: "sv",\n      unicode: "1F1F8-1F1EA",\n      beta: true\n    }, {\n      label: "Türkçe",\n      settingCode: "tr",\n      code: "tr",\n      isoCode: "tr",\n      codeMoment: "tr",\n      unicode: "1f1f9-1f1f7",\n      beta: false\n    }, {\n      label: "中文",\n      settingCode: "zh-cn",\n      code: "zh-cn",\n      isoCode: "zh-CN",\n      codeMoment: "zh-cn",\n      unicode: "1f1e8-1f1f3",\n      beta: false\n    }, {\n      label: "繁體中文",\n      settingCode: "zh-tw",\n      code: "zh-TW",\n      isoCode: "zh-TW",\n      codeMoment: "zh-tw",\n      unicode: "1F1F9-1F1FC",\n      beta: false\n    }, {\n      label: "العربية",\n      settingCode: "ar",\n      code: "ar",\n      isoCode: "ar",\n      codeMoment: "ar",\n      unicode: "0600–06FF",\n      beta: false\n    }];\n    service.languageCodes = service.getAvailableLanguages().map(function (language) {\n      return language.settingCode;\n    }); // Default settings\n\n    service.settings = {\n      "init": true,\n      "lang": "en",\n      "imSound": "true",\n      "imNotif": "true",\n      "notifReminder": "gentle",\n      "displayOrder": "FL",\n      "nbMaxConversations": "100",\n      "skin": "rainbow",\n      "microphone": "default",\n      "headsetMicrophone": null,\n      "speakerphoneMicrophone": null,\n      "customMicrophone": null,\n      "headsetDeviceName": null,\n      "speakerphoneDeviceName": null,\n      "speaker": "default",\n      "headsetSpeaker": null,\n      "speakerphoneSpeaker": null,\n      "customSpeaker": null,\n      "ringingSpeaker": "default",\n      "ringingSpeakerName": "",\n      "camera": "default",\n      "cameraUsed": "",\n      "audioProfile": "handfree",\n      "currentDevice": null,\n      "iceConfig": null,\n      "sdk": false,\n      "userWiewOrderType": "lastname",\n      "userWiewFilterType": "all",\n      "one2oneColors": "true",\n      "accessibleColors": "false",\n      "autoStartAnimatedGif": "false",\n      "translationMsg": "false",\n      "newUI": "false",\n      "autoAcceptRoomInvite": "false",\n      "server": null,\n      "activeAlarm": "relax1",\n      "activeNotif": "stairs",\n      "devMode": "false",\n      "hasSecondRinger": "false",\n      "validationMode": "false",\n      "disableCalendarPresence": "false",\n      "giphy": "false",\n      "deviceList": "[]",\n      "displayFilesType": "document-cell--as-grid",\n      "handFreeInputDeviceName": null,\n      "handFreeOutputDeviceName": null,\n      "customSpeakerName": null,\n      "customMicrophoneName": null,\n      "showBodyMessage": "false",\n      "bubblesFilterType": "all",\n      "bubblesOrderType": "lastActivityDate",\n      "suggestionDisplayed": "null",\n      "protectionAgainstMailTypeOffline": false,\n      "channelMarkdown": "false",\n      "chrisPrankMode": "true",\n      "joinSfuSound": "true",\n      "guideTourDisplayed": "null",\n      "searchFilterValue": "NoFiltering",\n      // Experimental features. Turn them on at your own risk.\n      // "disableSingleSignOn": "true", // disable the "email first" sign-in flow and therefore Single Sign-On feature.\n      "enableSingleSignOnWebAuthPopup": "false",\n      // IdP login page will appear in a window popup, even in web browser.\n      "enableSingleSignOnConfig": "false",\n      // allow SSO configuration even if COMPANY_SINGLE_SIGN_ON_SAML feature is not set in profile.\n      "enableDSCP": false,\n      // enable DSCP tagging for webrtc packages \n      "filterIce": false,\n      //filter prfxl ICE candidates,\n      "dtx": false,\n      // Discontinuous Transmission (DTX)\n      "simulcast": false,\n      //Enable simulcasting (conference usage)\n      "debugWebRTC": false,\n      //enable debug mode in WebRTC (with several options in conference call)\n      "unifiedPlan": false,\n      //force Unified Plan for WebRTC calls\n      "sipWiseMode": "false",\n      // sipWise mode\n      "lastInactiveBubbleShownDate": null,\n      "userEnvironment": ""\n    }; // Get all settings\n\n    $localStorage.get(Object.keys(service.settings)).then(function (settings) {\n      if (!settings.nbMaxConversations) {\n        settings.nbMaxConversations = service.settings.nbMaxConversations;\n      } else {\n        //in case the value is less than 15, reset it to 15\n        var nbMaxConversations = parseInt(settings.nbMaxConversations, 10);\n\n        if (nbMaxConversations < 15) {\n          service.setSetting("nbMaxConversations", 15);\n        }\n      }\n\n      if (!settings.skin) {\n        settings.skin = service.settings.skin;\n      } // If a language was set in query params, use it\n\n\n      if ($rootScope.default_language) {\n        settings.lang = getMappedLanguage($rootScope.default_language);\n        service.setSetting("lang", settings.lang);\n      }\n\n      if (settings.headsetMicrophone === "default") {\n        settings.headsetMicrophone = null;\n      }\n\n      if (settings.headsetSpeaker === "default") {\n        settings.headsetSpeaker = null;\n      }\n\n      if (settings.speakerphoneMicrophone === "default") {\n        settings.speakerphoneMicrophone = null;\n      }\n\n      if (settings.speakerphoneSpeaker === "default") {\n        settings.speakerphoneSpeaker = null;\n      }\n\n      if (settings.customMicrophone === "default") {\n        settings.customMicrophone = null;\n      }\n\n      if (settings.customSpeaker === "default") {\n        settings.customSpeaker = null;\n      } // If not init, initialize localStorage with default values\n\n\n      if (settings.init === null) {\n        var preferredLanguage = navigator.languages ? navigator.languages[0] : navigator.language || navigator.userLanguage;\n        service.settings.lang = settings.lang ? settings.lang : getMappedLanguage(preferredLanguage);\n        $localStorage.set(service.settings);\n      } // Else use received settings or set to default values\n      else {\n          Object.keys(settings).forEach(function (item) {\n            if (settings[item] !== null) {\n              service.settings[item] = settings[item];\n            }\n          });\n        } // Handle current language\n\n\n      var currentLanguage = service.getAppliLanguage();\n      $translate.use(currentLanguage.code);\n      moment.locale(currentLanguage.codeMoment);\n    });\n  };\n  /*****************************************************/\n\n  /**  GENERIC STUFF                                  **/\n\n  /*****************************************************/\n\n\n  service.getSetting = function (key) {\n    return service.settings[key];\n  };\n  /**\n         * SET SETTING\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.setSetting = function (key, value) {\n    service.settings[key] = value;\n    $localStorage.set(service.settings);\n  };\n\n  service.removeSetting = function (key) {\n    service.settings[key] = undefined;\n    $localStorage.remove([key]);\n  };\n  /*****************************************************/\n\n  /**  LANGUAGE STUFF                                 **/\n\n  /*****************************************************/\n\n\n  service.getAvailableLanguages = function () {\n    return service.languages.filter(function (language) {\n      return language.beta === false || config.betaLanguages;\n    });\n  };\n\n  service.getAppliLanguage = function () {\n    var language = service.getAvailableLanguages().filter(function (item) {\n      return item.settingCode === service.settings.lang;\n    })[0];\n    return language ? language : service.defaultLanguage;\n  };\n\n  service.setAppliLanguageCode = function (lang, save) {\n    if (save) {\n      service.setSetting("lang", lang);\n    } else {\n      service.settings.lang = lang;\n    }\n\n    var language = service.getAppliLanguage();\n    moment.locale(language.codeMoment);\n    $translate.use(language.code).then(function () {\n      $rootScope.$broadcast("ON_LANGUAGE_UPDATED_EVENT", lang);\n    });\n  };\n\n  service.getAppliLanguageCodeForServer = function () {\n    var langArray = service.settings.lang.split("-");\n\n    if (langArray.length === 1) {\n      return service.settings.lang;\n    }\n\n    return langArray[0] + "-" + langArray[1].toUpperCase();\n  };\n\n  service.setAppliLangageCodeFromServer = function (serverCode) {\n    var langArray = serverCode.split("-");\n    var clientCode = langArray[0];\n\n    if (clientCode) {\n      clientCode = clientCode.toLowerCase();\n    }\n\n    if (langArray.length === 2) {\n      clientCode += "-" + langArray[1].toLowerCase();\n    }\n\n    clientCode = getMappedLanguage(clientCode);\n    clientCode = service.languageCodes.indexOf(clientCode) >= 0 ? clientCode : "en";\n    service.setAppliLanguageCode(clientCode);\n  };\n\n  service.getLanguageByIsoCode = function (isoCode) {\n    return service.languages.find(function (lang) {\n      return lang.isoCode === isoCode;\n    });\n  };\n\n  service.getBestLanguageForIsoCode = function (isoCode) {\n    //find exact language\n    var language = service.getLanguageByIsoCode(isoCode);\n\n    if (!language) {\n      //exact language not found: try to find language without country variant (if any)\n      if (isoCode.indexOf("-") !== -1) {\n        var isoLanguageWithoutCountry = isoCode.split("-")[0]; //remove country variant\n\n        language = service.getLanguageByIsoCode(isoLanguageWithoutCountry);\n      }\n\n      if (!language) {\n        //still not found: finally select the language for isoCode "en"\n        language = service.getLanguageByIsoCode("en");\n      }\n    }\n\n    return language;\n  };\n  /*****************************************************/\n\n  /** redirect VoIP\t\t\t\t\t\t\t\t\t**/\n\n  /*****************************************************/\n\n\n  service.getRedirectVoIP = function () {\n    return service.redirectVoIP;\n  };\n\n  service.setRedirectVoIP = function (isActivated) {\n    $localStorage.set({\n      "redirectVoIP": isActivated\n    });\n    service.redirectVoIP = isActivated;\n  };\n  /*****************************************************/\n\n  /**  STUN/TURN CONFIG STUFF                         **/\n\n  /*****************************************************/\n\n\n  service.setIceConfig = function (iceConfig) {\n    service.settings.iceConfig = iceConfig;\n  };\n\n  service.forceTurn = function (turnOn) {\n    // Update global config object\n    config.turnOn = turnOn;\n    var message = turnOn ? "Debug mode : Only use turn servers" : "Normal mode : use stun and turn servers";\n    $rootScope.$broadcast("ON_SETTING_FORCE_TURN_EVENT", message);\n  };\n  /*****************************************************/\n\n  /**  STUN/TURN CONFIG STUFF                         **/\n\n  /*****************************************************/\n\n\n  service.enableRemoteConsole = function (channelId) {\n    var script = document.createElement("script");\n    script.src = "//console.re/connector.js";\n    script.id = "consolerescript";\n    script.setAttribute("data-channel", channelId);\n\n    script.onreadystatechange = script.onload = function () {\n      app.remoteConsole.info = true;\n      app.remoteConsole.debug = true;\n      app.remoteConsole.log = true;\n      console.re.info("Connected");\n    };\n\n    document.getElementsByTagName("head")[0].appendChild(script);\n  }; // Translate the language return by the browser to a language supported by the application\n\n\n  var getMappedLanguage = function getMappedLanguage(codedLanguage) {\n    var lang = "en"; // If no given language, return English as default\n\n    if (codedLanguage) {\n      var encodedLang = codedLanguage.split("-")[0];\n\n      switch (encodedLang) {\n        case "ar":\n          lang = "ar";\n          break;\n\n        case "en":\n          lang = "en";\n          break;\n\n        case "fr":\n          lang = "fr";\n          break;\n\n        case "de":\n          lang = "de";\n          break;\n\n        case "es":\n          lang = "es-es";\n          break;\n\n        case "fi":\n          lang = "fi";\n          break;\n\n        case "it":\n          lang = "it";\n          break;\n\n        case "he":\n          lang = "he";\n          break;\n\n        case "ja":\n          lang = "ja";\n          break;\n\n        case "ko":\n          lang = "ko";\n          break;\n\n        case "nl":\n          lang = "nl";\n          break;\n\n        case "no":\n          lang = "no";\n          break;\n\n        case "pt":\n          lang = codedLanguage.toLowerCase() === "pt-br" ? "pt-br" : "pt-pt";\n          break;\n\n        case "pl":\n          lang = "pl";\n          break;\n\n        case "sv":\n          lang = "sv-SE";\n          break;\n\n        case "tr":\n          lang = "tr";\n          break;\n\n        case "zh":\n          lang = ["zh-cn", "zh-tw"].indexOf(codedLanguage.toLowerCase()) >= 0 ? codedLanguage.toLowerCase() : "zh-cn";\n          break;\n\n        default:\n          lang = "en";\n      }\n    }\n\n    return lang;\n  };\n\n  service.initialize();\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/settingsService.js?')},function(module,exports){eval('/**\n * @ngdoc service\n * @module rainbow\n * @name channelService\n * @requires $q\n * @requires $http\n * @requires $log\n * @requires $rootScope\n * @requires authService\n * @requires xmppService\n * @requires contactService\n * @requires Channel\n * @requires roomService For some avatar related functions\n * @requires profileService\n * @description Rainbow ChannelService allows interaction with Channel API\n */\n/// <reference path="../../models/common/channel.ts" />\nclass FeedChannel {\n    constructor() {\n        this.messages = [];\n        this.complete = false;\n        this.pageIndex = 0;\n        this.isLoading = false;\n        this.type = "AGGREGATE";\n    }\n}\nclass ChannelService {\n    constructor($q, $http, $log, $interval, $rootScope, authService, xmppService, contactService, Channel, roomService, Contact, profileService) {\n        this.$q = $q;\n        this.$http = $http;\n        this.$log = $log;\n        this.$interval = $interval;\n        this.$rootScope = $rootScope;\n        this.authService = authService;\n        this.xmppService = xmppService;\n        this.contactService = contactService;\n        this.Channel = Channel;\n        this.roomService = roomService;\n        this.Contact = Contact;\n        this.profileService = profileService;\n        this.listeners = [];\n        this.isStarted = false;\n        this.channels = {};\n        this.channelsList = [];\n        this.LIST_EVENT_TYPE = {\n            ADD: 0,\n            UPDATE: 1,\n            REMOVE: 2,\n            DELETE: 3,\n            SUBSCRIBE: 4,\n            UNSUBSCRIBE: 5,\n            CREATE: 6\n        };\n        this.USER_ROLE = {\n            NONE: "none",\n            OWNER: "owner",\n            PUBLISHER: "publisher",\n            MEMBER: "member"\n        };\n        this.MESSAGE_ACTION = {\n            ADD: 0,\n            RETRACT: 1\n        };\n        this.xmpp_message_handler = null;\n        this.xmpp_management_handler = null;\n        this.notificationCounter = 0;\n        this.messageCounter = 0;\n        this.invitationCounter = 0;\n        this.CHANNEL_UPDATE_EVENT = "CHANNEL_UPDATE_EVENT";\n        this.CHANNEL_MESSAGE_RECEIVED = "CHANNEL_MESSAGE_RECEIVED";\n        this.CHANNEL_USERS_UPDATE_EVENT = "CHANNEL_USERS_UPDATE_EVENT";\n        this.CHANNEL_NOTIFICATION_NUMBER_UPDATED = "CHANNEL_NOTIFICATION_NUMBER_UPDATED";\n        this.CHANNEL_USER_SUBSCRIPTION_EVENT = "CHANNEL_USER_SUBSCRIPTION_EVENT";\n    }\n    /****************************************************************/\n    /*** SERVICE LIFECYCLE                                        ***/\n    /****************************************************************/\n    start(stats) {\n        return this.$q((resolve) => {\n            // Check feature availability\n            if (!this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.CHANNEL_ACTIVATED)) {\n                resolve();\n            }\n            // Don\'t start service for cpass guest\n            if (this.contactService.userContact.isCPaaSGuest()) {\n                resolve();\n            }\n            // Now start the service\n            this.$log.info("[channelService] === STARTING ===");\n            let startDate = performance.now();\n            this.feedChannel = new FeedChannel();\n            this.portalURL = config.restServerUrl + "/api/rainbow/channels/v1.0/channels";\n            resolve();\n            // Get my channels\n            this.getMyChannels()\n                .then(() => {\n                // Handle start duration statistics\n                let startDuration = Math.round(performance.now() - startDate);\n                this.$log.info("[channelService] === STARTED (" + startDuration + " ms) ===");\n                stats.push({ service: "channelService", startDuration: startDuration });\n                this.attachHandlers();\n                this.attachListeners();\n                this.isStarted = true;\n                this.$rootScope.$broadcast("ON_CHANNEL_SERVICE_STARTED");\n            })\n                .catch((error) => {\n                this.$log.info("[channelService] === STARTING FAILURE === " + error.message);\n            });\n        });\n    }\n    attachHandlers() {\n        this.$log.info("[channelService] attachHandlers");\n        if (this.xmpp_message_handler) {\n            this.xmppService.connection.deleteHandler(this.xmpp_message_handler);\n            this.xmpp_message_handler = null;\n        }\n        if (this.xmpp_management_handler) {\n            this.xmppService.connection.deleteHandler(this.xmpp_management_handler);\n            this.xmpp_management_handler = null;\n        }\n        this.xmpp_message_handler = this.xmppService.connection.addHandler((stanza) => { return this.onChannelMessageReceived(stanza); }, null, "message", "headline");\n        this.xmpp_management_handler = this.xmppService.connection.addHandler((stanza) => { return this.onChannelManagementReceived(stanza); }, null, "message", "management");\n    }\n    ;\n    attachListeners() {\n        this.listeners.push(this.$rootScope.$on(this.CHANNEL_USERS_UPDATE_EVENT, (_event, channelId, users) => this.usersUpdateHandler(_event, channelId, users)));\n    }\n    stop() {\n        return this.$q((resolve) => {\n            this.$log.info("[channelService] === STOPPING ===");\n            this.listeners.forEach(((destroyFunction) => { destroyFunction(); }));\n            this.channels = {};\n            this.channelsList = [];\n            this.feedChannel = null;\n            this.notificationCounter = 0;\n            this.$log.info("[channelService] === STOPPED ===");\n            resolve();\n        });\n    }\n    reconnect() {\n        return this.$q((resolve) => {\n            let stats = [];\n            this.$log.info("[channelService] reconnect");\n            this.stop();\n            this.start(stats);\n            resolve();\n        });\n    }\n    /****************************************************************/\n    /*** PRIVATE CHANNELS ACCESSORS                               ***/\n    /****************************************************************/\n    removeChannelFromCache(channelId) {\n        return this.$q((resolve, reject) => {\n            // Get the channel to remove\n            let channelToRemove = this.getChannelFromCache(channelId);\n            if (channelToRemove) {\n                // Store channel name\n                let channelName = channelToRemove.name;\n                // Handle invitation channel\n                if (channelToRemove.invited) {\n                    this.decrementInvitationCounter();\n                }\n                // Remove from channels\n                delete this.channels[channelId];\n                this.updateChannelsList();\n                // Update messagesList\n                this.feedChannel.messages = [];\n                this.retrieveLatests()\n                    .then(() => { resolve(channelName); })\n                    .catch((err) => { reject(err); });\n            }\n        });\n    }\n    /****************************************************************/\n    /*** MESSAGE EVENT HANDLER                                    ***/\n    /****************************************************************/\n    onChannelMessageReceived(stanza) {\n        try {\n            this.$rootScope.$apply(() => {\n                let eventNode = angular.element(stanza).find("event");\n                if (eventNode && eventNode.attr("xmlns") === "http://jabber.org/protocol/pubsub#event") {\n                    this.$log.info("[channelService] onChannelMessageReceived ");\n                    let items = eventNode.find("items");\n                    let item = items.find("item");\n                    let retract = items.find("retract");\n                    // New message received\n                    if (item.length === 1) {\n                        this.onNewMessage(item);\n                    }\n                    // Retract message (limit reached)\n                    else if (retract.length === 1) {\n                        let messageId = retract.attr("id");\n                        let channelId = items.attr("node").split(\':\')[0];\n                        this.onRetractMessage(channelId, messageId);\n                    }\n                }\n            });\n            return true;\n        }\n        catch (err) {\n            this.$log.error("[channelService] onChannelMessageReceived -- failure -- " + err.message);\n            return true;\n        }\n    }\n    ;\n    onNewMessage(item) {\n        let entry = item.find("entry");\n        let messageId = item.attr("id");\n        let channelId = entry.attr("channelId");\n        let creationDate = entry.attr("creation");\n        let action = creationDate ? "modify" : "new";\n        this.$log.info("[channelService] onChannelMessageReceived -- " + action + " message " + messageId + " on channel " + channelId);\n        // Create the message object\n        let message = {\n            id: messageId,\n            displayId: messageId + "-" + entry.attr("timestamp"),\n            channelId: channelId,\n            from: entry.attr("from"),\n            fromDetails: null,\n            new: false,\n            entry: {\n                type: entry.find("type").length ? entry.find("type")[0].textContent : "",\n                message: entry.find("message").length ? entry.find("message")[0].textContent : "",\n                title: entry.find("title").length ? entry.find("title")[0].textContent : "",\n                url: entry.find("url").length ? entry.find("url")[0].textContent : "",\n                images: [],\n                attachments: [],\n                video: null\n            },\n            modified: action === "modify",\n            timestamp: new Date(entry.attr("timestamp"))\n        };\n        // Fix missing blank links\n        message.entry.message = message.entry.message.replace(/<a/gi, "<a target=\'_blank\' rel=\'noopener noreferrer\' ");\n        // Extract images\n        let imagesElem = item.find("images");\n        if (imagesElem.length !== 0) {\n            imagesElem.find("id").each((index, image) => { message.entry.images.push({ id: image.textContent }); });\n        }\n        // Extract attachments\n        let attachmentsElem = item.find("attachments");\n        if (attachmentsElem.length !== 0) {\n            attachmentsElem.find("id").each((index, attachment) => { message.entry.attachments.push({ id: attachment.textContent }); });\n        }\n        // Extract video\n        let videoElem = item.find("video");\n        if (videoElem.length !== 0) {\n            message.entry.video = { provider: videoElem.find("provider")[0].textContent, id: videoElem.find("id")[0].textContent };\n        }\n        // Get the associated channel\n        let channel = this.getChannelFromCache(channelId);\n        // Get contact\n        this.contactService.getOrCreateContact(message.from)\n            .then((author) => {\n            message.fromDetails = { displayName: author.displayName, id: author.dbId, avatar: author.avatar };\n            message[\'fromContact\'] = author;\n            // New message : add in message arrays\n            if (action === "new") {\n                if (channel.loaded) {\n                    channel.messages.unshift(message);\n                }\n                this.feedChannel.messages.unshift(message);\n                if (this.contactService.userContact.jid !== message.from) {\n                    message.new = true;\n                    this.incrementMessagesCounter();\n                }\n                this.$rootScope.$broadcast(this.CHANNEL_MESSAGE_RECEIVED, this.MESSAGE_ACTION.ADD, message);\n            }\n            // Update message\n            else {\n                // Try to find eventual existing messages\n                let channelMessageIndex = channel.messages.findIndex((mess) => { return mess.id === messageId; });\n                let feedMessageIndex = this.feedChannel.messages.findIndex((mess) => { return mess.id === messageId; });\n                if (channelMessageIndex !== -1) {\n                    channel.messages.splice(channelMessageIndex, 1, message);\n                }\n                if (feedMessageIndex !== -1) {\n                    this.feedChannel.messages.splice(feedMessageIndex, 1, message);\n                }\n            }\n        });\n    }\n    onRetractMessage(channelId, messageId) {\n        this.$log.info("[channelService] onChannelMessageReceived -- retract message " + messageId + " on channel " + channelId);\n        let channel = this.getChannelFromCache(channelId);\n        let messageIndex = channel.messages.findIndex((message) => message.id === messageId);\n        if (messageIndex !== -1) {\n            let message = channel.messages[messageIndex];\n            if (message.new) {\n                this.decrementMessagesCounter();\n            }\n            channel.messages.splice(messageIndex, 1);\n        }\n        // Remove also from messagesList\n        let messageListIndex = this.feedChannel.messages.findIndex((message) => message.id === messageId);\n        if (messageListIndex !== -1) {\n            this.feedChannel.messages.splice(messageListIndex, 1);\n        }\n        this.$rootScope.$broadcast(this.CHANNEL_MESSAGE_RECEIVED, this.MESSAGE_ACTION.RETRACT, messageId);\n    }\n    /****************************************************************/\n    /*** MANAGEMENT EVENT HANDLER                                 ***/\n    /****************************************************************/\n    onChannelManagementReceived(stanza) {\n        try {\n            this.$rootScope.$apply(() => {\n                let channelElem = angular.element(stanza).find("channel");\n                if (channelElem && channelElem.length > 0) {\n                    // Extract channel identifier\n                    let channelId = channelElem.attr("channelid");\n                    // Handle cached channel info\n                    let channel = this.getChannelFromCache(channelId);\n                    if (channel) {\n                        let avatarElem = channelElem.find("avatar");\n                        let nameElem = channelElem.find("name");\n                        let topicElem = channelElem.find("topic");\n                        let categoryElem = channelElem.find("category");\n                        if (avatarElem && avatarElem.length > 0) {\n                            this.onAvatarChange(channelId, avatarElem);\n                        }\n                        if (nameElem && nameElem.length > 0) {\n                            channel.name = nameElem.text();\n                        }\n                        if (topicElem && topicElem.length > 0) {\n                            channel.topic = topicElem.text();\n                        }\n                        if (categoryElem && categoryElem.length > 0) {\n                            channel.category = categoryElem.text();\n                        }\n                    }\n                    // Handle channel action events\n                    let action = channelElem.attr("action");\n                    this.$log.info("[channelService] onChannelManagementReceived -- " + action + " event received on channel " + channelId);\n                    switch (action) {\n                        case \'add\':\n                            this.onAddToChannel(channelId);\n                            break;\n                        case \'update\':\n                            this.onUpdateToChannel(channelId);\n                            break;\n                        case \'remove\':\n                            this.onRemovedFromChannel(channelId);\n                            break;\n                        case \'subscribe\':\n                            this.onSubscribeToChannel(channelId, channelElem.attr("subscribers"));\n                            break;\n                        case \'unsubscribe\':\n                            this.onUnsubscribeToChannel(channelId, channelElem.attr("subscribers"));\n                            break;\n                        case \'delete\':\n                            this.onDeleteChannel(channelId);\n                            break;\n                        default: break;\n                    }\n                }\n                let channelSubscriptionElem = angular.element(stanza).find("channel-subscription");\n                if (channelSubscriptionElem && channelSubscriptionElem.length > 0) {\n                    // Extract information\n                    let channelId = channelSubscriptionElem.attr("channelid");\n                    let action = channelSubscriptionElem.attr("action");\n                    let userId = channelSubscriptionElem.attr("id");\n                    let subscribers = channelSubscriptionElem.attr("subscribers");\n                    let channel = this.getChannelFromCache(channelId);\n                    channel.subscribers_count = Number.parseInt(subscribers);\n                    this.$log.info("[channelService] onChannelManagementReceived -- subscription-" + action + " event received on channel " + channelId);\n                    switch (action) {\n                        case \'subscribe\':\n                            this.onUserSubscribeEvent(channelId, userId);\n                            break;\n                        case \'unsubscribe\':\n                            this.onUserUnsubscribeEvent(channelId, userId);\n                            break;\n                        default: break;\n                    }\n                }\n            });\n            return true;\n        }\n        catch (err) {\n            this.$log.error("[channels] onChannelManagementReceived -- failure -- " + err.message);\n            return true;\n        }\n    }\n    ;\n    onAvatarChange(channelId, avatar) {\n        let action = avatar.attr("action");\n        let updateDate = avatar.attr("lastAvatarUpdateDate") ? new Date(avatar.attr("lastAvatarUpdateDate")) : null;\n        this.$log.info("[channelService] onChannelManagementReceived -- " + action + " avatar for " + channelId);\n        if (action === "delete" || action === "update") {\n            let channel = this.getChannelFromCache(channelId);\n            channel.lastAvatarUpdateDate = updateDate;\n            if (updateDate !== null) {\n                channel.avatar = config.restServerUrl + "/api/channel-avatar/" + channelId + "?size=256&ts=" + new Date(updateDate).getTime();\n            }\n        }\n    }\n    onUpdateToChannel(channelId) {\n        // Get channel from cache\n        let channel = this.getChannelFromCache(channelId);\n        // Get channel from server\n        this.getChannel(channelId)\n            .then((newChannel) => {\n            if (newChannel.invited) {\n                this.addChannelToCache(newChannel);\n                this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.ADD, newChannel.id);\n            }\n        });\n    }\n    onAddToChannel(channelId) {\n        // Get channel from cache\n        let channel = this.getChannelFromCache(channelId);\n        // Get channel from server\n        this.getChannel(channelId)\n            .then((newChannel) => {\n            // Handle channel creation\n            if (!channel && !newChannel.invited) {\n                this.addChannelToCache(newChannel);\n                this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.ADD, newChannel.id);\n            }\n            // Handle channel invitation\n            else if (!channel && newChannel.invited) {\n                this.addChannelToCache(newChannel);\n                this.incrementInvitationCounter();\n                this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, newChannel.id);\n            }\n            // Handle change role\n            else if (channel && newChannel.userRole !== this.USER_ROLE.NONE) {\n                channel.userRole = newChannel.userRole;\n                this.feedChannel.messages = [];\n                this.retrieveLatests()\n                    .then(() => { this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId); });\n            }\n        });\n    }\n    onRemovedFromChannel(channelId) {\n        this.removeChannelFromCache(channelId)\n            .then((channelName) => {\n            this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.DELETE, channelId);\n        });\n    }\n    onSubscribeToChannel(channelId, subscribersInfo) {\n        // Handle invitation case\n        let channel = this.getChannelFromCache(channelId);\n        let subscribers = Number.parseInt(subscribersInfo);\n        if (channel) {\n            channel.invited = false;\n            channel.subscribed = true;\n            channel.subscribers_count = subscribers;\n            this.feedChannel.messages = [];\n            this.retrieveLatests()\n                .then(() => { this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId); });\n        }\n        // Handle self subscription case\n        else {\n            this.getChannel(channelId)\n                .then((newChannel) => {\n                this.addChannelToCache(newChannel);\n                this.feedChannel.messages = [];\n                return this.retrieveLatests();\n            })\n                .then(() => { this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId); });\n        }\n    }\n    onUnsubscribeToChannel(channelId, subscribersInfo) {\n        let subscribers = Number.parseInt(subscribersInfo);\n        let channel = this.getChannelFromCache(channelId);\n        channel.subscribers_count = subscribers;\n        channel.subscribed = false;\n        // Update messagesList\n        this.feedChannel.messages = [];\n        this.retrieveLatests()\n            .then(() => { this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.UNSUBSCRIBE, channelId); });\n    }\n    onDeleteChannel(channelId) {\n        this.removeChannelFromCache(channelId)\n            .then(() => { this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.DELETE, channelId); });\n    }\n    onUserSubscribeEvent(channelId, userId) {\n        this.$rootScope.$broadcast(this.CHANNEL_USER_SUBSCRIPTION_EVENT, this.LIST_EVENT_TYPE.SUBSCRIBE, channelId, userId);\n    }\n    onUserUnsubscribeEvent(channelId, userId) {\n        this.$rootScope.$broadcast(this.CHANNEL_USER_SUBSCRIPTION_EVENT, this.LIST_EVENT_TYPE.UNSUBSCRIBE, channelId, userId);\n    }\n    /****************************************************************/\n    /*** PUBLIC METHODS                                           ***/\n    /****************************************************************/\n    getChannelNextPage(channel, reset = false) {\n        return this.$q((resolve, reject) => {\n            // Discriminate channel\n            let logChannelName = (channel.type === "AGGREGATE") ? "feedChannel" : channel.id;\n            // Manage re-entry\n            if (channel.isLoading) {\n                this.$log.info("[channelService] getChannelNextPage(" + logChannelName + ", " + channel.pageIndex + ") -- ignored (isLoading)");\n                return resolve();\n            }\n            channel.isLoading = true;\n            // Manage reset mode\n            if (reset) {\n                channel.pageIndex = 0;\n            }\n            // Compute asked pages number\n            let alreadyLoadedmessageNumber = channel.messages.length;\n            let askedMessagesNumber = (channel.pageIndex + 1) * ChannelService.PAGE_SIZE;\n            // First case messages are already loaded return from cache\n            if (askedMessagesNumber <= channel.messages.length) {\n                this.$log.info("[channelService] getChannelNextPage(" + logChannelName + ", " + channel.pageIndex + ") -- success from cache");\n                channel.pageIndex += 1;\n                channel.isLoading = false;\n                resolve({ messages: channel.messages, nbMessages: askedMessagesNumber });\n            }\n            // Second case we already load all messages \n            else if (channel.complete) {\n                this.$log.info("[channelService] getChannelNextPage(" + logChannelName + ", " + channel.pageIndex + ") -- success from cache (complete)");\n                channel.isLoading = false;\n                resolve({ messages: channel.messages, nbMessages: channel.messages.length });\n            }\n            // Last case we have to load message on server}\n            else {\n                let messages = channel.messages;\n                let lastMessageDate = (messages.length) ? messages[messages.length - 1].timestamp : null;\n                this.getChannelMessages(channel, lastMessageDate)\n                    .then((nbMessages) => {\n                    if (nbMessages < ChannelService.PAGE_SIZE) {\n                        channel.complete = true;\n                    }\n                    this.$log.info("[channelService] getChannelNextPage(" + logChannelName + ", " + channel.pageIndex + ") -- success from server " + (channel.complete ? "(complete)" : "") + " -- retreive " + nbMessages + " message(s)");\n                    channel.pageIndex += 1;\n                    channel.loaded = true;\n                    channel.isLoading = false;\n                    resolve({ messages: channel.messages, nbMessages: channel.messages.length });\n                })\n                    .catch((error) => {\n                    channel.isLoading = false;\n                    this.channelErrorHandler("getChannelNextPage(" + logChannelName + ", " + channel.pageIndex + ")", reject, error);\n                });\n            }\n        });\n    }\n    getChannelPublishers(channel) {\n        return this.$q((resolve, reject) => {\n            if (channel.publishersRetreived) {\n                return resolve();\n            }\n            this.getChannelUsers(channel.id, { format: "full", types: "owner publisher" })\n                .then((usersData) => {\n                usersData.data.forEach((userData) => {\n                    let contact = this.contactService.getContactByJid(userData.jid_im);\n                    if (!contact) {\n                        contact = new this.Contact();\n                        contact.updateFromUserData(userData);\n                        contact.updateRichStatus();\n                        this.contactService.contacts[contact.id] = contact;\n                        this.contactService.dbContacts[contact.dbId] = contact;\n                        this.contactService.jtelContacts[contact.jidtel] = contact;\n                    }\n                    channel.users.push(contact);\n                });\n                channel.publishersRetreived = true;\n                this.$log.info("[channelService] getChannelPublishers (" + channel.id + ") -- success -- find " + usersData.length + " publisher(s)");\n                resolve();\n            })\n                .catch((err) => { this.channelErrorHandler("getChannelPublishers (" + channel.id + ")", reject, err); });\n        });\n    }\n    getChannelMessages(channel, beforeDate) {\n        return this.$q((resolve, reject) => {\n            let provider = null;\n            if (channel.type === "AGGREGATE") {\n                provider = this.getLatestMessages(10, beforeDate);\n            }\n            else {\n                provider = this.getChannelItems(channel.id, ChannelService.PAGE_SIZE, beforeDate);\n            }\n            provider.then((messages) => {\n                messages.forEach((message) => {\n                    if (message.entry.images === "null") {\n                        message.entry.images = [];\n                    }\n                    if (message.entry.attachments === "null" || message.entry.attachments === undefined) {\n                        message.entry.attachments = [];\n                    }\n                    if (!(message.entry.attachments instanceof Array)) {\n                        message.entry.attachments = [message.entry.attachments];\n                    }\n                    if (message.entry.message) {\n                        message.entry.message = message.entry.message.replace(/<a/gi, "<a target=\'_blank\' rel=\'noopener noreferrer\' ");\n                    }\n                    let content = message.entry.message ? message.entry.message : "";\n                    this.contactService.getOrCreateContact(message.from)\n                        .then((contact) => {\n                        message.fromDetails = { displayName: contact.displayName, id: contact.dbId, avatar: contact.avatar };\n                        message[\'fromContact\'] = contact;\n                    });\n                });\n                channel.messages.push.apply(channel.messages, messages);\n                resolve(messages.length);\n            });\n        });\n    }\n    /**\n     * GET MY CHANNELS\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    getMyChannels() {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "GET", url: this.portalURL + "?format=full", headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] getMyChannels -- success");\n                response.data.data.forEach((channelData) => {\n                    let channel = this.Channel(channelData);\n                    if (channel.invited) {\n                        this.incrementInvitationCounter();\n                    }\n                    if (channel.subscribed || channel.invited) {\n                        this.channels[channel.id] = channel;\n                    }\n                });\n                this.updateChannelsList();\n                resolve(this.channelsList);\n            })\n                .catch((err) => { this.channelErrorHandler("getMyChannels", reject, err); });\n        });\n    }\n    ;\n    /**\n     * CHANNEL CREATION\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    createChannel(name, mode, topic = "", category = "globalnews", autoProvisionning = false, max_items = 100) {\n        return this.$q((resolve, reject) => {\n            let url = this.portalURL + (autoProvisionning ? "?auto_provisioning=true" : "");\n            let data = { name, mode, topic, category, max_items };\n            this.$http({ method: "POST", url, headers: this.authService.getPostHeader(), data })\n                .then((response) => {\n                this.$log.info("[channelService] createChannel -- " + name + " -- " + mode + " -- success");\n                let channel = this.Channel(response.data.data);\n                resolve(channel);\n            })\n                .catch((err) => { this.channelErrorHandler("createChannel -- " + name + " -- " + mode, reject, err); });\n        });\n    }\n    /**\n     * CHANNEL DELETION\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    deleteChannel(channelId) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "DELETE", url: this.portalURL + "/" + channelId, headers: this.authService.getPostHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] deleteChannel -- " + channelId + " -- success");\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("deleteChannel (" + channelId + ")", reject, err); });\n        });\n    }\n    ;\n    /**\n     * CHANNELS FIND\n     * Used by SDK (public)\n     * Warning when modifying this method\n     * filter  {\n     *      name :      {String}    // optional, substring to search in channels\' names\n     *      topic :     {String}    // optional, substring to search in channels\' topic\n     *      limit :     {Number}    // optional, number max to retrzeive (default 100)\n     *      offset :    {Number}    // optional, allow to specify the position of first channel to retrieve\n     *                                  (first channel if not specified).\n     *                                  Warning: if offset > total, no results are returned.\n     *      sortField : {String}    // optional,\n     *                                  sort channel list based on the given field. Default value: topic\n     *                                  Allowed values: name, topic\n     *      sortOrder : {Number}    // optional, specify order ascending/descending. Default value: 1\n     *                                  Allowed values: -1, 1\n     * }\n     *\n     * returns an Object {\n     *      data :      {Array}     // found channels informations with an array of { id, name, topic, creatorId }\n     *      limit :     {Number}    // limit given\n     *      offset :    {Number}    // offset given\n     *      total :     {Number}    // total returned\n     * }\n     *\n     */\n    findChannels(filter) {\n        return this.$q((resolve, reject) => {\n            let query = "?sortOrder=" + (filter.sortOrder && (filter.sortOrder === 1) ? "1" : "-1");\n            if (filter.subscribed !== undefined) {\n                query += "&subscribed=" + filter.subscribed;\n            }\n            if (filter.name) {\n                query += "&name=" + filter.name;\n            }\n            if (filter.topic) {\n                query += "&topic=" + filter.topic;\n            }\n            if (filter.limit) {\n                query += "&limit=" + filter.limit;\n            }\n            if (filter.offset) {\n                query += "&offset=" + filter.offset;\n            }\n            if (filter.sortField) {\n                query += "&sortField=" + filter.sortField;\n            }\n            if (filter.category) {\n                query += "&category=" + filter.category;\n            }\n            // Call the REST WebService\n            this.$http({ method: "GET", url: this.portalURL + "/search" + query, headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                let channels = [];\n                response.data.data.forEach((channelData) => { channels.push(this.Channel(channelData)); });\n                resolve(channels);\n            })\n                .catch((err) => { this.channelErrorHandler("findChannels (" + query + ")", reject, err); });\n        });\n    }\n    ;\n    browseChannels(filter) {\n        return this.$q((resolve, reject) => {\n            let query = "?sortOrder=" + (filter.sortOrder && (filter.sortOrder === 1) ? "1" : "-1");\n            if (filter.category) {\n                query += "&category=" + filter.category;\n            }\n            if (filter.excluded_category) {\n                query += "&excluded_category=" + filter.excluded_category;\n            }\n            if (filter.subscribed !== undefined) {\n                query += "&subscribed=" + filter.subscribed;\n            }\n            if (filter.limit) {\n                query += "&limit=" + filter.limit;\n            }\n            if (filter.offset) {\n                query += "&offset=" + filter.offset;\n            }\n            if (filter.sortField) {\n                query += "&sortField=" + filter.sortField;\n            }\n            // Call the REST WebService\n            this.$http({ method: "GET", url: this.portalURL + "/browse" + query, headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                let channels = [];\n                response.data.data.forEach((channelData) => { channels.push(this.Channel(channelData)); });\n                resolve(channels);\n            })\n                .catch((err) => { this.channelErrorHandler("browseChannels (" + query + ")", reject, err); });\n        });\n    }\n    /**\n     * GET A CHANNEL\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    getChannel(channelId) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "GET", url: this.portalURL + "/" + channelId, headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] getChannel -- " + channelId + " -- success");\n                let channel = this.Channel(response.data.data);\n                resolve(channel);\n            })\n                .catch((err) => { this.channelErrorHandler("getChannel (" + channelId + ")", reject, err); });\n        });\n    }\n    ;\n    /**\n     * GET A CHANNEL FROM CACHE\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    getChannelFromCache(channelId) {\n        let channel = this.channels[channelId];\n        return channel !== undefined ? channel : null;\n    }\n    /**\n    * PUBLISH A MESSAGE TO A CHANNEL\n    * Used by SDK (public)\n    * Warning when modifying this method\n    */\n    publishToChannel(channelId, itemId, type, message, title, url, images, video, attachments) {\n        return this.$q((resolve, reject) => {\n            let data = { type, title: title || "", message: message || "", images: images || [], attachments: attachments || [] };\n            let queryParam = itemId ? "?itemId=" + itemId : "";\n            if (video) {\n                data.video = video;\n            }\n            this.$http({ method: "POST", url: this.portalURL + "/" + channelId + "/publish" + queryParam, headers: this.authService.getRequestHeader(), data: data })\n                .then((response) => {\n                this.$log.info("[channelService] publishToChannel -- " + channelId + " -- " + type + " -- success");\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("publishToChannel (" + channelId + ")", reject, err); });\n        });\n    }\n    ;\n    /**\n     * SUBSCRIBE TO A CHANNEL\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    subscribeToChannel(channel) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "POST", url: this.portalURL + "/" + channel.id + "/subscribe", headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] subscribeToChannel -- " + channel.id + " -- success");\n                channel.subscribed = true;\n                channel.users_count += 1;\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("subscribeToChannel (" + channel.id + ")", reject, err); });\n        });\n    }\n    ;\n    /**\n     * UNSUBSCRIBE TO A CHANNEL\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    unsubscribeToChannel(channel) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "DELETE", url: this.portalURL + "/" + channel.id + "/subscribe", headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] unsubscribeToChannel -- success");\n                channel.subscribed = false;\n                channel.users_count -= 1;\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("unsubscribeToChannel", reject, err); });\n        });\n    }\n    ;\n    /**\n     * CHANNEL UPDATE\n     * Allowed options : name, topic, visibility, max_items (int), max_payload_size (int)\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    updateChannel(channelId, options) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "PUT", url: this.portalURL + "/" + channelId, headers: this.authService.getPostHeader(), data: options })\n                .then((response) => {\n                let channel = this.getChannelFromCache(channelId);\n                channel.name = response.data.data.name;\n                channel.topic = response.data.data.topic;\n                channel.category = response.data.data.category;\n                this.$log.info("[channelService] updateChannel ( " + channelId + ") -- success");\n                this.$rootScope.$broadcast(this.CHANNEL_UPDATE_EVENT, this.LIST_EVENT_TYPE.UPDATE, channel.id);\n                resolve(channel);\n            })\n                .catch((err) => { this.channelErrorHandler("updateChannel (" + channelId + ")", reject, err); });\n        });\n    }\n    ;\n    /**\n     * Get items from a channel\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    getChannelItems(channelId, maxMessages, beforeDate = null, afterDate = null) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "GET", url: this.portalURL + "/" + channelId + "/items", headers: this.authService.getRequestHeader(), params: { max: maxMessages, before: beforeDate, after: afterDate } })\n                .then((response) => {\n                this.$log.info("[channelService] getChannelItems -- success");\n                this.chewReceivedItems(response.data.data.items);\n                resolve(response.data.data.items);\n            })\n                .catch((err) => { this.channelErrorHandler("getChannelItems", reject, err); });\n        });\n    }\n    ;\n    /**\n    * Delete item from a channel\n    * Used by SDK (public)\n    * Warning when modifying this method\n    */\n    deleteChannelItem(channelId, itemId) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "DELETE", url: this.portalURL + "/" + channelId + "/items/" + itemId, headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] deleteChannelItem (" + channelId + ") -- success");\n                resolve();\n            })\n                .catch((err) => { this.channelErrorHandler("deleteChannelItem (" + channelId + ")", reject, err); });\n        });\n    }\n    ;\n    /**\n     * Get users in a channel\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    getChannelUsers(channelId, options) {\n        return this.$q((resolve, reject) => {\n            let data = {};\n            if (options) {\n                if (options.format && (typeof options.format === "string") && options.format.length) {\n                    data.format = options.format;\n                }\n                if (options.types && (typeof options.types === "string") && options.types.length) {\n                    data.types = options.types;\n                }\n                if (options.limit && (typeof options.limit === "number") && (options.limit > 0)) {\n                    data.limit = options.limit;\n                }\n                if (options.offset && (typeof options.offset === "number") && (options.offset > 0)) {\n                    data.offset = options.offset;\n                }\n                if (options.sortField && (typeof options.sortField === "string") && options.sortField.length) {\n                    data.sortField = options.sortField;\n                }\n                if (options.sortOrder && (options.sortOrder === "-1" || options.sortOrder === "1")) {\n                    data.sortOrder = options.sortOrder;\n                }\n            }\n            this.$http({ method: "GET", url: this.portalURL + "/" + channelId + "/users", headers: this.authService.getRequestHeader(), params: data })\n                .then((response) => {\n                this.$log.info("[channelService] getChannelUsers (" + channelId + ") -- success");\n                resolve(response.data);\n            })\n                .catch((err) => { this.channelErrorHandler("getChannelUsers (" + channelId + ")", reject, err); });\n        });\n    }\n    ;\n    /**\n     * Search users for channelId by displayName\n     * Non-members can be returned (to add new people)\n     * options : offset; limit; sortField: sortOrder\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    searchUsersByName(channelId, displayName, options) {\n        options.displayName = displayName;\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "/" + channelId + "/users/search",\n                headers: this.authService.getRequestHeader(),\n                params: options\n            })\n                .then((response) => {\n                this.$log.info("[channelService] searchUsersByName (" + channelId + " -- success");\n                resolve(response.data.data);\n            })\n                .catch((err) => { this.channelErrorHandler("searchUsersByName (" + channelId + ")", reject, err); });\n        });\n    }\n    /**\n     * Delete avatar of a channel\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    deleteChannelAvatar(channelId) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "DELETE", url: this.portalURL + "/" + channelId + "/avatar", headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] deleteChannelAvatar " + channelId + " -- success");\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("deleteChannelAvatar " + channelId, reject, err); });\n        });\n    }\n    /**\n     * Upload avatar to a channel and resize it to avatarSize\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    uploadChannelAvatar(channelId, avatar, avatarSize) {\n        return this.$q((resolve, reject) => {\n            this.roomService.resizeImage(avatar, avatarSize, avatarSize)\n                .then((resizedImage) => {\n                var binaryData = this.roomService.getBinaryData(resizedImage);\n                this.$http({\n                    method: "POST",\n                    url: this.portalURL + "/" + channelId + "/avatar",\n                    headers: this.authService.getPostHeader("image/" + binaryData.type),\n                    data: binaryData.data,\n                    transformRequest: []\n                })\n                    .then((response) => {\n                    this.$log.info("[channelService] uploadChannelAvatar " + channelId + " -- success");\n                    resolve(response);\n                })\n                    .catch((err) => { this.channelErrorHandler("uploadChannelAvatar", reject, err); });\n            });\n        });\n    }\n    /**\n     * Update users present in a channel\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    updateChannelUsers(channelId, users, userType) {\n        return this.$q((resolve, reject) => {\n            let members = users.map((user) => { return { id: user.dbId, type: userType }; });\n            this.$http({\n                method: "PUT",\n                url: this.portalURL + "/" + channelId + "/users",\n                headers: this.authService.getRequestHeader(),\n                data: { data: members }\n            })\n                .then((response) => {\n                this.$log.info("[channelService] updateChannelUsers -- success");\n                let usersLists = response.data.data;\n                this.$rootScope.$broadcast(this.CHANNEL_USERS_UPDATE_EVENT, channelId, usersLists);\n                resolve(usersLists);\n            })\n                .catch((err) => { this.channelErrorHandler("updateChannelUsers", reject, err); });\n        });\n    }\n    ;\n    /***************************************************************************/\n    usersUpdateHandler(_event, channelId, users) {\n        let channel = this.getChannelFromCache(channelId);\n        //Update userlist when modified (Must be initialized in channel)\n        if (users !== null) {\n            //Update user count\n            channel.users_count += (users.added.length - users.removed.length);\n            if (channel.users.length) {\n                //Add new users\n                for (let i = 0; i < users.added.length; i++) {\n                    this.contactService.getContactByDBId(users.added[i])\n                        .then((contact) => {\n                        channel.users.push(contact);\n                    });\n                }\n                //TODO: Handle updates\n                /*Update contact that needs to be updated\n                for (let i = 0; i < users.updated.length; i++) {\n                  //this.channelsList[channelIndex].users[]\n                }*/\n                //Removed old users\n                for (let i = 0; i < users.removed.length; i++) {\n                    //Find user to remove in array\n                    for (let j = channel.users.length - 1; j >= 0; j--) {\n                        if (channel.users[j].dbId === users.removed[i]) {\n                            channel.users.splice(j, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    retrieveUsers(channel) {\n        this.$log.info("Retrieving users");\n        if ((channel.users.length === 0) && (channel.userRole === this.USER_ROLE.OWNER)) {\n            let publishers;\n            let owner = this.contactService.userContact;\n            owner.type = \'owner\';\n            //Retrieve publishers and owner info\n            return this.getChannelUsers(channel.id, { format: "full", types: "publisher", limit: 19 })\n                //Retrieve members info (up to 20)\n                .then((pubs) => {\n                publishers = pubs.data.length ? pubs.data : [];\n                if (publishers.length < 19) {\n                    return this.getChannelUsers(channel.id, { format: "full", types: "member", limit: 19 - publishers.length });\n                }\n                else {\n                    return [];\n                }\n            })\n                //Concat members and publishers\n                .then((members) => {\n                publishers.push.apply(publishers, members.data);\n                const users = publishers;\n                return this.usersToContacts(users).then((contacts) => {\n                    channel.users = contacts;\n                    channel.users.unshift(owner);\n                    return contacts;\n                });\n            });\n        }\n        else {\n            return this.$q.resolve(null);\n        }\n    }\n    ;\n    usersToContacts(users) {\n        if (users !== null) {\n            //Convert them to contact\n            let userPromises = [];\n            for (let i = 0; i < users.length; i++) {\n                let user = this.Contact.create(users[i].jid_im, users[i].firstName, users[i].lastName, users[i].company, users[i].loginEmail);\n                user.dbId = users[i].id;\n                user.lastAvatarUpdateDate = users[i].lastAvatarUpdateDate;\n                user.type = users[i].type || users[i].affiliation;\n                userPromises.push(user.getAvatar());\n            }\n            return this.$q.all(userPromises).then((contacts) => {\n                return contacts;\n            });\n        }\n    }\n    retrieveMessages(channel) {\n        if (!channel.messageRetrieved) {\n            //Retrieve messages\n            return this.getChannelItems(channel.id, 100, null, null)\n                .then((messages) => {\n                channel.messages = messages;\n                let authorPromises = [];\n                //only search each author one time (unique from values)\n                var uniqueAuthors = Array.from(new Set(channel.messages.map((msg) => msg.from)));\n                //Retrieve author of each message\n                for (let i = 0; i < uniqueAuthors.length; i++) {\n                    let contact = this.contactService.getOrCreateContact(uniqueAuthors[i]);\n                    authorPromises.push(contact);\n                }\n                return this.$q.all(authorPromises)\n                    .then((authors) => {\n                    for (let i = 0; i < channel.messages.length; i++) {\n                        let contact = authors.find((author) => author.id === channel.messages[i].from);\n                        channel.messages[i].fromDetails = { displayName: contact.displayName, id: contact.dbId, avatar: contact.avatar };\n                        channel.messages[i].fromContact = contact;\n                    }\n                    channel.messageRetrieved = true;\n                    return this.$q.resolve(channel.messages);\n                });\n            });\n        }\n        else {\n            return this.$q.resolve(null);\n        }\n    }\n    ;\n    retrieveLatests(beforeDate = null) {\n        return this.getLatestMessages(10, beforeDate, null).then((messages) => {\n            this.feedChannel.messages.push.apply(this.feedChannel.messages, messages);\n            return messages.length;\n        });\n    }\n    /* Notifications */\n    incrementMessagesCounter() { this.messageCounter += 1; this.updateNotificationCounter(); }\n    decrementMessagesCounter() { this.messageCounter -= 1; this.updateNotificationCounter(); }\n    incrementInvitationCounter() { this.invitationCounter += 1; this.updateNotificationCounter(); }\n    decrementInvitationCounter() { this.invitationCounter -= 1; this.updateNotificationCounter(); }\n    ackMessages() { this.messageCounter = 0; this.updateNotificationCounter(); this.feedChannel.messages.forEach((message) => { message.new = false; }); }\n    ackMessage(messageId) {\n        this.feedChannel.messages.forEach((message) => {\n            if (message.id === messageId) {\n                message.new = false;\n            }\n        });\n        this.decrementMessagesCounter();\n    }\n    updateNotificationCounter() {\n        this.notificationCounter = this.messageCounter + this.invitationCounter;\n        if (this.notificationCounter < 0) {\n            this.notificationCounter = 0;\n        }\n        this.$rootScope.$broadcast(this.CHANNEL_NOTIFICATION_NUMBER_UPDATED, this.notificationCounter);\n    }\n    /**\n     * Remove all users from A CHANNEL\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    removeAllUsersFromChannel(channelId) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "DELETE",\n                url: this.portalURL + "/" + channelId + "/users",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.$log.info("[channelService] Removed all users from channel -- success");\n                this.$rootScope.$broadcast(this.CHANNEL_USERS_UPDATE_EVENT, channelId, null);\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("removeAllUsersFromChannel", reject, err); });\n        });\n    }\n    ;\n    /**\n     * Get portals infos (version and description)\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    getPortalInfos() {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: config.restServerUrl + "/api/rainbow/channels/v1.0/about",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.$log.info("[channelService] successfully retrieved portal infos -- success");\n                resolve(response.data);\n            })\n                .catch((err) => { this.channelErrorHandler("getPortalInfos", reject, err); });\n        });\n    }\n    ;\n    /**\n     * Get latests message from channel\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    getLatestMessages(maxMessages, beforeDate = null, afterDate = null) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "/latest-items",\n                headers: this.authService.getRequestHeader(),\n                params: { max: maxMessages, before: beforeDate, after: afterDate }\n            })\n                .then((response) => {\n                this.chewReceivedItems(response.data.data.items);\n                resolve(response.data.data.items);\n            })\n                .catch((err) => { this.channelErrorHandler("getLatestMessages", reject, err); });\n        });\n    }\n    ;\n    /**\n     * Accept Invitation\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    acceptInvitation(channelId) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "PUT", url: this.portalURL + "/" + channelId + "/accept", headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] acceptInvitation (" + channelId + ") -- success");\n                this.decrementInvitationCounter();\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("acceptInvitation", reject, err); });\n        });\n    }\n    /**\n     * Decline invitation\n     * Used by SDK (public)\n     * Warning when modifying this method\n     */\n    declineInvitation(channelId) {\n        return this.$q((resolve, reject) => {\n            this.$http({ method: "PUT", url: this.portalURL + "/" + channelId + "/decline", headers: this.authService.getRequestHeader() })\n                .then((response) => {\n                this.$log.info("[channelService] declineInvitation (" + channelId + ") -- success");\n                this.decrementInvitationCounter();\n                resolve(response);\n            })\n                .catch((err) => { this.channelErrorHandler("declineInvitation", reject, err); });\n        });\n    }\n    chewReceivedItems(items) {\n        items.forEach((item) => {\n            if (item.type === "urn:xmpp:channels:simple") {\n                item["entry"] = { message: item.message };\n                delete item.message;\n            }\n            item.displayId = item.id + "-" + item.timestamp;\n            item.modified = item.creation !== undefined;\n        });\n    }\n    updateChannelsList() {\n        this.channelsList = Object.keys(this.channels).map((key) => { return this.channels[key]; });\n    }\n    addChannelToCache(channel) {\n        this.channels[channel.id] = channel;\n        this.updateChannelsList();\n    }\n    channelErrorHandler(methodName, reject, err) {\n        let error = null;\n        if (err.data) {\n            this.$log.error("[channelService] " + methodName + " -- failure -- " + err.data.errorDetails);\n            error = new RBError(err.data.errorMsg, err.data.errorDetails, err.data.errorDetailsCode);\n        }\n        else {\n            this.$log.error("[channelService] " + methodName + " -- failure -- Server failure");\n            error = new RBError("Server failure");\n        }\n        reject(error);\n    }\n}\nChannelService.PAGE_SIZE = 10;\nChannelService.$inject = [\n    "$q",\n    "$http",\n    "$log",\n    "$interval",\n    "$rootScope",\n    "authService",\n    "xmppService",\n    "contactService",\n    "Channel",\n    "roomService",\n    "Contact",\n    "profileService",\n];\nangular.module("rainbow").service("channelService", ChannelService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/channelService/channelService.ts?')},function(module,exports){eval("\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/channelService/channelServiceEventHandler.ts?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\nangular.module("rainbow").service("companyService", ["$q", "$log", "$http", "$rootScope", "authService", "errorHelperService", "userInfoService", "Company", function ($q, $log, $http, $rootScope, authService, errorHelperService, userInfoService, Company) {\n  "use strict";\n\n  var service = this;\n  var listeners = [];\n  /******************************************************************/\n\n  /** LIFECYCLE STUFF                                              **/\n\n  /******************************************************************/\n\n  service.start = function (stats) {\n    $log.info("");\n    $log.info("[companyService] === STARTING ===");\n    var startDate = performance.now();\n    service.portalURL = config.restServerUrl + "/api/rainbow/enduser/v1.0/";\n    service.companies = {};\n    var startDuration = Math.round(performance.now() - startDate);\n    stats.push({\n      service: "companyService",\n      startDuration: startDuration\n    });\n    $log.info("[companyService] === STARTED (" + startDuration + " ms) ===");\n    listeners.push($rootScope.$on("ON_COMPANY_CHANGE_EVENT", function (__event, companyId) {\n      service.getCompanyById(companyId, true);\n    }));\n    return $q.when();\n  };\n\n  service.stop = function () {\n    $log.info("");\n    $log.info("[companyService] === STOPPING ==="); // unregister listeners\n\n    var listener;\n\n    while (listener = listeners.pop()) {\n      listener();\n    }\n\n    $log.info("[companyService] === STOPPED ===");\n    service.companies = {};\n    return $q.when();\n  };\n  /******************************************************************/\n\n  /** PUBLIC API                                                   **/\n\n  /******************************************************************/\n\n\n  service.searchCompanies = function (searchText, hasBP, isBP, bpType) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "companies?name=" + searchText + "&format=full";\n\n      if (hasBP !== undefined && hasBP !== null) {\n        url += "&hasBP=" + hasBP;\n      }\n\n      if (isBP !== undefined && isBP !== null) {\n        url += "&isBP=" + isBP;\n      }\n\n      if (bpType) {\n        url += "&bpType=" + bpType;\n      }\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var companiesData = response.data.data;\n        var companies = [];\n        angular.forEach(companiesData, function (companyData) {\n          if (companyData.name !== "Default" && companyData.name !== "Rainbow" && companyData.status === "active") {\n            var company = service.companies[companyData.id];\n\n            if (!company) {\n              company = Company.createFromData(companyData);\n              service.companies[company.id] = company; // Load asynchronously company logo (not banner!)\n\n              service.getCompanyLogo(company);\n            }\n\n            companies.push(company);\n          }\n        });\n        $log.info("[companyService] searchCompanies with criteria \'" + searchText + "\' - success - found " + companiesData.length + " companies : returns " + companies.length + " companies");\n        resolve(companies);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[companyService] " + errorHelperService.getErrorFullMessage(response, "searchCompanies"));\n        reject(error);\n      });\n    });\n  };\n\n  service.getCompanyById = function (companyId, update) {\n    return $q(function (resolve, reject) {\n      if (!companyId) {\n        $log.error("[companyService] getCompanyById -- missing companyId");\n        reject(new Error("[companyService] getCompanyById -- missing companyId"));\n        return;\n      } // Try to get company from cache\n\n\n      var company = service.companies[companyId];\n\n      if (company && !update) {\n        $log.info("[companyService] getCompanyById (cache) " + companyId + " - success");\n        resolve(company);\n      } else {\n        $http({\n          method: "GET",\n          url: service.portalURL + "companies/" + companyId,\n          headers: authService.getRequestHeader()\n        }).then(function success(response) {\n          var companyData = response.data.data;\n\n          if (company) {\n            company.updateFromData(companyData); // update cache\n\n            $log.info("[companyService] getCompanyById (update) " + companyId + " - success");\n          } else {\n            company = Company.createFromData(companyData);\n            service.companies[company.id] = company; // put company in cache\n\n            $log.info("[companyService] getCompanyById " + companyId + " - success");\n          } // Load asynchronously company logo and banner\n\n\n          service.getCompanyLogo(company);\n          service.getCompanyBanner(company);\n          resolve(company);\n        }, function failure(response) {\n          var error = errorHelperService.handleError(response);\n          $log.error("[companyService] " + errorHelperService.getErrorFullMessage(response, "getCompanyById"));\n          reject(error);\n        });\n      }\n    });\n  };\n  /*service.getUsersInCompany = function(companyId) {\n  \treturn $q(function(resolve, reject) {\n  \t\tvar serverUrl = service.portalURL + "users?companyId=" + companyId;\n  \t\t$http({ method: "GET", url: serverUrl, headers: authService.getRequestHeader() })\n  \t\t\t.then(function success(response) {\n  \t\t\t\tvar data = response.data.data;\n  \t\t\t\t$log.info("[companyService] getUsersInCompany success)");\n  \t\t\t\tvar users = [];\n  \t\t\t\tdata.forEach(function(userData) {\n  \t\t\t\t\tvar contact = Contact.createFromData(userData);\n  \t\t\t\t\tusers.push(contact);\n  \t\t\t\t});\n  \t\t\t\tresolve({ users: users});\n  \t\t\t}, function failure(response) {\n  \t\t\t\tvar error = errorHelperService.handleError(response);\n  \t\t\t\treject(error);\t\t\t\t\t\t\n  \t\t\t\t$log.error("[companyService] " + errorHelperService.getErrorFullMessage(response, "getUsersInCompany"));\n  \t\t\t});\n  \t});\n  };*/\n\n\n  service.getAdministratorIds = function (companyId) {\n    return $q(function (resolve, reject) {\n      var serverUrl = service.portalURL + "companies/" + companyId + "/administrators";\n      $http({\n        method: "GET",\n        url: serverUrl,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var data = response.data.data;\n        var administratorIds = [];\n        data.forEach(function (userData) {\n          administratorIds.push(userData.id);\n        });\n        $log.info("[companyService] getAdministratorIds success)");\n        resolve(administratorIds);\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[companyService] " + errorHelperService.getErrorFullMessage(response, "getAdministratorIds"));\n        reject(error);\n      });\n    });\n  };\n  /******************************************************************/\n\n  /** PRIVATE METHODS                                              **/\n\n  /******************************************************************/\n\n\n  service.getCompanyLogo = function (company) {\n    return $q(function (resolve, reject) {\n      var companyColor = userInfoService.computeUserColor(company.name);\n      var companyInitials = company.name.substr(0, 1);\n      userInfoService.getAvatarImage(company.id, companyInitials, companyColor.color, 130, company.lastAvatarUpdateDate).then(function (companyLogo) {\n        company.logo = companyLogo;\n        $rootScope.$broadcast("ON_COMPANY_LOGO_UPDATED", company.id);\n        $log.info("[companyService] getCompanyLogo - " + company.getNameForLogs() + " - success");\n        resolve(companyLogo);\n      })["catch"](function (error) {\n        $log.error("[companyService] getCompanyLogo - failure - " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  service.getCompanyBanner = function (company) {\n    return $q(function (resolve) {\n      // Create the image\n      var image = new Image(); // Use default banner image\n\n      if (!company.lastBannerUpdateDate) {\n        if (window.rainbowSDK) {\n          image = null;\n        } else {\n          image.src = "/cache/images/company-banner-01.svg";\n        }\n\n        company.banner = image;\n        $rootScope.$broadcast("ON_COMPANY_BANNER_UPDATED", company.id);\n        $log.log("[companyService] Load default banner for " + company.getNameForLogs() + " success");\n        resolve(image);\n      } else {\n        // Build the image URL\n        var serverURL = config.webservices.protocol + "://" + config.webservices.currentServer;\n\n        if ($rootScope.cdn) {\n          serverURL = $rootScope.cdnServer;\n        }\n\n        var imgSrc = serverURL + "/api/banner/" + company.id + "?size=831";\n        imgSrc += "&update=" + Object(crypto_js__WEBPACK_IMPORTED_MODULE_0__["MD5"])(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Latin1.parse(company.lastBannerUpdateDate)).toString(crypto_js__WEBPACK_IMPORTED_MODULE_0__["enc"].Hex);\n\n        image.onload = function () {\n          var loadedBannerImage = this;\n          $rootScope.$apply(function () {\n            company.banner = loadedBannerImage;\n            $rootScope.$broadcast("ON_COMPANY_BANNER_UPDATED", company.id);\n            $log.log("[companyService] Load banner for " + company.getNameForLogs() + " success");\n            resolve(loadedBannerImage);\n          });\n        };\n\n        image.onerror = function () {\n          $rootScope.$apply(function () {\n            $log.warn("[companyService] Load banner for " + company.getNameForLogs() + " failure");\n            resolve(null);\n          });\n        }; // Load the image\n\n\n        image.src = imgSrc;\n      }\n    });\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/company/companyService.js?')},function(module,exports){eval('(function () {\n  "use strict";\n\n  angular.module("rainbow").service("browserService", [function () {\n    this.extractBrowserVersion = function (uastring, expr, pos) {\n      var match = uastring.match(expr);\n      return match && match.length >= pos && parseInt(match[pos], 10);\n    };\n  }]);\n})();\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/browserService.js?')},function(module,exports){eval('angular.module("rainbow").service("gRTCStatsService", [function () {\n  "use strict";\n\n  var calls = {};\n\n  this.resetStatsForAllCalls = function () {\n    // Reset all stats for analyzing a new call\n    calls = {};\n  };\n\n  this.resetStatsForCall = function (callid) {\n    if (callid in calls) {\n      delete calls[callid];\n    }\n  };\n\n  this.getCalls = function () {\n    return calls;\n  };\n\n  this.nbCalls = function () {\n    return Object.keys(calls).length;\n  };\n\n  this.hasStatsForCall = function (callid) {\n    return callid in calls;\n  };\n\n  this.addStreamToCall = function (callid, stream) {\n    if (!(callid in calls)) {\n      calls[callid] = {};\n    }\n\n    var call = calls[callid];\n    call[stream.id] = {};\n    call[stream.id].stream = stream;\n  };\n\n  this.nbStreamsInACall = function (callid) {\n    if (!(callid in calls)) {\n      return 0;\n    }\n\n    return Object.keys(calls[callid]).length;\n  };\n\n  this.getBundlePolicyForCall = function (callid) {\n    if (!(callid in calls)) {\n      return "unknown";\n    }\n\n    var call = calls[callid];\n    var nbActiveStream = 0;\n    var nbTotalStreams = this.nbStreamsInACall(callid);\n\n    for (var componentID in call) {\n      if ("selectedCandidatePairId" in call[componentID].stream) {\n        nbActiveStream++;\n      }\n    } // Audio and video call\n\n\n    if (nbTotalStreams === 4) {\n      switch (nbActiveStream) {\n        case 0:\n          return "failed";\n\n        case 1:\n          return "max-bundle";\n        // 1 flow for audio/video both side    \n\n        case 2:\n          return "balanced";\n        // 2 flows: one for audio (send/recv), one for video (send/recv)\n\n        case 4:\n          return "max-compat";\n        // 4 flows: one for audio send, one for audio recv, one for video send, one for video recv\n\n        default:\n          return "unknown";\n      }\n    } //Only audio or video call\n    else if (nbTotalStreams === 2) {\n        switch (nbActiveStream) {\n          case 0:\n            return "failed";\n\n          case 1:\n            return "max-bundle";\n          // 1 flow for audio send and recv\n\n          case 2:\n            return "max-compat";\n          // 2 flows: one for send, one for recv \n\n          default:\n            return "unknown";\n        }\n      } else {\n        return "unknown";\n      }\n  };\n\n  this.addSSRCToStream = function (callid, ssrc) {\n    var call = null;\n    var stream = null;\n\n    if (ssrc.type !== "ssrc") {\n      return;\n    }\n\n    if (!(callid in calls)) {\n      return;\n    }\n\n    call = calls[callid];\n\n    if (!(ssrc.transportId in call)) {\n      return;\n    }\n\n    stream = call[ssrc.transportId];\n\n    if (!stream.ssrc) {\n      stream.ssrc = {};\n    }\n\n    stream.ssrc[ssrc.ssrc] = ssrc;\n  };\n\n  this.hasSSRCInStream = function (callid, streamid, ssrcid) {\n    var call = null;\n    var stream = null;\n\n    if (!(callid in calls)) {\n      return false;\n    }\n\n    call = calls[callid];\n\n    if (!(streamid in call)) {\n      return false;\n    }\n\n    stream = call[streamid];\n\n    if (!stream.ssrc) {\n      return false;\n    }\n\n    return ssrcid in stream.ssrc;\n  };\n\n  this.getSSRCMediaType = function (callid, streamid, ssrcid) {\n    var call = null;\n    var stream = null;\n    var ssrc = null;\n\n    if (!(callid in calls)) {\n      return "unknown";\n    }\n\n    call = calls[callid];\n\n    if (!(streamid in call)) {\n      return "unknown";\n    }\n\n    stream = call[streamid];\n\n    if (!stream.ssrc) {\n      return "unknown";\n    }\n\n    if (!(ssrcid in stream.ssrc)) {\n      return "unknown";\n    }\n\n    ssrc = stream.ssrc[ssrcid];\n    return ssrc.mediaType;\n  };\n\n  this.getSSRCDirection = function (callid, streamid, ssrcid) {\n    var call = null;\n    var stream = null;\n    var ssrc = null;\n\n    if (!(callid in calls)) {\n      return "unknown";\n    }\n\n    call = calls[callid];\n\n    if (!(streamid in call)) {\n      return "unknown";\n    }\n\n    stream = call[streamid];\n\n    if (!stream.ssrc) {\n      return "unknown";\n    }\n\n    if (!(ssrcid in stream.ssrc)) {\n      return "unknown";\n    }\n\n    ssrc = stream.ssrc[ssrcid];\n    return getDirection(ssrc.id);\n  };\n\n  this.getSSRCAudioCodecName = function (callid, streamid, ssrcid) {\n    var call = null;\n    var stream = null;\n    var ssrc = null;\n\n    if (!(callid in calls)) {\n      return "unknown";\n    }\n\n    call = calls[callid];\n\n    if (!(streamid in call)) {\n      return "unknown";\n    }\n\n    stream = call[streamid];\n\n    if (!stream.ssrc) {\n      return "unknown";\n    }\n\n    if (!(ssrcid in stream.ssrc)) {\n      return "unknown";\n    }\n\n    ssrc = stream.ssrc[ssrcid];\n    return ssrc.googCodecName;\n  };\n\n  this.isSSRCFlowing = function (callid, streamid, ssrcid) {\n    var call = null;\n    var stream = null;\n    var ssrc = null;\n\n    if (!(callid in calls)) {\n      return false;\n    }\n\n    call = calls[callid];\n\n    if (!(streamid in call)) {\n      return false;\n    }\n\n    stream = call[streamid];\n\n    if (!stream.ssrc) {\n      return false;\n    }\n\n    if (!(ssrcid in stream.ssrc)) {\n      return false;\n    }\n\n    ssrc = stream.ssrc[ssrcid];\n    var direction = getDirection(ssrc.id);\n    var bytesFlowing = 0;\n\n    if (direction === "IN") {\n      bytesFlowing = parseInt(ssrc.bytesReceived, 10);\n    } else {\n      bytesFlowing = parseInt(ssrc.bytesSent, 10);\n    }\n\n    return bytesFlowing > 0;\n  };\n\n  this.getStreamsDetailsFromCall = function (callid) {\n    var call = null;\n    var stream = null;\n\n    if (!(callid in calls)) {\n      return [];\n    }\n\n    call = calls[callid];\n    var streams = [];\n\n    for (var streamid in call) {\n      if (call.hasOwnProperty(streamid)) {\n        stream = call[streamid];\n        var audioResult = "no";\n        var videoResult = "no";\n        var hasAudioIN = false;\n        var hasVideoIN = false;\n        var hasAudioOUT = false;\n        var hasVideoOUT = false;\n\n        for (var ssrcid in stream.ssrc) {\n          if (stream.ssrc && stream.ssrc.hasOwnProperty && stream.ssrc.hasOwnProperty(ssrcid)) {\n            var type = this.getSSRCMediaType(callid, streamid, ssrcid);\n            var direction = this.getSSRCDirection(callid, streamid, ssrcid);\n            var isFlowing = this.isSSRCFlowing(callid, streamid, ssrcid);\n\n            if (type === "audio" && direction === "IN" && isFlowing) {\n              hasAudioIN = true;\n            } else if (type === "audio" && direction === "OUT" && isFlowing) {\n              hasAudioOUT = true;\n            } else if (type === "video" && direction === "IN" && isFlowing) {\n              hasVideoIN = true;\n            } else if (type === "video" && direction === "OUT" && isFlowing) {\n              hasVideoOUT = true;\n            }\n          }\n        }\n\n        if (hasAudioIN && hasAudioOUT) {\n          audioResult = "IN|OUT";\n        } else if (hasAudioIN) {\n          audioResult = "IN";\n        } else if (hasAudioOUT) {\n          audioResult = "OUT";\n        }\n\n        if (hasVideoIN && hasVideoOUT) {\n          videoResult = "IN|OUT";\n        } else if (hasVideoIN) {\n          videoResult = "IN";\n        } else if (hasVideoOUT) {\n          videoResult = "OUT";\n        }\n\n        if (!hasAudioIN && !hasAudioOUT && !hasVideoIN && !hasVideoOUT) {\n          streams.push({\n            id: streamid,\n            streams: {}\n          });\n        } else {\n          streams.push({\n            id: streamid,\n            streams: {\n              audio: audioResult,\n              video: videoResult\n            }\n          });\n        }\n      }\n    }\n\n    return streams;\n  };\n\n  this.getCodecDetailsFromCall = function (callid) {\n    var call = null;\n    var stream = null;\n    var audioCodec = "-";\n    var videoCodec = "-";\n    var codecs = {\n      codec: {\n        "audio": audioCodec,\n        "video": videoCodec\n      }\n    };\n\n    if (!(callid in calls)) {\n      return codecs;\n    }\n\n    call = calls[callid];\n\n    for (var streamid in call) {\n      if (call.hasOwnProperty(streamid)) {\n        stream = call[streamid];\n\n        for (var ssrcid in stream.ssrc) {\n          if (stream.ssrc[ssrcid].mediaType === "audio") {\n            audioCodec = this.getSSRCAudioCodecName(callid, streamid, ssrcid);\n          }\n\n          if (stream.ssrc[ssrcid].mediaType === "video") {\n            videoCodec = this.getSSRCAudioCodecName(callid, streamid, ssrcid);\n          }\n        }\n      }\n    }\n\n    codecs.codec.audio = audioCodec;\n    codecs.codec.video = videoCodec;\n    return codecs;\n  };\n\n  var getDirection = function getDirection(id) {\n    return id.indexOf("recv") > -1 ? "IN" : "OUT";\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/gRTCStatsService.js?')},function(module,exports){eval('angular.module("rainbow").service("fRTCStatsService", [function () {\n  "use strict";\n\n  var calls = {};\n\n  this.getCalls = function () {\n    return calls;\n  };\n\n  this.nbCalls = function () {\n    return Object.keys(calls).length;\n  };\n\n  this.addStreamToCall = function (callid, stream) {\n    if (stream.isRemote) {\n      return;\n    }\n\n    if (!(callid in calls)) {\n      calls[callid] = {};\n    }\n\n    var call = calls[callid];\n\n    if (!call.streams) {\n      call.streams = {};\n    }\n\n    call.streams[stream.id] = {};\n    call.streams[stream.id] = stream;\n  };\n\n  this.nbStreamsInACall = function (callid) {\n    if (!(callid in calls)) {\n      return 0;\n    }\n\n    return Object.keys(calls[callid].streams).length;\n  };\n\n  this.resetStatsForAllCalls = function () {\n    calls = {};\n  };\n\n  this.resetStatsForCall = function (callid) {\n    if (callid in calls) {\n      delete calls[callid];\n    }\n  };\n\n  this.hasStatsForCall = function (callid) {\n    return callid in calls;\n  };\n\n  this.hasSSRCInStream = function (callid, streamid, ssrcid) {\n    var call = null;\n    var stream = null;\n\n    if (!(callid in calls)) {\n      return false;\n    }\n\n    call = calls[callid];\n\n    if (!call.streams) {\n      return false;\n    }\n\n    if (!(streamid in call.streams)) {\n      return false;\n    }\n\n    stream = call.streams[streamid];\n    return stream.ssrc === ssrcid;\n  };\n\n  this.hasStreamInCall = function (callid, streamid) {\n    var call = null;\n\n    if (!(callid in calls)) {\n      return false;\n    }\n\n    call = calls[callid];\n    return streamid in call.streams;\n  };\n\n  this.getSSRCMediaType = function (callid, streamid) {\n    var call = null;\n    var stream = null;\n\n    if (!(callid in calls)) {\n      return "unknown";\n    }\n\n    call = calls[callid];\n\n    if (!(streamid in call.streams)) {\n      return "unknown";\n    }\n\n    stream = call.streams[streamid];\n    return stream.mediaType;\n  };\n\n  this.getStreamsDetailsFromCall = function (callid) {\n    var call = null;\n\n    if (!(callid in calls)) {\n      return [];\n    }\n\n    call = calls[callid];\n    var streams = [];\n\n    for (var streamid in call.streams) {\n      if (call.streams.hasOwnProperty(streamid)) {\n        var type = this.getSSRCMediaType(callid, streamid);\n        var direction = getDirection(streamid);\n\n        if (type === "audio") {\n          streams.push({\n            id: streamid,\n            streams: {\n              audio: direction\n            }\n          });\n        } else if (type === "video") {\n          streams.push({\n            id: streamid,\n            streams: {\n              video: direction\n            }\n          });\n        }\n      }\n    }\n\n    return streams;\n  };\n\n  this.addCandidatePairToCall = function (callid, candidatePair) {\n    var call = null;\n    var hasAlreadyThisCandidatePair = false;\n\n    if (!(callid in calls)) {\n      return;\n    }\n\n    call = calls[callid];\n\n    if (!call.candidatesPairs) {\n      call.candidatesPairs = [];\n    }\n\n    for (var i = 0; i < call.candidatesPairs.length; i++) {\n      if (call.candidatesPairs[i].id === candidatePair.id) {\n        hasAlreadyThisCandidatePair = true;\n        break;\n      }\n    }\n\n    if (!hasAlreadyThisCandidatePair && candidatePair.state === "succeeded" && candidatePair.selected) {\n      call.candidatesPairs.push(candidatePair);\n    }\n  };\n\n  this.getNbCandidatePairs = function (callid) {\n    var call = null;\n    var nbCandidatePairs = 0;\n\n    if (!(callid in calls)) {\n      return nbCandidatePairs;\n    }\n\n    call = calls[callid];\n\n    if (call.candidatesPairs) {\n      nbCandidatePairs = call.candidatesPairs.length;\n    }\n\n    return nbCandidatePairs;\n  };\n\n  this.getBundlePolicyForCall = function (callid) {\n    var policy = "unknown";\n\n    if (!(callid in calls)) {\n      return policy;\n    }\n\n    switch (this.getNbCandidatePairs(callid)) {\n      case 0:\n        policy = "failed";\n        break;\n\n      case 1:\n        policy = "max-bundle";\n        break;\n\n      case 2:\n        if (this.nbStreamsInACall(callid) > 2) {\n          policy = "balanced";\n        } else {\n          policy = "max-compat";\n        }\n\n        break;\n\n      default:\n        policy = "max-compat";\n        break;\n    }\n\n    return policy;\n  };\n\n  var getDirection = function getDirection(id) {\n    return id.indexOf("inbound") > -1 ? "IN" : "OUT";\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/fRTCStatsService.js?')},function(module,exports){eval('angular.module("rainbow").service("platformService", ["$log", "$rootScope", "$window", "$interval", "settingsService", "$q", "$filter", "$http", "authService", "errorHelperService", function ($log, $rootScope, $window, $interval, settingsService, $q, $filter, $http, authService, errorHelperService) {\n  "use strict";\n\n  var service = this;\n  var listeners = [];\n  service.$q = $q;\n  this.isWin = navigator.platform.toUpperCase().indexOf("WIN") >= 0;\n  /*************************************************************/\n\n  /** LIFECYCLE STUFF                                         **/\n\n  /*************************************************************/\n\n  service.start = function (stats) {\n    return $q(function (resolve, __reject) {\n      var startDate = performance.now();\n      $log.info("");\n      $log.info("[platformService] === STARTING ===");\n      service.languages = ["en", "fr", "es", "de", "it"];\n      listeners.push($rootScope.$on("$translateChangeSuccess", function () {\n        service.fixDeviceLabels();\n      }));\n      listeners.push($rootScope.$on("ON_INPUT_DEVICE_CHANGED_EVENT", onAudioInputChange));\n      listeners.push($rootScope.$on("ON_OUTPUT_DEVICE_CHANGED_EVENT", updateOutputDevice));\n      listeners.push($rootScope.$on("ON_CONNECTION_STATE_CHANGE_EVENT", service.onAuthenticationStatusChangedEvent)); // service.detectRTC = null;\n\n      service.isAskingMedia = false;\n      service.hasAudioPermission = false;\n      service.hasVideoPermission = false;\n      service.stopWatcher(); //wait for 2s before starting watcher\n\n      $interval(service.startWatcher, 2000, 1);\n      var startDuration = Math.round(performance.now() - startDate);\n      stats.push({\n        service: "platformService",\n        startDuration: startDuration\n      });\n      $log.info("[platformService] === STARTED (" + startDuration + " ms) ===");\n      resolve();\n    });\n  };\n\n  service.stop = function () {\n    $log.info("[platformService] === STOPPING ===");\n    listeners.forEach(function (listener) {\n      listener();\n    });\n    service.stopWatcher();\n    this.mediaDevicesLength = 0;\n    this.mediaDevices = [];\n    $log.info("[platformService] === STOPPED ===");\n    return $q.when();\n  };\n\n  service.onAuthenticationStatusChangedEvent = function (__event, status) {\n    if (status === "connected") {\n      //check the current sinkId for global audio tag element\n      if (service.allowDevicesManagement() && angular.element("#globalAudioTag")[0] && (!angular.element("#globalAudioTag")[0].sinkId || angular.element("#globalAudioTag")[0].sinkId === "default")) {\n        //update the output device\n        $log.info("[platformService] onAuthenticationStatusChangedEvent -- update global audio tag");\n        service.getCurrentSpeaker().then(function (device) {\n          if (device && device.id) {\n            updateCurrentOutputDevice(device.id);\n          }\n        });\n      } //make a simple Get User Media to test the microphone device\n\n\n      service.testGetUserMedia();\n    }\n  };\n\n  this.audioDevices = 0;\n  this.videoDevices = 0;\n\n  this.detectRTCLoaded = function () {\n    service.hasAudioPermission = DetectRTC.isWebsiteHasMicrophonePermissions;\n    service.hasVideoPermission = DetectRTC.isWebsiteHasWebcamPermissions;\n    service.fixDeviceLabels();\n    var shouldAskAudio = false;\n    var shouldAskVideo = false;\n    var shouldAskMedia = service.shouldAskGetUserMedia();\n\n    if (DetectRTC.audioInputDevices && DetectRTC.audioInputDevices.length || DetectRTC.audioOutputDevices && DetectRTC.audioOutputDevices.length) {\n      if (!service.hasAudioPermission || shouldAskMedia.audio) {\n        //ask audio user media\n        shouldAskAudio = true;\n      } else {\n        _isWebsiteHasMicrophonePermissions = true;\n      }\n    }\n\n    if (DetectRTC.videoInputDevices && DetectRTC.videoInputDevices.length) {\n      if (!service.hasVideoPermission || shouldAskMedia.video) {\n        //ask video user media\n        shouldAskVideo = true;\n      } else {\n        _isWebsiteHasWebcamPermissions = true;\n      }\n    } //ask media if not already\n\n\n    if (shouldAskAudio || shouldAskVideo) {\n      if (!service.isAskingMedia) {\n        service.isAskingMedia = true;\n        service.getUserMedia(shouldAskAudio, shouldAskVideo);\n      }\n    } else {\n      service.fixDeviceLabels();\n      updateHeadsetDevices().then(function () {\n        //update desktop devices ID, if possible\n        if (service.isDesktop()) {\n          service.updateNewDesktopDevicesIds();\n        }\n\n        updateAvailability();\n\n        if (service.audioDevices !== DetectRTC.audioInputDevices.length + DetectRTC.audioOutputDevices.length) {\n          service.audioDevices = DetectRTC.audioInputDevices.length + DetectRTC.audioOutputDevices.length;\n          service.audioMediaDeviceUpdated();\n        }\n\n        if (service.videoDevices !== DetectRTC.videoInputDevices.length) {\n          service.videoDevices = DetectRTC.videoInputDevices.length;\n          service.videoMediaDeviceUpdated();\n        }\n\n        angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n          if (mediaDevice) {\n            $log.info("[PlatformService] DetectRTC.MediaDevices device " + mediaDevice.id + " with kind " + mediaDevice.kind + " with label " + mediaDevice.label);\n          }\n        });\n        service.getCurrentSpeaker().then(function (device) {\n          if (device && device.id) {\n            updateCurrentOutputDevice(device.id);\n          }\n        }); //check for JAC input change\n\n        if (service.newDevice) {\n          service.checkAndUpdateHandFreeProfile();\n        }\n\n        service.startWatcher();\n      });\n    }\n  };\n\n  this.testGetUserMedia = function () {\n    if (!service.hasAudioPermission) {\n      $log.info("[PlatformService] testGetUserMedia -- no audio permission given");\n      return;\n    }\n\n    var startDate = performance.now();\n    service.getCurrentMicrophone().then(function (microphone) {\n      var constraints = {};\n      var mic = "default";\n\n      if (microphone) {\n        constraints.audio = {\n          optional: [{\n            sourceId: microphone.id\n          }]\n        };\n        mic = "id - " + microphone.id + " and label " + microphone.label;\n      } else {\n        constraints.audio = true;\n      }\n\n      $log.info("[PlatformService] testGetUserMedia -- getUserMedia for Mic " + mic);\n      navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n        var completeStartDuration = Math.round(performance.now() - startDate);\n        $log.info("[PlatformService] testGetUserMedia -- getUserMedia success for time : " + completeStartDuration + " ms");\n        angular.forEach(stream.getTracks(), function (mediaStreamTrack) {\n          $log.info("[PlatformService] testGetUserMedia mediaStreamTrack -- " + mediaStreamTrack.label);\n          mediaStreamTrack.stop();\n        });\n        service.isAskingMedia = false;\n      })["catch"](function (error) {\n        $log.info("[PlatformService] testGetUserMedia -- getUserMedia error " + error);\n        service.isAskingMedia = false;\n      });\n    });\n  };\n\n  this.shouldAskGetUserMedia = function () {\n    var result = {\n      audio: false,\n      video: false\n    };\n    angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n      if (mediaDevice) {\n        if (mediaDevice.label && mediaDevice.label.indexOf("invoke getUserMedia") !== -1) {\n          if (mediaDevice.kind === "audioinput" || mediaDevice.kind === "audiooutput") {\n            result.audio = true;\n          } else {\n            result.video = true;\n          }\n        }\n      }\n    });\n    $log.info("[platformService] shouldAskGetUserMedia : audio " + result.audio + " and video " + result.video);\n    return result;\n  };\n\n  this.updateNewDesktopDevicesIds = function () {\n    var handFreeInputDeviceName = settingsService.getSetting("handFreeInputDeviceName");\n    var handFreeOutputDeviceName = settingsService.getSetting("handFreeOutputDeviceName");\n    var headsetDeviceName = settingsService.getSetting("headsetDeviceName");\n    var customMicrophoneName = settingsService.getSetting("customMicrophoneName");\n    var customSpeakerName = settingsService.getSetting("customSpeakerName");\n    var cameraUsed = settingsService.getSetting("cameraUsed");\n    var secondRinging = settingsService.getSetting("ringingSpeakerName");\n\n    if (handFreeInputDeviceName || handFreeOutputDeviceName || headsetDeviceName || customMicrophoneName || customSpeakerName) {\n      angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n        if (mediaDevice.kind === "audioinput") {\n          if (mediaDevice.normalizedLabel === headsetDeviceName) {\n            settingsService.setSetting("headsetMicrophone", mediaDevice.id);\n          }\n\n          if (mediaDevice.normalizedLabel === handFreeInputDeviceName) {\n            settingsService.setSetting("microphone", mediaDevice.id);\n          }\n\n          if (mediaDevice.normalizedLabel === customMicrophoneName) {\n            settingsService.setSetting("customMicrophone", mediaDevice.id);\n          }\n        } else if (mediaDevice.kind === "audiooutput") {\n          if (mediaDevice.normalizedLabel === headsetDeviceName) {\n            settingsService.setSetting("headsetSpeaker", mediaDevice.id);\n          }\n\n          if (mediaDevice.normalizedLabel === handFreeOutputDeviceName) {\n            settingsService.setSetting("speaker", mediaDevice.id);\n          }\n\n          if (mediaDevice.normalizedLabel === customSpeakerName) {\n            settingsService.setSetting("customSpeaker", mediaDevice.id);\n          }\n        }\n      });\n    }\n\n    if (cameraUsed) {\n      angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n        if (mediaDevice.kind === "videoinput") {\n          if (mediaDevice.label === cameraUsed) {\n            settingsService.setSetting("camera", mediaDevice.id);\n          }\n        }\n      });\n    }\n\n    if (secondRinging) {\n      angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n        if (mediaDevice.kind === "audiooutput") {\n          if (mediaDevice.normalizedLabel === secondRinging) {\n            settingsService.setSetting("ringingSpeaker", mediaDevice.id);\n          }\n        }\n      });\n    }\n  };\n\n  this.mediaDevicesLength = 0;\n  this.mediaDevices = [];\n  this.newDevice = null;\n\n  this.devicesWatcher = function () {\n    navigator.mediaDevices.enumerateDevices().then(function (devices) {\n      if (service.mediaDevicesLength !== devices.length || service.checkForIdChange(devices)) {\n        $log.debug("[platformService] MediaDevices count changed ! from " + service.mediaDevicesLength + " to " + devices.length);\n        $log.debug("[platformService] MediaDevices brut devices list " + JSON.stringify(devices)); //check if jack mic has been plugged\n\n        if (devices.length - service.mediaDevicesLength === 1) {\n          service.newDevice = service.getNewDevice(service.mediaDevices, devices);\n        } else {\n          service.newDevice = null;\n        }\n\n        service.mediaDevicesLength = devices.length;\n        service.mediaDevices = devices;\n        service.stopWatcher();\n        DetectRTC.load(service.detectRTCLoaded);\n      }\n    });\n  };\n  /*\n  * This function will check whether the new detected device has \n  * the same group ID as our current handfree profile device\n  * and set it as a new input device. This is the case when \n  * we plug JACK microphone in the PC\n  */\n\n\n  service.checkAndUpdateHandFreeProfile = function () {\n    $log.info("[platformService] checkAndUpdateHandFreeProfile");\n    var activeProfile = service.getActiveAudioProfile();\n\n    if (activeProfile.key === 1 && activeProfile.available === true) {\n      //check if new device has the same group as our current output device\n      service.getCurrentSpeaker().then(function (speaker) {\n        if (speaker && speaker.groupId === service.newDevice.groupId) {\n          $log.info("[platformService] checkAndUpdateHandFreeProfile -- should update the Jack Mic");\n          $rootScope.$broadcast("ON_HANDFREE_JACK_MICROPHONE_EVENT", service.newDevice);\n        }\n      });\n    }\n  };\n\n  service.checkForIdChange = function (devices) {\n    var changed = false;\n\n    if (service.mediaDevices.length) {\n      angular.forEach(service.mediaDevices, function (device) {\n        if (device.deviceId === "default" || device.deviceId === "communications") {\n          return;\n        }\n\n        var found = false;\n\n        for (var i = 0; i < devices.length; i++) {\n          if (device.deviceId === devices[i].deviceId) {\n            found = true;\n          }\n        }\n\n        if (!found) {\n          changed = true;\n        }\n      });\n    }\n\n    if (changed) {\n      $log.info("[platformService] checkForIdChange " + changed);\n    }\n\n    return changed;\n  };\n\n  service.getNewDevice = function (oldDevices, newDevices) {\n    var newDevice = null;\n\n    if (newDevices.length) {\n      angular.forEach(newDevices, function (device) {\n        if (device.deviceId === "default" || device.deviceId === "communications") {\n          return;\n        }\n\n        var found = false;\n\n        for (var i = 0; i < oldDevices.length; i++) {\n          if (device.deviceId === oldDevices[i].deviceId) {\n            found = true;\n          }\n        }\n\n        if (!found && device.kind === "audioinput") {\n          newDevice = device;\n        }\n      });\n    }\n\n    return newDevice;\n  };\n\n  service.tryToGetUserMediaForEachDevice = function () {\n    $log.info("[platformService] tryToGetUserMediaForEachDevice");\n\n    if (DetectRTC.audioInputDevices && DetectRTC.audioInputDevices.length) {\n      var chain = $q.when();\n\n      for (var i = 0; i < DetectRTC.audioInputDevices.length; i++) {\n        (function (index) {\n          var device = DetectRTC.audioInputDevices[index];\n          chain = chain.then(function () {\n            return service.getUserMediaForAudioDevice(device.id);\n          });\n        })(i);\n      }\n\n      chain = chain["finally"](function () {\n        $log.info("[platformService] tryToGetUserMediaForEachDevice finally -- has audio permission " + service.hasAudioPermission);\n\n        if (service.hasAudioPermission) {\n          service.loadDetectRTC();\n        } else {\n          _isWebsiteHasMicrophonePermissions = false;\n          _isWebsiteHasWebcamPermissions = false;\n          service.isAskingMedia = false; //open popup - Rainbow does not have access to your camera / microphone\n\n          var data = {\n            popupTitle: "information",\n            popupBody: "devicePermission",\n            okLabel: "ok"\n          };\n          $rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", data);\n          service.startWatcher();\n        }\n      });\n    } else {\n      $log.warn("[platformService] tryToGetUserMediaForEachDevice -- no audio devices found, restart the watcher"); //no audio devices detected, restart the watcher !\n\n      service.startWatcher();\n    }\n  };\n\n  service.getUserMediaForAudioDevice = function (id) {\n    return $q(function (resolve) {\n      if (service.hasAudioPermission) {\n        $log.info("[platformService] getUserMediaForAudioDevice for id: " + id + " no longer needed !");\n        resolve();\n        return;\n      }\n\n      if (!id) {\n        $log.info("[platformService] getUserMediaForAudioDevice missing id !");\n        resolve();\n        return;\n      }\n\n      $log.info("[platformService] getUserMediaForAudioDevice for id: " + id);\n      var constraints = {};\n      constraints.audio = {\n        optional: [{\n          sourceId: id\n        }]\n      };\n      navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n        $log.info("[platformService] getUserMediaForAudioDevice for id: " + id + " success");\n        angular.forEach(stream.getAudioTracks(), function (mediaStreamTrack) {\n          mediaStreamTrack.stop();\n        });\n        service.hasAudioPermission = true;\n        _isWebsiteHasMicrophonePermissions = true; //NB ! We should try and test all the cameras until we find one that works\n        //TO BE FINISHED\n\n        service.hasVideoPermission = true;\n        _isWebsiteHasWebcamPermissions = true;\n        resolve();\n      })["catch"](function (error) {\n        $log.info("[platformService] getUserMediaForAudioDevice for id: " + id + " failed with error " + error);\n        resolve();\n      });\n    });\n  };\n\n  service.getUserMedia = function (audio, video) {\n    $log.info("[platformService] getUserMedia audio: " + audio + " and video: " + video);\n    navigator.mediaDevices.getUserMedia({\n      audio: audio,\n      video: video\n    }).then(function (stream) {\n      $log.info("[platformService] getUserMedia audio: " + audio + " and video: " + video + " -- success!");\n      angular.forEach(stream.getAudioTracks(), function (mediaStreamTrack) {\n        mediaStreamTrack.stop();\n      });\n      angular.forEach(stream.getVideoTracks(), function (mediaStreamTrack) {\n        mediaStreamTrack.stop();\n      });\n\n      if (audio) {\n        service.hasAudioPermission = true;\n        _isWebsiteHasMicrophonePermissions = true;\n      }\n\n      if (video) {\n        service.hasVideoPermission = true;\n        _isWebsiteHasWebcamPermissions = true;\n      }\n\n      stream = null;\n      service.loadDetectRTC();\n    })["catch"](function (error) {\n      $log.error("[platformService] getUserMedia -- error -- " + error); //try back-up plan and try to get at least one device media\n\n      service.tryToGetUserMediaForEachDevice();\n    });\n  };\n\n  service.loadDetectRTC = function () {\n    DetectRTC.load(function () {\n      service.fixDeviceLabels();\n      updateHeadsetDevices().then(function () {\n        //update desktop devices ID, if possible\n        if (service.isDesktop()) {\n          service.updateNewDesktopDevicesIds();\n        }\n\n        updateAvailability();\n        service.isAskingMedia = false;\n\n        if (service.audioDevices !== DetectRTC.audioInputDevices.length + DetectRTC.audioOutputDevices.length) {\n          service.audioDevices = DetectRTC.audioInputDevices.length + DetectRTC.audioOutputDevices.length;\n          service.audioMediaDeviceUpdated();\n        }\n\n        if (service.videoDevices !== DetectRTC.videoInputDevices.length) {\n          service.videoDevices = DetectRTC.videoInputDevices.length;\n          service.videoMediaDeviceUpdated();\n        }\n\n        angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n          if (mediaDevice) {\n            $log.info("[PlatformService] DetectRTC.MediaDevices device " + mediaDevice.id + " with kind " + mediaDevice.kind + " with label " + mediaDevice.label);\n          }\n        });\n        service.getCurrentSpeaker().then(function (device) {\n          if (device && device.id) {\n            updateCurrentOutputDevice(device.id);\n          }\n        });\n        service.startWatcher();\n      });\n    });\n  };\n  /*************************************************************/\n\n  /** WHATSNEW STUFF                                          **/\n\n  /*************************************************************/\n\n\n  service.getWhatsNew = function () {\n    return $q(function (resolve) {\n      var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/settings/changelogs";\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        $log.info("[adminPlatformService] getWhatsNew -- success");\n        var data = response.data.data.changeLog.split("§%§");\n        var whatsNew = {};\n        data.forEach(function (markdown, index) {\n          whatsNew[service.languages[index]] = markdown;\n        });\n        Object.keys(whatsNew).forEach(function (key) {\n          if (whatsNew[key].length === 0) {\n            whatsNew[key] = whatsNew.en;\n          }\n        });\n\n        if (!whatsNew.en) {\n          whatsNew = {\n            en: "",\n            fr: "",\n            es: "",\n            de: "",\n            it: ""\n          };\n        }\n\n        resolve(whatsNew);\n      }, function failure(response) {\n        var whatsNew = {\n          en: "",\n          fr: "",\n          es: "",\n          de: "",\n          it: ""\n        };\n        resolve(whatsNew);\n        $log.error("[adminPlatformService] " + errorHelperService.getErrorFullMessage(response, "getWhatsNew"));\n      });\n    });\n  };\n\n  service.getAvailableLanguage = function (lang) {\n    var mainLang = lang.split("-")[0];\n    var realLang = service.languages.find(function (language) {\n      return language === mainLang;\n    });\n    return realLang = realLang ? realLang : "en";\n  };\n  /*************************************************************/\n\n  /** AUDIO STUFF                                             **/\n\n  /*************************************************************/\n\n\n  this.isDesktop = function () {\n    return navigator.userAgent.indexOf(" Rainbow/") >= 0;\n  };\n\n  this.allowDevicesManagement = function () {\n    return $window.chrome || this.isDesktop();\n  };\n\n  var _isWebsiteHasWebcamPermissions = false;\n\n  this.isWebsiteHasWebcamPermissions = function () {\n    if (!service.allowDevicesManagement()) {\n      return false;\n    }\n\n    return _isWebsiteHasWebcamPermissions;\n  };\n\n  var _isWebsiteHasMicrophonePermissions = false;\n\n  this.isWebsiteHasMicrophonePermissions = function () {\n    if (!service.allowDevicesManagement()) {\n      return false;\n    }\n\n    return _isWebsiteHasMicrophonePermissions;\n  };\n  /************************/\n\n  /*    Audio profiles    */\n\n  /************************/\n\n\n  var audioProfile = {\n    HANDFREE: {\n      key: 1,\n      value: "handfree",\n      available: false\n    },\n    HEADSET: {\n      key: 2,\n      value: "headset",\n      available: false\n    },\n    SPEAKERPHONE: {\n      key: 3,\n      value: "speakerphone",\n      available: false\n    },\n    CUSTOM: {\n      key: 4,\n      value: "custom",\n      available: false\n    }\n  };\n  this.audioProfileEnum = audioProfile;\n\n  this.getAudioProfiles = function () {\n    return audioProfile;\n  };\n\n  this.currentAudioProfile = audioProfile.HANDFREE;\n\n  this.getCurrentAudioProfile = function () {\n    var profileValue = settingsService.getSetting("audioProfile");\n    var profile = null;\n\n    switch (profileValue) {\n      case audioProfile.HEADSET.value:\n        profile = audioProfile.HEADSET;\n        break;\n\n      case audioProfile.HANDFREE.value:\n        profile = audioProfile.HANDFREE;\n        break;\n\n      case audioProfile.SPEAKERPHONE.value:\n        profile = audioProfile.SPEAKERPHONE;\n        break;\n\n      case audioProfile.CUSTOM.value:\n        profile = audioProfile.CUSTOM;\n        break;\n\n      default:\n        profile = audioProfile.HANDFREE;\n        settingsService.setSetting("audioProfile", profile.value);\n    }\n\n    return profile;\n  };\n\n  this.getActiveAudioProfile = function () {\n    var profile = this.getCurrentAudioProfile();\n\n    if (profile.key !== audioProfile.HANDFREE.key && !profile.available) {\n      return audioProfile.HANDFREE;\n    }\n\n    return profile;\n  };\n\n  this.setCurrentAudioProfile = function (profile) {\n    //&& (profile === audioProfile.HANDFREE || audioProfile.HEADSET)\n    if (profile) {\n      service.currentAudioProfile = profile;\n    }\n  };\n\n  this.isHandfreeAvailable = function () {\n    return service.isHandfreeMicrophoneAvailable() && service.isHandfreeSpeakerAvailable();\n  };\n\n  this.isHeadsetAvailable = function () {\n    return service.isHeadsetMicrophoneAvailable() && service.isHeadsetSpeakerAvailable();\n  };\n\n  this.isSpeakerphoneAvailable = function () {\n    return service.isSpeakerphoneMicrophoneAvailable() && service.isSpeakerphoneSpeakerAvailable();\n  };\n\n  this.isCustomAvailable = function () {\n    return service.isCustomMicrophoneAvailable() && service.isCustomSpeakerAvailable();\n  };\n  /************************/\n\n  /* Microphone treatment */\n\n  /************************/\n\n\n  this.getCurrentMicrophone = function () {\n    if (settingsService.getSetting("apiMode") === "sdk") {\n      var microphone = service.getMicrophoneForSDK();\n\n      if (microphone) {\n        return microphone;\n      }\n    }\n\n    switch (service.getActiveAudioProfile()) {\n      case audioProfile.SPEAKERPHONE:\n        return service.getSpeakerphoneMicrophone();\n\n      case audioProfile.CUSTOM:\n        return service.getCustomMicrophone();\n\n      case audioProfile.HEADSET:\n        return service.getHeadsetMicrophone();\n\n      default:\n        return service.getHandfreeMicrophone();\n    }\n  };\n\n  this.getMicrophoneForSDK = function () {\n    var deferred = $q.defer();\n    service.getMicrophones().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, settingsService.getSetting("microphone")));\n    });\n    return deferred.promise;\n  };\n\n  this.getSecondRingerStatusFromSettings = function () {\n    return settingsService.getSetting("hasSecondRinger");\n  };\n\n  this.setSecondRingerStatusFromSettings = function (val) {\n    return settingsService.setSetting("hasSecondRinger", val);\n  };\n\n  this.getHandfreeMicrophoneFromSettings = function () {\n    return settingsService.getSetting("microphone");\n  };\n\n  this.getHandfreeMicrophone = function () {\n    var deferred = $q.defer();\n    service.getMicrophones().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getHandfreeMicrophoneFromSettings()));\n    });\n    return deferred.promise;\n  };\n\n  this.getHeadsetMicrophoneFromSettings = function () {\n    return settingsService.getSetting("headsetMicrophone");\n  };\n\n  this.getHeadsetMicrophone = function () {\n    var deferred = $q.defer();\n    service.getMicrophones().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getHeadsetMicrophoneFromSettings()));\n    });\n    return deferred.promise;\n  };\n\n  this.getHeadsetDeviceName = function () {\n    var deferred = $q.defer();\n    deferred.resolve(settingsService.getSetting("headsetDeviceName"));\n    return deferred.promise;\n  };\n\n  this.getSpeakerphoneMicrophoneFromSettings = function () {\n    return settingsService.getSetting("speakerphoneMicrophone");\n  };\n\n  this.getSpeakerphoneMicrophone = function () {\n    var deferred = $q.defer();\n    service.getMicrophones().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getSpeakerphoneMicrophoneFromSettings()));\n    });\n    return deferred.promise;\n  };\n\n  this.getSpeakerphoneDeviceName = function () {\n    var deferred = $q.defer();\n    deferred.resolve(settingsService.getSetting("speakerphoneDeviceName"));\n    return deferred.promise;\n  };\n\n  this.getCustomMicrophoneFromSettings = function () {\n    return settingsService.getSetting("customMicrophone");\n  };\n\n  this.getCustomMicrophone = function () {\n    var deferred = $q.defer();\n    service.getMicrophones().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getCustomMicrophoneFromSettings()));\n    });\n    return deferred.promise;\n  };\n\n  this.getMicrophones = function () {\n    var deferred = $q.defer();\n\n    if (!this.allowDevicesManagement()) {\n      deferred.resolve([]);\n    }\n\n    service.getAudioInputDevices().then(function (devices) {\n      deferred.resolve(devices && devices.constructor === Array && _isWebsiteHasMicrophonePermissions ? devices : []);\n    })["catch"](function (error) {\n      $log.info("[PlatformService] === SERVICES FAILURE === : " + error.message);\n      deferred.reject(error);\n      return deferred.promise;\n    });\n    return deferred.promise;\n  };\n\n  this.isHandfreeMicrophoneAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getHandfreeMicrophoneFromSettings(), "audioinput");\n  };\n\n  this.isHeadsetMicrophoneAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getHeadsetMicrophoneFromSettings(), "audioinput");\n  };\n\n  this.isSpeakerphoneMicrophoneAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getSpeakerphoneMicrophoneFromSettings(), "audioinput");\n  };\n\n  this.isCustomMicrophoneAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getCustomMicrophoneFromSettings(), "audioinput");\n  };\n  /************************/\n\n  /* Speaker treatment    */\n\n  /************************/\n\n\n  this.getCurrentSpeaker = function () {\n    if (settingsService.getSetting("apiMode") === "sdk") {\n      var speaker = service.getSpeakerForSDK();\n\n      if (speaker) {\n        return speaker;\n      }\n    }\n\n    switch (service.getActiveAudioProfile()) {\n      case audioProfile.SPEAKERPHONE:\n        return service.getSpeakerphoneSpeaker();\n\n      case audioProfile.CUSTOM:\n        return service.getCustomSpeaker();\n\n      case audioProfile.HEADSET:\n        return service.getHeadsetSpeaker();\n\n      default:\n        return service.getHandfreeSpeaker();\n    }\n  };\n\n  this.getSpeakerForSDK = function () {\n    var deferred = $q.defer();\n    service.getSpeakers().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, settingsService.getSetting("speaker")));\n    });\n    return deferred.promise;\n  };\n\n  this.getHandfreeSpeakerFromSettings = function () {\n    return settingsService.getSetting("speaker");\n  };\n\n  this.getHandfreeSpeaker = function () {\n    var deferred = $q.defer();\n    service.getSpeakers().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getHandfreeSpeakerFromSettings(), true));\n    });\n    return deferred.promise;\n  };\n\n  this.getHeadsetSpeakerFromSettings = function () {\n    return settingsService.getSetting("headsetSpeaker");\n  };\n\n  this.getHeadsetSpeaker = function () {\n    var deferred = $q.defer();\n    service.getSpeakers().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getHeadsetSpeakerFromSettings()));\n    });\n    return deferred.promise;\n  };\n\n  this.getSpeakerphoneSpeakerFromSettings = function () {\n    return settingsService.getSetting("speakerphoneSpeaker");\n  };\n\n  this.getSpeakerphoneSpeaker = function () {\n    var deferred = $q.defer();\n    service.getSpeakers().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getSpeakerphoneSpeakerFromSettings()));\n    });\n    return deferred.promise;\n  };\n\n  this.getCustomSpeakerFromSettings = function () {\n    return settingsService.getSetting("customSpeaker");\n  };\n\n  this.getCustomSpeaker = function () {\n    var deferred = $q.defer();\n    service.getSpeakers().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getCustomSpeakerFromSettings()));\n    });\n    return deferred.promise;\n  };\n\n  this.getRingingSpeakerFromSettings = function () {\n    return settingsService.getSetting("ringingSpeaker");\n  };\n\n  this.getRingingSpeaker = function () {\n    var deferred = $q.defer();\n    service.getSpeakers().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, service.getRingingSpeakerFromSettings()));\n    });\n    return deferred.promise;\n  };\n  /**\n   * SET SPEAKER FOR ELEMENT\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  this.setSpeakerForElement = function (element, sinkId) {\n    var defered = $q.defer();\n\n    if (!element || !element.setSinkId) {\n      $log.warn("[platformService] setSpeakerForElement -- missing element");\n      return $q.when();\n    }\n\n    if (this.allowDevicesManagement()) {\n      if (sinkId === element.sinkId) {\n        return $q.when();\n      }\n\n      if (element.id) {\n        $log.log("[platformService] setSpeakerForElement " + element.id + " with " + sinkId);\n      }\n\n      element.setSinkId(sinkId).then(function () {\n        $log.log("[platformService] Success, audio output device attached: " + sinkId);\n\n        if (angular.element("#globalAudioTag")[0]) {\n          $log.log("[platformService] sinkId for globalAudioTag is " + angular.element("#globalAudioTag")[0].sinkId);\n        }\n\n        defered.resolve();\n      })["catch"](function (error) {\n        var errorMessage = error;\n\n        if (error.name === "SecurityError") {\n          errorMessage = "[platformService] You need to use HTTPS for selecting audio output " + "device: " + error;\n        }\n\n        $log.error("[platformService] " + errorMessage);\n        defered.resolve();\n      });\n    } else {\n      $log.warn("[platformService] Browser does not support output device selection.");\n      defered.resolve();\n    }\n\n    return defered.promise;\n  };\n\n  this.getSpeakers = function () {\n    var deferred = $q.defer();\n\n    if (!service.allowDevicesManagement()) {\n      deferred.resolve([]);\n    }\n\n    service.getAudioOutputDevices().then(function (devices) {\n      deferred.resolve(devices && devices.constructor === Array && _isWebsiteHasMicrophonePermissions ? devices : []);\n    })["catch"](function (error) {\n      $log.info("[PlatformService] === SERVICES FAILURE === : " + error.message);\n      deferred.reject(error);\n      return deferred.promise;\n    });\n    return deferred.promise;\n  };\n\n  this.isHandfreeSpeakerAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getHandfreeSpeakerFromSettings(), "audiooutput");\n  };\n\n  var _handfreeAvailibilityStatus = false;\n\n  function setHandfreeAvailabilityStatus(isAvailable) {\n    if (_handfreeAvailibilityStatus !== isAvailable) {\n      $log.info("[PlatformService] Handfree is now " + (isAvailable ? "available" : "unavailable"));\n      _handfreeAvailibilityStatus = isAvailable;\n      audioProfile.HANDFREE.available = isAvailable;\n      $rootScope.$broadcast("ON_AUDIO_PROFILE_CHANGED_EVENT", isAvailable);\n      $rootScope.$broadcast("ON_INPUT_DEVICE_CHANGED_EVENT");\n\n      if (!isAvailable) {\n        service.getCurrentSpeaker().then(function (device) {\n          if (device && device.id) {\n            updateCurrentOutputDevice(device.id);\n          }\n        });\n      }\n    }\n  }\n\n  this.isHeadsetSpeakerAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getHeadsetSpeakerFromSettings(), "audiooutput");\n  };\n\n  var _headsetAvailibilityStatus = null;\n\n  function setHeadsetAvailabilityStatus(isAvailable) {\n    if (_headsetAvailibilityStatus !== isAvailable) {\n      $log.info("[PlatformService] Headset is now " + (isAvailable ? "available" : "unavailable"));\n      _headsetAvailibilityStatus = isAvailable;\n      audioProfile.HEADSET.available = isAvailable;\n\n      if (!isAvailable) {\n        //remove headset from local storage\n        var profileValue = settingsService.getSetting("audioProfile");\n\n        if (profileValue === audioProfile.HEADSET.value) {\n          settingsService.setSetting("audioProfile", audioProfile.HANDFREE.value);\n        }\n\n        service.getCurrentSpeaker().then(function (device) {\n          if (device && device.id) {\n            updateCurrentOutputDevice(device.id);\n          }\n        });\n      } else {\n        var profileValue = settingsService.getSetting("audioProfile");\n\n        if (profileValue === audioProfile.HANDFREE.value) {\n          settingsService.setSetting("audioProfile", audioProfile.HEADSET.value);\n          service.getCurrentSpeaker().then(function (device) {\n            if (device && device.id) {\n              updateCurrentOutputDevice(device.id);\n            }\n          });\n        }\n      }\n\n      $rootScope.$broadcast("ON_AUDIO_PROFILE_CHANGED_EVENT", isAvailable);\n      $rootScope.$broadcast("ON_INPUT_DEVICE_CHANGED_EVENT");\n    }\n  }\n\n  this.isSpeakerphoneSpeakerAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getSpeakerphoneSpeakerFromSettings(), "audiooutput");\n  };\n\n  var _speakerphoneAvailibilityStatus = false;\n\n  function setSpeakerphoneAvailabilityStatus(isAvailable) {\n    if (_speakerphoneAvailibilityStatus !== isAvailable) {\n      $log.info("[PlatformService] Speakerphone is now " + (isAvailable ? "available" : "unavailable"));\n      _speakerphoneAvailibilityStatus = isAvailable;\n      audioProfile.SPEAKERPHONE.available = isAvailable;\n      $rootScope.$broadcast("ON_AUDIO_PROFILE_CHANGED_EVENT", isAvailable);\n      $rootScope.$broadcast("ON_INPUT_DEVICE_CHANGED_EVENT");\n\n      if (!isAvailable) {\n        service.getCurrentSpeaker().then(function (device) {\n          if (device && device.id) {\n            updateCurrentOutputDevice(device.id);\n          }\n        });\n      }\n    }\n  }\n\n  this.isCustomSpeakerAvailable = function () {\n    return service.isDeviceAvailable(service.mediaDevices, service.getCustomSpeakerFromSettings(), "audiooutput");\n  };\n\n  var _customAvailibilityStatus = false;\n\n  function setCustomAvailabilityStatus(isAvailable) {\n    if (_customAvailibilityStatus !== isAvailable) {\n      $log.info("[PlatformService] Custom is now " + (isAvailable ? "available" : "unavailable"));\n      _customAvailibilityStatus = isAvailable;\n      audioProfile.CUSTOM.available = isAvailable;\n      $rootScope.$broadcast("ON_AUDIO_PROFILE_CHANGED_EVENT", isAvailable);\n      $rootScope.$broadcast("ON_INPUT_DEVICE_CHANGED_EVENT");\n\n      if (!isAvailable) {\n        service.getCurrentSpeaker().then(function (device) {\n          if (device && device.id) {\n            updateCurrentOutputDevice(device.id);\n          }\n        });\n      }\n    }\n  }\n\n  function onAudioInputChange() {\n    updateAvailability();\n\n    if (service.isAskingMedia) {\n      $log.info("[PlatformService] onAudioInputChange -- already asking media -- ignore");\n      return;\n    }\n\n    service.isAskingMedia = true; //make a simple Get User Media to test the microphone device\n\n    $interval(service.testGetUserMedia, 2000, 1);\n  }\n\n  function updateAvailability() {\n    setHandfreeAvailabilityStatus(service.isHandfreeAvailable());\n    setHeadsetAvailabilityStatus(service.isHeadsetAvailable());\n    setSpeakerphoneAvailabilityStatus(service.isSpeakerphoneAvailable());\n    setCustomAvailabilityStatus(service.isCustomAvailable());\n  }\n\n  function updateOutputDevice(__event, device_id) {\n    updateAvailability();\n    $log.info("[PlatformService] updateOutputDevice " + device_id);\n\n    if (service.allowDevicesManagement() && device_id) {\n      updateCurrentOutputDevice(device_id);\n    }\n  }\n\n  var currentUpdatingDeviceId = "";\n\n  function updateCurrentOutputDevice(device_id) {\n    $log.info("[PlatformService] updateCurrentOutputDevice " + device_id);\n\n    if (angular.element("#globalAudioTag")[0] && angular.element("#globalAudioTag")[0].sinkId !== device_id && currentUpdatingDeviceId !== device_id) {\n      currentUpdatingDeviceId = device_id;\n      $log.info("[PlatformService] updateCurrentOutputDevice current ID " + angular.element("#globalAudioTag")[0].sinkId + " new id " + device_id);\n      service.setSpeakerForElement(angular.element("#globalAudioTag")[0], "default").then(function () {\n        service.setSpeakerForElement(angular.element("#globalAudioTag")[0], device_id);\n        currentUpdatingDeviceId = "";\n      })["catch"](function () {\n        //reset current output device\n        currentUpdatingDeviceId = "";\n      });\n    } else {\n      $log.info("[PlatformService] updateCurrentOutputDevice -- ignored ");\n    }\n  }\n\n  var microphones = [];\n  var speakers = [];\n  var allDevices = [];\n  var headsetDevices = [];\n  var speakerphoneDevices = [];\n  var firstDeviceUpdateHeadset = true;\n  var firstDeviceUpdateSpeakerphone = true;\n  var speakerphoneSupportedDevices = ["jabra speak", "calisto p6", "sp10", "sp20", "sp220"];\n  var handfreeSupportedDevices = ["realtek", "soundmax", "high definition audio", "nomachine"];\n\n  service.arrayContains = function (array, textSearched) {\n    return array.some(function (element) {\n      return textSearched.indexOf(element) > -1;\n    });\n  };\n\n  service.getDeviceType = function (deviceLabel) {\n    deviceLabel = deviceLabel.toLowerCase();\n\n    if (service.arrayContains(handfreeSupportedDevices, deviceLabel)) {\n      return audioProfile.HANDFREE;\n    } // else if (service.arrayContains(speakerphoneSupportedDevices, deviceLabel)) {\n    //     return audioProfile.SPEAKERPHONE;\n    // }\n    //Default is a headset\n\n\n    return audioProfile.HEADSET;\n  };\n\n  this.normalizeAnyLabel = function (anyDevice) {\n    if (!anyDevice) {\n      return null;\n    } // anyDevice.normalizedLabel = anyDevice.label;\n\n\n    if (anyDevice.id !== "default" && anyDevice.id !== "communications" && !anyDevice.normalizedLabel) {\n      if (service.isWin) {\n        anyDevice.normalizedLabel = anyDevice.label.substring(anyDevice.label.indexOf("(") + 1, anyDevice.label.indexOf(")"));\n      } else {\n        anyDevice.normalizedLabel = anyDevice.label;\n      }\n    }\n\n    return anyDevice;\n  };\n\n  var updateHeadsetDevices = function updateHeadsetDevices() {\n    var deferred = $q.defer();\n    service.getMicrophones().then(function (devices) {\n      microphones = devices;\n      return service.getSpeakers();\n    }).then(function (devices) {\n      speakers = devices;\n      var _headsetDevices = [];\n      angular.forEach(microphones, function (microphone) {\n        if (microphone.id === "default" || microphone.id === "communications") {\n          return;\n        }\n\n        microphone = service.normalizeAnyLabel(microphone);\n\n        var found = _headsetDevices.some(function (device) {\n          return device.microphone.normalizedLabel === microphone.normalizedLabel;\n        });\n\n        if (found) {\n          return;\n        }\n\n        angular.forEach(speakers, function (speaker) {\n          speaker = service.normalizeAnyLabel(speaker);\n\n          if (microphone.normalizedLabel === speaker.normalizedLabel) {\n            if (service.getDeviceType(microphone.normalizedLabel) === audioProfile.HEADSET) {\n              var _device = {\n                label: microphone.normalizedLabel,\n                microphone: microphone,\n                speaker: speaker\n              };\n\n              _headsetDevices.push(_device);\n\n              if (firstDeviceUpdateHeadset) {\n                allDevices.push(_device);\n              }\n            }\n          }\n        });\n      });\n      var headSetName = settingsService.getSetting("headsetDeviceName"); //if no headset device is present in the local storage, store the first headset device that we find\n\n      if ((!headSetName || headSetName === "null") && _headsetDevices.length) {\n        headSetName = _headsetDevices[0].label;\n        settingsService.setSetting("headsetDeviceName", _headsetDevices[0].label);\n        settingsService.setSetting("headsetMicrophone", _headsetDevices[0].microphone.id);\n        settingsService.setSetting("headsetSpeaker", _headsetDevices[0].speaker.id);\n      }\n\n      var ringingSpeakerName = settingsService.getSetting("ringingSpeakerName"); //if no ringing speaker is set, store the first one\n\n      if ((!ringingSpeakerName || ringingSpeakerName === "null") && speakers.length) {\n        for (var i = 0; i < speakers.length; i++) {\n          if (speakers[i].id === "default" || speakers[i].id === "communications") {\n            continue;\n          }\n\n          settingsService.setSetting("ringingSpeakerName", speakers[i].normalizedLabel);\n          settingsService.setSetting("ringingSpeaker", speakers[i].id);\n          break;\n        }\n      } // Check first if the device list has a new headset device\n\n\n      var newHeadsetDevices = [];\n\n      if (!firstDeviceUpdateHeadset) {\n        angular.forEach(_headsetDevices, function (newDevice) {\n          var result = headsetDevices.some(function (oldDevice) {\n            return oldDevice.label === newDevice.label;\n          });\n\n          if (!result) {\n            newHeadsetDevices.push(newDevice);\n            allDevices.push(newDevice);\n          }\n        });\n\n        if (newHeadsetDevices.length > 0) {\n          $log.info("[PlatformService] hotplugged headset(s): " + (newHeadsetDevices.length > 1 ? newHeadsetDevices.reduce(function (deviceA, deviceB) {\n            return {\n              label: deviceA.Label + ", " + deviceB.Label\n            };\n          }).label : newHeadsetDevices[0].label));\n          $rootScope.$broadcast("ON_AUDIO_HOTPLUG_DEVICES_CHANGED_EVENT", {\n            devices: newHeadsetDevices,\n            action: "add"\n          });\n        }\n      } // Check first if a device was disconnected\n\n\n      var disconnectedDevices = [];\n\n      if (!firstDeviceUpdateHeadset && headsetDevices.length > _headsetDevices.length) {\n        angular.forEach(headsetDevices, function (newDevice) {\n          var result = _headsetDevices.some(function (oldDevice) {\n            return oldDevice.label === newDevice.label;\n          });\n\n          if (!result) {\n            disconnectedDevices.push(newDevice);\n            var index = allDevices.map(function (dev) {\n              return dev.label;\n            }).indexOf(newDevice.label);\n            allDevices.splice(index, 1);\n          }\n        });\n\n        if (disconnectedDevices.length > 0) {\n          $log.info("[PlatformService] unplugged headset(s): " + (disconnectedDevices.length > 1 ? disconnectedDevices.reduce(function (deviceA, deviceB) {\n            return {\n              label: deviceA.Label + ", " + deviceB.Label\n            };\n          }).label : disconnectedDevices[0].label)); //check if unplugged device is the one stored in the local storage\n          //if no headset device is present in the local storage, store the first headset device that we find\n          // if ((headSetName && disconnectedDevices[0].label) && disconnectedDevices[0].label.indexOf(headSetName) !== -1 && _headsetDevices.length) {\n          //     $log.info("[PlatformService] update current headset with: " + _headsetDevices[0].label);\n          //     settingsService.setSetting("headsetDeviceName", _headsetDevices[0].label);\n          //     settingsService.setSetting("headsetMicrophone", _headsetDevices[0].microphone.id);\n          //     settingsService.setSetting("headsetSpeaker", _headsetDevices[0].speaker.id);\n          // }\n\n          $rootScope.$broadcast("ON_AUDIO_HOTPLUG_DEVICES_CHANGED_EVENT", {\n            devices: disconnectedDevices,\n            action: "remove"\n          });\n        }\n      }\n\n      firstDeviceUpdateHeadset = false;\n      headsetDevices = _headsetDevices;\n      deferred.resolve(_headsetDevices);\n    });\n    return deferred.promise;\n  };\n\n  this.getHeadsetDevices = function () {\n    return headsetDevices;\n  };\n\n  var updateSpeakerphoneDevices = function updateSpeakerphoneDevices() {\n    var deferred = $q.defer();\n    service.getMicrophones().then(function (devices) {\n      microphones = devices;\n      return service.getSpeakers();\n    }).then(function (devices) {\n      speakers = devices;\n      var _speakerphoneDevices = [];\n      angular.forEach(microphones, function (microphone) {\n        if (microphone.id === "default" || microphone.id === "communications") {\n          return;\n        }\n\n        microphone = service.normalizeAnyLabel(microphone);\n\n        var found = _speakerphoneDevices.some(function (device) {\n          return device.microphone.normalizedLabel === microphone.normalizedLabel;\n        });\n\n        if (found) {\n          return;\n        }\n\n        angular.forEach(speakers, function (speaker) {\n          speaker = service.normalizeAnyLabel(speaker);\n\n          if (microphone.normalizedLabel === speaker.normalizedLabel) {\n            if (service.getDeviceType(microphone.normalizedLabel) === audioProfile.SPEAKERPHONE) {\n              var _device = {\n                label: microphone.normalizedLabel,\n                microphone: microphone,\n                speaker: speaker\n              };\n\n              _speakerphoneDevices.push(_device);\n\n              if (firstDeviceUpdateSpeakerphone) {\n                allDevices.push(_device);\n              }\n            }\n          }\n        });\n      }); // Check first if the device list has a new speakerphone\n\n      var newSpeakerphoneDevices = [];\n\n      if (!firstDeviceUpdateSpeakerphone && speakerphoneDevices.length < _speakerphoneDevices.length) {\n        //var currentSpeakerphoneMicrophoneId = service.getSpeakerphoneMicrophoneFromSettings();\n        angular.forEach(_speakerphoneDevices, function (newDevice) {\n          var result = speakerphoneDevices.some(function (oldDevice) {\n            return oldDevice.label === newDevice.label;\n          });\n\n          if (!result) {\n            newSpeakerphoneDevices.push(newDevice);\n            allDevices.push(newDevice);\n          }\n        });\n\n        if (newSpeakerphoneDevices.length > 0) {\n          $log.info("[PlatformService] hotplugged speakerphone(s): " + (newSpeakerphoneDevices.length > 1 ? newSpeakerphoneDevices.reduce(function (deviceA, deviceB) {\n            return {\n              label: deviceA.Label + ", " + deviceB.Label\n            };\n          }).label : newSpeakerphoneDevices[0].label));\n          $rootScope.$broadcast("ON_AUDIO_HOTPLUG_DEVICES_CHANGED_EVENT", {\n            devices: newSpeakerphoneDevices,\n            action: "add"\n          });\n        }\n      } // Check first if a device was disconnected\n\n\n      var disconnectedDevices = [];\n\n      if (!firstDeviceUpdateSpeakerphone && speakerphoneDevices.length > _speakerphoneDevices.length) {\n        angular.forEach(speakerphoneDevices, function (newDevice) {\n          var result = _speakerphoneDevices.some(function (oldDevice) {\n            return oldDevice.label === newDevice.label;\n          });\n\n          if (!result) {\n            disconnectedDevices.push(newDevice);\n            var index = allDevices.map(function (dev) {\n              return dev.label;\n            }).indexOf(newDevice.label);\n            allDevices.splice(index, 1);\n          }\n        });\n\n        if (disconnectedDevices.length > 0) {\n          $log.info("[PlatformService] unplugged speakerphone(s): " + (disconnectedDevices.length > 1 ? disconnectedDevices.reduce(function (deviceA, deviceB) {\n            return {\n              label: deviceA.Label + ", " + deviceB.Label\n            };\n          }).label : disconnectedDevices[0].label));\n          $rootScope.$broadcast("ON_AUDIO_HOTPLUG_DEVICES_CHANGED_EVENT", {\n            devices: disconnectedDevices,\n            action: "remove"\n          });\n        }\n      }\n\n      firstDeviceUpdateSpeakerphone = false;\n      speakerphoneDevices = _speakerphoneDevices;\n      deferred.resolve(_speakerphoneDevices);\n    });\n    return deferred.promise;\n  };\n\n  this.getSpeakerphoneDevices = function () {\n    return speakerphoneDevices;\n  };\n\n  this.getAllDevices = function () {\n    return allDevices;\n  };\n\n  this.getHandFreeDevice = function () {\n    var deferred = $q.defer();\n    service.getHandfreeMicrophone().then(function (microphone) {\n      var curMic = microphone;\n      service.getHandfreeSpeaker().then(function (speaker) {\n        var curSpeak = speaker;\n\n        if (!service.handFreeDevice || service.handFreeDevice.microphone && service.handFreeDevice.microphone.id !== curMic.id || service.handFreeDevice.speaker && service.handFreeDevice.speaker.id !== curSpeak.id) {\n          service.handFreeDevice = {\n            label: "",\n            microphone: curMic,\n            speaker: curSpeak,\n            profile: audioProfile.HANDFREE\n          };\n        }\n\n        deferred.resolve(service.handFreeDevice);\n      });\n    });\n    return deferred.promise;\n  };\n\n  this.getCustomDevice = function () {\n    var deferred = $q.defer();\n    service.getCustomMicrophone().then(function (microphone) {\n      var curMic = microphone;\n      service.getCustomSpeaker().then(function (speaker) {\n        var curSpeak = speaker;\n\n        if (!service.customDevice || service.customDevice.microphone && service.customDevice.microphone.id !== curMic.id || service.customDevice.speaker && service.customDevice.speaker.id !== curSpeak.id) {\n          service.customDevice = {\n            label: "",\n            microphone: curMic,\n            speaker: curSpeak,\n            profile: audioProfile.CUSTOM\n          };\n        }\n\n        deferred.resolve(service.customDevice);\n      });\n    });\n    return deferred.promise;\n  };\n\n  this.getAvailableDevices = function () {\n    var deferred = $q.defer();\n    var res = [];\n    service.getHandFreeDevice().then(function (device) {\n      res.push(device);\n      headsetDevices.forEach(function (elem) {\n        elem.profile = audioProfile.HEADSET;\n        res.push(elem);\n      });\n      speakerphoneDevices.forEach(function (elem) {\n        elem.profile = audioProfile.SPEAKERPHONE;\n        res.push(elem);\n      });\n      service.getCustomDevice().then(function (customDevice) {\n        res.push(customDevice);\n        deferred.resolve(res);\n      });\n    });\n    return deferred.promise;\n  };\n\n  this.getStoredDeviceList = function () {\n    return settingsService.getSetting("deviceList");\n  };\n\n  this.saveDeviceList = function (devices) {\n    var deviceLabelList = [];\n\n    for (var i = 0; i < devices.length; i++) {\n      deviceLabelList[i] = devices[i].label;\n    }\n\n    settingsService.setSetting("deviceList", angular.toJson(deviceLabelList));\n  };\n  /************************/\n\n  /*  Camera treatment    */\n\n  /************************/\n\n\n  this.getCurrentCamera = function () {\n    var deferred = $q.defer();\n    service.getCameras().then(function (devices) {\n      deferred.resolve(service.getDeviceWithId(devices, settingsService.getSetting("camera")));\n    });\n    return deferred.promise;\n  };\n\n  this.getCameraForSDK = function () {\n    return {\n      id: settingsService.getSetting("camera")\n    };\n  };\n\n  this.getCameras = function () {\n    var deferred = $q.defer();\n\n    if (!this.allowDevicesManagement()) {\n      deferred.resolve([]);\n    } // service.checkVideoMediaPermission().then(function() {\n\n\n    service.getVideoInputDevices().then(function (devices) {\n      deferred.resolve(devices && devices.constructor === Array && _isWebsiteHasWebcamPermissions ? devices : []);\n    })["catch"](function (error) {\n      $log.info("[PlatformService] === SERVICES FAILURE === : " + error.message);\n      deferred.reject(error);\n      return deferred.promise;\n    });\n    return deferred.promise;\n  };\n\n  this.isDeviceAvailable = function (devices, id, kind) {\n    var current_device = devices.find(function (device) {\n      return device.kind === kind && device.deviceId === id;\n    });\n    return angular.isDefined(current_device);\n  };\n  /*\n  * When we search for the default speaker device\n  * we should find the default input device and find the \n  * corresponding output device (with the same groupID), if possible.\n  * This is the case when some users have set a strange default output \n  * configuration on their PC.\n  */\n\n\n  this.getDeviceWithId = function (devices, id, isSpeaker) {\n    if (devices.constructor !== Array) {\n      return null;\n    }\n\n    var current_device = null; //get device that is the default one\n\n    if (id === "default" || id === "communications") {\n      //find the device with the same groupID as the default one for input\n      if (isSpeaker) {\n        var default_device = service.mediaDevices.find(function (device) {\n          return device.deviceId === id && device.kind === "audioinput";\n        });\n\n        if (default_device) {\n          current_device = devices.find(function (device) {\n            return device.id !== "default" && device.id !== "communications" && default_device.groupId === device.groupId;\n          });\n        }\n      } else {\n        var default_device = devices.find(function (device) {\n          return device.id === id;\n        });\n\n        if (default_device) {\n          current_device = devices.find(function (device) {\n            return device.id !== "default" && device.id !== "communications" && default_device.groupId === device.groupId;\n          });\n        }\n      }\n    }\n\n    if (current_device) {\n      return current_device;\n    }\n\n    current_device = devices.find(function (device) {\n      return device.id === id;\n    }); //if device is no longer available\n\n    if (!current_device) {\n      //find the device with the same groupID as the default one for input\n      if (isSpeaker) {\n        var default_device = service.mediaDevices.find(function (device) {\n          return device.deviceId === "default" && device.kind === "audioinput";\n        });\n\n        if (default_device) {\n          current_device = devices.find(function (device) {\n            return device.id !== "default" && device.id !== "communications" && default_device.groupId === device.groupId;\n          });\n        }\n      } //still no device found\n\n\n      if (!current_device) {\n        //get device that is the same as the default one\n        default_device = devices.find(function (device) {\n          return device.id === "default";\n        });\n\n        if (default_device) {\n          current_device = devices.find(function (device) {\n            return device.id !== "default" && device.id !== "communications" && default_device.groupId === device.groupId;\n          });\n        }\n      }\n    }\n\n    if (!current_device) {\n      if (devices.length > 0) {\n        return devices[0];\n      }\n\n      return null;\n    }\n\n    return current_device;\n  };\n  /**************************************************/\n\n  /** PRIVATE METHODS                              **/\n\n  /**************************************************/\n\n\n  var watcher;\n\n  this.startWatcher = function () {\n    if (service.allowDevicesManagement()) {\n      if (angular.isDefined(watcher)) {\n        return;\n      }\n\n      watcher = $interval(service.devicesWatcher, 1000);\n    }\n  };\n\n  this.stopWatcher = function () {\n    if (angular.isDefined(watcher)) {\n      $interval.cancel(watcher);\n      watcher = undefined;\n    }\n  };\n\n  this.capitalizeFirstLetter = function (string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  }; // On desktop default and communication are not well detected\n\n\n  this.fixDeviceLabels = function () {\n    angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n      if (mediaDevice) {\n        if (mediaDevice.id === "default" && (!mediaDevice.label || mediaDevice.label === "Default")) {\n          //find the default input/output device for desktop\n          mediaDevice.label = service.findAndUpdateDefaultDeviceLabel(mediaDevice.kind, mediaDevice.groupId);\n        } else if (mediaDevice.id.length < 64 && mediaDevice.label === "Please invoke getUserMedia once.") {\n          mediaDevice.label = service.capitalizeFirstLetter(mediaDevice.id);\n        }\n\n        $log.info("[PlatformService] fixDeviceLabels || update device " + mediaDevice.id + " with kind " + mediaDevice.kind + " with label " + mediaDevice.label);\n      }\n    });\n  };\n\n  this.findAndUpdateDefaultDeviceLabel = function (kind, groupId) {\n    var label = kind === "audioinput" ? $filter("translate")("yourComputerMicrophoneDevice") : $filter("translate")("yourComputerSpeakerDevice");\n\n    for (var i = 0; i < DetectRTC.MediaDevices.length; i++) {\n      if (DetectRTC.MediaDevices[i].id !== "default" && DetectRTC.MediaDevices[i].kind === kind && DetectRTC.MediaDevices[i].groupId === groupId) {\n        label = label + " - " + DetectRTC.MediaDevices[i].label;\n        break;\n      }\n    }\n\n    return label;\n  };\n\n  this.updatePermissions = function () {\n    var result = false;\n    angular.forEach(DetectRTC.MediaDevices, function (mediaDevice) {\n      if (mediaDevice) {\n        if (mediaDevice.id.length >= 64) {\n          if (mediaDevice.label === "Please invoke getUserMedia once.") {\n            result = true;\n          } else {\n            if (mediaDevice.kind === "videoinput" && !_isWebsiteHasWebcamPermissions) {\n              _isWebsiteHasWebcamPermissions = true;\n            }\n\n            if (mediaDevice.kind === "audioinput" && !_isWebsiteHasMicrophonePermissions) {\n              _isWebsiteHasMicrophonePermissions = true;\n            }\n          }\n        }\n      }\n    });\n    return result;\n  };\n\n  this.isGetUserMediaRequested = function () {\n    if (_isWebsiteHasWebcamPermissions && _isWebsiteHasMicrophonePermissions) {\n      return false;\n    }\n\n    return service.updatePermissions(DetectRTC.MediaDevices);\n  }; // this.checkMicrophonePermission = function() {\n  //     var deferred = service.$q.defer();\n  //     if (_isWebsiteHasMicrophonePermissions) {\n  //         deferred.resolve(_isWebsiteHasMicrophonePermissions);\n  //         return deferred.promise;\n  //     }\n  //     console.error("checkMicrophonePermission should not get here !!!!");\n  //     // navigator.mediaDevices.getUserMedia({\n  //     //     audio: true\n  //     // }).then(function(stream) {\n  //     //     angular.forEach(stream.getAudioTracks(), function(mediaStreamTrack) {\n  //     //         mediaStreamTrack.stop();\n  //     //     });\n  //     //     _isWebsiteHasMicrophonePermissions = true;\n  //     //     updateHeadsetDevices();\n  //     //     updateSpeakerphoneDevices();\n  //     //     $rootScope.$broadcast("ON_USER_AUDIO_MEDIA_CHANGED_EVENT");\n  //     //     deferred.resolve(_isWebsiteHasMicrophonePermissions);\n  //     // })\n  //     //     .catch(function(error) {\n  //     //         $log.error(error);\n  //     //         _isWebsiteHasMicrophonePermissions = false;\n  //     //         deferred.resolve(_isWebsiteHasMicrophonePermissions);\n  //     //     });\n  //     return deferred.promise;\n  // };\n  // this.checkVideoPermission = function() {\n  //     var deferred = $q.defer();\n  //     if (_isWebsiteHasWebcamPermissions) {\n  //         deferred.resolve(_isWebsiteHasWebcamPermissions);\n  //         return deferred.promise;\n  //     }\n  //     console.error("checkVideoPermission should not get here !!!!");\n  //     navigator.mediaDevices.getUserMedia({\n  //         video: true\n  //     }).then(function(stream) {\n  //         angular.forEach(stream.getVideoTracks(), function(mediaStreamTrack) {\n  //             mediaStreamTrack.stop();\n  //         });\n  //         _isWebsiteHasWebcamPermissions = true;\n  //         $rootScope.$broadcast("ON_USER_VIDEO_MEDIA_CHANGED_EVENT");\n  //         deferred.resolve(_isWebsiteHasWebcamPermissions);\n  //     })\n  //         .catch(function(error) {\n  //             $log.info("webcam permission : " + error);\n  //             _isWebsiteHasWebcamPermissions = false;\n  //             deferred.resolve(_isWebsiteHasWebcamPermissions);\n  //         });\n  //     return deferred.promise;\n  // };\n  // this.checkMicrophoneMediaPermission = function() {\n  //     var defered = $q.defer();\n  //     if (service.isGetUserMediaRequested()) {\n  //         defered.resolve();\n  //     } else {\n  //         defered.resolve();\n  //     }\n  //     return defered.promise;\n  // };\n  // this.checkVideoMediaPermission = function() {\n  //     var defered = $q.defer();\n  //     if (service.isGetUserMediaRequested()) {\n  //         defered.resolve();\n  //         // service.checkVideoPermission()\n  //         //     .then(function() {\n  //         //         defered.resolve();\n  //         //     })\n  //         //     .catch(function(error) {\n  //         //         defered.reject(error);\n  //         //         return defered.promise;\n  //         //     });\n  //     } else {\n  //         defered.resolve();\n  //     }\n  //     return defered.promise;\n  // };\n\n\n  this.audioMediaDeviceUpdated = function () {\n    service.fixDeviceLabels();\n    $rootScope.$broadcast("ON_USER_AUDIO_MEDIA_CHANGED_EVENT");\n  };\n\n  this.videoMediaDeviceUpdated = function () {\n    service.fixDeviceLabels();\n    $rootScope.$broadcast("ON_USER_VIDEO_MEDIA_CHANGED_EVENT");\n  }; // this.detectRTCAudioLoad = function(isFirst) {\n  //     console.error("detectRTCAudioLoad");\n  //     var deferred = $q.defer();\n  //     if (isFirst) {\n  //         service.detectRTCLoad()\n  //             .then(function() {\n  //                 return service.checkMicrophoneMediaPermission();\n  //             })\n  //             .then(function() {\n  //                 return service.detectRTCAudioLoad(false);\n  //             })\n  //             .then(function() {\n  //                 deferred.resolve();\n  //             });\n  //     } else {\n  //         service.detectRTCLoad()\n  //             .then(function() {\n  //                 // if (DetectRTC.audioInputDevices.length > 0) {\n  //                 //     service.audioMediaDeviceUpdated();\n  //                 // }\n  //                 deferred.resolve();\n  //                 return deferred.promise;\n  //             })\n  //             .catch(function(error) {\n  //                 $log.info("[PlatformService] === SERVICES FAILURE === : " + error.message);\n  //                 deferred.reject(error);\n  //                 return deferred.promise;\n  //             });\n  //     }\n  //     return deferred.promise;\n  // };\n  // this.detectRTCVideoLoad = function(isFirst) {\n  //     console.error("detectRTCVideoLoad");\n  //     var deferred = $q.defer();\n  //     if (isFirst) {\n  //         service.detectRTCLoad()\n  //             .then(function() {\n  //                 return service.checkVideoMediaPermission();\n  //             })\n  //             .then(function() {\n  //                 return service.detectRTCVideoLoad(false);\n  //             })\n  //             .then(function() {\n  //                 deferred.resolve();\n  //             });\n  //     } else {\n  //         service.detectRTCLoad()\n  //             .then(function() {\n  //                 // if (DetectRTC.videoInputDevices.length > 0) {\n  //                 //     service.videoMediaDeviceUpdated();\n  //                 // }\n  //                 deferred.resolve();\n  //                 return deferred.promise;\n  //             })\n  //             .catch(function(error) {\n  //                 $log.info("[PlatformService] === SERVICES FAILURE === : " + error.message);\n  //                 deferred.reject(error);\n  //                 return deferred.promise;\n  //             });\n  //     }\n  //     return deferred.promise;\n  // };\n  // this.detectRTCLoad = function() {\n  //     console.error("detectRTCLoad");\n  //     return $q.when();\n  //     var deferred = $q.defer();\n  //     DetectRTC.load(function() {\n  //         deferred.resolve();\n  //     });\n  //     return deferred.promise;\n  // };\n\n\n  var removeDuplicates = function removeDuplicates(devices) {\n    var result = [];\n    angular.forEach(devices, function (device) {\n      if (!result.some(function (item) {\n        return item.id === device.id;\n      })) {\n        result.push(device);\n      }\n    });\n    return result;\n  }; // var isAudioFirstLoad = true;\n\n\n  this.getAudioInputDevices = function () {\n    return $q.when(removeDuplicates(DetectRTC.audioInputDevices));\n  };\n\n  this.getAudioOutputDevices = function () {\n    var deferred = $q.defer();\n    deferred.resolve(removeDuplicates(DetectRTC.audioOutputDevices)); // if (isAudioFirstLoad) {\n    //     service.detectRTCAudioLoad(isAudioFirstLoad)\n    //         .then(function() {\n    //             if (DetectRTC.audioInputDevices.length > 0) {\n    //                 isAudioFirstLoad = false;\n    //             } else {\n    //                 deferred.resolve([]);\n    //             }\n    //             deferred.resolve(removeDuplicates(DetectRTC.audioOutputDevices));\n    //         })\n    //         .catch(function(error) {\n    //             $log.info("[PlatformService] === SERVICES FAILURE === : " + error.message);\n    //             deferred.reject(error);\n    //             return deferred.promise;\n    //         });\n    // } else {\n    //     deferred.resolve(removeDuplicates(DetectRTC.audioOutputDevices));\n    // }\n\n    return deferred.promise;\n  }; // var isVideoFirstLoad = true;\n\n\n  this.getVideoInputDevices = function () {\n    var deferred = $q.defer();\n    deferred.resolve(removeDuplicates(DetectRTC.videoInputDevices)); // if (isVideoFirstLoad) {\n    //     service.detectRTCVideoLoad(isVideoFirstLoad)\n    //         .then(function() {\n    //             if (DetectRTC.videoInputDevices.length > 0) {\n    //                 isVideoFirstLoad = false;\n    //             } else {\n    //                 deferred.resolve([]);\n    //             }\n    //             deferred.resolve(removeDuplicates(DetectRTC.videoInputDevices));\n    //         })\n    //         .catch(function(error) {\n    //             $log.info("[PlatformService] === SERVICES FAILURE === : " + error.message);\n    //             deferred.reject(error);\n    //             return deferred.promise;\n    //         });\n    // } else {\n    //     deferred.resolve(removeDuplicates(DetectRTC.videoInputDevices));\n    // }\n\n    return deferred.promise;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/platformService.js?')},function(module,exports){eval('angular.module("rainbow").service("gaService", [function () {\n  "use strict";\n\n  var analytics = {\n    "ICEFailed": {\n      "category": "webrtc",\n      "action": "CallsSuccessRate",\n      "label": "error_failed"\n    },\n    "ICESuccess": {\n      "category": "webrtc",\n      "action": "CallsSuccessRate",\n      "label": "success"\n    },\n    "ICENoSTUNCandidate": {\n      "category": "webrtc",\n      "action": "CallsSuccessRate",\n      "label": "error_no_stun_candidate"\n    },\n    "ICEUsed": {\n      "category": "webrtc",\n      "action": "ICEDistribution"\n    },\n    "ICETopology": {\n      "category": "webrtc",\n      "action": "ICETopology"\n    },\n    "NegotiationTime": {\n      "category": "webrtc",\n      "action": "ICENegotiation",\n      "label": "DurationMs"\n    },\n    "GetUserMedia": {\n      "category": "webrtc",\n      "action": "GetUserMediaRate",\n      "label": "success"\n    },\n    "GetUserMediaErrorNoTrack": {\n      "category": "webrtc",\n      "action": "GetUserMediaRate",\n      "label": "error_no_Track"\n    },\n    "GetUserMediaError": {\n      "category": "webrtc",\n      "action": "GetUserMediaRate",\n      "label": "error"\n    },\n    "CodecsUsed": {\n      "category": "webrtc",\n      "action": "CodecsDistribution"\n    },\n    "NbSuccessCall": {\n      "category": "webrtc",\n      "action": "CallsDistribution"\n    },\n    "CallsDuration": {\n      "category": "webrtc",\n      "action": "CallsDurationRange"\n    },\n    "DragAndDrop": {\n      "category": "ux",\n      "action": "dragAndDrop"\n    },\n    "InviteFromProvider": {\n      "category": "invitations",\n      "action": "inviteFromProvider"\n    }\n  };\n  var _startNegotiationTime = null;\n  var _endNegotiationTime = null;\n  var _pendingComputation = false;\n  var _lastICESuccessTracked = null;\n  var _lastICEFailedTracked = null;\n  var _ga = null;\n\n  this.provideGA = function (ga) {\n    _ga = ga;\n  };\n\n  this.hasGA = function () {\n    return _ga !== null;\n  };\n\n  this.trackICEUsed = function (local, remote) {\n    if (_ga) {\n      var localICEUsed = "";\n      var remoteICEUsed = "";\n\n      switch (local) {\n        case "local":\n          localICEUsed = "host";\n          break;\n\n        case "peerreflexive":\n        case "prflx":\n        case "serverreflexive":\n          localICEUsed = "stun";\n          break;\n\n        case "relayed":\n          localICEUsed = "relay";\n          break;\n\n        default:\n          localICEUsed = local;\n          break;\n      }\n\n      switch (remote) {\n        case "local":\n          remoteICEUsed = "host";\n          break;\n\n        case "peerreflexive":\n        case "prflx":\n        case "serverreflexive":\n          remoteICEUsed = "stun";\n          break;\n\n        case "relayed":\n          remoteICEUsed = "relay";\n          break;\n\n        default:\n          remoteICEUsed = remote;\n          break;\n      }\n\n      _ga.send("event", analytics.ICEUsed.category, analytics.ICEUsed.action, localICEUsed + "|" + remoteICEUsed);\n    }\n  };\n\n  this.trackICEFailed = function (sid) {\n    if (_ga && sid) {\n      if (_lastICEFailedTracked !== sid) {\n        _ga.send("event", analytics.ICEFailed.category, analytics.ICEFailed.action, analytics.ICEFailed.label);\n\n        _lastICEFailedTracked = sid;\n      }\n    }\n  };\n\n  this.trackICESuccess = function (sid) {\n    if (_ga && sid) {\n      if (_lastICESuccessTracked !== sid) {\n        _ga.send("event", analytics.ICESuccess.category, analytics.ICESuccess.action, analytics.ICESuccess.label);\n\n        _lastICESuccessTracked = sid;\n      }\n    }\n  };\n\n  this.trackICENoSTUNCandidate = function () {\n    if (_ga) {\n      _ga.send("event", analytics.ICENoSTUNCandidate.category, analytics.ICENoSTUNCandidate.action, analytics.ICENoSTUNCandidate.label);\n    }\n  };\n\n  this.trackICETopology = function (topology) {\n    if (_ga) {\n      _ga.send("event", analytics.ICETopology.category, analytics.ICETopology.action, topology);\n    }\n  };\n\n  this.trackGetUserMediaSuccess = function () {\n    if (_ga) {\n      _ga.send("event", analytics.GetUserMedia.category, analytics.GetUserMedia.action, analytics.GetUserMedia.label);\n    }\n  };\n\n  this.trackGetUserMediaErrorNoTrack = function () {\n    if (_ga) {\n      _ga.send("event", analytics.GetUserMediaErrorNoTrack.category, analytics.GetUserMediaErrorNoTrack.action, analytics.GetUserMediaErrorNoTrack.label);\n    }\n  };\n\n  this.trackGetUserMediaError = function () {\n    if (_ga) {\n      _ga.send("event", analytics.GetUserMediaError.category, analytics.GetUserMediaError.action, analytics.GetUserMediaError.label);\n    }\n  };\n\n  this.trackCodecsUsed = function (audioCodec, videoCodec) {\n    if (_ga) {\n      _ga.send("event", analytics.CodecsUsed.category, analytics.CodecsUsed.action, audioCodec + "|" + videoCodec);\n    }\n  };\n\n  this.negotiationTime = function () {\n    if (!_endNegotiationTime || !_startNegotiationTime) {\n      return null;\n    }\n\n    if (_endNegotiationTime < _startNegotiationTime) {\n      return null;\n    }\n\n    return _endNegotiationTime - _startNegotiationTime;\n  };\n\n  this.startNegotiationTime = function (time) {\n    if (time) {\n      _startNegotiationTime = time;\n    } else {\n      _startNegotiationTime = new Date().getTime();\n    }\n\n    _pendingComputation = true;\n  };\n\n  this.endNegotiationTime = function (time) {\n    if (_pendingComputation) {\n      if (time) {\n        _endNegotiationTime = time;\n      } else {\n        _endNegotiationTime = new Date().getTime();\n      }\n\n      _pendingComputation = false;\n    }\n  };\n\n  this.trackNegotiationTime = function () {\n    if (_ga) {\n      var duration = this.negotiationTime();\n\n      if (duration) {\n        _ga.send("event", analytics.NegotiationTime.category, analytics.NegotiationTime.action, analytics.NegotiationTime.label, duration);\n      }\n\n      _endNegotiationTime = null;\n      _startNegotiationTime = null;\n    }\n  };\n\n  this.resetProvider = function () {\n    _ga = null;\n  };\n\n  this.trackCallSuccessNumber = function (type) {\n    if (type && type.length > 0 && _ga) {\n      _ga.send("event", analytics.NbSuccessCall.category, analytics.NbSuccessCall.action, type);\n    }\n  };\n\n  this.trackCallDuration = function (durationMs) {\n    if (_ga && angular.isDefined(durationMs) && durationMs >= 0) {\n      var durationCategoryLabel = "";\n      var durationInSeconds = Math.round(durationMs / 1000);\n\n      if (durationInSeconds < 15) {\n        durationCategoryLabel = "very_short_less_15s";\n      } else if (durationInSeconds < 30) {\n        durationCategoryLabel = "very_short_less_30s";\n      } else if (durationInSeconds < 60) {\n        durationCategoryLabel = "short_less_60s";\n      } else if (durationInSeconds < 120) {\n        durationCategoryLabel = "short_less_120s";\n      } else if (durationInSeconds < 300) {\n        durationCategoryLabel = "short_less_300s";\n      } else if (durationInSeconds < 600) {\n        durationCategoryLabel = "normal_less_600s";\n      } else if (durationInSeconds < 1200) {\n        durationCategoryLabel = "normal_less_1200s";\n      } else if (durationInSeconds < 1800) {\n        durationCategoryLabel = "normal_less_1800s";\n      } else if (durationInSeconds < 3600) {\n        durationCategoryLabel = "long_less_3600s";\n      } else {\n        durationCategoryLabel = "long_more_3600s";\n      }\n\n      _ga.send("event", analytics.CallsDuration.category, analytics.CallsDuration.action, durationCategoryLabel);\n    }\n  };\n\n  this.trackDragAndDrop = function (type) {\n    if (_ga) {\n      _ga.send("event", analytics.DragAndDrop.category, analytics.DragAndDrop.action, type);\n    }\n  };\n\n  this.inviteContactsFromProvider = function (provider, number) {\n    if (_ga) {\n      _ga.send("event", analytics.InviteFromProvider.category, analytics.InviteFromProvider.action, provider, number);\n    }\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/gaService.js?')},function(module,exports){eval('/**\n * @ngdoc service\n * @module rainbow\n * @name countryService\n * @description Rainbow CountryService provides interface to manage countries\n */\nangular.module("rainbow").service("countryService", ["$http", "$q", "$log", "$translate", "authService", function ($http, $q, $log, $translate, authService) {\n  "use strict";\n\n  var service = this;\n  /**\n   * List of data center locations, grouped by geographical regions\n   */\n\n  service.datacenters = [{\n    "name": "France",\n    "alpha-3": "FRA",\n    "alpha-2": "FR",\n    "region": "Europe"\n  }, {\n    "name": "Germany",\n    "alpha-3": "DEU",\n    "alpha-2": "DE",\n    "region": "Europe"\n  }, {\n    "name": "Canada",\n    "alpha-3": "CAN",\n    "alpha-2": "CA",\n    "region": "America"\n  }, {\n    "name": "Singapore",\n    "alpha-3": "SGP",\n    "alpha-2": "SG",\n    "region": "Asia-Pacific"\n  }];\n  /**\n   * List of countries (obsolete)\n   */\n\n  service.countries = [{\n    "name": "Australia",\n    "alpha-3": "AUS",\n    "country-code": "036",\n    "alpha-2": "AU"\n  }, {\n    "name": "Austria",\n    "alpha-3": "AUT",\n    "country-code": "040",\n    "alpha-2": "AT"\n  }, {\n    "name": "Belgium",\n    "alpha-3": "BEL",\n    "country-code": "056",\n    "alpha-2": "BE"\n  }, {\n    "name": "Brazil",\n    "alpha-3": "BRA",\n    "country-code": "076",\n    "alpha-2": "BR"\n  }, {\n    "name": "Canada",\n    "alpha-3": "CAN",\n    "country-code": "124",\n    "alpha-2": "CA"\n  }, {\n    "name": "China",\n    "alpha-3": "CHN",\n    "country-code": "156",\n    "alpha-2": "CN"\n  }, {\n    "name": "Czech Republic",\n    "alpha-3": "CZE",\n    "country-code": "203",\n    "alpha-2": "CZ"\n  }, {\n    "name": "Denmark",\n    "alpha-3": "DNK",\n    "country-code": "208",\n    "alpha-2": "DK"\n  }, {\n    "name": "Finland",\n    "alpha-3": "FIN",\n    "country-code": "246",\n    "alpha-2": "FI"\n  }, {\n    "name": "France",\n    "alpha-3": "FRA",\n    "country-code": "250",\n    "default": true,\n    "alpha-2": "FR"\n  }, {\n    "name": "Germany",\n    "alpha-3": "DEU",\n    "country-code": "276",\n    "alpha-2": "DE"\n  }, {\n    "name": "Hong Kong",\n    "alpha-3": "HKG",\n    "country-code": "344",\n    "alpha-2": "HK"\n  }, {\n    "name": "Ireland",\n    "alpha-3": "IRL",\n    "country-code": "372",\n    "alpha-2": "IE"\n  }, {\n    "name": "Israel",\n    "alpha-3": "ISR",\n    "country-code": "376",\n    "alpha-2": "IL"\n  }, {\n    "name": "Italy",\n    "alpha-3": "ITA",\n    "country-code": "380",\n    "alpha-2": "IT"\n  }, {\n    "name": "Mexico",\n    "alpha-3": "MEX",\n    "country-code": "484",\n    "alpha-2": "MX"\n  }, {\n    "name": "Netherlands",\n    "alpha-3": "NLD",\n    "country-code": "528",\n    "alpha-2": "NL"\n  }, {\n    "name": "Norway",\n    "alpha-3": "NOR",\n    "country-code": "578",\n    "alpha-2": "NO"\n  }, {\n    "name": "Poland",\n    "alpha-3": "POL",\n    "country-code": "616",\n    "alpha-2": "PL"\n  }, {\n    "name": "Portugal",\n    "alpha-3": "PRT",\n    "country-code": "620",\n    "alpha-2": "PT"\n  }, {\n    "name": "Russia",\n    "alpha-3": "RUS",\n    "country-code": "643",\n    "alpha-2": "RU"\n  }, {\n    "name": "South Africa",\n    "alpha-3": "ZAF",\n    "country-code": "710",\n    "alpha-2": "ZA"\n  }, {\n    "name": "South Korea",\n    "alpha-3": "KOR",\n    "country-code": "410",\n    "alpha-2": "KR"\n  }, {\n    "name": "Spain",\n    "alpha-3": "ESP",\n    "country-code": "724",\n    "alpha-2": "ES"\n  }, {\n    "name": "Sweden",\n    "alpha-3": "SWE",\n    "country-code": "752",\n    "alpha-2": "SE"\n  }, {\n    "name": "Switzerland",\n    "alpha-3": "CHE",\n    "country-code": "756",\n    "alpha-2": "CH"\n  }, {\n    "name": "Taiwan",\n    "alpha-3": "TWN",\n    "country-code": "158",\n    "alpha-2": "TW"\n  }, {\n    "name": "Turkey",\n    "alpha-3": "TUR",\n    "country-code": "792",\n    "alpha-2": "TR"\n  }, {\n    "name": "United Kingdom",\n    "alpha-3": "GBR",\n    "country-code": "826",\n    "alpha-2": "GB"\n  }, {\n    "name": "United States of America",\n    "alpha-3": "USA",\n    "country-code": "840",\n    "alpha-2": "US"\n  }, {\n    "name": "Afghanistan",\n    "alpha-3": "AFG",\n    "country-code": "004",\n    "alpha-2": "AF"\n  }, {\n    "name": "Albania",\n    "alpha-3": "ALB",\n    "country-code": "008",\n    "alpha-2": "AL"\n  }, {\n    "name": "Algeria",\n    "alpha-3": "DZA",\n    "country-code": "012",\n    "alpha-2": "DZ"\n  }, {\n    "name": "Andorra",\n    "alpha-3": "AND",\n    "country-code": "020",\n    "alpha-2": "AD"\n  }, {\n    "name": "Angola",\n    "alpha-3": "AGO",\n    "country-code": "024",\n    "alpha-2": "AO"\n  }, {\n    "name": "Anguilla",\n    "alpha-3": "AIA",\n    "country-code": "660",\n    "alpha-2": "AI"\n  }, {\n    "name": "Antigua and Barbuda",\n    "alpha-3": "ATG",\n    "country-code": "028",\n    "alpha-2": "AG"\n  }, {\n    "name": "Argentina",\n    "alpha-3": "ARG",\n    "country-code": "032",\n    "alpha-2": "AR"\n  }, {\n    "name": "Armenia",\n    "alpha-3": "ARM",\n    "country-code": "051",\n    "alpha-2": "AM"\n  }, {\n    "name": "Aruba",\n    "alpha-3": "ABW",\n    "country-code": "533",\n    "alpha-2": "AW"\n  }, {\n    "name": "Azerbaijan",\n    "alpha-3": "AZE",\n    "country-code": "031",\n    "alpha-2": "AZ"\n  }, {\n    "name": "Bahamas",\n    "alpha-3": "BHS",\n    "country-code": "044",\n    "alpha-2": "BS"\n  }, {\n    "name": "Bahrain",\n    "alpha-3": "BHR",\n    "country-code": "048",\n    "alpha-2": "BH"\n  }, {\n    "name": "Bangladesh",\n    "alpha-3": "BGD",\n    "country-code": "050",\n    "alpha-2": "BD"\n  }, {\n    "name": "Barbados",\n    "alpha-3": "BRB",\n    "country-code": "052",\n    "alpha-2": "BB"\n  }, {\n    "name": "Belarus",\n    "alpha-3": "BLR",\n    "country-code": "112",\n    "alpha-2": "BY"\n  }, {\n    "name": "Belize",\n    "alpha-3": "BLZ",\n    "country-code": "084",\n    "alpha-2": "BZ"\n  }, {\n    "name": "Benin",\n    "alpha-3": "BEN",\n    "country-code": "204",\n    "alpha-2": "BJ"\n  }, {\n    "name": "Bermuda",\n    "alpha-3": "BMU",\n    "country-code": "060",\n    "alpha-2": "BM"\n  }, {\n    "name": "Bhutan",\n    "alpha-3": "BTN",\n    "country-code": "064",\n    "alpha-2": "BT"\n  }, {\n    "name": "Bolivia",\n    "alpha-3": "BOL",\n    "country-code": "068",\n    "alpha-2": "BO"\n  }, {\n    "name": "Bosnia and Herzegovina",\n    "alpha-3": "BIH",\n    "country-code": "070",\n    "alpha-2": "BA"\n  }, {\n    "name": "Botswana",\n    "alpha-3": "BWA",\n    "country-code": "072",\n    "alpha-2": "BW"\n  }, {\n    "name": "British Virgin Islands",\n    "alpha-3": "VGB",\n    "country-code": "092",\n    "alpha-2": "VG"\n  }, {\n    "name": "Brunei Darussalam",\n    "alpha-3": "BRN",\n    "country-code": "096",\n    "alpha-2": "BN"\n  }, {\n    "name": "Bulgaria",\n    "alpha-3": "BGR",\n    "country-code": "100",\n    "alpha-2": "BG"\n  }, {\n    "name": "Burkina Faso",\n    "alpha-3": "BFA",\n    "country-code": "854",\n    "alpha-2": "BF"\n  }, {\n    "name": "Burundi",\n    "alpha-3": "BDI",\n    "country-code": "108",\n    "alpha-2": "BI"\n  }, {\n    "name": "Cambodia",\n    "alpha-3": "KHM",\n    "country-code": "116",\n    "alpha-2": "KH"\n  }, {\n    "name": "Cameroon",\n    "alpha-3": "CMR",\n    "country-code": "120",\n    "alpha-2": "CM"\n  }, {\n    "name": "Cape Verde",\n    "alpha-3": "CPV",\n    "country-code": "132",\n    "alpha-2": "CV"\n  }, {\n    "name": "Cayman Islands",\n    "alpha-3": "CYM",\n    "country-code": "136",\n    "alpha-2": "KY"\n  }, {\n    "name": "Central African Republic",\n    "alpha-3": "CAF",\n    "country-code": "140",\n    "alpha-2": "CF"\n  }, {\n    "name": "Chad",\n    "alpha-3": "TCD",\n    "country-code": "148",\n    "alpha-2": "TD"\n  }, {\n    "name": "Chile",\n    "alpha-3": "CHL",\n    "country-code": "152",\n    "alpha-2": "CL"\n  }, {\n    "name": "Colombia",\n    "alpha-3": "COL",\n    "country-code": "170",\n    "alpha-2": "CO"\n  }, {\n    "name": "Comoros",\n    "alpha-3": "COM",\n    "country-code": "174",\n    "alpha-2": "KM"\n  }, {\n    "name": "Congo",\n    "alpha-3": "COG",\n    "country-code": "178",\n    "alpha-2": "CG"\n  }, {\n    "name": "Congo, Democratic Republic of",\n    "alpha-3": "COD",\n    "country-code": "180",\n    "alpha-2": "CD"\n  }, {\n    "name": "Costa Rica",\n    "alpha-3": "CRI",\n    "country-code": "188",\n    "alpha-2": "CR"\n  }, {\n    "name": "Ivory Coast",\n    "alpha-3": "CIV",\n    "country-code": "384",\n    "alpha-2": "CI"\n  }, {\n    "name": "Croatia",\n    "alpha-3": "HRV",\n    "country-code": "191",\n    "alpha-2": "HR"\n  }, {\n    "name": "Cyprus",\n    "alpha-3": "CYP",\n    "country-code": "196",\n    "alpha-2": "CY"\n  }, {\n    "name": "Djibouti",\n    "alpha-3": "DJI",\n    "country-code": "262",\n    "alpha-2": "DJ"\n  }, {\n    "name": "Dominica",\n    "alpha-3": "DMA",\n    "country-code": "212",\n    "alpha-2": "DM"\n  }, {\n    "name": "Dominican Republic",\n    "alpha-3": "DOM",\n    "country-code": "214",\n    "alpha-2": "DO"\n  }, {\n    "name": "Ecuador",\n    "alpha-3": "ECU",\n    "country-code": "218",\n    "alpha-2": "EC"\n  }, {\n    "name": "El Salvador",\n    "alpha-3": "SLV",\n    "country-code": "222",\n    "alpha-2": "SV"\n  }, {\n    "name": "Egypt",\n    "alpha-3": "EGY",\n    "country-code": "818",\n    "alpha-2": "EG"\n  }, {\n    "name": "Eritrea",\n    "alpha-3": "ERI",\n    "country-code": "232",\n    "alpha-2": "ER"\n  }, {\n    "name": "Estonia",\n    "alpha-3": "EST",\n    "country-code": "233",\n    "alpha-2": "EE"\n  }, {\n    "name": "Ethiopia",\n    "alpha-3": "ETH",\n    "country-code": "231",\n    "alpha-2": "ET"\n  }, {\n    "name": "Fiji",\n    "alpha-3": "FJI",\n    "country-code": "242",\n    "alpha-2": "FJ"\n  }, {\n    "name": "French Guiana",\n    "alpha-3": "GUF",\n    "country-code": "254",\n    "alpha-2": "GF"\n  }, {\n    "name": "French Polynesia",\n    "alpha-3": "PYF",\n    "country-code": "258",\n    "alpha-2": "PF"\n  }, {\n    "name": "Gabon",\n    "alpha-3": "GAB",\n    "country-code": "266",\n    "alpha-2": "GA"\n  }, {\n    "name": "Gambia",\n    "alpha-3": "GMB",\n    "country-code": "270",\n    "alpha-2": "GM"\n  }, {\n    "name": "Georgia",\n    "alpha-3": "GEO",\n    "country-code": "268",\n    "alpha-2": "GE"\n  }, {\n    "name": "Ghana",\n    "alpha-3": "GHA",\n    "country-code": "288",\n    "alpha-2": "GH"\n  }, {\n    "name": "Greece",\n    "alpha-3": "GRC",\n    "country-code": "300",\n    "alpha-2": "GR"\n  }, {\n    "name": "Grenada",\n    "alpha-3": "GRD",\n    "country-code": "308",\n    "alpha-2": "GD"\n  }, {\n    "name": "Guadeloupe",\n    "alpha-3": "GLP",\n    "country-code": "312",\n    "alpha-2": "GP"\n  }, {\n    "name": "Guatemala",\n    "alpha-3": "GTM",\n    "country-code": "320",\n    "alpha-2": "GT"\n  }, {\n    "name": "Guinea",\n    "alpha-3": "GIN",\n    "country-code": "324",\n    "alpha-2": "GN"\n  }, {\n    "name": "Guyana",\n    "alpha-3": "GUY",\n    "country-code": "328",\n    "alpha-2": "GY"\n  }, {\n    "name": "Haiti",\n    "alpha-3": "HTI",\n    "country-code": "332",\n    "alpha-2": "HT"\n  }, {\n    "name": "Honduras",\n    "alpha-3": "HND",\n    "country-code": "340",\n    "alpha-2": "HN"\n  }, {\n    "name": "Hungary",\n    "alpha-3": "HUN",\n    "country-code": "348",\n    "alpha-2": "HU"\n  }, {\n    "name": "Iceland",\n    "alpha-3": "ISL",\n    "country-code": "352",\n    "alpha-2": "IS"\n  }, {\n    "name": "India",\n    "alpha-3": "IND",\n    "country-code": "356",\n    "alpha-2": "IN"\n  }, {\n    "name": "Indonesia",\n    "alpha-3": "IDN",\n    "country-code": "360",\n    "alpha-2": "ID"\n  }, {\n    "name": "Iraq",\n    "alpha-3": "IRQ",\n    "country-code": "368",\n    "alpha-2": "IQ"\n  }, {\n    "name": "Jamaica",\n    "alpha-3": "JAM",\n    "country-code": "388",\n    "alpha-2": "JM"\n  }, {\n    "name": "Japan",\n    "alpha-3": "JPN",\n    "country-code": "392",\n    "alpha-2": "JP"\n  }, {\n    "name": "Jordan",\n    "alpha-3": "JOR",\n    "country-code": "400",\n    "alpha-2": "JO"\n  }, {\n    "name": "Kazakhstan",\n    "alpha-3": "KAZ",\n    "country-code": "398",\n    "alpha-2": "KZ"\n  }, {\n    "name": "Kenya",\n    "alpha-3": "KEN",\n    "country-code": "404",\n    "alpha-2": "KE"\n  }, {\n    "name": "Kuwait",\n    "alpha-3": "KWT",\n    "country-code": "414",\n    "alpha-2": "KW"\n  }, {\n    "name": "Kyrgyzstan",\n    "alpha-3": "KGZ",\n    "country-code": "417",\n    "alpha-2": "KG"\n  }, {\n    "name": "Latvia",\n    "alpha-3": "LVA",\n    "country-code": "428",\n    "alpha-2": "LV"\n  }, {\n    "name": "Lebanon",\n    "alpha-3": "LBN",\n    "country-code": "422",\n    "alpha-2": "LB"\n  }, {\n    "name": "Lesotho",\n    "alpha-3": "LSO",\n    "country-code": "426",\n    "alpha-2": "LS"\n  }, {\n    "name": "Liberia",\n    "alpha-3": "LBR",\n    "country-code": "430",\n    "alpha-2": "LR"\n  }, {\n    "name": "Libya",\n    "alpha-3": "LBY",\n    "country-code": "434",\n    "alpha-2": "LY"\n  }, {\n    "name": "Liechtenstein",\n    "alpha-3": "LIE",\n    "country-code": "438",\n    "alpha-2": "LI"\n  }, {\n    "name": "Lithuania",\n    "alpha-3": "LTU",\n    "country-code": "440",\n    "alpha-2": "LT"\n  }, {\n    "name": "Luxembourg",\n    "alpha-3": "LUX",\n    "country-code": "442",\n    "alpha-2": "LU"\n  }, {\n    "name": "Macao",\n    "alpha-3": "MAC",\n    "country-code": "446",\n    "alpha-2": "MO"\n  }, {\n    "name": "Macedonia",\n    "alpha-3": "MKD",\n    "country-code": "807",\n    "alpha-2": "MK"\n  }, {\n    "name": "Madagascar",\n    "alpha-3": "MDG",\n    "country-code": "450",\n    "alpha-2": "MG"\n  }, {\n    "name": "Malawi",\n    "alpha-3": "MWI",\n    "country-code": "454",\n    "alpha-2": "MW"\n  }, {\n    "name": "Malaysia",\n    "alpha-3": "MYS",\n    "country-code": "458",\n    "alpha-2": "MY"\n  }, {\n    "name": "Maldives",\n    "alpha-3": "MDV",\n    "country-code": "462",\n    "alpha-2": "MV"\n  }, {\n    "name": "Mali",\n    "alpha-3": "MLI",\n    "country-code": "466",\n    "alpha-2": "ML"\n  }, {\n    "name": "Malta",\n    "alpha-3": "MLT",\n    "country-code": "470",\n    "alpha-2": "MT"\n  }, {\n    "name": "Mauritius",\n    "alpha-3": "MUS",\n    "country-code": "480",\n    "alpha-2": "MU"\n  }, {\n    "name": "Mayotte",\n    "alpha-3": "MYT",\n    "country-code": "175",\n    "alpha-2": "YT"\n  }, {\n    "name": "Moldova",\n    "alpha-3": "MDA",\n    "country-code": "498",\n    "alpha-2": "MD"\n  }, {\n    "name": "Monaco",\n    "alpha-3": "MCO",\n    "country-code": "492",\n    "alpha-2": "MC"\n  }, {\n    "name": "Mongolia",\n    "alpha-3": "MNG",\n    "country-code": "496",\n    "alpha-2": "MN"\n  }, {\n    "name": "Montenegro",\n    "alpha-3": "MNE",\n    "country-code": "499",\n    "alpha-2": "ME"\n  }, {\n    "name": "Montserrat",\n    "alpha-3": "MSR",\n    "country-code": "500",\n    "alpha-2": "MS"\n  }, {\n    "name": "Morocco",\n    "alpha-3": "MAR",\n    "country-code": "504",\n    "alpha-2": "MA"\n  }, {\n    "name": "Mozambique",\n    "alpha-3": "MOZ",\n    "country-code": "508",\n    "alpha-2": "MZ"\n  }, {\n    "name": "Myanmar",\n    "alpha-3": "MMR",\n    "country-code": "104",\n    "alpha-2": "MM"\n  }, {\n    "name": "Namibia",\n    "alpha-3": "NAM",\n    "country-code": "516",\n    "alpha-2": "NA"\n  }, {\n    "name": "Nepal",\n    "alpha-3": "NPL",\n    "country-code": "524",\n    "alpha-2": "NP"\n  }, {\n    "name": "New Zealand",\n    "alpha-3": "NZL",\n    "country-code": "554",\n    "alpha-2": "NZ"\n  }, {\n    "name": "Nicaragua",\n    "alpha-3": "NIC",\n    "country-code": "558",\n    "alpha-2": "NI"\n  }, {\n    "name": "Niger",\n    "alpha-3": "NER",\n    "country-code": "562",\n    "alpha-2": "NE"\n  }, {\n    "name": "Nigeria",\n    "alpha-3": "NGA",\n    "country-code": "566",\n    "alpha-2": "NG"\n  }, {\n    "name": "Oman",\n    "alpha-3": "OMN",\n    "country-code": "512",\n    "alpha-2": "OM"\n  }, {\n    "name": "Pakistan",\n    "alpha-3": "PAK",\n    "country-code": "586",\n    "alpha-2": "PK"\n  }, {\n    "name": "Palestine",\n    "alpha-3": "PSE",\n    "country-code": "275",\n    "alpha-2": "PS"\n  }, {\n    "name": "Panama",\n    "alpha-3": "PAN",\n    "country-code": "591",\n    "alpha-2": "PA"\n  }, {\n    "name": "Paraguay",\n    "alpha-3": "PRY",\n    "country-code": "600",\n    "alpha-2": "PY"\n  }, {\n    "name": "Peru",\n    "alpha-3": "PER",\n    "country-code": "604",\n    "alpha-2": "PE"\n  }, {\n    "name": "Philippines",\n    "alpha-3": "PHL",\n    "country-code": "608",\n    "alpha-2": "PH"\n  }, {\n    "name": "Puerto Rico",\n    "alpha-3": "PRI",\n    "country-code": "630",\n    "alpha-2": "PR"\n  }, {\n    "name": "Qatar",\n    "alpha-3": "QAT",\n    "country-code": "634",\n    "alpha-2": "QA"\n  }, {\n    "name": "Romania",\n    "alpha-3": "ROU",\n    "country-code": "642",\n    "alpha-2": "RO"\n  }, {\n    "name": "Rwanda",\n    "alpha-3": "RWA",\n    "country-code": "646",\n    "alpha-2": "RW"\n  }, {\n    "name": "Saint Kitts and Nevis",\n    "alpha-3": "KNA",\n    "country-code": "659",\n    "alpha-2": "KN"\n  }, {\n    "name": "Saint Lucia",\n    "alpha-3": "LCA",\n    "country-code": "662",\n    "alpha-2": "LC"\n  }, {\n    "name": "Saint Vincent and the Grenadines",\n    "alpha-3": "VCT",\n    "country-code": "670",\n    "alpha-2": "VC"\n  }, {\n    "name": "Saudi Arabia",\n    "alpha-3": "SAU",\n    "country-code": "682",\n    "alpha-2": "SA"\n  }, {\n    "name": "Senegal",\n    "alpha-3": "SEN",\n    "country-code": "686",\n    "alpha-2": "SN"\n  }, {\n    "name": "Serbia",\n    "alpha-3": "SRB",\n    "country-code": "688",\n    "alpha-2": "RS"\n  }, {\n    "name": "Sierra Leone",\n    "alpha-3": "SLE",\n    "country-code": "694",\n    "alpha-2": "SL"\n  }, {\n    "name": "Singapore",\n    "alpha-3": "SGP",\n    "country-code": "702",\n    "alpha-2": "SG"\n  }, {\n    "name": "Slovakia",\n    "alpha-3": "SVK",\n    "country-code": "703",\n    "alpha-2": "SK"\n  }, {\n    "name": "Slovenia",\n    "alpha-3": "SVN",\n    "country-code": "705",\n    "alpha-2": "SI"\n  }, {\n    "name": "South Sudan",\n    "alpha-3": "SSD",\n    "country-code": "728",\n    "alpha-2": "SS"\n  }, {\n    "name": "Sri Lanka",\n    "alpha-3": "LKA",\n    "country-code": "144",\n    "alpha-2": "LK"\n  }, {\n    "name": "Sudan",\n    "alpha-3": "SDN",\n    "country-code": "729",\n    "alpha-2": "SD"\n  }, {\n    "name": "Swaziland",\n    "alpha-3": "SWZ",\n    "country-code": "748",\n    "alpha-2": "SZ"\n  }, {\n    "name": "Tajikistan",\n    "alpha-3": "TJK",\n    "country-code": "762",\n    "alpha-2": "TJ"\n  }, {\n    "name": "Tanzania",\n    "alpha-3": "TZA",\n    "country-code": "834",\n    "alpha-2": "TZ"\n  }, {\n    "name": "Thailand",\n    "alpha-3": "THA",\n    "country-code": "764",\n    "alpha-2": "TH"\n  }, {\n    "name": "Togo",\n    "alpha-3": "TGO",\n    "country-code": "768",\n    "alpha-2": "TG"\n  }, {\n    "name": "Trinidad and Tobago",\n    "alpha-3": "TTO",\n    "country-code": "780",\n    "alpha-2": "TT"\n  }, {\n    "name": "Tunisia",\n    "alpha-3": "TUN",\n    "country-code": "788",\n    "alpha-2": "TN"\n  }, {\n    "name": "Turkmenistan",\n    "alpha-3": "TKM",\n    "country-code": "795",\n    "alpha-2": "TM"\n  }, {\n    "name": "Turks and Caicos Islands",\n    "alpha-3": "TCA",\n    "country-code": "796",\n    "alpha-2": "TC"\n  }, {\n    "name": "Uganda",\n    "alpha-3": "UGA",\n    "country-code": "800",\n    "alpha-2": "UG"\n  }, {\n    "name": "Ukraine",\n    "alpha-3": "UKR",\n    "country-code": "804",\n    "alpha-2": "UA"\n  }, {\n    "name": "United Arab Emirates",\n    "alpha-3": "ARE",\n    "country-code": "784",\n    "alpha-2": "AE"\n  }, {\n    "name": "Virgin Islands, US",\n    "alpha-3": "VIR",\n    "country-code": "850",\n    "alpha-2": "VI"\n  }, {\n    "name": "Uruguay",\n    "alpha-3": "URY",\n    "country-code": "858",\n    "alpha-2": "UY"\n  }, {\n    "name": "Uzbekistan",\n    "alpha-3": "UZB",\n    "country-code": "860",\n    "alpha-2": "UZ"\n  }, {\n    "name": "Venezuela",\n    "alpha-3": "VEN",\n    "country-code": "862",\n    "alpha-2": "VE"\n  }, {\n    "name": "Vietnam",\n    "alpha-3": "VNM",\n    "country-code": "704",\n    "alpha-2": "VN"\n  }, {\n    "name": "Zambia",\n    "alpha-3": "ZMB",\n    "country-code": "894",\n    "alpha-2": "ZM"\n  }, {\n    "name": "Zimbabwe",\n    "alpha-3": "ZWE",\n    "country-code": "716",\n    "alpha-2": "ZW"\n  }];\n  /** Alphabetical list of Canadian states **/\n\n  service.statesOfCanada = {\n    AB: "Alberta",\n    BC: "British Columbia",\n    MB: "Manitoba",\n    NB: "New Brunswick",\n    NL: "Newfoundland and Labrador",\n    NS: "Nova Scotia",\n    NT: "Northwest Territories",\n    NU: "Nunavut",\n    ON: "Ontario",\n    PE: "Prince Edward Island",\n    QC: "Quebec",\n    SK: "Saskatchewan",\n    YT: "Yukon"\n  };\n  /** Alphabetical list of US states **/\n\n  service.statesOfAmerica = {\n    AL: "Alabama",\n    AK: "Alaska",\n    AZ: "Arizona",\n    AR: "Arkansas",\n    AA: "Armed Forces America",\n    AE: "Armed Forces",\n    AP: "Armed Forces Pacific",\n    CA: "California",\n    CO: "Colorado",\n    CT: "Connecticut",\n    DE: "Delaware",\n    FL: "Florida",\n    GA: "Georgia",\n    GU: "Guam",\n    HI: "Hawaii",\n    ID: "Idaho",\n    IL: "Illinois",\n    IN: "Indiana",\n    IA: "Iowa",\n    KS: "Kansas",\n    KY: "Kentucky",\n    LA: "Louisiana",\n    ME: "Maine",\n    MD: "Maryland",\n    MA: "Massachusetts",\n    MI: "Michigan",\n    MN: "Minnesota",\n    MS: "Mississippi",\n    MO: "Missouri",\n    MT: "Montana",\n    NE: "Nebraska",\n    NV: "Nevada",\n    NH: "New Hampshire",\n    NJ: "New Jersey",\n    NM: "New Mexico",\n    NY: "New York",\n    NC: "North Carolina",\n    ND: "North Dakota",\n    OH: "Ohio",\n    OK: "Oklahoma",\n    OR: "Oregon",\n    PA: "Pennsylvania",\n    PR: "Puerto Rico",\n    RI: "Rhode Island",\n    SC: "South Carolina",\n    SD: "South Dakota",\n    TN: "Tennessee",\n    TX: "Texas",\n    UT: "Utah",\n    VT: "Vermont",\n    VI: "Virgin Islands",\n    VA: "Virginia",\n    WA: "Washington",\n    DC: "Washington DC",\n    WV: "West Virginia",\n    WI: "Wisconsin",\n    WY: "Wyoming"\n  };\n\n  service.init = function () {\n    // Get and store portalURL\n    this.portalURL = config.restServerUrl + "/api/rainbow/enduser/v1.0/";\n  };\n  /********************************************************/\n\n  /** LIFE CYCLE STUFF                                   **/\n\n  /********************************************************/\n\n\n  service.start = function (stats) {\n    $log.info("");\n    $log.info("[countryService] === STARTING ===");\n    var startDate = performance.now();\n    return $q(function (resolve, __reject) {\n      service.init();\n      service.getAvailableCountries().then(function (availableCountries) {\n        // build countries array\n        service.countries = availableCountries.map(function (country) {\n          var entry = {\n            "name": country.fullname,\n            "alpha-3": country.isoAlpha3Code,\n            "alpha-2": country.isoAlpha2Code\n          };\n\n          if (country.isoAlpha3Code === "FRA") {\n            entry["default"] = true;\n          }\n\n          return entry;\n        });\n      })["catch"](function (error) {\n        $log.info("[countryService] === warning === " + error.message);\n      })["finally"](function () {\n        var startDuration = Math.round(performance.now() - startDate);\n        stats.push({\n          service: "countryService",\n          startDuration: startDuration\n        });\n        $log.info("[countryService] === STARTED (" + startDuration + " ms) === " + service.countries.length + " countries");\n        $log.info("");\n        resolve();\n      });\n    });\n  };\n\n  service.stop = function () {\n    $log.info("[countryService] STOPPED");\n  };\n  /********************************************************/\n\n  /** PRIVATE                                            **/\n\n  /********************************************************/\n\n  /**\n   * @private\n   */\n\n\n  service.getAvailableCountries = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "countries",\n        headers: authService.getRequestHeader()\n      }).then(function (response) {\n        resolve(response.data.data);\n      })["catch"](function (response) {\n        var errorMessage = response.data ? response.data.errorDetails || response.data.errorMsg : response.message;\n        $log.error("[countryService] " + "getAvailableCountries failure -- " + errorMessage + " - status " + response.status);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** PUBLIC                                             **/\n\n  /********************************************************/\n\n  /**\n   * Get a countries list ready for <drop-list> tag\n   */\n\n\n  service.getCountries = function () {\n    var countries = service.countries.map(service.translateCountryName);\n    countries.sort(service.sortByCountryName);\n    return countries;\n  };\n\n  service.sortByCountryName = function (country1, country2) {\n    return country1.name.localeCompare(country2.name, $translate.use());\n  };\n\n  service.translateCountryName = function (country) {\n    var label = service.getCountryLabel(country["alpha-2"]);\n\n    if (label) {\n      var name = $translate.instant(label);\n\n      if (name && name !== label) {\n        country.name = name; // translated country name\n      }\n    }\n\n    return country;\n  };\n  /**\n   * Get an american states list (ready for <select> tag)\n   */\n\n\n  service.getCountryStates = function (country) {\n    if (country && country["alpha-3"] === "USA") {\n      return service.statesOfAmerica;\n    }\n\n    if (country && country["alpha-3"] === "CAN") {\n      return service.statesOfCanada;\n    }\n\n    return {};\n  };\n\n  service.getCountry = function (countryCode, defaulted) {\n    if (!countryCode) {\n      return defaulted ? service.getDefaultCountry() : null;\n    }\n\n    var countries = service.countries.filter(function (country) {\n      return country["alpha-3"] === countryCode;\n    });\n    return countries.length > 0 ? countries[0] : null;\n  };\n\n  service.getDefaultCountry = function () {\n    var countries = service.countries.filter(function (country) {\n      return country["default"] === true;\n    });\n    return countries.length > 0 ? countries[0] : service.countries[0];\n  };\n\n  service.getCountryName = function (countryCode) {\n    var country = service.getCountry(countryCode);\n    return country ? service.getCountry(countryCode).name : null;\n  };\n\n  service.getCountryCode = function (country) {\n    if (country) {\n      return country["alpha-3"];\n    }\n\n    return null;\n  };\n\n  service.getDefaultState = function (country) {\n    if (country && country["alpha-3"] === "USA") {\n      return "AL";\n    }\n\n    if (country && country["alpha-3"] === "CAN") {\n      return "AB";\n    }\n\n    return null;\n  };\n\n  service.getAlpha2Code = function (alpha3Code) {\n    if (!alpha3Code) {\n      return null;\n    }\n\n    var countries = service.countries.filter(function (country) {\n      return country["alpha-3"] === alpha3Code;\n    });\n    return countries.length > 0 ? countries[0]["alpha-2"] : null;\n  };\n\n  service.getCountryLabel = function (alphaCode) {\n    if (alphaCode.length === 3) {\n      // alpha-3 code\n      var alpha2Code = service.getAlpha2Code(alphaCode);\n    } else {\n      // alpha-2 code\n      var alpha2Code = alphaCode;\n    }\n\n    if (alpha2Code) {\n      return "country" + alpha2Code;\n    }\n\n    return null;\n  };\n\n  service.getDataCenterLabel = function (datacenterLocation, companyCountry) {\n    // By default, take the geographical region (zone) where the data center is located\n    var label = service.getRegionLabel(datacenterLocation.name);\n\n    if (datacenterLocation.country === companyCountry) {\n      // Take exact data center location when the company is nearby\n      label = service.getCountryLabel(datacenterLocation.country);\n    } else {\n      // Otherwise, let\'s be vague about the exact region (ex. Canada (North-America) => America)\n      var datacenter = service.datacenters.find(function (dc) {\n        return dc["alpha-3"] === datacenterLocation.country;\n      });\n\n      if (datacenter) {\n        label = service.getRegionLabel(datacenter.region);\n      }\n    }\n\n    return label;\n  };\n\n  service.getRegionLabel = function (regionName) {\n    return regionName;\n  };\n}]);\nangular.module("rainbow").filter("countryFilter", ["countryService", function (countryService) {\n  "use strict";\n\n  return function (input) {\n    return countryService.getCountryName(input);\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/countryService.js?')},function(module,exports){eval('angular.module("rainbow").service("usersService", ["$q", "$log", "$rootScope", "contactService", function ($q, $log, $rootScope, contactService) {\n  "use strict";\n\n  var that = this;\n  var listeners = [];\n  this.started = false;\n\n  this.start = function (stats) {\n    $log.info("[usersService] === STARTING ===");\n    that.started = true;\n    var startDate = performance.now();\n    $log.info("[usersService] start");\n    that.contactsInRoster = that.getAllRosterContacts();\n    that.lastNameList = that.orderContacts("lastname");\n    that.firstNameList = that.orderContacts("firstname");\n    that.companyNameList = that.orderContacts("company");\n    listeners.push($rootScope.$on("ON_CONTACT_ROSTER_UPDATE_EVENT", that.onContactUpdatedEvent));\n    var startDuration = Math.round(performance.now() - startDate);\n    stats.push({\n      service: "usersService",\n      startDuration: startDuration\n    });\n    $log.info("[usersService] === STARTED (" + startDuration + " ms) ===");\n    return $q.when();\n  };\n\n  this.stop = function () {\n    $log.info("[usersService] === STOPPING ===");\n\n    if (that.started) {\n      that.started = false;\n    } // Remove listeners\n\n\n    var listener;\n\n    while (listener = listeners.pop()) {\n      listener();\n    }\n\n    $log.info("[usersService] === STOPPED ===");\n    return $q.when();\n  };\n\n  this.onContactUpdatedEvent = function () {\n    $log.info("[usersService] onContactUpdatedEvent");\n    var newRosterList = that.getAllRosterContacts();\n\n    if (newRosterList.length - that.contactsInRoster.length !== 0) {\n      $log.info("[usersService] onContactUpdatedEvent - update all user lists");\n      that.contactsInRoster = newRosterList;\n      that.lastNameList = that.orderContacts("lastname");\n      that.firstNameList = that.orderContacts("firstname");\n      that.companyNameList = that.orderContacts("company");\n      $rootScope.$broadcast("ON_USER_SERVICE_ROSTER_UPDATE_EVENT");\n    }\n  };\n\n  this.getLastNameList = function () {\n    return that.lastNameList;\n  };\n\n  this.getFirstNameList = function () {\n    return that.firstNameList;\n  };\n\n  this.getCompanyNameList = function () {\n    return that.companyNameList;\n  };\n\n  this.getAllRosterContacts = function () {\n    return contactService.getContacts().filter(function (contact) {\n      return contact.displayName && contact.roster;\n    });\n  };\n\n  this.addSeparators = function (users, sortByMember) {\n    var result = [];\n    var label = "";\n    var paramExtractor = null;\n\n    if (sortByMember !== "company") {\n      paramExtractor = function paramExtractor(user) {\n        return user[sortByMember].charAt(0);\n      };\n    } else {\n      paramExtractor = function paramExtractor(user) {\n        return user.company.name;\n      };\n    }\n\n    users.forEach(function (user) {\n      var sortString = paramExtractor(user).toUpperCase().trim().normalize("NFD").replace(/[\\u0300-\\u036f]/g, "");\n\n      if (label !== sortString) {\n        label = sortString;\n        result.push({\n          value: label,\n          type: "separator",\n          id: label\n        });\n      }\n\n      result.push(user);\n    });\n    return result;\n  };\n\n  this.orderContacts = function (criteria) {\n    var orderedUsers = that.getOrderedUsers(that.contactsInRoster, criteria);\n    return that.addSeparators(orderedUsers, criteria);\n  };\n\n  this.getFilterAndOrderUsersGroupedByOrderLabel = function (users, orderType, filterType, isGroup) {\n    isGroup = Boolean(isGroup & true);\n    var listOrderUsers = that.getFilterAndOrderUsers(users, orderType, filterType, isGroup);\n\n    if (orderType === "firstname") {\n      return that.addSeparators(listOrderUsers, "firstname");\n    } else if (orderType === "company") {\n      return that.addSeparators(listOrderUsers, "company");\n    }\n\n    return that.addSeparators(listOrderUsers, "lastname");\n  };\n\n  this.getFilterAndOrderUsersGroupedByOrderLabelAndUpdateActivity = function (users, orderType, filterType, isGroup) {\n    isGroup = Boolean(isGroup & true);\n    var listOrderUsers = that.getFilterAndOrderUsers(users, orderType, filterType, isGroup);\n\n    if (orderType === "firstname") {\n      return that.addSeparators(listOrderUsers, "firstname");\n    } else if (orderType === "company") {\n      return that.addSeparators(listOrderUsers, "company");\n    }\n\n    return that.addSeparators(listOrderUsers, "lastname");\n  };\n\n  this.getFilterAndOrderUsers = function (users, orderType, filterType, isGroup) {\n    var listFilteredUsers = that.getFilteredUsers(users, filterType, isGroup);\n    return that.getOrderedUsers(listFilteredUsers, orderType);\n  };\n\n  this.getFilteredUsers = function (contactList, filter, isGroup) {\n    var contacts = contactList.filter(function (contact) {\n      if (contact.type === "separator") {\n        return true;\n      }\n\n      var isExistingContact = contact.displayName && contact.roster || isGroup;\n      var isContactOnline = contact.status !== "offline" && contact.status !== "wait" && contact.status !== "xa" && contact.status !== "unknown"; //contact.status !== "unknown" && contact.imStatus !== "offline";\n\n      var isContactPending = contact.status === "wait";\n      var isContactTerminated = contact.isTerminated;\n\n      if (filter === "online") {\n        return isExistingContact && isContactOnline;\n      } else if (filter === "offline") {\n        return isExistingContact && !isContactOnline && !isContactTerminated;\n      } else if (filter === "pending") {\n        return isExistingContact && isContactPending;\n      } else if (filter === "all") {\n        return isExistingContact && !isContactTerminated;\n      }\n\n      return isExistingContact;\n    });\n    var contacts = contacts.filter(function (contact, index) {\n      if (contact.type === "separator") {\n        if (!contacts[index + 1] || contacts[index + 1].type === "separator") {\n          return false;\n        }\n      }\n\n      return true;\n    });\n    return contacts;\n  };\n\n  this.getOrderedUsers = function (contactList, orderType) {\n    var contacts = contactList.sort(function (aa, bb) {\n      if (orderType === "lastname") {\n        var sortName = aa.lastname.localeCompare(bb.lastname);\n\n        if (sortName === 0) {\n          return aa.firstname.localeCompare(bb.firstname);\n        }\n\n        return sortName;\n      } else if (orderType === "firstname") {\n        var sortName = aa.firstname.localeCompare(bb.firstname);\n\n        if (sortName === 0) {\n          return aa.lastname.localeCompare(bb.lastname);\n        }\n\n        return sortName;\n      } else if (orderType === "company") {\n        var sortCompany = aa.company.name.localeCompare(bb.company.name);\n\n        if (sortCompany === 0) {\n          return aa.lastname.localeCompare(bb.lastname);\n        }\n\n        return sortCompany;\n      }\n\n      return 0;\n    });\n    return contacts;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/usersService.js?')},function(module,exports){eval('angular.module("rainbow").service("utilService", ["$log", function ($log) {\n  "use strict";\n\n  var defaultDiacriticsRemovalMap = [{\n    "base": "A",\n    "letters": /[\\u0041\\u24B6\\uFF21\\u00C0\\u00C1\\u00C2\\u1EA6\\u1EA4\\u1EAA\\u1EA8\\u00C3\\u0100\\u0102\\u1EB0\\u1EAE\\u1EB4\\u1EB2\\u0226\\u01E0\\u00C4\\u01DE\\u1EA2\\u00C5\\u01FA\\u01CD\\u0200\\u0202\\u1EA0\\u1EAC\\u1EB6\\u1E00\\u0104\\u023A\\u2C6F]/g\n  }, {\n    "base": "AA",\n    "letters": /[\\uA732]/g\n  }, {\n    "base": "AE",\n    "letters": /[\\u00C6\\u01FC\\u01E2]/g\n  }, {\n    "base": "AO",\n    "letters": /[\\uA734]/g\n  }, {\n    "base": "AU",\n    "letters": /[\\uA736]/g\n  }, {\n    "base": "AV",\n    "letters": /[\\uA738\\uA73A]/g\n  }, {\n    "base": "AY",\n    "letters": /[\\uA73C]/g\n  }, {\n    "base": "B",\n    "letters": /[\\u0042\\u24B7\\uFF22\\u1E02\\u1E04\\u1E06\\u0243\\u0182\\u0181]/g\n  }, {\n    "base": "C",\n    "letters": /[\\u0043\\u24B8\\uFF23\\u0106\\u0108\\u010A\\u010C\\u00C7\\u1E08\\u0187\\u023B\\uA73E]/g\n  }, {\n    "base": "D",\n    "letters": /[\\u0044\\u24B9\\uFF24\\u1E0A\\u010E\\u1E0C\\u1E10\\u1E12\\u1E0E\\u0110\\u018B\\u018A\\u0189\\uA779]/g\n  }, {\n    "base": "DZ",\n    "letters": /[\\u01F1\\u01C4]/g\n  }, {\n    "base": "Dz",\n    "letters": /[\\u01F2\\u01C5]/g\n  }, {\n    "base": "E",\n    "letters": /[\\u0045\\u24BA\\uFF25\\u00C8\\u00C9\\u00CA\\u1EC0\\u1EBE\\u1EC4\\u1EC2\\u1EBC\\u0112\\u1E14\\u1E16\\u0114\\u0116\\u00CB\\u1EBA\\u011A\\u0204\\u0206\\u1EB8\\u1EC6\\u0228\\u1E1C\\u0118\\u1E18\\u1E1A\\u0190\\u018E]/g\n  }, {\n    "base": "F",\n    "letters": /[\\u0046\\u24BB\\uFF26\\u1E1E\\u0191\\uA77B]/g\n  }, {\n    "base": "G",\n    "letters": /[\\u0047\\u24BC\\uFF27\\u01F4\\u011C\\u1E20\\u011E\\u0120\\u01E6\\u0122\\u01E4\\u0193\\uA7A0\\uA77D\\uA77E]/g\n  }, {\n    "base": "H",\n    "letters": /[\\u0048\\u24BD\\uFF28\\u0124\\u1E22\\u1E26\\u021E\\u1E24\\u1E28\\u1E2A\\u0126\\u2C67\\u2C75\\uA78D]/g\n  }, {\n    "base": "I",\n    "letters": /[\\u0049\\u24BE\\uFF29\\u00CC\\u00CD\\u00CE\\u0128\\u012A\\u012C\\u0130\\u00CF\\u1E2E\\u1EC8\\u01CF\\u0208\\u020A\\u1ECA\\u012E\\u1E2C\\u0197]/g\n  }, {\n    "base": "J",\n    "letters": /[\\u004A\\u24BF\\uFF2A\\u0134\\u0248]/g\n  }, {\n    "base": "K",\n    "letters": /[\\u004B\\u24C0\\uFF2B\\u1E30\\u01E8\\u1E32\\u0136\\u1E34\\u0198\\u2C69\\uA740\\uA742\\uA744\\uA7A2]/g\n  }, {\n    "base": "L",\n    "letters": /[\\u004C\\u24C1\\uFF2C\\u013F\\u0139\\u013D\\u1E36\\u1E38\\u013B\\u1E3C\\u1E3A\\u0141\\u023D\\u2C62\\u2C60\\uA748\\uA746\\uA780]/g\n  }, {\n    "base": "LJ",\n    "letters": /[\\u01C7]/g\n  }, {\n    "base": "Lj",\n    "letters": /[\\u01C8]/g\n  }, {\n    "base": "M",\n    "letters": /[\\u004D\\u24C2\\uFF2D\\u1E3E\\u1E40\\u1E42\\u2C6E\\u019C]/g\n  }, {\n    "base": "N",\n    "letters": /[\\u004E\\u24C3\\uFF2E\\u01F8\\u0143\\u00D1\\u1E44\\u0147\\u1E46\\u0145\\u1E4A\\u1E48\\u0220\\u019D\\uA790\\uA7A4]/g\n  }, {\n    "base": "NJ",\n    "letters": /[\\u01CA]/g\n  }, {\n    "base": "Nj",\n    "letters": /[\\u01CB]/g\n  }, {\n    "base": "O",\n    "letters": /[\\u004F\\u24C4\\uFF2F\\u00D2\\u00D3\\u00D4\\u1ED2\\u1ED0\\u1ED6\\u1ED4\\u00D5\\u1E4C\\u022C\\u1E4E\\u014C\\u1E50\\u1E52\\u014E\\u022E\\u0230\\u00D6\\u022A\\u1ECE\\u0150\\u01D1\\u020C\\u020E\\u01A0\\u1EDC\\u1EDA\\u1EE0\\u1EDE\\u1EE2\\u1ECC\\u1ED8\\u01EA\\u01EC\\u00D8\\u01FE\\u0186\\u019F\\uA74A\\uA74C]/g\n  }, {\n    "base": "OI",\n    "letters": /[\\u01A2]/g\n  }, {\n    "base": "OO",\n    "letters": /[\\uA74E]/g\n  }, {\n    "base": "OU",\n    "letters": /[\\u0222]/g\n  }, {\n    "base": "P",\n    "letters": /[\\u0050\\u24C5\\uFF30\\u1E54\\u1E56\\u01A4\\u2C63\\uA750\\uA752\\uA754]/g\n  }, {\n    "base": "Q",\n    "letters": /[\\u0051\\u24C6\\uFF31\\uA756\\uA758\\u024A]/g\n  }, {\n    "base": "R",\n    "letters": /[\\u0052\\u24C7\\uFF32\\u0154\\u1E58\\u0158\\u0210\\u0212\\u1E5A\\u1E5C\\u0156\\u1E5E\\u024C\\u2C64\\uA75A\\uA7A6\\uA782]/g\n  }, {\n    "base": "S",\n    "letters": /[\\u0053\\u24C8\\uFF33\\u1E9E\\u015A\\u1E64\\u015C\\u1E60\\u0160\\u1E66\\u1E62\\u1E68\\u0218\\u015E\\u2C7E\\uA7A8\\uA784]/g\n  }, {\n    "base": "T",\n    "letters": /[\\u0054\\u24C9\\uFF34\\u1E6A\\u0164\\u1E6C\\u021A\\u0162\\u1E70\\u1E6E\\u0166\\u01AC\\u01AE\\u023E\\uA786]/g\n  }, {\n    "base": "TZ",\n    "letters": /[\\uA728]/g\n  }, {\n    "base": "U",\n    "letters": /[\\u0055\\u24CA\\uFF35\\u00D9\\u00DA\\u00DB\\u0168\\u1E78\\u016A\\u1E7A\\u016C\\u00DC\\u01DB\\u01D7\\u01D5\\u01D9\\u1EE6\\u016E\\u0170\\u01D3\\u0214\\u0216\\u01AF\\u1EEA\\u1EE8\\u1EEE\\u1EEC\\u1EF0\\u1EE4\\u1E72\\u0172\\u1E76\\u1E74\\u0244]/g\n  }, {\n    "base": "V",\n    "letters": /[\\u0056\\u24CB\\uFF36\\u1E7C\\u1E7E\\u01B2\\uA75E\\u0245]/g\n  }, {\n    "base": "VY",\n    "letters": /[\\uA760]/g\n  }, {\n    "base": "W",\n    "letters": /[\\u0057\\u24CC\\uFF37\\u1E80\\u1E82\\u0174\\u1E86\\u1E84\\u1E88\\u2C72]/g\n  }, {\n    "base": "X",\n    "letters": /[\\u0058\\u24CD\\uFF38\\u1E8A\\u1E8C]/g\n  }, {\n    "base": "Y",\n    "letters": /[\\u0059\\u24CE\\uFF39\\u1EF2\\u00DD\\u0176\\u1EF8\\u0232\\u1E8E\\u0178\\u1EF6\\u1EF4\\u01B3\\u024E\\u1EFE]/g\n  }, {\n    "base": "Z",\n    "letters": /[\\u005A\\u24CF\\uFF3A\\u0179\\u1E90\\u017B\\u017D\\u1E92\\u1E94\\u01B5\\u0224\\u2C7F\\u2C6B\\uA762]/g\n  }, {\n    "base": "a",\n    "letters": /[\\u0061\\u24D0\\uFF41\\u1E9A\\u00E0\\u00E1\\u00E2\\u1EA7\\u1EA5\\u1EAB\\u1EA9\\u00E3\\u0101\\u0103\\u1EB1\\u1EAF\\u1EB5\\u1EB3\\u0227\\u01E1\\u00E4\\u01DF\\u1EA3\\u00E5\\u01FB\\u01CE\\u0201\\u0203\\u1EA1\\u1EAD\\u1EB7\\u1E01\\u0105\\u2C65\\u0250]/g\n  }, {\n    "base": "aa",\n    "letters": /[\\uA733]/g\n  }, {\n    "base": "ae",\n    "letters": /[\\u00E6\\u01FD\\u01E3]/g\n  }, {\n    "base": "ao",\n    "letters": /[\\uA735]/g\n  }, {\n    "base": "au",\n    "letters": /[\\uA737]/g\n  }, {\n    "base": "av",\n    "letters": /[\\uA739\\uA73B]/g\n  }, {\n    "base": "ay",\n    "letters": /[\\uA73D]/g\n  }, {\n    "base": "b",\n    "letters": /[\\u0062\\u24D1\\uFF42\\u1E03\\u1E05\\u1E07\\u0180\\u0183\\u0253]/g\n  }, {\n    "base": "c",\n    "letters": /[\\u0063\\u24D2\\uFF43\\u0107\\u0109\\u010B\\u010D\\u00E7\\u1E09\\u0188\\u023C\\uA73F\\u2184]/g\n  }, {\n    "base": "d",\n    "letters": /[\\u0064\\u24D3\\uFF44\\u1E0B\\u010F\\u1E0D\\u1E11\\u1E13\\u1E0F\\u0111\\u018C\\u0256\\u0257\\uA77A]/g\n  }, {\n    "base": "dz",\n    "letters": /[\\u01F3\\u01C6]/g\n  }, {\n    "base": "e",\n    "letters": /[\\u0065\\u24D4\\uFF45\\u00E8\\u00E9\\u00EA\\u1EC1\\u1EBF\\u1EC5\\u1EC3\\u1EBD\\u0113\\u1E15\\u1E17\\u0115\\u0117\\u00EB\\u1EBB\\u011B\\u0205\\u0207\\u1EB9\\u1EC7\\u0229\\u1E1D\\u0119\\u1E19\\u1E1B\\u0247\\u025B\\u01DD]/g\n  }, {\n    "base": "f",\n    "letters": /[\\u0066\\u24D5\\uFF46\\u1E1F\\u0192\\uA77C]/g\n  }, {\n    "base": "g",\n    "letters": /[\\u0067\\u24D6\\uFF47\\u01F5\\u011D\\u1E21\\u011F\\u0121\\u01E7\\u0123\\u01E5\\u0260\\uA7A1\\u1D79\\uA77F]/g\n  }, {\n    "base": "h",\n    "letters": /[\\u0068\\u24D7\\uFF48\\u0125\\u1E23\\u1E27\\u021F\\u1E25\\u1E29\\u1E2B\\u1E96\\u0127\\u2C68\\u2C76\\u0265]/g\n  }, {\n    "base": "hv",\n    "letters": /[\\u0195]/g\n  }, {\n    "base": "i",\n    "letters": /[\\u0069\\u24D8\\uFF49\\u00EC\\u00ED\\u00EE\\u0129\\u012B\\u012D\\u00EF\\u1E2F\\u1EC9\\u01D0\\u0209\\u020B\\u1ECB\\u012F\\u1E2D\\u0268\\u0131]/g\n  }, {\n    "base": "j",\n    "letters": /[\\u006A\\u24D9\\uFF4A\\u0135\\u01F0\\u0249]/g\n  }, {\n    "base": "k",\n    "letters": /[\\u006B\\u24DA\\uFF4B\\u1E31\\u01E9\\u1E33\\u0137\\u1E35\\u0199\\u2C6A\\uA741\\uA743\\uA745\\uA7A3]/g\n  }, {\n    "base": "l",\n    "letters": /[\\u006C\\u24DB\\uFF4C\\u0140\\u013A\\u013E\\u1E37\\u1E39\\u013C\\u1E3D\\u1E3B\\u017F\\u0142\\u019A\\u026B\\u2C61\\uA749\\uA781\\uA747]/g\n  }, {\n    "base": "lj",\n    "letters": /[\\u01C9]/g\n  }, {\n    "base": "m",\n    "letters": /[\\u006D\\u24DC\\uFF4D\\u1E3F\\u1E41\\u1E43\\u0271\\u026F]/g\n  }, {\n    "base": "n",\n    "letters": /[\\u006E\\u24DD\\uFF4E\\u01F9\\u0144\\u00F1\\u1E45\\u0148\\u1E47\\u0146\\u1E4B\\u1E49\\u019E\\u0272\\u0149\\uA791\\uA7A5]/g\n  }, {\n    "base": "nj",\n    "letters": /[\\u01CC]/g\n  }, {\n    "base": "o",\n    "letters": /[\\u006F\\u24DE\\uFF4F\\u00F2\\u00F3\\u00F4\\u1ED3\\u1ED1\\u1ED7\\u1ED5\\u00F5\\u1E4D\\u022D\\u1E4F\\u014D\\u1E51\\u1E53\\u014F\\u022F\\u0231\\u00F6\\u022B\\u1ECF\\u0151\\u01D2\\u020D\\u020F\\u01A1\\u1EDD\\u1EDB\\u1EE1\\u1EDF\\u1EE3\\u1ECD\\u1ED9\\u01EB\\u01ED\\u00F8\\u01FF\\u0254\\uA74B\\uA74D\\u0275]/g\n  }, {\n    "base": "oi",\n    "letters": /[\\u01A3]/g\n  }, {\n    "base": "ou",\n    "letters": /[\\u0223]/g\n  }, {\n    "base": "oo",\n    "letters": /[\\uA74F]/g\n  }, {\n    "base": "p",\n    "letters": /[\\u0070\\u24DF\\uFF50\\u1E55\\u1E57\\u01A5\\u1D7D\\uA751\\uA753\\uA755]/g\n  }, {\n    "base": "q",\n    "letters": /[\\u0071\\u24E0\\uFF51\\u024B\\uA757\\uA759]/g\n  }, {\n    "base": "r",\n    "letters": /[\\u0072\\u24E1\\uFF52\\u0155\\u1E59\\u0159\\u0211\\u0213\\u1E5B\\u1E5D\\u0157\\u1E5F\\u024D\\u027D\\uA75B\\uA7A7\\uA783]/g\n  }, {\n    "base": "s",\n    "letters": /[\\u0073\\u24E2\\uFF53\\u00DF\\u015B\\u1E65\\u015D\\u1E61\\u0161\\u1E67\\u1E63\\u1E69\\u0219\\u015F\\u023F\\uA7A9\\uA785\\u1E9B]/g\n  }, {\n    "base": "t",\n    "letters": /[\\u0074\\u24E3\\uFF54\\u1E6B\\u1E97\\u0165\\u1E6D\\u021B\\u0163\\u1E71\\u1E6F\\u0167\\u01AD\\u0288\\u2C66\\uA787]/g\n  }, {\n    "base": "tz",\n    "letters": /[\\uA729]/g\n  }, {\n    "base": "u",\n    "letters": /[\\u0075\\u24E4\\uFF55\\u00F9\\u00FA\\u00FB\\u0169\\u1E79\\u016B\\u1E7B\\u016D\\u00FC\\u01DC\\u01D8\\u01D6\\u01DA\\u1EE7\\u016F\\u0171\\u01D4\\u0215\\u0217\\u01B0\\u1EEB\\u1EE9\\u1EEF\\u1EED\\u1EF1\\u1EE5\\u1E73\\u0173\\u1E77\\u1E75\\u0289]/g\n  }, {\n    "base": "v",\n    "letters": /[\\u0076\\u24E5\\uFF56\\u1E7D\\u1E7F\\u028B\\uA75F\\u028C]/g\n  }, {\n    "base": "vy",\n    "letters": /[\\uA761]/g\n  }, {\n    "base": "w",\n    "letters": /[\\u0077\\u24E6\\uFF57\\u1E81\\u1E83\\u0175\\u1E87\\u1E85\\u1E98\\u1E89\\u2C73]/g\n  }, {\n    "base": "x",\n    "letters": /[\\u0078\\u24E7\\uFF58\\u1E8B\\u1E8D]/g\n  }, {\n    "base": "y",\n    "letters": /[\\u0079\\u24E8\\uFF59\\u1EF3\\u00FD\\u0177\\u1EF9\\u0233\\u1E8F\\u00FF\\u1EF7\\u1E99\\u1EF5\\u01B4\\u024F\\u1EFF]/g\n  }, {\n    "base": "z",\n    "letters": /[\\u007A\\u24E9\\uFF5A\\u017A\\u1E91\\u017C\\u017E\\u1E93\\u1E95\\u01B6\\u0225\\u0240\\u2C6C\\uA763]/g\n  }];\n\n  this.removeDiacritis = function (str) {\n    for (var i = 0; i < defaultDiacriticsRemovalMap.length; i++) {\n      str = str.replace(defaultDiacriticsRemovalMap[i].letters, defaultDiacriticsRemovalMap[i].base);\n    }\n\n    return str;\n  };\n\n  this.escapeHtml = function (unsafe) {\n    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/\'/g, "&#039;");\n  };\n\n  this.extractHtmlContent = function extractHtmlContent(html) {\n    var parser = new DOMParser();\n    var content = "{}";\n\n    try {\n      content = parser.parseFromString(html, "text/html").documentElement.textContent;\n    } catch (e) {\n      $log.error("[utilService] error in extractHtmlContent:", e);\n      content = "{}";\n    }\n\n    return content;\n  };\n\n  this.sortAlphaNum = function (nameA, nameB) {\n    var reA = /[^a-zA-Z]/g;\n    var reN = /[^0-9]/g;\n    var aA = nameA.replace(reA, "");\n    var bA = nameB.replace(reA, "");\n\n    if (aA === bA) {\n      var aN = parseInt(nameA.replace(reN, ""), 10);\n      var bN = parseInt(nameB.replace(reN, ""), 10);\n      return aN === bN ? 0 : aN > bN ? 1 : -1;\n    }\n\n    return aA > bA ? 1 : -1;\n  };\n\n  this.anonymizePhoneNumber = function (number) {\n    if (number === null || typeof number === "undefined") {\n      return null;\n    }\n\n    if (config && config.debug) {\n      return number;\n    }\n\n    var result = "";\n\n    if (number.indexOf("+") === 0) {\n      result = "+";\n    }\n\n    if (number.length > 4) {\n      result = result + "*".repeat(number.length - 4 - result.length) + number.slice(number.length - 4);\n    } else {\n      result = number;\n    }\n\n    return result;\n  };\n\n  this.anonymizeString = function (inputString) {\n    if (inputString === null || typeof inputString === "undefined") {\n      return null;\n    }\n\n    if (config && config.debug) {\n      return inputString;\n    }\n\n    var result = "";\n\n    if (inputString.length > 4) {\n      result = result + "*".repeat(inputString.length - 4 - result.length) + inputString.slice(inputString.length - 4);\n    } else {\n      result = inputString;\n    }\n\n    return result;\n  };\n\n  this.bytesToSize = function (bytes) {\n    var sizes = [\'Bytes\', \'KB\', \'MB\', \'GB\', \'TB\'];\n    if (bytes == 0) return \'0 Byte\';\n    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));\n    return Math.round(bytes / Math.pow(1024, i), 2) + \' \' + sizes[i];\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/utilService.js?')},function(module,exports){eval("\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/serviceInterface.ts?")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @ngdoc service\n * @module rainbow\n * @name FileServerService\n * @requires $q\n * @requires $http\n * @requires $log\n * @requires authService\n * @requires errorHelperService\n * @requires $rootScope\n * @description Rainbow FileServerService provides interface request services from server\n */\nObject.defineProperty(exports, "__esModule", { value: true });\nconst crypto_js_1 = __webpack_require__(2);\nconst crypto_js_2 = __webpack_require__(2);\nclass LocalImage {\n    release() { URL.revokeObjectURL(this.url); }\n    constructor(fd, blob) {\n        if (blob) {\n            this.url = URL.createObjectURL(blob);\n        }\n        this.fd = fd;\n    }\n}\nclass Capabilities {\n}\nclass FileServerService {\n    constructor($q, $http, $log, authService, fileStorageService, TransfertPromiseQueue, FileDescriptorEventHandler, xmppService, errorHelperService, $rootScope, $interval) {\n        this.$q = $q;\n        this.$http = $http;\n        this.$log = $log;\n        this.authService = authService;\n        this.fileStorageService = fileStorageService;\n        this.TransfertPromiseQueue = TransfertPromiseQueue;\n        this.FileDescriptorEventHandler = FileDescriptorEventHandler;\n        this.xmppService = xmppService;\n        this.errorHelperService = errorHelperService;\n        this.$rootScope = $rootScope;\n        this.$interval = $interval;\n        this.ONE_KILOBYTE = 1024;\n        this.ONE_MEGABYTE = 1024 * 1024;\n        this.ONE_GIGABYTE = 1024 * 1024 * 1024;\n        this.started = false;\n        this.thumbnailPromises = [];\n    }\n    start(stats) {\n        this.$log.info("[FileServerService] === STARTING ===");\n        let startDate = performance.now();\n        this.started = false;\n        this.portalURL = config.restServerUrl + "/api/rainbow/fileserver/v1.0/files";\n        this.getServercapabilities()\n            .then(() => {\n            // Register to xmpp and call events\n            this.attachHandlers();\n            // Create the transfertPromiseQueue\n            this.transfertPromiseQueue = this.TransfertPromiseQueue.create();\n            var startDuration = Math.round(performance.now() - startDate);\n            stats.push({ service: "FileServerService", startDuration: startDuration });\n            this.$log.info("[FileServerService] === STARTED (" + startDuration + " ms) ===");\n        })\n            .catch((error) => {\n            this.$log.error("[FileServerService] === STARTING FAILURE === " + error.message);\n        });\n        return this.$q.when();\n    }\n    stop() {\n        this.$log.info("[FileServerService] === STOPPING ===");\n        if (this.started) {\n            this.started = false;\n        }\n        this.$log.info("[FileServerService] === STOPPED ===");\n        return this.$q.when();\n    }\n    attachHandlers() {\n        this.removeHandlers();\n        this.fileDescriptorEventHandler = this.FileDescriptorEventHandler.create(this);\n        if (!this.fileMessageHandlerRef) {\n            this.fileMessageHandlerRef = this.xmppService.addHandler((stanza) => {\n                this.$interval(() => {\n                    this.fileDescriptorEventHandler.onManagementMessageReceived(stanza);\n                }, 250, 1);\n                return true;\n            }, null, "message", "management");\n        }\n    }\n    ;\n    removeHandlers() {\n        //remove fileDescriptor handler\n        this.fileDescriptorEventHandler = undefined;\n        this.fileMessageHandlerRef = undefined;\n    }\n    /******************************************************************/\n    /** PUBLIC METHODS                                               **/\n    /******************************************************************/\n    getLocalImage(fileDescriptorId, thumbnail, forced = true) {\n        return this.$q((resolve, reject) => {\n            // Get the filedescriptor\n            let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileDescriptorId);\n            let fileDescriptorGetter = fileDescriptor ? this.$q.resolve(fileDescriptor) : this.fileStorageService.retrieveAndStoreOneFileDescriptor(fileDescriptorId);\n            fileDescriptorGetter\n                .then((aFileDescriptor) => {\n                // Determine fileLoader\n                let fileLoader = null;\n                if (thumbnail && aFileDescriptor.previewBlob && !forced) {\n                    fileLoader = this.$q.resolve(aFileDescriptor.previewBlob);\n                }\n                else if (thumbnail) {\n                    fileLoader = this.getLargeBlobThumbnail(aFileDescriptor);\n                }\n                else {\n                    fileLoader = this.getBlobFromFileDescriptor(aFileDescriptor, false, null);\n                }\n                // Get file  \n                fileLoader.then((blob) => { resolve(new LocalImage(aFileDescriptor, blob)); });\n            })\n                .catch((error) => {\n                let localFile = new LocalImage(null, null);\n                localFile.url = "/resources/skins/rainbow/images/wizard/chrome.png";\n                this.$log.error(`[fileServerService] getFileLocalURL -- no file descriptor found with ${fileDescriptorId} + " id.`);\n                resolve(null);\n            });\n        });\n    }\n    getLargeBlobThumbnail(fileDescriptor) {\n        let url = fileDescriptor.url + "?thumbnail500=true";\n        return this.getBlobFromUrl(url, fileDescriptor.typeMIME, fileDescriptor.size, fileDescriptor.fileName);\n    }\n    /**\n     * Method retrieve data from server using range request mecanism (RFC7233)\n     *\n     * @private\n     * @param {string} url [required] server url for request\n     * @param {number} minRange [requied] minimum value of range\n     * @param {number} maxRange [required] maximum value of range\n     * @param {number} index [required] index of the part. Used to re-assemble the data\n     * @returns {ng.IPromise<{}>} structure containing the response data from server and the index\n     *\n     * @memberof FileServerService\n     */\n    getPartialDataFromServer(url, minRange, maxRange, index) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: url,\n                headers: this.authService.getRequestHeaderWithRange("bytes=" + minRange + "-" + maxRange),\n                responseType: \'arraybuffer\'\n            }).then((response) => {\n                resolve({ data: response.data, index: index });\n            }, (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\n                let translatedErrorMessage = this.errorHelperService.getLocalizedError(errorDataObj.errorDetailsCode);\n                this.$log.error( true ? translatedErrorMessage : undefined);\n                reject(error);\n            });\n        });\n    }\n    // In order to avoid cyclic dependancy\n    getFileStorageService() {\n        return this.fileStorageService;\n    }\n    getBlobThumbnailFromFileDescriptor(fileDescriptor, large = false) {\n        if (fileDescriptor.thumbnail.isThumbnailAvailable() ||\n            (fileDescriptor.isImage() && fileDescriptor.size < (20 * this.ONE_KILOBYTE))) {\n            // Check if a request for this thumbnail is already lauched\n            var existingPromise = this.thumbnailPromises[fileDescriptor.id];\n            if (existingPromise) {\n                this.$log.info("[FileServerService] getBlobThumbnailFromFileDescriptor " + fileDescriptor.id + " already lauched");\n                return existingPromise.promise;\n            }\n            // Create the defered object\n            var defered = this.$q.defer();\n            this.thumbnailPromises[fileDescriptor.id] = defered;\n            // Forge the thumbnail url\n            let url = fileDescriptor.url;\n            if (fileDescriptor.thumbnail.isThumbnailAvailable() && fileDescriptor.size >= (20 * this.ONE_KILOBYTE)) {\n                if (large) {\n                    url += "?thumbnail500=true";\n                }\n                else {\n                    url += "?thumbnail500=true";\n                }\n            }\n            else if (fileDescriptor.uploadedDate) {\n                url += "?update=" + crypto_js_1.MD5(crypto_js_2.enc.Latin1.parse(fileDescriptor.uploadedDate)).toString(crypto_js_2.enc.Hex);\n            }\n            // Get the thumbnail blob\n            this.getBlobFromUrl(url, fileDescriptor.typeMIME, fileDescriptor.size, fileDescriptor.fileName)\n                .then((blob) => {\n                fileDescriptor.previewBlob = blob;\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                    result: "success", type: "download",\n                    fileDesc: fileDescriptor\n                });\n                delete this.thumbnailPromises[fileDescriptor.id];\n                defered.resolve(blob);\n            })\n                .catch((error) => {\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                    result: "failure", type: "download", message: error.message,\n                    fileDesc: fileDescriptor\n                });\n                delete this.thumbnailPromises[fileDescriptor.id];\n                defered.reject(error);\n            });\n            return defered.promise;\n        }\n        else {\n            return this.$q.reject();\n        }\n    }\n    ;\n    /**\n     * Method creates blob from a file retrieved from server using optimization (range request) whenever necessary\n     *\n     * @param {IFileDescriptor} fd [required] the file descriptor\n     * @returns {ng.IPromise<Blob>} Blob created from data received from server\n     *\n     * @memberof FileServerService\n     */\n    getBlobFromFileDescriptor(fd, cancelable = true, actionOnPartialResponse) {\n        if (!fd) {\n            this.$log.warn("[FileServerService] getBlobFromFileDescriptor : missing file descriptor");\n            return this.$q.reject();\n        }\n        this.$log.info("[FileServerService] getBlobFromFileDescriptor: " + fd.id);\n        if (fd.state !== "uploaded") {\n            this.$log.warn("[FileServerService] getBlobFromFileDescriptor : file is not in uploaded state=" + fd.state);\n            return this.$q.reject();\n        }\n        let url = fd.url;\n        if (fd.uploadedDate) {\n            url += "?update=" + crypto_js_1.MD5(crypto_js_2.enc.Latin1.parse(fd.uploadedDate)).toString(crypto_js_2.enc.Hex);\n        }\n        let range = this.ONE_MEGABYTE;\n        if (!!this.capabilities.maxChunkSizeDownload && fd.size !== 0 && fd.size > range) {\n            if (fd.size >= 100 * range) {\n                range = (fd.size / 100) + this.ONE_KILOBYTE;\n                this.$log.debug("[FileServerService] changing chunk size: " + range);\n            }\n            var defered = this.$q.defer();\n            let blobArray = new Array();\n            let promiseArray = [];\n            fd.state = "downloading";\n            fd.chunkTotalNumber = Math.ceil(fd.size / range);\n            fd.chunkPerformed = 0;\n            fd.chunkPerformedPercent = 0;\n            this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { type: "download", fileDesc: fd, cancelable: cancelable });\n            this.$log.info("[FileServerService] getBlobFromFileDescriptor: need to download " + fd.chunkTotalNumber + " chunks");\n            for (let i = 0, minRange = 0, maxRange = range - 1, repetition = Math.ceil(fd.size / range); repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\n                maxRange = (maxRange < fd.size) ? maxRange : fd.size;\n                promiseArray.push(() => {\n                    var promiseArrayDeferred = this.$q.defer();\n                    this.getPartialDataFromServer(url, minRange, maxRange, i)\n                        .then((response) => {\n                        fd.chunkPerformed++;\n                        fd.chunkPerformedPercent = 100 * fd.chunkPerformed / fd.chunkTotalNumber;\n                        this.$log.info("[FileServerService] getBlobFromFileDescriptor : chunk downloaded=" + fd.chunkPerformed);\n                        blobArray[response[\'index\']] = response[\'data\'];\n                        this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { type: "download", fileDesc: fd, cancelable: cancelable });\n                        if (actionOnPartialResponse) {\n                            return actionOnPartialResponse(response, fd.id).then(() => {\n                                return promiseArrayDeferred.resolve(response[\'data\']);\n                            });\n                        }\n                        return promiseArrayDeferred.resolve(response);\n                    })\n                        .catch((error) => {\n                        this.$log.info("[FileServerService] error on chunk download=" + error);\n                        promiseArrayDeferred.reject(error);\n                    });\n                    return promiseArrayDeferred.promise;\n                });\n            }\n            var promisesCompletion = () => {\n                let blob = new Blob(blobArray, { type: fd.typeMIME });\n                this.$log.info("[FileServerService] getBlobFromFileDescriptor success");\n                fd.state = "uploaded";\n                fd.chunkPerformed = 0;\n                fd.chunkTotalNumber = 0;\n                fd.chunkPerformedPercent = 0;\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { type: "download", fileDesc: fd });\n                defered.resolve(blob);\n            };\n            var promisesReject = (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                fd.state = "uploaded";\n                fd.chunkPerformed = 0;\n                fd.chunkTotalNumber = 0;\n                fd.chunkPerformedPercent = 0;\n                let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\n                let translatedErrorMessage = this.errorHelperService.getLocalizedError(errorDataObj.errorDetailsCode);\n                this.$log.error( true ? translatedErrorMessage : undefined);\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                    result: "failure",\n                    type: "download",\n                    message: translatedErrorMessage ? translatedErrorMessage : error.message,\n                    fileDesc: fd\n                });\n                defered.reject(error);\n            };\n            this.transfertPromiseQueue.addPromiseArray(fd.id, promiseArray, promisesCompletion, promisesReject);\n            return defered.promise;\n        }\n        else {\n            fd.state = "downloading";\n            fd.chunkTotalNumber = 1;\n            fd.chunkPerformed = 0;\n            fd.chunkPerformedPercent = 0;\n            this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { fileDesc: fd, cancelable: false });\n            return this.getBlobFromUrl(url, fd.typeMIME, fd.size, fd.fileName).then((blob) => {\n                fd.state = "uploaded";\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { fileDesc: fd });\n                return this.$q.resolve(blob);\n            }).catch((error) => {\n                fd.state = "uploaded";\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { fileDesc: fd });\n                this.$log.info("[FileServerService] arrayPromise : error " + error.message);\n                return this.$q.reject(error);\n            });\n        }\n    }\n    /**\n     * Method creates blob from a file retrieved from server\n     *\n     * @private\n     * @param {string} url [required] server url for request\n     * @param {string} mime [required] Mime type of the blob to be created\n     * @param {number} fileSize [required] size of file to be retrieved\n     * @param {string} fileName [required] name of file to be downloaded\n     * @returns {ng.IPromise<Blob>} Blob created from data received from server\n     *\n     * @memberof FileServerService\n     */\n    getBlobFromUrl(url, mime, fileSize, fileName) {\n        this.$log.debug("[FileServerService] >getBlobFromUrl: " + url);\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: url,\n                headers: this.authService.getRequestHeader(),\n                responseType: \'arraybuffer\'\n            }).then((response) => {\n                let blob = new Blob([response.data], { type: mime });\n                this.$log.debug("[FileServerService] getBlobFromUrl success");\n                resolve(blob);\n            }, (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                //let translatedErrorMessage = null;\n                //if (errorResponse.data) {\n                //    let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\n                //let translatedErrorMessage = this.errorHelperService.getLocalizedError(error.errorDetailsCode);\n                //}\n                this.$log.error("[FileServerService] " + error.translatedMessage);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method retrieves an URL object from an url\n     *\n     * @param {string} id [required] the ID of the image file\n     * @returns {ng.IPromise<Object>} Object containing the orientation and the Object URL\n     *\n     * @memberof FileServerService\n     */\n    getBlobUrlAndOrientationByFileDescriptorId(id) {\n        return this.$q((resolve, reject) => {\n            let fileDescriptor = this.fileStorageService.getFileDescriptorById(id);\n            if (fileDescriptor) {\n                this.getBlobFromFileDescriptor(fileDescriptor, false, null)\n                    .then((blob) => {\n                    let result = {};\n                    result["blobUrl"] = URL.createObjectURL(blob);\n                    result["id"] = id;\n                    //if we\'ve already calculated the orientation\n                    if (fileDescriptor.orientation) {\n                        result["orientation"] = fileDescriptor.orientation;\n                        resolve(result);\n                        return;\n                    }\n                    //should calculate the orientation\n                    else {\n                        this.setImageOrientationForFileDescriptor(fileDescriptor, blob)\n                            .then((orientation) => {\n                            result["orientation"] = orientation;\n                            resolve(result);\n                        })\n                            .catch(() => {\n                            //resolve without the orientation\n                            resolve(result);\n                        });\n                    }\n                })\n                    .catch((error) => {\n                    reject(error);\n                });\n            }\n            else {\n                this.$log.error("[FileServerService] getBlobUrlAndOrientationById no file descriptor found for ID " + id);\n                reject(new Error("[FileServerService] getBlobUrlAndOrientationById no file descriptor found"));\n            }\n        });\n    }\n    /**\n     * Method to read EXIF data for image to extract the orientation and store it\n     *\n     * @param {<fileDescriptor>}: The file descriptor object\n     * @param {<Blob>}: Blob Object of the image\n     * @returns {ng.IPromise<{}>}: return the orientation value if available\n     */\n    setImageOrientationForFileDescriptor(fileDescriptor, blob) {\n        return this.$q((resolve, reject) => {\n            if (!fileDescriptor || !fileDescriptor.isImage()) {\n                reject();\n                return;\n            }\n            var reader = new FileReader();\n            reader.onload = (e) => {\n                fileDescriptor.orientation = 1;\n                var arrayBuffer = e.target.result;\n                var view = new DataView(arrayBuffer);\n                //var view = new DataView(reader.result);\n                if (view.getUint16(0, false) !== 0xFFD8) {\n                    reject();\n                    return;\n                }\n                var length = view.byteLength;\n                var offset = 2;\n                while (offset < length) {\n                    if (view.getUint16(offset + 2, false) <= 8) {\n                        reject();\n                        return;\n                    }\n                    var marker = view.getUint16(offset, false);\n                    offset += 2;\n                    if (marker === 0xFFE1) {\n                        if (view.getUint32(offset += 2, false) !== 0x45786966) {\n                            reject();\n                            return;\n                        }\n                        var little = view.getUint16(offset += 6, false) === 0x4949;\n                        offset += view.getUint32(offset + 4, little);\n                        var tags = view.getUint16(offset, little);\n                        offset += 2;\n                        for (var i = 0; i < tags; i++) {\n                            if (view.getUint16(offset + (i * 12), little) === 0x0112) {\n                                var orientation = view.getUint16(offset + (i * 12) + 8, little);\n                                fileDescriptor.orientation = orientation;\n                                resolve(orientation);\n                                return;\n                            }\n                        }\n                    }\n                    else if ((marker & 0xFF00) !== 0xFF00) {\n                        break;\n                    }\n                    else {\n                        offset += view.getUint16(offset, false);\n                    }\n                }\n                reject();\n                return;\n            };\n            reader.readAsArrayBuffer(blob);\n        });\n    }\n    /**\n     * Method sends data file to server\n     *\n     * @private\n     * @param {string} fileId [required] file descriptor ID of file to be sent\n     * @param {File} file [required] file to be sent\n     * @param {string} mime [required] mime type of file\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor data received as response from server or http error response\n     *\n     * @memberof FileServerService\n     */\n    uploadAFile(fileId, file, mime) {\n        return this.$q((resolve, reject) => {\n            let fileDescriptor = this.fileStorageService.getFileDescriptorById(fileId);\n            if (fileDescriptor) {\n                fileDescriptor.state = "uploading";\n            }\n            this.$http({\n                method: "PUT",\n                url: this.portalURL + "/" + fileId,\n                headers: this.authService.getPostHeader("application/octet-stream"),\n                data: file,\n                uploadEventHandlers: {\n                    progress: (e) => {\n                        this.$log.log(e);\n                    }\n                }\n            }).then((response) => {\n                //let fileDescResponse = response.data.data;\n                let newFileDescriptor = this.fileStorageService.getFileDescriptorById(fileId);\n                if (newFileDescriptor) {\n                    newFileDescriptor.state = "uploaded";\n                }\n                this.$log.info("[FileServerService] uploadAFile success");\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                    result: "success",\n                    type: "upload",\n                    fileDesc: newFileDescriptor\n                });\n                this.fileStorageService.orderDocuments();\n                resolve(newFileDescriptor);\n            }, (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                    result: "failure",\n                    type: "upload",\n                    fileDesc: fileDescriptor\n                });\n                reject(error);\n                this.$log.error("[FileServerService] " + error.message);\n            });\n        });\n    }\n    /**\n     * Method sends data to server using range request mecanism (RFC7233)\n     *\n     * @private\n     * @param {string} fileId [required] file descriptor ID of file to be sent\n     * @param {Blob} file [required] file to be sent\n     * @param {number} initialSize [required] initial size of whole file to be sent before partition\n     * @param {number} minRange [requied] minimum value of range\n     * @param {number} maxRange [required] maximum value of range\n     * @param {number} index [required] index of the part. Used to indicate the part number to the server\n     * @returns {ng.IPromise<{}>} file descriptor data received as response from server or http error response\n     *\n     * @memberof FileServerService\n     */\n    sendPartialDataToServer(fileId, filePart, initialSize, minRange, maxRange, index) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "PUT",\n                url: this.portalURL + "/" + fileId + "/parts/" + index,\n                headers: this.authService.getPostHeaderWithRange("bytes " + minRange + "-" + maxRange + "/" + initialSize, "application/octet-stream"),\n                data: filePart,\n                uploadEventHandlers: {\n                    progress: (e) => {\n                        this.$log.log(e);\n                    }\n                }\n            }).then((response) => {\n                let chunkResponse = response.data.data;\n                this.$log.info("[FileServerService] sendPartialDataToServer success");\n                resolve(chunkResponse);\n            }, (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                reject(error);\n                this.$log.error("[FileServerService] " + error.message);\n            });\n        });\n    }\n    calculateMd5(blob, callback) {\n        var reader = new FileReader();\n        reader.readAsBinaryString(blob);\n        reader.onloadend = () => { callback(crypto_js_1.MD5(crypto_js_2.enc.Latin1.parse(reader.result)).toString(crypto_js_2.enc.Hex)); };\n    }\n    /**\n     * Method divide a given file in multiple parts using range request mecanism (RFC7233) whenever necessary to send it to server\n     *\n     * @param {IFileDescriptor} fileDescriptor [required] file descriptor ID of file to be sent\n     * @param {File} file [required] file to be sent\n     * @param {object} message [required] message of cell\n     * @param {function} progressCallBack [required] function return (message, fileDescriptor)\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor of file uploaded sucessfully or error\n     *\n     * @memberof FileServerService\n     */\n    uploadAFileByChunk(fileDescriptor, file, message, progressCallback) {\n        this.$log.info("[FileServerService] >uploadAFileByChunk");\n        let range = this.ONE_MEGABYTE;\n        if (range < file.size) {\n            if (file.size >= 100 * range) {\n                range = Math.round((file.size / 100) + this.ONE_KILOBYTE);\n                this.$log.debug("[FileServerService] changing chunk size: " + range);\n            }\n            var defered = this.$q.defer();\n            // let minRange = 0;\n            // let maxRange = range - 1;\n            // let repetition = Math.ceil(file.size / range);\n            fileDescriptor.chunkTotalNumber = Math.ceil(file.size / range);\n            fileDescriptor.chunkPerformed = 0;\n            fileDescriptor.chunkPerformedPercent = 0;\n            fileDescriptor.state = "uploading";\n            this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { fileDesc: fileDescriptor, cancelable: true });\n            let promiseArray = [];\n            for (let i = 0, minRange = 0, maxRange = range - 1, repetition = Math.ceil(file.size / range); repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\n                let max = maxRange < file.size ? maxRange : file.size;\n                let blob = file.slice(minRange, max + 1);\n                promiseArray.push(() => {\n                    var promiseArrayDeferred = this.$q.defer();\n                    this.calculateMd5(blob, (blobChecksum) => {\n                        this.$log.info("[FileServerService] sendPartialDataToServer calculated checksum=" + blobChecksum);\n                        this.sendPartialDataToServer(fileDescriptor.id, blob, file.size, minRange, max, i)\n                            .then((response) => {\n                            this.$log.info("[FileServerService] sendPartialDataToServer md5sum=" + response["md5sum"]);\n                            if (response["md5sum"].localeCompare(blobChecksum)) {\n                                this.$log.error("[FileServerService] Wrong Checksum for chunk detected: " + response["md5sum"] + "/" + blobChecksum);\n                                var error = { errorDetailsCode: 500, message: "Wrong Checksum for chunk" };\n                                promiseArrayDeferred.reject(error);\n                            }\n                            else {\n                                fileDescriptor.chunkPerformed++;\n                                fileDescriptor.chunkPerformedPercent = 100 * fileDescriptor.chunkPerformed / fileDescriptor.chunkTotalNumber;\n                                if (progressCallback) {\n                                    progressCallback(message, fileDescriptor);\n                                }\n                                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", { fileDesc: fileDescriptor, cancelable: true });\n                                return promiseArrayDeferred.resolve(response);\n                            }\n                        })\n                            .catch((error) => {\n                            this.$log.info("[FileServerService] error on chunk upload=" + error);\n                            promiseArrayDeferred.reject(error);\n                        });\n                    });\n                    return promiseArrayDeferred.promise;\n                });\n            }\n            var promisesCompletion = () => {\n                this.$http({\n                    method: "PUT",\n                    url: this.portalURL + "/" + fileDescriptor.id + "/parts/end",\n                    headers: this.authService.getPostHeader("application/octet-stream"),\n                    uploadEventHandlers: {\n                        progress: (e) => {\n                            this.$log.log(e);\n                        }\n                    }\n                }).then((response) => {\n                    this.$log.info("[FileServerService] uploadAFileByChunk success");\n                    fileDescriptor.state = "uploaded";\n                    fileDescriptor.chunkPerformed = 0;\n                    fileDescriptor.chunkTotalNumber = 0;\n                    fileDescriptor.chunkPerformedPercent = 0;\n                    if (progressCallback) {\n                        progressCallback(message, fileDescriptor);\n                    }\n                    this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                        result: "success",\n                        type: "upload",\n                        fileDesc: fileDescriptor\n                    });\n                    this.fileStorageService.orderDocuments();\n                    this.fileStorageService.retrieveUserConsumption();\n                    defered.resolve(fileDescriptor);\n                }, (errorResponse) => {\n                    let error = this.errorHelperService.handleError(errorResponse);\n                    this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                        result: "failure",\n                        type: "upload",\n                        fileDesc: fileDescriptor\n                    });\n                    defered.reject(error);\n                });\n            };\n            var promisesReject = (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                this.$rootScope.$broadcast("ON_FILE_TRANSFER_EVENT", {\n                    result: "failure",\n                    type: "upload",\n                    fileDesc: fileDescriptor\n                });\n                defered.reject(error);\n            };\n            this.transfertPromiseQueue.addPromiseArray(fileDescriptor.id, promiseArray, promisesCompletion, promisesReject);\n            return defered.promise;\n        }\n        else {\n            // Fallback if capabilities retrieval fails or file is small enough to upload the whole file in one go\n            if (progressCallback) {\n                progressCallback(message, fileDescriptor);\n            }\n            return this.uploadAFile(fileDescriptor.id, file, fileDescriptor.typeMIME)\n                .then((response) => {\n                this.$log.info("[FileServerService] uploadAFile success");\n                if (progressCallback) {\n                    progressCallback(message, fileDescriptor);\n                }\n                this.fileStorageService.retrieveUserConsumption();\n                return this.$q.resolve(fileDescriptor);\n            });\n        }\n    }\n    isTransferInProgress() {\n        return this.transfertPromiseQueue.isTransferInProgress();\n    }\n    cancelAllTransfers() {\n        this.transfertPromiseQueue.cancelAllTransfers();\n    }\n    cancelCurrentFiletransfer(id) {\n        this.transfertPromiseQueue.cancelCurrentFiletransfer(id);\n    }\n    /**\n     * Method retrieves user quota (capabilities) for user\n     *\n     * @returns {ng.IPromise<Capabilities>} user quota for user\n     *\n     * @memberof FileServerService\n     */\n    getServercapabilities() {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: config.restServerUrl + "/api/rainbow/fileserver/v1.0/capabilities",\n                headers: this.authService.getRequestHeader()\n            }).then((response) => {\n                this.$log.info("[FileServerService] getServercapabilities -- success");\n                this.capabilities = response.data[\'data\'];\n                resolve(this.capabilities);\n            }, (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse);\n                this.$log.error("[FileServerService] getServercapabilities " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method creates blob from a file retrieved from server using optimization (range request) whenever necessary\n     *\n     * @param {string} url [required] server url for request\n     * @param {string} mime [required] Mime type of the blob to be created\n     * @param {number} fileSize [optional] size of file to be retrieved. Default: 0\n     * @param {string} fileName [optional] name of file to be downloaded\n     * @returns {ng.IPromise<Blob>} Blob created from data received from server\n     *\n     * @memberof FileServerService\n     * !Warning - Used by the SDK\n     */\n    getBlobFromUrlWithOptimization(url, mime, fileSize = 0, fileName = "", uploadedDate = "") {\n        if (uploadedDate.length !== 0) {\n            url += "?update=" + crypto_js_1.MD5(crypto_js_2.enc.Latin1.parse(uploadedDate)).toString(crypto_js_2.enc.Hex);\n        }\n        return this.$q((resolve, reject) => {\n            if (!!this.capabilities.maxChunkSizeDownload && fileSize !== 0 && fileSize > this.capabilities.maxChunkSizeDownload) {\n                let range = this.capabilities.maxChunkSizeDownload;\n                if (range > this.ONE_MEGABYTE) {\n                    range = this.ONE_MEGABYTE;\n                }\n                let minRange = 0;\n                let maxRange = range - 1;\n                let repetition = Math.ceil(fileSize / range);\n                let blobArray = new Array(repetition);\n                this.$log.debug("[FileServerService] getBlobFromUrlWithOptimization : " + repetition + " chunks to be downloaded");\n                let promiseArray = [];\n                for (let i = 0; repetition > 0; i++, repetition--, minRange += range, maxRange += range) {\n                    promiseArray.push(this.getPartialDataFromServer(url, minRange, maxRange, i)\n                        .then((response) => {\n                        blobArray[response[\'index\']] = response[\'data\'];\n                        return (response[\'data\']);\n                    }));\n                }\n                this.$q.all(promiseArray)\n                    .then(() => {\n                    let blob = new Blob(blobArray, { type: mime });\n                    this.$log.debug("[FileServerService] getBlobFromUrlWithOptimization success");\n                    resolve(blob);\n                }, (errorResponse) => {\n                    let error = this.errorHelperService.handleError(errorResponse);\n                    let errorDataObj = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(errorResponse.data)));\n                    let translatedErrorMessage = this.errorHelperService.getLocalizedError(errorDataObj.errorDetailsCode);\n                    this.$log.error( true ? translatedErrorMessage : undefined);\n                    reject(error);\n                });\n            }\n            else {\n                this.getBlobFromUrl(url, mime, fileSize, fileName)\n                    .then((blob) => {\n                    resolve(blob);\n                })\n                    .catch((error) => {\n                    reject(error);\n                });\n            }\n        });\n    }\n    ;\n    /**\n     * Method retrieves an URL object from an url\n     *\n     * @param {string} url [required] server url for request\n     * @param {string} mime [required] Mime type of the blob to be created\n     * @param {number} filesize [optional] size of file to be retrieved\n     * @param {string} fileName [optional] name of file to be downloaded\n     * @returns {ng.IPromise<String>} URL object created\n     *\n     * @memberof FileServerService\n     * !Warning - Used by the SDK\n     */\n    getBlobUrlFromUrl(url, mime, filesize = 0, fileName = "") {\n        return this.$q((resolve, reject) => {\n            this.getBlobFromUrlWithOptimization(url, mime, filesize, fileName)\n                .then((blob) => {\n                resolve(URL.createObjectURL(blob));\n            })\n                .catch((error) => {\n                reject(error);\n            });\n        });\n    }\n}\nFileServerService.$inject = [\n    "$q",\n    "$http",\n    "$log",\n    "authService",\n    "fileStorageService",\n    "TransfertPromiseQueue",\n    "FileDescriptorEventHandler",\n    "xmppService",\n    "errorHelperService",\n    "$rootScope",\n    "$interval"\n];\nangular.module("rainbow").service("fileServerService", FileServerService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/files/fileServerService.ts?')},function(module,exports){eval('/**\n * @ngdoc service\n * @module rainbow\n * @name FileStorageService\n * @requires $q\n * @requires $http\n * @requires $log\n * @requires $scope\n * @requires authService\n * @requires errorHelperService\n * @requires orderByFilter\n * @requires contactService\n * @description Rainbow FileStorageService provides interface to maniplate file descriptors of files received or sent by user\n */\n/// <reference path="../serviceInterface.ts"/>\n/// <reference path="../../models/common/fileDescriptor.ts"/>\n/// <reference path="../../models/common/httpResult.ts"/>\nclass FileStorageService {\n    constructor($injector, $q, $http, $log, $rootScope, authService, fileViewerFactory, errorHelperService, orderByFilter, contactService, helpersService, fileViewerElementFactory, fileDescriptorFactory) {\n        this.$injector = $injector;\n        this.$q = $q;\n        this.$http = $http;\n        this.$log = $log;\n        this.$rootScope = $rootScope;\n        this.authService = authService;\n        this.fileViewerFactory = fileViewerFactory;\n        this.errorHelperService = errorHelperService;\n        this.orderByFilter = orderByFilter;\n        this.contactService = contactService;\n        this.helpersService = helpersService;\n        this.fileViewerElementFactory = fileViewerElementFactory;\n        this.fileDescriptorFactory = fileDescriptorFactory;\n        this.started = false;\n        this.listeners = [];\n        this.rotationValues = {\n            1: "rotate(0deg)",\n            3: "rotate(180deg)",\n            6: "rotate(90deg)",\n            8: "rotate(270deg)"\n        };\n    }\n    start(stats) {\n        this.$log.info("[FileStorageService] === STARTING ===");\n        let startDate = performance.now();\n        this.started = false;\n        this.portalURL = config.restServerUrl + "/api/rainbow/filestorage/v1.0/files";\n        this.fileDescriptors = [];\n        this.voiceMessageFileDescriptors = [];\n        this.fileDescriptorsByDate = [];\n        this.fileDescriptorsByName = [];\n        this.fileDescriptorsBySize = [];\n        this.receivedFileDescriptors = [];\n        this.receivedFileDescriptorsByName = [];\n        this.receivedFileDescriptorsByDate = [];\n        this.receivedFileDescriptorsBySize = [];\n        this.consumptionData = {};\n        this.channelService = this.$injector.get("channelService"); // MCO : YES A CIRCULAR REFERENCE, I KNOW IT\'S UGLY...\n        // No blocking service\n        this.retrieveFileDescriptorsListPerOwner()\n            .then(() => {\n            return this.retrieveReceivedFiles(this.contactService.userContact.dbId);\n        })\n            .then(() => {\n            this.orderDocuments();\n            return this.retrieveUserConsumption();\n        })\n            .then(() => {\n            this.started = true;\n            var startDuration = Math.round(performance.now() - startDate);\n            stats.push({ service: "FileStorageService", startDuration: startDuration });\n            this.$log.info("[FileStorageService] === STARTED (" + startDuration + " ms) ===");\n        })\n            .catch((error) => {\n            this.$log.error("[FileStorageService] === STARTING === failure -- " + error.message);\n        });\n        this.retrieveVoiceMessageFileDescriptorsListPerOwner()\n            .then(() => {\n            this.$log.info("[FileStorageService] === STARTED (retrieveVoiceMessageFileDescriptorsListPerOwner)");\n        })\n            .catch((error) => {\n            this.$log.error("[FileStorageService] === STARTING === failure -- (retrieveVoiceMessageFileDescriptorsListPerOwner)");\n        });\n        this.listeners.push(this.$rootScope.$on("ROOM_UPDATE_EVENT", (__event, room, action) => {\n            if (action && action === "remove") {\n                this.$log.info("[FileStorageService] ROOM_UPDATE_EVENT REMOVED for roomId=" + room.dbId);\n                this.removeRoomFileViewer(room);\n            }\n        }));\n        return this.$q.when();\n    }\n    stop() {\n        this.$log.info("[FileStorageService] === STOPPING ===");\n        if (this.started) {\n            this.started = false;\n        }\n        // Unregister event listeners\n        if (this.listeners) {\n            this.listeners.forEach((unregisterListener) => { unregisterListener(); });\n        }\n        this.$log.info("[FileStorageService] === STOPPED ===");\n        return this.$q.when();\n    }\n    reinit(isBlocking) {\n        return this.$q((resolve, reject) => {\n            //if not blocking, resolve ASAP\n            if (!isBlocking) {\n                this.$log.info("[FileStorageService] === reinit not blocking ===");\n                resolve();\n                this.reinitInternal();\n                return;\n            }\n            this.$log.info("[FileStorageService] === reinit blocking ===");\n            //blocking call \n            this.reinitInternal()\n                .then(() => {\n                resolve();\n            })\n                .catch(() => {\n                reject();\n            });\n        });\n    }\n    reinitInternal() {\n        return this.$q((resolve, reject) => {\n            this.retrieveFileDescriptorsListPerOwner()\n                .then(() => {\n                return this.retrieveReceivedFiles(this.contactService.userContact.dbId);\n            })\n                .then(() => {\n                this.orderDocuments();\n                this.$log.info("[FileStorageService] reinitInternal done");\n                resolve();\n            })\n                .catch((error) => {\n                this.$log.error("[FileStorageService] reinitInternal failure -- " + error.message);\n                reject();\n            });\n        });\n    }\n    removeRoomFileViewer(room) {\n        this.$log.info("[FileStorageService] >removeRoomFileViewer: " + room.dbId);\n        let fileDesc;\n        do {\n            fileDesc = this.getFileDescriptorByViewerId(room.dbId);\n            if (fileDesc) {\n                var viewerFound = fileDesc.viewers.find((element) => {\n                    return element.viewerId === room.dbId;\n                });\n                if (viewerFound) {\n                    this.$log.info("[FileStorageService] >viewer found delete it");\n                    fileDesc.viewers.splice(fileDesc.viewers.indexOf(viewerFound), 1);\n                }\n            }\n        } while (fileDesc);\n    }\n    getFileDescriptorByViewerId(id) {\n        for (let fileDescriptor of this.fileDescriptors) {\n            for (let viewer of fileDescriptor.viewers) {\n                if (viewer.viewerId === id) {\n                    return fileDescriptor;\n                }\n            }\n        }\n        for (let fileDescriptor of this.receivedFileDescriptors) {\n            if (fileDescriptor.id === id) {\n                return fileDescriptor;\n            }\n        }\n        return null;\n    }\n    /**********************************************************/\n    /**  Basic accessors to FileStorageService\'s properties   **/\n    /**********************************************************/\n    getFileDescriptorById(id) {\n        for (let fileDescriptor of this.fileDescriptors) {\n            if (fileDescriptor.id === id) {\n                return fileDescriptor;\n            }\n        }\n        for (let fileDescriptor of this.receivedFileDescriptors) {\n            if (fileDescriptor.id === id) {\n                return fileDescriptor;\n            }\n        }\n        return null;\n    }\n    /**\n     * Method returns a file descriptor with full contact object in viewers\'list by requesting server\n     *\n     * @param {string} fileId [required] Identifier of file descriptor\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor\n     *\n     * @memberOf FileStorageService\n     */\n    getCompleteFileDescriptorById(id) {\n        return this.$q((resolve, reject) => {\n            let fileDescriptor;\n            if (this.fileDescriptors.some((fd) => { if (fd.id === id) {\n                fileDescriptor = fd;\n                return true;\n            } return false; })) {\n                let promiseArray = [];\n                //for each viewer ID, associate the contact\n                for (let viewer of fileDescriptor.viewers) {\n                    if (viewer.type === "user") {\n                        promiseArray.push(this.contactService.getContactByDBId(viewer["viewerId"])\n                            .then((contact) => {\n                            viewer["contact"] = contact;\n                            return (viewer);\n                        })\n                            .catch((error) => {\n                            this.$log.error("[FileStorageService] " + error);\n                            reject(error);\n                        }));\n                    }\n                    else {\n                    }\n                }\n                this.$q.all(promiseArray)\n                    .then(() => {\n                    resolve(fileDescriptor);\n                })\n                    .catch((error) => {\n                    this.$log.error("[FileStorageService] " + error);\n                    reject(error);\n                });\n            }\n            else {\n                reject();\n            }\n        });\n    }\n    getDocuments() {\n        return this.fileDescriptors;\n    }\n    getReceivedDocuments() {\n        return this.receivedFileDescriptors;\n    }\n    getDocumentsByName(received) {\n        return received ? this.receivedFileDescriptorsByName : this.fileDescriptorsByName;\n    }\n    getDocumentsByDate(received) {\n        return received ? this.receivedFileDescriptorsByDate : this.fileDescriptorsByDate;\n    }\n    getDocumentsBySize(received) {\n        return received ? this.receivedFileDescriptorsBySize : this.fileDescriptorsBySize;\n    }\n    getReceivedFilesFromContact(dbId) {\n        let files = this.receivedFileDescriptorsByDate.filter((file) => {\n            return (file.ownerId === dbId);\n        });\n        return files;\n    }\n    getSentFilesToContact(dbId) {\n        let files = this.fileDescriptorsByDate.filter((file) => {\n            for (let i = 0; i < file.viewers.length; i++) {\n                if (file.viewers[i].viewerId === dbId) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        return files;\n    }\n    getReceivedFilesForRoom(dbId) {\n        let files = this.receivedFileDescriptorsByDate.filter((file) => {\n            for (let i = 0; i < file.viewers.length; i++) {\n                if (file.viewers[i].viewerId === dbId && file.ownerId !== this.contactService.userContact.dbId) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        return files;\n    }\n    getConsumptionData() {\n        return this.consumptionData;\n    }\n    getVoiceMessageFileDescriptorByMsgId(msgId) {\n        return this.voiceMessageFileDescriptors.find((file) => {\n            return (file.tags !== null && file.tags.msgId === msgId);\n        });\n    }\n    /**********************************************************/\n    /**  Methods requesting server                           **/\n    /**********************************************************/\n    /**\n     * Method requests server to create a file descriptor this will be saved to local file descriptor list (i.e. this.fileDescriptors)\n     *\n     * @param {String} name [required] name of file for which file descriptor has to be created\n     * @param {String} extension [required] extension of file\n     * @param {number} size [required] size of  file\n     * @param {IFileViewer[]} viewers [required] list of viewers having access to the file (a viewer could be either be a user or a room)\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor created by server or error\n     *\n     * @memberof FileStorageService\n     */\n    createFileDescriptor(name, extension, size, viewers, voiceMessage) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "POST",\n                url: this.portalURL,\n                headers: this.authService.getRequestHeader(),\n                data: { fileName: name, extension: extension, size: size, viewers: viewers, voicemessage: voiceMessage }\n            })\n                .then((response) => {\n                const fileDescriptor = this.createFileDescriptorFromData(response.data.data);\n                this.$log.info("[FileStorageService] createFileDescriptor -- " + fileDescriptor.id + " -- success");\n                //in case something went wrong with the creation\n                if (fileDescriptor) {\n                    this.fileDescriptors.push(fileDescriptor);\n                }\n                this.orderDocuments();\n                resolve(fileDescriptor);\n            })\n                .catch((errorResponse) => {\n                const error = this.errorHelperService.handleError(errorResponse, "createFileDescriptor");\n                this.$log.error("[FileStorageService] " + error.message);\n                reject(error);\n            });\n        });\n    }\n    createFileDescriptorFromData(data) {\n        if (data) {\n            let viewers = [];\n            if (data.viewers) {\n                for (let viewerData of data.viewers) {\n                    viewers.push(this.fileViewerElementFactory(viewerData.viewerId, viewerData.type, viewerData.contact, this.contactService, this.channelService));\n                }\n            }\n            let url = data.url;\n            if (!url) {\n                url = config.restServerUrl + "/api/rainbow/fileserver/v1.0/files/" + data.id;\n            }\n            var state = "unknown";\n            if (data.isUploaded) {\n                state = "uploaded";\n            }\n            else {\n                state = "not_uploaded";\n            }\n            var virusScanState = "unknown";\n            if (data.isClean === null) {\n                virusScanState = "notScanned";\n            }\n            else if (data.isClean === true) {\n                virusScanState = "isClean";\n            }\n            else {\n                virusScanState = "isInfected";\n            }\n            var voiceMessage = false;\n            if (data.tags && data.tags.purpose === "voicemail") {\n                voiceMessage = true;\n            }\n            return this.fileDescriptorFactory(data.id, url, data.ownerId, data.fileName, data.extension, data.typeMIME, data.size, data.registrationDate, data.uploadedDate, data.dateToSort, viewers, state, data.thumbnail, data.orientation, data.tags, virusScanState, voiceMessage);\n        }\n        return;\n    }\n    ;\n    /**\n     * Method request deletion of a file descriptor on the server and removes it from local storage\n     * @param {any} id [required] file descriptor id to be destroyed\n     * @returns {ng.IPromise<IFileDescriptor[]>} list of remaining file descriptors\n     * @memberof FileStorageService\n     */\n    deleteFileDescriptor(id) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "DELETE",\n                url: this.portalURL + "/" + id,\n                headers: this.authService.getRequestHeader()\n            })\n                .then(() => {\n                this.$log.info("[FileStorageService] deleteFileDescriptor -- success");\n                this.deleteFileDescriptorFromCache(id, false);\n                this.$rootScope.$broadcast("ON_FILE_REMOVED_FROM_STORE_EVENT", { fileId: id });\n                this.retrieveUserConsumption();\n                resolve(undefined);\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "deleteFileDescriptor");\n                reject(error);\n                this.$log.error("[FileStorageService] " + error.message);\n            });\n        });\n    }\n    /**\n     * Method request deletion of all files on the server and removes them from local storage\n     * @returns {ng.IPromise<{}>}\n     * @memberof FileStorageService\n     */\n    deleteAllFileDescriptor() {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "DELETE",\n                url: this.portalURL + "/all",\n                headers: this.authService.getRequestHeader()\n            })\n                .then(() => {\n                this.$log.info("[FileStorageService] deleteAllFileDescriptor -- success");\n                this.deleteAllFilesDescriptorsFromCache();\n                this.retrieveUserConsumption();\n                resolve();\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "deleteAllFileDescriptor");\n                this.$log.error("[FileStorageService]" + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method retrieve full list of files belonging to user making the request\n     *\n     * @returns {ng.IPromise<IFileDescriptor[]>}\n     *\n     * @memberof FileStorageService\n     */\n    retrieveFileDescriptorsListPerOwner() {\n        if (!this.fileDescriptors) {\n            this.fileDescriptors = [];\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "?format=full&limit=1000",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.fileDescriptors = [];\n                let fileDescriptorsData = response.data["data"];\n                if (!fileDescriptorsData) {\n                    resolve();\n                }\n                // Check if we have received all fileDescriptors\n                let limit = response.data["limit"];\n                let total = response.data["total"];\n                let getAllFileDescriptorPromise = null;\n                // Create the getAllFileDescritor promise\n                if (total <= limit) {\n                    getAllFileDescriptorPromise = this.$q.resolve([]);\n                }\n                else {\n                    let offset = limit;\n                    let requestCount = total / limit;\n                    let requestArray = [];\n                    for (let index = 1; index < requestCount; index++) {\n                        requestArray.push(this.retrieveFileDescriptorsListPerOwnerwithOffset(offset, limit));\n                        offset += limit;\n                    }\n                    getAllFileDescriptorPromise = this.$q.all(requestArray);\n                }\n                // Call the getAllFileDescritor promise\n                getAllFileDescriptorPromise\n                    .then((responsesData) => {\n                    // Contact all response in a single array\n                    responsesData.forEach((responseData) => { fileDescriptorsData = fileDescriptorsData.concat(responseData); });\n                    // Create file descriptors\n                    for (let fileDescriptorData of fileDescriptorsData) {\n                        let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorData);\n                        if (fileDescriptor.state === "not_uploaded") {\n                            this.$log.info("[FileStorageService] file " + fileDescriptor.fileName + " not uploaded");\n                            if (fileDescriptor.ownerId === this.contactService.userContact.dbId) {\n                                this.$log.info("[FileStorageService] file " + fileDescriptor.fileName + " is our property, we can delete it");\n                                this.deleteFileDescriptor(fileDescriptor.id);\n                            }\n                            else {\n                                this.$log.info("[FileStorageService] file " + fileDescriptor.fileName + " is NOT our property, we CANNOT delete it");\n                            }\n                        }\n                        else {\n                            this.fileDescriptors.push(fileDescriptor);\n                        }\n                    }\n                    this.$log.info("[FileStorageService] retrieveFileDescriptorsListPerOwner -- success");\n                    resolve(this.fileDescriptors);\n                });\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "retrieveFileDescriptorsListPerOwner");\n                reject(error);\n                this.$log.error("[FileStorageService] " + error.message);\n            });\n        });\n    }\n    /**\n * Method retrieve full list of files belonging to user making the request\n *\n * @returns {ng.IPromise<IFileDescriptor[]>}\n *\n * @memberof FileStorageService\n */\n    retrieveVoiceMessageFileDescriptorsListPerOwner() {\n        if (!this.voiceMessageFileDescriptors) {\n            this.voiceMessageFileDescriptors = [];\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "?format=full&path=/voice-messages",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.voiceMessageFileDescriptors = [];\n                let fileDescriptorsData = response.data["data"];\n                if (!fileDescriptorsData) {\n                    resolve();\n                }\n                // Create file descriptors\n                for (let fileDescriptorData of fileDescriptorsData) {\n                    let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorData);\n                    if (fileDescriptor.state === "not_uploaded") {\n                        this.$log.info("[FileStorageService] file " + fileDescriptor.fileName + " not uploaded");\n                        if (fileDescriptor.ownerId === this.contactService.userContact.dbId) {\n                            this.$log.info("[FileStorageService] file " + fileDescriptor.fileName + " is our property, we can delete it");\n                            this.deleteFileDescriptor(fileDescriptor.id);\n                        }\n                        else {\n                            this.$log.info("[FileStorageService] file " + fileDescriptor.fileName + " is NOT our property, we CANNOT delete it");\n                        }\n                    }\n                    else {\n                        this.voiceMessageFileDescriptors.push(fileDescriptor);\n                    }\n                }\n                this.$log.info("[FileStorageService] retrieveVoiceMessageFileDescriptorsListPerOwner -- success");\n                resolve(this.voiceMessageFileDescriptors);\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "retrieveVoiceMessageFileDescriptorsListPerOwner");\n                reject(error);\n                this.$log.error("[FileStorageService] " + error.message);\n            });\n        });\n    }\n    /**\n     * Method retrieve a list of [limit] files belonging to user making the request begining with offset\n     *\n     * @returns {ng.IPromise<IFileDescriptor[]>}\n     *\n     * @memberof FileStorageService\n     */\n    retrieveFileDescriptorsListPerOwnerwithOffset(offset, limit) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "?format=full&limit=" + limit + "&offset=" + offset,\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                resolve(response.data["data"]);\n            });\n        });\n    }\n    /**\n    * Method request for the list of files received by a user from a given peer (i.e. inside a given conversation)\n    *\n    * @param {string} userId [required] dbId of user making the request\n    * @param {string} peerId [required] dbId of peer user in the conversation\n    * @returns {ng.IPromise<IFileDescriptor[]>} : list of received files descriptors\n    *\n    * @memberOf FileStorageService\n    */\n    retrieveFilesReceivedFromPeer(userId, peerId) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "/viewers/" + userId + "?ownerId=" + peerId + "&format=full",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                let receivedFileDescriptors = [];\n                let fileDescriptorsData = response.data["data"];\n                if (fileDescriptorsData) {\n                    for (let fileDescriptorData of fileDescriptorsData) {\n                        let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorData);\n                        receivedFileDescriptors.push(fileDescriptor);\n                    }\n                }\n                this.$log.info("[FileStorageService] retrieveFilesReceivedFromPeer success");\n                resolve(receivedFileDescriptors);\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "retrieveFilesReceivedFromPeer");\n                this.$log.error("[FileStorageService] " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method request for the list of files sent to a given peer (i.e. inside a given conversation)\n     *\n     * @param {string} peerId [required] dbId of peer user in the conversation\n     * @returns {ng.IPromise<IFileDescriptor[]>} : list of sent files descriptors\n     *\n     * @memberOf FileStorageService\n     */\n    retrieveSentFiles(peerId) {\n        this.$log.info("[FileStorageService] >retrieveSentFiles");\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "?format=full&viewerId=" + peerId,\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                let sentFilesDescriptors = [];\n                let fileDescriptorsData = response.data["data"];\n                if (fileDescriptorsData) {\n                    for (let fileDescriptorData of fileDescriptorsData) {\n                        let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorData);\n                        if (fileDescriptor.state === "not_uploaded") {\n                            this.$log.warn("[FileStorageService] file " + fileDescriptor.fileName + " not uploaded");\n                        }\n                        else {\n                            sentFilesDescriptors.push(fileDescriptor);\n                        }\n                    }\n                }\n                this.$log.info("[FileStorageService] retrieveSentFiles success");\n                resolve(sentFilesDescriptors);\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "retrieveSentFiles");\n                this.$log.error("[FileStorageService] " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method request for the list of files received in a room\n     *\n     * @param {string} roomId [required] Id of the room\n     * @returns {ng.IPromise<void>} : list of received files descriptors\n     *\n     * @memberOf FileStorageService\n     */\n    retrieveReceivedFilesForRoom(roomId) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "/viewers/" + roomId + "?format=full",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                let fileDescriptorsData = response.data["data"];\n                let result = [];\n                if (!fileDescriptorsData) {\n                    resolve(result);\n                }\n                else {\n                    fileDescriptorsData.forEach((fileDescriptorData) => {\n                        if (fileDescriptorData.ownerId !== this.contactService.userContact.dbId) {\n                            fileDescriptorData.viewers = [];\n                            let newFileDesc = this.createFileDescriptorFromData(fileDescriptorData);\n                            result.push(newFileDesc);\n                            if (!this.receivedFileDescriptors.find((fd) => { return fd.id === fileDescriptorData.id; })) {\n                                this.receivedFileDescriptors.push(newFileDesc);\n                            }\n                        }\n                    });\n                    resolve(result);\n                }\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "retrieveReceivedFilesForRoom");\n                this.$log.error("[FileStorageService] " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method request for the list of files received by a user\n     *\n     * @param {string} viewerId [required] Id of the viewer, could be either an userId or a roomId\n     * @returns {ng.IPromise<IFileDescriptor[]>} : list of received files descriptors\n     *\n     * @memberOf FileStorageService\n     */\n    retrieveReceivedFiles(viewerId) {\n        if (!this.receivedFileDescriptors) {\n            this.receivedFileDescriptors = [];\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "/viewers/" + viewerId + "?format=full&limit=1000",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.receivedFileDescriptors = [];\n                let fileDescriptorsData = response.data["data"];\n                if (!fileDescriptorsData) {\n                    resolve();\n                    return;\n                }\n                // Check if we have received all fileDescriptors\n                let limit = response.data["limit"];\n                let total = response.data["total"];\n                let getReceivedFileDescriptorPromise = null;\n                // Create the getAllFileDescritor promise\n                if (total <= limit) {\n                    getReceivedFileDescriptorPromise = this.$q.resolve([]);\n                }\n                else {\n                    let offset = limit;\n                    let requestCount = total / limit;\n                    let requestArray = [];\n                    for (let index = 1; index < requestCount; index++) {\n                        requestArray.push(this.retrieveReceivedFilesWithOffset(viewerId, offset, limit));\n                        offset += limit;\n                    }\n                    getReceivedFileDescriptorPromise = this.$q.all(requestArray);\n                }\n                getReceivedFileDescriptorPromise\n                    .then((responsesData) => {\n                    responsesData.forEach((responseData) => { fileDescriptorsData = fileDescriptorsData.concat(responseData); });\n                    for (let fileDescriptorItem of fileDescriptorsData) {\n                        // fileDescriptorItem.viewers = [];\n                        let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorItem);\n                        // filter files I sent but this are still returned by server because it is part of a room\n                        if (fileDescriptor.ownerId !== this.contactService.userContact.dbId) {\n                            let oldFileDesc = this.getFileDescriptorById(fileDescriptor.id);\n                            if (oldFileDesc) {\n                                fileDescriptor.previewBlob = oldFileDesc.previewBlob;\n                            }\n                            this.receivedFileDescriptors.push(fileDescriptor);\n                        }\n                    }\n                    this.orderReceivedDocuments();\n                    this.$log.info("[FileStorageService] retrieveReceivedFiles -- success");\n                    resolve(this.receivedFileDescriptors);\n                });\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "retrieveReceivedFiles");\n                this.$log.error("[FileStorageService] " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method retrieve a list of [limit] files belonging to user making the request begining with offset\n     *\n     * @returns {ng.IPromise<IFileDescriptor[]>}\n     *\n     * @memberof FileStorageService\n     */\n    retrieveReceivedFilesWithOffset(viewerId, offset, limit) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "/viewers/" + viewerId + "?format=full&limit=" + limit + "&offset=" + offset,\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                resolve(response.data["data"]);\n            });\n        });\n    }\n    /**\n     * Method retrieve the data usage of a given user\n     *\n     * @returns {ng.IPromise<{}>} : object data with the following properties:\n     *                  - feature {String} : The feature key belonging to the user\'s profile\n     *                  - maxValue {number} : The quota associated to this offer [octet]\n     *                  - currentValue {number} : The user\'s current consumption [octet]\n     *                  - unit {String} : The unit of this counters\n     * @memberOf FileStorageService\n     */\n    retrieveUserConsumption() {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: config.restServerUrl + "/api/rainbow/filestorage/v1.0/users/consumption",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.consumptionData = response.data["data"];\n                this.$log.info("[FileStorageService] retrieveUserConsumption success");\n                this.$rootScope.$broadcast("ON_CONSUMPTION_DATA_UPDATED_EVENT");\n                resolve(this.consumptionData);\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "retrieveUserConsumption");\n                this.$log.error("[FileStorageService] " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method deletes a viewer from the list of viewer of a given file\n     *\n     * @param {string} viewerId [required] Identifier of viewer to be removed. Could be either a user or a room\n     * @param {string} fileId [required] Identifier of the fileDescriptor from which the viewer will be removed\n     * @returns {ng.IPromise<{}>}\n     *\n     * @memberof FileStorageService\n     */\n    deleteFileViewer(viewerId, fileId) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "DELETE",\n                url: this.portalURL + "/" + fileId + "/viewers/" + viewerId,\n                headers: this.authService.getRequestHeader()\n            }).then((response) => {\n                this.$log.info("[FileStorageService] deleteFileViewer " + response.statusText);\n                // delete viewer from viewer list\n                let fd = this.getFileDescriptorById(fileId);\n                if (fd) {\n                    let index = -1;\n                    for (let i = 0; i < fd.viewers.length; i++) {\n                        if (fd.viewers[i].viewerId === viewerId) {\n                            index = i;\n                            break;\n                        }\n                    }\n                    if (index !== -1) {\n                        fd.viewers.splice(index, 1);\n                    }\n                }\n                resolve();\n            }, (errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "deleteFileViewer");\n                reject(error);\n                this.$log.error("[FileStorageService] " + error.message);\n            });\n        });\n    }\n    /**\n     * Method adds a viewer to a given file on server if it is not already one\n     *\n     * @param {string} fileId [required] Identifier of file\n     * @param {string} viewerId [required] Identifier of viewer to be added\n     * @param {string} viewerType [required] type of viewer to be added (user or room)\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor with newly added viewer\n     *\n     * @memberOf FileStorageService\n     */\n    addFileViewer(fileId, viewerId, viewerType) {\n        let fileDescriptor = this.getFileDescriptorById(fileId);\n        if (fileDescriptor && fileDescriptor.isAlreadyFileViewer(viewerId)) {\n            return this.$q.resolve(fileDescriptor);\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "POST",\n                url: this.portalURL + "/" + fileId + "/viewers",\n                headers: this.authService.getRequestHeader(),\n                data: {\n                    viewerId: viewerId,\n                    type: viewerType\n                }\n            }).then((response) => {\n                this.$log.info("[FileStorageService] addFileViewer success");\n                let fd = this.getFileDescriptorById(fileId);\n                if (fd) {\n                    var viewerAdded = this.fileViewerFactory([{\n                            viewerId: response.data.data.viewerId,\n                            type: response.data.data.type\n                        }])[0];\n                    if (viewerAdded.type === "user") {\n                        this.contactService.getContactByDBId(viewerId)\n                            .then((contact) => {\n                            viewerAdded.contact = contact;\n                            fd.viewers.push(viewerAdded);\n                            resolve(fd);\n                        })\n                            .catch((error) => {\n                            this.$log.error("[FileStorageService] " + error);\n                            reject(error);\n                        });\n                    }\n                    else {\n                        fd.viewers.push(viewerAdded);\n                        resolve(fd);\n                    }\n                }\n            }, (errorResponse) => {\n                const error = this.errorHelperService.handleError(errorResponse, "addFileViewer");\n                reject(error);\n                this.$log.error("[FileStorageService] " + error.message);\n            });\n        });\n    }\n    /**\n     * This method is used to copy the file to user personal storage\n     *\n     * @param {string} fileId [required] Identifier of file descriptor to copy\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor retrieved\n     *\n     * @memberOf FileStorageService\n     */\n    copyFileToUserCloudStorage(fileId) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "POST",\n                url: this.portalURL + "/" + fileId + "/copy",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.$log.info("[FileStorageService] copyFileToUserCloudStorage | copyFile " + fileId + " -- success");\n                this.retrieveAndStoreOneFileDescriptor(response.data["data"].id, true).then((fileDescriptor) => {\n                    resolve(fileDescriptor);\n                }).catch((error) => {\n                    reject(error);\n                });\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "copyFileToUserCloudStorage");\n                this.$log.error("[FileStorageService] copyFileToUserCloudStorage " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method retrieve a specific file descriptor from server\n     *\n     * @param {string} fileId [required] Identifier of file descriptor to retrieve\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor retrieved\n     *\n     * @memberOf FileStorageService\n     */\n    retrieveOneFileDescriptor(fileId) {\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.portalURL + "/" + fileId + "?format=full",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                let fileDescriptor = this.createFileDescriptorFromData(response.data["data"]);\n                this.$log.info("[FileStorageService] getOneFileDescriptor " + fileId + " -- success");\n                resolve(fileDescriptor);\n            })\n                .catch((errorResponse) => {\n                let error = this.errorHelperService.handleError(errorResponse, "getOneFileDescriptor");\n                this.$log.error("[FileStorageService] " + error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Method retrieve a specific file descriptor from server and stores it in local fileDescriptors (replace existing and add if new)\n     *\n     * @param {string} fileId [required] Identifier of file descriptor to retrieve\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor retrieved or null if none found\n     *\n     * @memberOf FileStorageService\n     */\n    retrieveAndStoreOneFileDescriptor(fileId, forceRetrieve) {\n        let fileDescriptor = this.getFileDescriptorById(fileId);\n        if (fileDescriptor && !forceRetrieve) {\n            this.$log.info("[FileStorageService] retrieveAndStoreOneFileDescriptor -- return existing fileDescriptor " + fileId);\n            return this.$q.resolve(fileDescriptor);\n        }\n        return this.retrieveOneFileDescriptor(fileId)\n            .then((retrievedFileDescriptor) => {\n            if (fileDescriptor && fileDescriptor.isImage()) {\n                retrievedFileDescriptor.previewBlob = fileDescriptor.previewBlob;\n            }\n            // Remove old file descriptor with same id if there\'s one\n            let oldFileDescriptorIndex = this.helpersService.findIndex(this.fileDescriptors, (_fileDescriptor) => { return _fileDescriptor.id === retrievedFileDescriptor.id; });\n            if (oldFileDescriptorIndex > -1) {\n                this.fileDescriptors.splice(oldFileDescriptorIndex, 1);\n            }\n            let oldReceivedFileDescriptorIndex = this.helpersService.findIndex(this.receivedFileDescriptors, (_fileDescriptor) => { return _fileDescriptor.id === retrievedFileDescriptor.id; });\n            if (oldReceivedFileDescriptorIndex > -1) {\n                this.receivedFileDescriptors.splice(oldReceivedFileDescriptorIndex, 1);\n            }\n            if (retrievedFileDescriptor.ownerId === this.contactService.userContact.dbId) { // The file is mine\n                this.fileDescriptors.push(retrievedFileDescriptor);\n                this.$log.info("[FileStorageService] retrieveAndStoreOneFileDescriptor -- fileDescriptor " + retrievedFileDescriptor.id + " -- now stored in my files");\n            }\n            else { // The file is not mine\n                let retrievedFileDescriptors = [];\n                this.receivedFileDescriptors.push(retrievedFileDescriptor);\n                this.$log.info("[FileStorageService] retrieveAndStoreOneFileDescriptor -- fileDescriptor " + retrievedFileDescriptor.id + " -- now stored in received files");\n                this.$rootScope.$broadcast("ON_MESSAGE_WITH_FILE_RECEIVED_EVENT");\n            }\n            this.orderDocuments();\n            this.$rootScope.$broadcast("ON_FILE_DESCRIPTOR_RECEIVED_EVENT", { fileId: retrievedFileDescriptor.id });\n            return this.$q.resolve(retrievedFileDescriptor);\n        })\n            .catch((errorResponse) => {\n            this.$log.warn("[FileStorageService] Error on getting FileDescriptor: " + errorResponse.errorDetailsCode);\n            let error = this.errorHelperService.handleError(errorResponse, "retrieveAndStoreOneFileDescriptor");\n            if (error.status >= 400 && error.status < 500) {\n                if (fileDescriptor) {\n                    // ATTENTION MODIFIED BY MCO\n                    //if (error.status === 404) { fileDescriptor.state = "deleted"; }\n                    //else { this.deleteFileDescriptorFromCache(fileDescriptor.id, true); }\n                    if (error.status === 404) {\n                        this.deleteFileDescriptorFromCache(fileDescriptor.id, true);\n                    }\n                    this.orderDocuments();\n                    this.$log.debug("[FileStorageService] Sending ON_FILE_REMOVED_FROM_STORE_EVENT");\n                    this.$rootScope.$broadcast("ON_FILE_REMOVED_FROM_STORE_EVENT", { fileId: fileDescriptor.id });\n                }\n            }\n            return this.$q.reject(errorResponse);\n        });\n    }\n    // public SharePubliclyAFile(fileId: string): ng.IPromise<{}> {\n    //\n    //     return this.$q((resolve, reject) => {\n    //         this.$http({\n    //             method: "POST",\n    //             url: this.portalURL + "/" + fileId + "/share",\n    //             headers: this.authService.getRequestHeader()\n    //         }).then(\n    //             response => {\n    //                 let fileDescriptorData = response.data["data"];\n    //                 this.$log.info("[FileStorageService] SharePubliclyAFile success");\n    //                 resolve(fileDescriptorData);\n    //             },\n    //             errorResponse => {\n    //                 let error = this.errorHelperService.handleError(response);\n    //                 reject(error);\n    //                 this.$log.error("[FileStorageService] " + errorHelperService.getErrorFullMessage(response, "SharePubliclyAFile"));\n    //             });\n    //     });\n    // }\n    // public StopThePublicFileSharing(fileId: string): ng.IPromise<{}> {\n    //     return this.$q((resolve, reject) => {\n    //         this.$http({\n    //             method: "DELETE",\n    //             url: this.portalURL + "/" + fileId + "/stop-share",\n    //             headers: this.authService.getRequestHeader()\n    //         }).then(\n    //             response => {\n    //                 let fileDescriptorData = response.data.data;\n    //                 this.$log.info("[FileStorageService] StopThePublicFileSharing success");\n    //                 resolve(fileDescriptorData);\n    //             },\n    //             errorResponse => {\n    //                 let error = this.errorHelperService.handleError(response);\n    //                 reject(error);\n    //                 this.$log.error("[FileStorageService] " + errorHelperService.getErrorFullMessage(response, "StopThePublicFileSharing"));\n    //             });\n    //     });\n    // }\n    /**********************************************************/\n    /**  Utilities                                           **/\n    /**********************************************************/\n    deleteFileDescriptorFromCache(id, forceDelete) {\n        this.$log.info("[FileStorageService] deleteFileDescriptorFromCache " + id);\n        for (let index = 0; index < this.receivedFileDescriptors.length; index++) {\n            if (this.receivedFileDescriptors[index].id === id) {\n                this.receivedFileDescriptors.splice(index, 1);\n                break;\n            }\n        }\n        for (let index = 0; index < this.fileDescriptors.length; index++) {\n            if (this.fileDescriptors[index].id === id) {\n                if (forceDelete) {\n                    this.fileDescriptors.splice(index, 1);\n                }\n                else {\n                    this.fileDescriptors[index].state = "deleted";\n                }\n                break;\n            }\n        }\n        this.orderDocuments();\n    }\n    deleteAllFilesDescriptorsFromCache() {\n        this.$log.info("[FileStorageService] deleteAllFilesDesceiptorsFromCache");\n        this.fileDescriptors.forEach((fileDescriptor) => {\n            fileDescriptor.state = "deleted";\n            this.receivedFileDescriptors.forEach((receivedFileDescriptor, index) => {\n                if (receivedFileDescriptor.id === fileDescriptor.id) {\n                    this.receivedFileDescriptors.splice(index, 1);\n                }\n            });\n        });\n        this.fileDescriptors = [];\n        this.orderDocuments();\n    }\n    orderDocuments() {\n        this.$log.debug("[FileStorageService] orderDocuments: " + this.fileDescriptors.length);\n        this.replaceOrderedByFilter(this.fileDescriptorsByDate, this.fileDescriptors, this.getDate, false, this.sortByDate);\n        this.replaceOrderedByFilter(this.fileDescriptorsByName, this.fileDescriptors, this.getName, false, this.sortByName);\n        this.replaceOrderedByFilter(this.fileDescriptorsBySize, this.fileDescriptors, this.getSize, false, this.sortBySize);\n        this.orderReceivedDocuments();\n    }\n    orderReceivedDocuments() {\n        this.$log.debug("[FileStorageService] orderReceivedDocuments: " + this.receivedFileDescriptors.length);\n        this.replaceOrderedByFilter(this.receivedFileDescriptorsByName, this.receivedFileDescriptors, this.getName, false, this.sortByName);\n        this.replaceOrderedByFilter(this.receivedFileDescriptorsByDate, this.receivedFileDescriptors, this.getDate, false, this.sortByDate);\n        this.replaceOrderedByFilter(this.receivedFileDescriptorsBySize, this.receivedFileDescriptors, this.getSize, false, this.sortBySize);\n    }\n    orderDocumentsForRoom(documents) {\n        return this.orderByFilter(documents, this.getDate, false, this.sortByDate);\n    }\n    replaceOrderedByFilter(resultArray, originalArray, filterFct, flag, sortFct) {\n        this.$log.debug("[FileStorageService] replaceOrderedByFilter");\n        resultArray.length = 0;\n        let orderedArrayResult = this.orderByFilter(originalArray, filterFct, flag, sortFct);\n        for (let fileResult of orderedArrayResult) {\n            if (fileResult.state !== "deleted") {\n                resultArray.push(fileResult);\n            }\n        }\n    }\n    getName(file) {\n        let result = { name: "", date: "" };\n        if (file.fileName) {\n            result.name = file.fileName;\n        }\n        let date;\n        if (file.uploadedDate) {\n            date = new Date(file.uploadedDate);\n        }\n        else if (file.registrationDate) {\n            date = new Date(file.registrationDate);\n        }\n        else {\n            date = new Date(file.dateToSort);\n        }\n        result.date = date.getTime();\n        return result;\n    }\n    getDate(file) {\n        let date;\n        if (file.uploadedDate) {\n            date = new Date(file.uploadedDate);\n        }\n        else if (file.registrationDate) {\n            date = new Date(file.registrationDate);\n        }\n        else {\n            date = new Date(file.dateToSort);\n        }\n        return date.getTime();\n    }\n    getSize(file) {\n        let result = { name: "", size: "" };\n        if (file.name) {\n            result.name = file.fileName;\n        }\n        result.size = file.size;\n        return result;\n    }\n    sortByName(fileA, fileB) {\n        let res = -1;\n        if (fileA.value.name && fileB.value.name) {\n            res = fileA.value.name.localeCompare(fileB.value.name);\n            if (res === 0) {\n                res = fileB.value.date - fileA.value.date;\n            }\n        }\n        return res;\n    }\n    sortBySize(fileA, fileB) {\n        let res = -1;\n        if (fileA.value.size && fileB.value.size) {\n            res = fileB.value.size - fileA.value.size;\n        }\n        return res;\n    }\n    sortByDate(fileA, fileB) {\n        let res = 1;\n        if (fileA && fileB) {\n            res = fileB.value - fileA.value;\n        }\n        return res;\n    }\n    /**\n     * Method extract fileId part of URL\n     *\n     * @param {string} url\n     * @returns {string}\n     *\n     * @memberof FileStorageService\n     */\n    extractFileIdFromUrl(url) {\n        let parts = url.split("/");\n        let fileDescriptorId = parts.pop() || parts.pop();\n        return fileDescriptorId;\n    }\n    /**\n     * Method retrieve a specific file descriptor from server\n     *\n     * @param {string} fileId [required] Identifier of file descriptor to retrieve from voice message filedescriptorlist\n     * @returns {ng.IPromise<IFileDescriptor>} file descriptor retrieved\n     *\n     * @memberOf FileStorageService\n     */\n    retrieveAndStoreOneVoiceMessageFileDescriptor(fileId) {\n        this.retrieveOneFileDescriptor(fileId)\n            .then((retrievedFileDescriptor) => {\n            if (retrievedFileDescriptor.tags && retrievedFileDescriptor.tags.path === "/voice-messages") {\n                let fileDescriptorExist = this.voiceMessageFileDescriptors.find((file) => {\n                    return file.id === fileId;\n                });\n                if (fileDescriptorExist !== undefined) {\n                    // Remove old file descriptor with same id if there\'s one\n                    let fileDescriptorIndex = this.voiceMessageFileDescriptors.findIndex((oneFileDescriptor) => { return oneFileDescriptor.id === retrievedFileDescriptor.id; });\n                    if (fileDescriptorIndex > -1) {\n                        this.voiceMessageFileDescriptors.splice(fileDescriptorIndex, 1, retrievedFileDescriptor);\n                    }\n                    this.$log.info("[FileStorageService] getRetrieveAndStoreOneVoiceMessageFileDescriptor " + fileId + " -- success");\n                }\n                else {\n                    this.voiceMessageFileDescriptors.push(retrievedFileDescriptor);\n                }\n            }\n        });\n    }\n    deleteVoiceMessageFileDescriptor(fileId) {\n        this.$log.info("[FileStorageService] deleteVoiceMessageFileDescriptore " + fileId);\n        let fileDescriptorExist = this.voiceMessageFileDescriptors.find((file) => {\n            return file.id === fileId;\n        });\n        if (fileDescriptorExist !== undefined) {\n            let fileDescriptorIndex = this.voiceMessageFileDescriptors.findIndex((oneFileDescriptor) => { return oneFileDescriptor.id === fileDescriptorExist.id; });\n            if (fileDescriptorIndex > -1) {\n                this.voiceMessageFileDescriptors.splice(fileDescriptorIndex, 1);\n            }\n        }\n    }\n}\nFileStorageService.$inject = [\n    "$injector",\n    "$q",\n    "$http",\n    "$log",\n    "$rootScope",\n    "authService",\n    "fileViewerFactory",\n    "errorHelperService",\n    "orderByFilter",\n    "contactService",\n    "helpersService",\n    "fileViewerElementFactory",\n    "fileDescriptorFactory"\n];\nangular.module("rainbow").service("fileStorageService", FileStorageService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/files/fileStorageService.ts?')},function(module,exports){eval('angular.module("rainbow").factory("FileDescriptorEventHandler", ["$log", "$rootScope", "contactService", function ($log, $rootScope, contactService) {\n  "use strict";\n  /*********************************************************************/\n\n  /** PUBLIC STATIC FACTORY                                           **/\n\n  /*********************************************************************/\n\n  FileDescriptorEventHandler.create = function (fileServerService) {\n    return new FileDescriptorEventHandler(fileServerService);\n  };\n  /*********************************************************************/\n\n  /** PRIVATE CONSTRUCTOR                                             **/\n\n  /*********************************************************************/\n\n\n  function FileDescriptorEventHandler(fileServerService) {\n    var that = this;\n    this.fileServerService = fileServerService;\n    this.fileStorageService = fileServerService.getFileStorageService();\n    /*********************************************************************/\n\n    /** PUBLIC API                                                      **/\n\n    /*********************************************************************/\n\n    that.onManagementMessageReceived = function (stanza) {\n      try {\n        var stanzaElem = $(stanza);\n\n        if (stanzaElem.find("file").length > 0) {\n          this.manageFileStanzaData(stanzaElem.find("file"));\n        } else if (stanzaElem.find("thumbnail").length > 0) {\n          this.manageThumbnailStanzaData(stanzaElem.find("thumbnail"));\n        } else {\n          $log.info("[FileDescriptorEventHandler] onManagementMessageReceived  -- ignore the message");\n        }\n\n        return true;\n      } catch (error) {\n        $log.error("[FileDescriptorEventHandler] onManagementMessageReceived ERROR " + error);\n        return true;\n      }\n    };\n\n    that.manageFileStanzaData = function (stanza) {\n      var action = $(stanza).attr("action"); // we might have many fileIds in the same message, we should treat them all one by one\n\n      var filesId = $(stanza).find("fileid");\n      var updateConsumption = false;\n\n      for (var i = 0; i < filesId.length; i++) {\n        var fileId = $(filesId[i]).text();\n        var fileDescriptor = this.fileStorageService.getFileDescriptorById(fileId);\n        $log.info("[FileDescriptorEventHandler] manageFileStanzaData -- " + action + " fileDescriptor " + fileId);\n\n        switch (action) {\n          case "create":\n            $log.debug("[FileDescriptorEventHandler] fileDescriptor " + fileId + " created on server -- do nothing");\n            break;\n\n          case "delete":\n            if (fileDescriptor) {\n              //check if we\'ve deleted one of our own files\n              if (fileDescriptor.ownerId === contactService.userContact.dbId && fileDescriptor.state !== "deleted") {\n                updateConsumption = true;\n              }\n\n              this.fileStorageService.deleteFileDescriptorFromCache(fileId);\n              this.fileStorageService.deleteVoiceMessageFileDescriptor(fileId);\n              $rootScope.$broadcast("ON_FILE_REMOVED_FROM_STORE_EVENT", {\n                fileId: fileId\n              });\n            }\n\n            break;\n\n          case "update":\n            if (!fileDescriptor) {\n              updateConsumption = true;\n            }\n\n            that.fileStorageService.retrieveAndStoreOneFileDescriptor(fileId, true).then(function (fileDesc) {\n              $log.info("[FileDescriptorEventHandler] fileDescriptor retrieved");\n\n              if (!fileDesc.previewBlob) {\n                that.fileServerService.getBlobThumbnailFromFileDescriptor(fileDesc).then(function (blob) {\n                  fileDesc.previewBlob = blob;\n                });\n              }\n            });\n            that.fileStorageService.retrieveAndStoreOneVoiceMessageFileDescriptor(fileId);\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (updateConsumption) {\n        this.fileStorageService.retrieveUserConsumption();\n      }\n    };\n\n    that.manageThumbnailStanzaData = function (stanza) {\n      var action = $(stanza).attr("action");\n      var fileId = $(stanza).find("fileid").text();\n      var fileUrl = $(stanza).find("url").text();\n      var fileMime = $(stanza).find("mime").text();\n      var fileName = $(stanza).find("filename").text();\n      var fileSize = $(stanza).find("size").text();\n      var md5sum = $(stanza).find("md5sum").text();\n      $log.info("[FileDescriptorEventHandler] manageThumbnailStanzaData -- " + action + " fileDescriptor " + fileId);\n      $log.debug("[FileDescriptorEventHandler]   fileUrl=" + fileUrl);\n      $log.debug("[FileDescriptorEventHandler]   fileMime=" + fileMime);\n      $log.debug("[FileDescriptorEventHandler]   fileName=" + fileName);\n      $log.debug("[FileDescriptorEventHandler]   fileSize=" + fileSize);\n      $log.debug("[FileDescriptorEventHandler]   md5sum=" + md5sum);\n      $log.debug("[FileDescriptorEventHandler]   fileId=" + fileId);\n\n      if (action === "create" || action === "update") {\n        var fileDescriptor = this.fileStorageService.getFileDescriptorById(fileId);\n\n        if (fileDescriptor) {\n          $log.debug("[FileDescriptorEventHandler] updating Thumbnail of found FileDescriptor " + fileId);\n\n          if (fileDescriptor.previewBlob && !fileDescriptor.thumbnail.availableThumbnail || !fileDescriptor.previewBlob) {\n            $rootScope.$broadcast("ON_FILE_DESCRIPTOR_THUMBNAIL_READY", fileDescriptor.id); // Either we have the raw file serve as thumbnail or we don\'t have one yet\n\n            fileDescriptor.thumbnail.availableThumbnail = true;\n            fileDescriptor.thumbnail.md5sum = md5sum;\n            fileDescriptor.thumbnail.size = fileSize;\n            $log.info("[FileDescriptorEventHandler] preview not already downloaded for " + fileId + " -- download it");\n            this.fileServerService.getBlobThumbnailFromFileDescriptor(fileDescriptor).then(function () {\n              $rootScope.$broadcast("ON_FILE_DESCRIPTOR_RECEIVED_EVENT", {\n                fileId: fileDescriptor.id\n              });\n            });\n          } else {\n            $rootScope.$broadcast("ON_FILE_DESCRIPTOR_THUMBNAIL_READY", fileDescriptor.id);\n            $log.info("[FileDescriptorEventHandler] preview already downloaded for " + fileId + " -- do nothing");\n          }\n        } else {\n          $log.error("[FileDescriptorEventHandler] FileDescriptor not found and we do nothing and its not OK");\n        }\n      }\n    };\n  }\n\n  return FileDescriptorEventHandler;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/files/fileDescriptorEventHandler.js?')},function(module,exports){eval('angular.module("rainbow").service("extensionSharingService", ["$q", "$log", "$rootScope", function ($q, $log, $rootScope) {\n  "use strict";\n\n  var that = this;\n  this.extensionFound = false; //this.extensionId = "leoifkjnlmbfndjoonnggpeipkanfokd";\n  //this.extensionId = "niopgbnmffbdlobcihigdlginoekehji";\n  //this.extensionId = "mgneongoclkopahpapenfhbbeckhdmnj";\n  // this.extensionId = "gjfehkihjflogogmfegpjgkfcfblmjfc";\n\n  this.minVersion = "1.5.1";\n  this.port = null;\n  this.currentStreamId = "screen";\n\n  this.start = function () {\n    this.extensionId = this.extensionId || this.getExtensionId(config.webservices.server);\n    var defered = $q.defer();\n    $log.info("[extensionService] === STARTING ===");\n\n    if (window.chrome && window.chrome.runtime) {\n      $log.info("[extensionService] Chrome extension - try to ping...", this.extensionId);\n      chrome.runtime.sendMessage(this.extensionId, {\n        type: "ping",\n        data: null\n      }, null, function (extensionMessageResponse) {\n        if (extensionMessageResponse && extensionMessageResponse.type === "pong") {\n          $log.info("[extensionService] Chrome extension - pong received");\n          $log.info("[extensionService] Chrome extension - extension installed and detected");\n          $log.info("[extensionService] Chrome extension - try to connect...");\n          that.port = chrome.runtime.connect(that.extensionId);\n\n          if (that.port) {\n            $log.info("[extensionService] Chrome extension - port created");\n            that.port.onDisconnect.addListener(function () {\n              $log.info("Extension DISCONNECTED");\n              that.extensionFound = false;\n              that.port = null;\n            });\n            that.port.onMessage.addListener(function (msg) {\n              $log.info("[extensionService] Chrome extension - connected");\n\n              switch (msg.type) {\n                case "loginResponse":\n                  that.extensionFound = true;\n                  $log.info("[extensionService] Chrome extension - ready!");\n                  $log.info("[extensionService] === STARTED ===");\n                  $rootScope.$broadcast("ON_EXTENSION_SHARING_READY");\n                  defered.resolve();\n                  break;\n\n                case "getVersionResponse":\n                  if (msg.code === 0 && msg.version) {\n                    $rootScope.$broadcast("ON_EXTENSION_VERSION_UPDATED", msg.version);\n                    $log.info("[extensionService] Chrome extension - Detected version " + msg.version);\n                  } else {\n                    $rootScope.$broadcast("ON_EXTENSION_VERSION_UPDATED", null);\n                    $log.error("[extensionService] Chrome extension - No version received");\n                  }\n\n                  break;\n\n                case "startsharingResponse":\n                  if (msg.code === 0 && msg.streamID) {\n                    $log.info("[extensionService] Chrome extension - stream ID received " + msg.streamID);\n                    $rootScope.$broadcast("ON_EXTENSION_SHARING_STREAM_FOUND", msg.streamID);\n                  } else {\n                    $log.info("[extensionService] Chrome extension - No stream ID received");\n                    $rootScope.$broadcast("ON_EXTENSION_SHARING_STREAM_FOUND", null);\n                  }\n\n                  break;\n\n                case "endsharingResponse":\n                  $log.info("[extensionService] Chrome extension - end sharing session received");\n                  break;\n\n                default:\n                  break;\n              }\n            }); // Login to the chrome extension\n\n            that.port.postMessage({\n              type: "login",\n              data: null\n            });\n          } else {\n            $log.info("[extensionService] Chrome extension - can\'t create port to contact the extension!!!");\n            $log.info("[extensionService] === STARTED ===");\n            defered.resolve();\n          }\n        } else {\n          $log.info("[extensionService] Chrome extension - not found");\n\n          if (chrome.runtime.lastError) {\n            $log.info("[extensionService] Chrome extension - error " + chrome.runtime.lastError);\n          }\n\n          defered.resolve();\n        }\n      });\n    } else {\n      $log.info("[extensionService] Not in chrome");\n      $log.info("[extensionService] === STARTED ===");\n      defered.resolve();\n    }\n\n    return defered.promise;\n  };\n\n  this.stop = function () {\n    $log.info("[extensionService] === STOPPING ===");\n    $log.info("[extensionService] === STOPPED ===");\n    return $q.when();\n  };\n\n  this.getExtensionId = function (domain) {\n    $log.info("Detected domain : " + domain);\n\n    if (domain.indexOf("openrainbow.net") !== -1) {\n      return "koefhabbjedbiecnldkolbijjfjinogj";\n    } else if (domain.indexOf("openrainbow.org") !== -1) {\n      return "ehamhlkmecdnidihfedapmplddlbidee";\n    } else if (domain.indexOf("openrainbow.com") !== -1) {\n      return "mgneongoclkopahpapenfhbbeckhdmnj";\n    }\n\n    $log.error("Unkown domain, extension may not be available");\n    return "mgneongoclkopahpapenfhbbeckhdmnj";\n  };\n\n  this.setExtensionId = function (extensionId) {\n    $log.info("set extensionId to : " + extensionId);\n    this.extensionId = extensionId;\n  };\n\n  this.getStreamToShareFromExtension = function (constraints) {\n    var defered = $q.defer();\n    var callback = $rootScope.$on("ON_EXTENSION_SHARING_STREAM_FOUND", function (__event, streamid) {\n      that.currentStreamId = streamid;\n      callback();\n\n      if (streamid) {\n        constraints.video.mandatory.chromeMediaSourceId = streamid;\n        defered.resolve();\n      } else {\n        defered.reject();\n      }\n    });\n    this.port.postMessage({\n      type: "startsharing",\n      data: null\n    });\n    return defered.promise;\n  };\n\n  this.getStreamId = function () {\n    return this.currentStreamId;\n  };\n\n  this.isExtensionInstalled = function () {\n    var defered = $q.defer();\n\n    if (this.extensionFound) {\n      defered.resolve(true);\n    } else {\n      this.start().then(function () {\n        defered.resolve(that.extensionFound);\n      });\n    }\n\n    return defered.promise;\n  };\n\n  this.getExtensionVersion = function () {\n    var defered = $q.defer();\n    var callback = $rootScope.$on("ON_EXTENSION_VERSION_UPDATED", function (__event, version) {\n      callback(); //Unregister event\n\n      if (version) {\n        defered.resolve(version);\n      } else {\n        defered.reject();\n      }\n    });\n    this.port.postMessage({\n      type: "getVersion",\n      data: null\n    });\n    return defered.promise;\n  };\n\n  this.checkExtensionStatus = function () {\n    var defered = $q.defer();\n\n    if (adapter["default"].browserDetails.browser !== "chrome") {\n      defered.resolve("notNeeded");\n    } else {\n      this.isExtensionInstalled().then(function (isInstalled) {\n        if (isInstalled) {\n          that.checkVersion().then(function (isUpToDate) {\n            if (!isUpToDate) {\n              defered.resolve("needUpdate");\n            } else {\n              defered.resolve("good");\n            }\n          });\n        } else {\n          defered.resolve("notInstalled");\n        }\n      });\n    }\n\n    return defered.promise;\n  };\n\n  this.checkVersion = function () {\n    var defered = $q.defer();\n    this.getExtensionVersion().then(function (version) {\n      defered.resolve(that.cmpVersions(version, that.minVersion) >= 0);\n    });\n    return defered.promise;\n  };\n\n  this.cmpVersions = function (curVersion, minVersion) {\n    var i;\n    var diff;\n    var regExStrip0 = /(\\.0+)+$/;\n    var segmentsA = curVersion.replace(regExStrip0, "").split(".");\n    var segmentsB = minVersion.replace(regExStrip0, "").split(".");\n    var length = Math.min(segmentsA.length, segmentsB.length);\n\n    for (i = 0; i < length; i++) {\n      diff = parseInt(segmentsA[i], 10) - parseInt(segmentsB[i], 10);\n\n      if (diff) {\n        return diff;\n      }\n    }\n\n    return segmentsA.length - segmentsB.length;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/extensionSharingService.js?')},function(module,exports,__webpack_require__){eval('/**\n * @ngdoc service\n * @module rainbow\n * @name pstnConferenceService\n * @description Rainbow PstnConferenceService provides pstn conference services\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/// <reference path="../serviceInterface.ts" />\n/// <reference path="../../models/common/httpResult.ts" />\nclass PstnConferenceService {\n    /************************************************************/\n    /** LIFECYCLE STUFF                                        **/\n    /************************************************************/\n    constructor($q, $rootScope, $log, $http, authService, errorHelperService, ConferenceSession, profileService, xmppService, countryService, Conference, contactService, $translate, conferenceUserFactory) {\n        this.$q = $q;\n        this.$rootScope = $rootScope;\n        this.$log = $log;\n        this.$http = $http;\n        this.authService = authService;\n        this.errorHelperService = errorHelperService;\n        this.ConferenceSession = ConferenceSession;\n        this.profileService = profileService;\n        this.xmppService = xmppService;\n        this.countryService = countryService;\n        this.Conference = Conference;\n        this.contactService = contactService;\n        this.$translate = $translate;\n        this.conferenceUserFactory = conferenceUserFactory;\n        this.MEDIATYPE = {\n            PSTNAUDIO: "pstnAudio",\n            WEBRTC: "webrtc",\n            WEBRTCSHARINGONLY: "webrtcSharingOnly"\n        };\n        this.started = false;\n        this.conferenceProvisionRef = null;\n        // data accessed from conferenceService\n        this.isPstnConferenceAvailable = false;\n        this.conferenceSessions = {};\n        this.pstnConferenceEndpoints = {};\n        this.pstnConferenceUser = null;\n        this.pstnInstantConferenceEndpoint = null;\n        this.pstnConferencePhoneNumbers = null;\n    }\n    start(stats) {\n        return this.$q((resolve) => {\n            let startDate = performance.now();\n            this.$log.info("[PstnConferenceService] === STARTING ===");\n            this.isPstnConferenceAvailable = false;\n            this.conferenceSessions = {};\n            this.pstnConferenceEndpoints = {};\n            this.pstnConferenceUser = null;\n            this.pstnInstantConferenceEndpoint = null;\n            this.pstnConferencePhoneNumbers = null;\n            this.confProvPortalURL = config.restServerUrl + "/api/rainbow/confprovisioning/v1.0/";\n            this.confPortalURL = config.restServerUrl + "/api/rainbow/conference/v1.0/conferences/";\n            this.started = true;\n            let startDuration = Math.round(performance.now() - startDate);\n            stats.push({ service: "pstnConferenceService", startDuration: startDuration });\n            this.$log.info("[PstnConferenceService] === STARTED (" + startDuration + " ms) ===");\n            resolve();\n        });\n    }\n    stop() {\n        return this.$q((resolve) => {\n            this.$log.info("");\n            this.$log.info("[PstnConferenceService] === STOPPING ===");\n            this.started = false;\n            this.$log.info("[PstnConferenceService] === STOPPED ===");\n            resolve();\n        });\n    }\n    /**\n    * Method updateConference\n    * @public\n    * @param {string} confEndpointId ID of conference to update\n    * @param {any} confData data to update conference with\n    * @returns {ng.IPromise<any>} a promise that resolve when conference is updated\n    * @memberof PstnConferenceService\n    */\n    updateConference(confEndpointId, confData) {\n        this.$log.info("[PstnConferenceService] updateConference");\n        return this.$q((resolve, reject) => {\n            if (confEndpointId) {\n                this.$http({\n                    method: "PUT",\n                    url: this.confProvPortalURL + "conferences/" + confEndpointId,\n                    headers: this.authService.getRequestHeader(),\n                    data: confData\n                })\n                    .then((response) => {\n                    let conferenceData = response.data.data;\n                    let conference = this.Conference.createFromData(conferenceData);\n                    if (conferenceData.hasOwnProperty("id")) {\n                        if (this.pstnConferenceEndpoints[conferenceData.id]) {\n                            delete this.pstnConferenceEndpoints[conferenceData.id];\n                        }\n                        this.pstnConferenceEndpoints[conferenceData.id] = conference;\n                        if (!conferenceData.scheduled) {\n                            delete this.pstnInstantConferenceEndpoint;\n                            this.pstnInstantConferenceEndpoint = conference;\n                        }\n                    }\n                    this.$log.info("[PstnConferenceService] updateConference successfully");\n                    resolve(conference);\n                }, (response) => {\n                    let msg = response.data ? response.data.errorDetails : response.data;\n                    let errorMessage = "updateConference failure: " + msg;\n                    this.$log.error("[PstnConferenceService] " + errorMessage);\n                    reject(new Error(errorMessage));\n                });\n            }\n            else {\n                let errorMessage = "updateConference failure: No confEndpoint";\n                this.$log.error("[PstnConferenceService] updateConference failure : No confEndpoint");\n                reject(new Error(errorMessage));\n            }\n        });\n    }\n    /**\n    * Method retrieveConferenceUser\n    * @public\n    * @param {string} userId [required] ID of user\n    * @returns {ng.IPromise<any>} a promise that resolves with conferenceUser or error\n    * @memberof PstnConferenceService\n    */\n    retrieveConferenceUser(userId) {\n        this.$log.info("[PstnConferenceService] retrieveConferenceUser");\n        if (!userId) {\n            this.$log.warn("[PstnConferenceService] retrieveConferenceUser missing userId");\n            return this.$q.reject();\n        }\n        if (this.pstnConferenceUser) {\n            return this.$q.resolve(this.pstnConferenceUser);\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.confProvPortalURL + "users?userId=" + userId,\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                let conferenceProvisionData = response.data.data;\n                if (conferenceProvisionData && conferenceProvisionData.length) {\n                    this.pstnConferenceUser = this.conferenceUserFactory(conferenceProvisionData[0]);\n                    this.$log.info("[PstnConferenceService] retrieveConferenceUser successfully");\n                    resolve(this.pstnConferenceUser);\n                }\n                else {\n                    this.$log.warn("[PstnConferenceService] retrieveConferenceUser no ConferenceUser found");\n                    reject();\n                }\n            }, (errorResponse) => {\n                let msg = errorResponse.data ? errorResponse.data.errorDetails : errorResponse.data;\n                let errorMessage = "retrieveConferenceUser failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method retrievePstnConferences\n    * @public\n    * @param {boolean} scheduled [optional] whether it is a scheduled conference or not\n    * @param {boolean} provisioning [optional] whether it is a conference that is in provisioning state or not\n    * @returns {ng.IPromise<any>} a promise that resolves when conference are reterived\n    * @memberof PstnConferenceService\n    */\n    retrievePstnConferences(scheduled, provisioning) {\n        this.$log.info("[PstnConferenceService] retrievePstnConferences with scheduled=" + scheduled);\n        return this.$q((resolve, reject) => {\n            if (!this.isPstnConferenceAvailable) {\n                this.$log.warn("[PstnConferenceService] retrieveConference - user is not allowed");\n                reject(new Error("notAllowed"));\n                return;\n            }\n            let urlQueryParameters = "?format=full&userId=" + this.contactService.userContact.dbId + "&mediaType=" + this.MEDIATYPE.PSTNAUDIO;\n            if (angular.isDefined(scheduled)) {\n                urlQueryParameters += "&scheduled=" + scheduled;\n            }\n            if (provisioning) {\n                urlQueryParameters += "&provisioning=true";\n            }\n            this.$http({\n                method: "GET",\n                url: this.confProvPortalURL + "conferences" + urlQueryParameters,\n                headers: this.authService.getRequestHeader()\n            })\n                // Handle success response\n                .then((response) => {\n                let conferencesProvisionData = response.data.data;\n                for (let conferenceData of conferencesProvisionData) {\n                    this.updateOrCreatePstnConferenceEndpoint(conferenceData);\n                }\n                this.$log.info("[PstnConferenceService] retrievePstnConferences successfully");\n                resolve(conferencesProvisionData);\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "retrievePstnConferences failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    ;\n    /**\n    * Method updateOrCreateConferenceSession\n    * @public\n    * @param {string} confId [required] the conferenceID of the conferenceSession we are updating or creating\n    * @param {any} snapshotData [required] snapshot data for the update / creation\n    * @returns {any} the updated conferenceSession or null on error\n    * @memberof PstnConferenceService\n    */\n    updateOrCreateConferenceSession(confId, snapshotData) {\n        this.$log.debug("[PstnConferenceService] updateOrCreateConferenceSession for " + confId);\n        if (!confId || !snapshotData || !snapshotData.data) {\n            this.$log.error("[PstnConferenceService] updateOrCreateConferenceSession - Not enough data");\n            return null;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (!conferenceSession) {\n            this.$log.debug("[PstnConferenceService] updateOrCreateConferenceSession - create new conferencesession with id " + confId + "and data: \\n" + JSON.stringify(snapshotData.data));\n            conferenceSession = this.ConferenceSession.createFromData(confId, [], snapshotData.data.active, this.MEDIATYPE.PSTNAUDIO);\n            this.conferenceSessions[confId] = conferenceSession;\n            // Emit event to notify conference state data update\n            this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", conferenceSession);\n        }\n        else if (snapshotData.data.active !== conferenceSession.active) {\n            this.$log.debug( true ? "active" : undefined);\n            conferenceSession.updateActiveState(snapshotData.data.active);\n            // Emit event to notify conference state data update\n            this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", conferenceSession);\n        }\n        if (snapshotData.data.participants) {\n            this.$log.debug("[PstnConferenceService] updateOrCreateConferenceSession - update participants for " + confId + " with:\\n" + JSON.stringify(snapshotData.data.participants));\n            // Note: we are not smart, we always update participants on update. \n            conferenceSession.updateParticipants(snapshotData.data.participants)\n                .then(() => {\n                this.$rootScope.$broadcast("ON_CONFERENCE_PARTICIPANT_EVENT", conferenceSession);\n            });\n        }\n        return conferenceSession;\n    }\n    /**\n    * Method updateOrCreatePstnConferenceEndpoint\n    * @public\n    * @param {any} conferenceData [required] conference data for the update / creation\n    * @returns {any} the updated conferenceEndpoint or null on error\n    * @memberof PstnConferenceService\n    */\n    updateOrCreatePstnConferenceEndpoint(conferenceData) {\n        this.$log.info("[PstnConferenceService] updateOrCreatePstnConferenceEndpoint for " + conferenceData.id);\n        if (!conferenceData) {\n            this.$log.error("[PstnConferenceService] updateOrCreatePstnConferenceEndpoint - no conference data !");\n            return null;\n        }\n        if (conferenceData.mediaType !== this.MEDIATYPE.PSTNAUDIO) {\n            this.$log.error("[PstnConferenceService] updateOrCreatePstnConferenceEndpoint - wrong mediaType:" + conferenceData.mediaType);\n            return null;\n        }\n        let conference = this.Conference.createFromData(conferenceData);\n        this.pstnConferenceEndpoints[conferenceData.id] = conference;\n        if (!conference.scheduled) {\n            this.pstnInstantConferenceEndpoint = conference;\n            // Affect the name to the conference is not defined\n            if (!this.pstnInstantConferenceEndpoint.name) {\n                this.updateConference(this.pstnInstantConferenceEndpoint.id, { name: this.$translate.instant("namePersonalConference", { name: this.contactService.userContact.displayName }) });\n            }\n        }\n        return this.pstnConferenceEndpoints[conferenceData.id];\n    }\n    /**\n    * Method formatPstnPhoneNumbers\n    * @private\n    * @returns {any} a formated list of phone numbers\n    * @memberof PstnConferenceService\n    */\n    formatPstnPhoneNumbers(phoneNumbers) {\n        this.$log.info("[PstnConferenceService] formatPstnPhoneNumbers");\n        let pstnConferencePhoneNumbers = {};\n        phoneNumbers.forEach((phoneNumber) => {\n            /* Create a structure like that:\n                {\n                    "fr": {\n                        "numbersList": [\n                            { number: "038812345678", city: "Strasbourg", locationName: "Strasbourg, France", numberType: "local", needLanguageSelection: true}\n                            { number: "038812345679", city: "Colmar", locationName: "Colmar, France", numberType: "local", needLanguageSelection: true}\n                            { number: "038812345670", city: "", locationName: "", numberType: "local", needLanguageSelection: false}\n                    },\n                    "gb": {\n                        ...\n                    }\n                }\n            */\n            if (phoneNumber.locationcode) {\n                let propertyName = this.countryService.getAlpha2Code(phoneNumber.locationcode.substr(0, 3));\n                if (propertyName) { // NB: Numbers without locationCode are silently ignored\n                    if (!pstnConferencePhoneNumbers[propertyName]) {\n                        pstnConferencePhoneNumbers[propertyName] = {\n                            numbersList: []\n                        };\n                    }\n                }\n                pstnConferencePhoneNumbers[propertyName].numbersList.push({\n                    number: phoneNumber.number,\n                    locationName: phoneNumber.location,\n                    city: phoneNumber.location.split(", ")[1],\n                    numberType: phoneNumber.numberType,\n                    needLanguageSelection: phoneNumber.needLanguageSelection\n                });\n            }\n        });\n        return pstnConferencePhoneNumbers;\n    }\n    /**\n    * Method retrievePstnPhoneNumbers\n    * @private\n    * @returns {any} a promise that resolves with an object containing the phone numbers for PGi dial in or error\n    * @memberof PstnConferenceService\n    */\n    retrievePstnPhoneNumbers(shouldFormatResults) {\n        this.$log.info("[ConferenceService] retrievePstnPhoneNumbers");\n        if (this.pstnConferencePhoneNumbers) {\n            return shouldFormatResults ? this.$q.resolve(this.formatPstnPhoneNumbers(this.pstnConferencePhoneNumbers)) : this.$q.resolve(this.pstnConferencePhoneNumbers);\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.confProvPortalURL + "conferences/audio/phonenumbers?shortList=false",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.$log.info("[PstnConferenceService] retrievePstnPhoneNumbers successfully");\n                this.pstnConferencePhoneNumbers = response.data.data.phoneNumberList;\n                if (shouldFormatResults) {\n                    resolve(this.formatPstnPhoneNumbers(this.pstnConferencePhoneNumbers));\n                }\n                else {\n                    resolve(this.pstnConferencePhoneNumbers);\n                }\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "retrievePstnPhoneNumbers failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    ;\n    /**\n    * Method retrievePstnInstantConference\n    * @public\n    * @returns {any} a promise that resolves with pstn instant conference or, if user doesn\'t have conferencing permission, nothing\n    * @memberof PstnConferenceService\n    */\n    retrievePstnInstantConference() {\n        if (!this.isPstnConferenceAvailable) {\n            this.$log.info("[PstnConferenceService] retrievePstnInstantConference -- No conference rights");\n            return this.$q.resolve();\n        }\n        return this.retrievePstnConferences(false) // instant conference bridge\n            .then((conferenceData) => {\n            conferenceData.forEach((data) => {\n                if (data.hasOwnProperty("id")) {\n                    let conference = this.Conference.createFromData(data);\n                    if (conference.mediaType === this.MEDIATYPE.PSTNAUDIO && conference.userId === this.contactService.userContact.dbId && !conference.scheduled) {\n                        this.pstnConferenceEndpoints[conferenceData.id] = conference;\n                        this.pstnInstantConferenceEndpoint = conference;\n                        // Affect the name to the conference is not defined\n                        if (!this.pstnInstantConferenceEndpoint.name) {\n                            this.updateConference(this.pstnInstantConferenceEndpoint.id, { name: this.$translate.instant("namePersonalConference", { name: this.contactService.userContact.displayName }) });\n                        }\n                    }\n                }\n            });\n            // Hack - Protection against lost instant conference\n            if (!this.pstnInstantConferenceEndpoint && this.isPstnConferenceAvailable) {\n                this.$log.info("[PstnConferenceService] User has no instant conference : we create a new one");\n                this.retrieveConferenceUser(this.contactService.userContact.dbId)\n                    .then((confUser) => {\n                    // Create the instant conference\n                    this.createInstantConference(confUser.id, "instantConference")\n                        .then((instantConf) => {\n                        this.pstnInstantConferenceEndpoint = instantConf;\n                    });\n                });\n            }\n            return this.$q.resolve();\n        }, () => {\n            this.$log.warn("[PstnConferenceService] retrievePstnInstantConference - issue retrieving instant conference");\n            return this.$q.resolve();\n        });\n    }\n    /**\n    * Method createInstantConference\n    * @private\n    * @param {string} confUserId [required] conferenceUser id\n    * @param {string} name [optional] name of conference to be created. Default: ""\n    * @returns {any} a promise that resolves instant conference created or error\n    * @memberof PstnConferenceService\n    */\n    createInstantConference(confUserId, name = "") {\n        return this.$q((resolve, reject) => {\n            this.$log.info("[PstnConferenceService] createInstantConference");\n            this.$http({\n                method: "POST",\n                url: this.confProvPortalURL + "conferences",\n                headers: this.authService.getRequestHeader(),\n                data: {\n                    confUserId: confUserId,\n                    name: name\n                },\n            })\n                .then((response) => {\n                let conferenceData = response.data.data;\n                let conference = this.Conference.createFromData(conferenceData);\n                if (conferenceData.hasOwnProperty("id")) {\n                    this.pstnConferenceEndpoints[conferenceData.id] = conference;\n                }\n                this.$log.info("[PstnConferenceService] createInstantConference successfully");\n                resolve(conference);\n            }, (errorResponse) => {\n                let msg = errorResponse.data ? errorResponse.data.errorDetails : errorResponse.data;\n                let errorMessage = "createInstantConference failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method getConferenceSessionById\n    * @public\n    * @param {string} confId ID of conference to retrieve\n    * @returns {any} the conference session corresponding to the ID if there\'s one, undefined otherwise\n    * @memberof PstnConferenceService\n    */\n    getConferenceSessionById(confId) {\n        return this.conferenceSessions[confId];\n    }\n    /**\n    * Method getConferenceSessionForRoom\n    * @public\n    * @param {any[]} roomConfEndpoints array containing list of conference of room\n    * @returns {ng.IPromise<any>} a promise that resolves when snapshots are done\n    * @memberof PstnConferenceService\n    * Returns session for room if any\n    * */\n    getConferenceSessionForRoom(roomConfEndpoints) {\n        let pstnSession = null;\n        if (roomConfEndpoints && roomConfEndpoints.length) {\n            for (let i = 0; i < roomConfEndpoints.length; i++) {\n                if (roomConfEndpoints[i].mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                    pstnSession = this.conferenceSessions[roomConfEndpoints[i].confEndpointId];\n                }\n            }\n        }\n        return pstnSession;\n    }\n    /**\n    * Method removeConferenceSession\n    * @public\n    * @param {string} confId ID of conference to remove\n    * @memberof PstnConferenceService\n    */\n    removeConferenceSession(confId) {\n        if (!confId) {\n            return;\n        }\n        delete this.conferenceSessions[confId];\n    }\n    /**\n    * Method initiatesCallParticipant\n    * @public\n    * @param {string} confId [required] ID of conference to join\n    * @param {string} participantPhoneNumber [required] phone number to join\n    * @param {any} participant [required] {role, type} role: moderator or member. type: muted or unmuted\n    * @param {string} country [optional] Country where the called number is from. If not provided, the user\'s country is taken\n    * @returns {ng.IPromise<any>} a promise that resolves when joined or error\n    * @memberof PstnConferenceService\n    */\n    initiatesCallParticipant(confId, participantPhoneNumber, participant, country) {\n        this.$log.info("[PstnConferenceService] initiatesCallParticipant( confId=" + confId + ", PhoneNumber=" + participantPhoneNumber + ", role=" + participant.role + " country = " + country + " )");\n        if (!confId || !participantPhoneNumber) {\n            this.$log.error("[PstnConferenceService] initiatesCallParticipant - missing parameter");\n            return this.$q.reject();\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "POST",\n                url: this.confPortalURL + confId + "/join",\n                headers: this.authService.getPostHeader(),\n                data: { participantPhoneNumber: participantPhoneNumber, participant: participant, country: country },\n            })\n                .then((response) => {\n                let joinStatus = response.data.status;\n                this.$log.info("[PstnConferenceService] initiatesCallParticipant( confId=" + confId + ") success : " + joinStatus);\n                resolve();\n            }, (errorResponse) => {\n                let msg = errorResponse.data ? errorResponse.data.errorDetails : errorResponse.data;\n                let errorMessage = "initiatesCallParticipant( confId=" + confId + ") failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                let error = this.errorHelperService.handleError(errorResponse);\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method initiatesAudio\n    * @public\n    * @param {string} confId [required] ID of conference\n    * @returns {ng.IPromise<any>} a promise that resolves when conference is started or error\n    * @memberof PstnConferenceService\n    */\n    initiatesAudio(confId) {\n        this.$log.info("[PstnConferenceService] initiatesAudio( confId=" + confId + ")");\n        if (!confId) {\n            this.$log.error("[PstnConferenceService] initiatesAudio - missing parameter");\n            return this.$q.reject();\n        }\n        if (this.conferenceSessions[confId] && this.conferenceSessions[confId].isActive()) {\n            this.$log.info("[PstnConferenceService] initiatesAudio : conference already started");\n            return this.$q.resolve();\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "PUT",\n                url: this.confPortalURL + confId + "/start",\n                headers: this.authService.getRequestHeader()\n            })\n                .then(() => {\n                this.$log.info("[PstnConferenceService] initiatesAudio( confId=" + confId + ") successfully");\n                resolve();\n            }, (response) => {\n                let error = this.errorHelperService.handleError(response);\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method initiatesAudioRecording\n    * @public\n    * @param {string} confId [required] ID of conference\n    * @param {string} participantId [required] ID of participant\n    * @param {string} fileName\n    * @param {string} fileExtension\n    * @returns {ng.IPromise<any>} a promise that resolves recording is initiated or error\n    * @memberof PstnConferenceService\n    */\n    initiatesAudioRecording(confId, participantId, fileName, fileExtension) {\n        this.$log.info("[PstnConferenceService] initiatesAudioRecording( confId=" + confId + "participantId=" + participantId + "fileName=" + fileName + "fileExtension=" + fileExtension + ")");\n        if (!confId || !participantId) {\n            this.$log.error("[PstnConferenceService] initiatesAudioRecording - missing parameter");\n            return this.$q.reject();\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "POST",\n                url: this.confPortalURL + confId + "/participants/" + participantId + "/start-recording",\n                headers: this.authService.getPostHeader(),\n                data: { fileName: fileName, fileExtension: fileExtension },\n            })\n                .then(() => {\n                this.$log.info("[PstnConferenceService] initiatesAudioRecording( confId=" + confId + "participantId=" + participantId + ") successfully");\n                resolve();\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "initiatesAudioRecording( confId=" + confId + "participantId=" + participantId + ") failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method stopsAudioRecording\n    * @public\n    * @param {string} confId [required] ID of conference\n    * @param {string} participantId [required] ID of participant\n    * @returns {ng.IPromise<any>} a promise that resolves recording is initiated or error\n    * @memberof PstnConferenceService\n    */\n    stopsAudioRecording(confId, participantId) {\n        return this.$q((resolve, reject) => {\n            this.$log.info("[PstnConferenceService] stopsAudioRecording( confId=" + confId + "participantId=" + participantId + ")");\n            if (!confId || !participantId) {\n                this.$log.error("[PstnConferenceService] initiatesAudioRecording - missing parameter");\n                return this.$q.reject();\n            }\n            this.$http({\n                method: "POST",\n                url: this.confPortalURL + confId + "/participants/" + participantId + "/stop-recording",\n                headers: this.authService.getPostHeader()\n            })\n                .then(() => {\n                this.$log.info("[PstnConferenceService] stopsAudioRecording( confId=" + confId + "participantId=" + participantId + ") successfully");\n                resolve();\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "stopsAudioRecording( confId=" + confId + "participantId=" + participantId + ") failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method pausesAudioRecording\n    * @public\n    * @param {string} confId [required] ID of conference\n    * @param {string} participantId [required] ID of participant\n    * @returns {ng.IPromise<any>} a promise that resolves recording is paused or error\n    * @memberof PstnConferenceService\n    */\n    pausesAudioRecording(confId, participantId) {\n        return this.$q((resolve, reject) => {\n            this.$log.info("[PstnConferenceService] pausesAudioRecording( confId=" + confId + "participantId=" + participantId + ")");\n            if (!confId || !participantId) {\n                this.$log.error("[PstnConferenceService] pausesAudioRecording - missing parameter");\n                return this.$q.reject();\n            }\n            this.$http({\n                method: "POST",\n                url: this.confPortalURL + confId + "/participants/" + participantId + "/pause-recording",\n                headers: this.authService.getPostHeader()\n            })\n                // Handle success response\n                .then(() => {\n                this.$log.info("[PstnConferenceService] pausesAudioRecording( confId=" + confId + "participantId=" + participantId + ") successfully");\n                resolve();\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "pausesAudioRecording( confId=" + confId + "participantId=" + participantId + ") failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method pausesAudioRecording\n    * @public\n    * @param {string} confId [required] ID of conference\n    * @param {string} participantId [required] ID of participant\n    * @returns {ng.IPromise<any>} a promise that resolves recording is resumed or error\n    * @memberof PstnConferenceService\n    */\n    resumesAudioRecording(confId, participantId) {\n        return this.$q((resolve, reject) => {\n            this.$log.info("[PstnConferenceService] resumesAudioRecording( confId=" + confId + "participantId=" + participantId + ")");\n            if (!confId || !participantId) {\n                this.$log.error("[PstnConferenceService] resumesAudioRecording - missing parameter");\n                return this.$q.reject();\n            }\n            this.$http({\n                method: "POST",\n                url: this.confPortalURL + confId + "/participants/" + participantId + "/resume-recording",\n                headers: this.authService.getPostHeader()\n            })\n                .then(() => {\n                this.$log.info("[PstnConferenceService] resumesAudioRecording( confId=" + confId + "participantId=" + participantId + ") successfully");\n                resolve();\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "resumesAudioRecording( confId=" + confId + "participantId=" + participantId + ") failure: " + msg;\n                this.$log.error("[PstnConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method makeSnapshotForConfId\n    * @public\n    * @param {string} confId [required] the conferenceID of the conference we snapshot\n    * @returns {ng.IPromise<any>} a promise containing the result of the request or error\n    * @memberof PstnConferenceService\n    */\n    makeSnapshotForConfId(confId = null) {\n        if (!confId) {\n            let errorMsg = "[PstnConferenceService] makeSnapshotForConfId - No confId !!";\n            this.$log.error(errorMsg);\n            return this.$q.reject(errorMsg);\n        }\n        let confSession = this.conferenceSessions[confId];\n        if (confSession && confSession.active && confSession.haveJoined) {\n            this.$log.debug("[WebConferenceService] makeSnapshotForConfId skipped, already joined");\n            return this.$q.resolve(confSession);\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.confPortalURL + confId + "/snapshot?mediaType=pstnAudio",\n                headers: this.authService.getRequestHeader()\n            }).then((response) => {\n                this.$log.info("[PstnConferenceService] makeSnapshotForConfId success for confId " + confId);\n                let snapshotData = response.data;\n                this.updateOrCreateConferenceSession(confId, snapshotData);\n                resolve(snapshotData["data"]);\n            })\n                .catch((errorResponse) => {\n                this.$log.info("[PstnConferenceService] makeSnapshotForConfId failure for confID " + confId);\n                if (errorResponse.status === 404) {\n                    this.$log.error("[PstnConferenceService] makeSnapshotForConfId - confId " + confId + " not found on server");\n                }\n                else {\n                    this.$log.error("[PstnConferenceService] makeSnapshotForConfId - inconsistent object on server");\n                    // TODO : popup error ?\n                }\n                // Cleanup conferenceSession stored if we have one\n                if (this.conferenceSessions[confId]) {\n                    this.removeConferenceSession(confId);\n                }\n                reject();\n            });\n        });\n    }\n    /**\n    * Method refreshConferenceSessions\n    * @public Method re refreshes all the conferenceSessions stored inside the service by doing a snapshot on them\n    * @returns {ng.IPromise<any>} a promise containing the result of the request or error\n    * @memberof PstnConferenceService\n    */\n    refreshConferenceSessions() {\n        this.$log.info("[PstnConferenceService] refreshConferenceSessions");\n        return this.$q((resolve, reject) => {\n            let promiseArray = [];\n            for (let key in this.conferenceSessions) {\n                if (this.conferenceSessions.hasOwnProperty(key)) {\n                    let conferenceSession = this.conferenceSessions[key];\n                    promiseArray.push(this.makeSnapshotForConfId(conferenceSession.id));\n                }\n            }\n            this.$q.all(promiseArray)\n                .then(() => {\n                this.$log.info("[PstnConferenceService] refreshConferenceSessions -- success");\n                resolve();\n            })\n                .catch(() => {\n                this.$log.error("[PstnConferenceService] refreshConferenceSessions -- error -- cleaning up all sessions");\n                this.removeAllConferenceSessions();\n                reject();\n            });\n        });\n    }\n    getConferenceSessionWithConnId(connId) {\n        this.$log.info("[PstnConferenceService] getConferenceSessionWithConnId with connId : " + connId);\n        for (let key in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(key)) {\n                let conferenceSession = this.conferenceSessions[key];\n                if (conferenceSession && conferenceSession.callId === connId) {\n                    return conferenceSession;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n    * Method subscribeToPstnSession\n    * @public\n    * @async\n    * @param {string} confId [required] ID of conference to join\n    * @returns {Promise<any>} a promise that resolves when joined or error\n    * @memberof PstnConferenceService\n    */\n    subscribeToPstnSession(confId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info("[PstnConferenceService] subscribeToPstnSession( confId=" + confId + " )");\n            if (!confId) {\n                const error = new Error("[PstnConferenceService] subscribeToPstnSession - missing parameter");\n                this.$log.error(error.message);\n                throw (error);\n            }\n            try {\n                let response = yield this.$http({\n                    method: "POST",\n                    url: this.confPortalURL + confId + "/join",\n                    headers: this.authService.getPostHeader(),\n                    data: {\n                        participantPhoneNumber: "joinWithoutAudio",\n                        participant: { role: "member", type: "unmuted" },\n                        mediaType: this.MEDIATYPE.PSTNAUDIO\n                    },\n                });\n                const joinStatus = response.data.status;\n                this.$log.info("[PstnConferenceService] subscribeToPstnSession( confId=" + confId + ") success : " + joinStatus);\n                return confId;\n            }\n            catch (error) {\n                let e = error;\n                // Handle $http errors\n                if (error && error.data) {\n                    e = this.errorHelperService.handleError(error);\n                    this.$log.error("[PstnConferenceService] subscribeToPstnSession - " + e.message);\n                }\n                // Other errors are rethrown\n                throw (e);\n            }\n        });\n    }\n    /**\n    * Method unSubscribeParticipantFromPstnSession\n    * @public\n    * @async\n    * @param {string} confId [required] ID of conference to join\n    * @param {string} participantId [required] ID of the participant to unsubscribe\n    * @returns {ng.IPromise<any>} a promise that resolves when joined or error\n    * @memberof PstnConferenceService\n    */\n    unSubscribeParticipantFromPstnSession(confId, participantId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.$log.info("[PstnConferenceService] unSubscribeParticipantFromPstnSession( confId=" + confId + " - participantId=" + participantId + ")");\n            if (!confId || !participantId) {\n                const error = new Error("[PstnConferenceService] unSubscribeParticipantFromPstnSession - missing parameter");\n                this.$log.error(error.message);\n                throw (error);\n            }\n            try {\n                yield this.$http({\n                    method: "DELETE",\n                    url: this.confPortalURL + confId + "/participants/" + participantId + "?mediaType=" + this.MEDIATYPE.PSTNAUDIO,\n                    headers: this.authService.getPostHeader()\n                });\n                this.$log.info("[PstnConferenceService] unSubscribeParticipantFromPstnSession( confId=" + confId + ") success");\n            }\n            catch (error) {\n                let e = error;\n                // Handle $http errors\n                if (error && error.data) {\n                    e = this.errorHelperService.handleError(error);\n                    this.$log.error("[PstnConferenceService] unSubscribeParticipantFromPstnSession - " + e.message);\n                }\n                // Other errors are rethrown\n                throw (e);\n            }\n        });\n    }\n    /**\n    * Method removeAllConferenceSessions\n    * @private Method removes all conferenceSessions stored in the service\n    * @memberof PstnConferenceService\n    */\n    removeAllConferenceSessions() {\n        this.$log.info("[PstnConferenceService] removeAllConferenceSessions");\n        for (let key in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(key)) {\n                this.removeConferenceSession(key);\n            }\n        }\n    }\n}\nPstnConferenceService.$inject = [\n    "$q",\n    "$rootScope",\n    "$log",\n    "$http",\n    "authService",\n    "errorHelperService",\n    "ConferenceSession",\n    "profileService",\n    "xmppService",\n    "countryService",\n    "Conference",\n    "contactService",\n    "$translate",\n    "conferenceUserFactory"\n];\nangular.module("rainbow").service("pstnConferenceService", PstnConferenceService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/conference/pstnConferenceService.ts?')},function(module,exports,__webpack_require__){eval('/**\n * @ngdoc service\n * @module rainbow\n * @name WebConferenceService\n * @requires $q\n * @requires $log\n * @requires $http\n * @description Rainbow webConferenceService provides SFU services\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/// <reference path="../serviceInterface.ts" />\n/// <reference path="../../models/common/httpResult.ts" />\nclass WebConferenceService {\n    /************************************************************/\n    /** LIFECYCLE STUFF                                        **/\n    /************************************************************/\n    constructor($q, $rootScope, $log, $http, uuid4, $interval, authService, xmppService, videoService, roomService, errorHelperService, ConferenceSession, contactService, platformService, Conference, profileService) {\n        this.$q = $q;\n        this.$rootScope = $rootScope;\n        this.$log = $log;\n        this.$http = $http;\n        this.uuid4 = uuid4;\n        this.$interval = $interval;\n        this.authService = authService;\n        this.xmppService = xmppService;\n        this.videoService = videoService;\n        this.roomService = roomService;\n        this.errorHelperService = errorHelperService;\n        this.ConferenceSession = ConferenceSession;\n        this.contactService = contactService;\n        this.platformService = platformService;\n        this.Conference = Conference;\n        this.profileService = profileService;\n        this.MEDIATYPE = {\n            WEBRTC: "webrtc",\n            WEBRTCSHARINGONLY: "webrtcSharingOnly"\n        };\n        this.started = false;\n        this.webConferenceRoom = null;\n        this.webrtcConferenceId = null;\n        this.webrtcSharingOnlyRoom = null;\n        this.webrtcSharingOnlyConferenceId = null;\n        this.jingleJid = null;\n        this.makingCall = false;\n        this.connected = false;\n        this.disconnecting = false;\n        this.reconnecting = false;\n        this.audioProfileChanging = false;\n        // SFU data accessed from conferenceService\n        this.conferenceEndpoints = {};\n        this.attachLocalMediaStream = (attach, conferenceSession) => {\n            if (attach) {\n                if (conferenceSession.hasLocalVideo) {\n                    let session = conferenceSession.sessions[conferenceSession.localVideoSessionId];\n                    if (session) {\n                        let stream = conferenceSession.localStreams[session.localStreamId];\n                        this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#conferenceVideoPip"), stream, session.sid);\n                        this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#conferenceVideoPipSmall"), stream, session.sid);\n                    }\n                }\n                if (conferenceSession.hasLocalSharing) {\n                    let session = conferenceSession.sessions[conferenceSession.localSharingSessionId];\n                    if (session) {\n                        let stream = conferenceSession.localStreams[session.localStreamId];\n                        this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#conferenceSharingPip"), stream, session.sid);\n                    }\n                }\n            }\n            else {\n                this.videoService.RTC.clearMediaStream(angular.element("#minivideo"), null);\n            }\n        };\n    }\n    start(stats) {\n        return this.$q((resolve) => {\n            let startDate = performance.now();\n            this.$log.info("[WebConferenceService] === STARTING ===");\n            this.confProvPortalURL = config.restServerUrl + "/api/rainbow/confprovisioning/v1.0/";\n            this.confPortalURL = config.restServerUrl + "/api/rainbow/conference/v1.0/conferences/";\n            this.conferenceEndpoints = {};\n            this.conferenceSessions = {};\n            this.listeners = [];\n            this.statsIntervals = [];\n            this.connected = true;\n            this.disconnecting = false;\n            this.webConferenceRoom = null;\n            this.webrtcConferenceId = null;\n            this.webrtcSharingOnlyRoom = null;\n            this.webrtcSharingOnlyConferenceId = null;\n            this.jingleJid = null;\n            this.makingCall = false;\n            this.videoGalleryElements = [];\n            this.attachHandlers();\n            //by default, we\'ve 4 gallery videos elements\n            this.videoGalleryElementsNumber = 4;\n            this.started = true;\n            let startDuration = Math.round(performance.now() - startDate);\n            stats.push({ service: "WebConferenceService", startDuration: startDuration });\n            this.$log.info("[WebConferenceService] === STARTED (" + startDuration + " ms) ===");\n            resolve();\n        });\n    }\n    stop() {\n        this.$log.info("[WebConferenceService] === STOPPING ===");\n        this.started = false;\n        this.makingCall = false;\n        if (this.listeners) {\n            this.listeners.forEach((listenerDestroy) => {\n                listenerDestroy();\n            });\n        }\n        this.$log.info("[WebConferenceService] === STOPPED ===");\n        return this.$q.when();\n    }\n    attachHandlers() {\n        this.listeners.push(this.$rootScope.$on("ON_INPUT_DEVICE_CHANGED_EVENT", () => {\n            this.onAudioProfileChangeEvent();\n        }));\n        this.listeners.push(this.$rootScope.$on("ON_CONNECTION_STATE_CHANGE_EVENT", (event, status) => {\n            this.$log.info("[WebConferenceService] onConnectionStateChangeEvent : " + status);\n            try {\n                if (status === "disconnected") {\n                    this.$log.info("[WebConferenceService] onConnectionStateChangeEvent : disconnected");\n                    this.connected = false;\n                }\n                else if (status === "connected") {\n                    this.$log.info("[WebConferenceService] onConnectionStateChangeEvent : connected");\n                    this.connected = true;\n                    for (let key in this.conferenceSessions) {\n                        if (this.conferenceSessions.hasOwnProperty(key)) {\n                            let conferenceSession = this.conferenceSessions[key];\n                            if (conferenceSession.status === "reconnecting") {\n                                for (let sessId in conferenceSession.sessions) {\n                                    if (conferenceSession.sessions.hasOwnProperty(sessId)) {\n                                        let session = conferenceSession.sessions[sessId];\n                                        //if main audio session, should send transport-replace \n                                        if (session.localType === "audio") {\n                                            //send transport replace   \n                                            this.sendTransportReplaceForSession(session, 10000);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                this.$log.info("[WebConferenceService] onConnectionStateChangeEvent error : " + error);\n            }\n        }));\n    }\n    /**\n    * Method retrieveWebConferences\n    * @public\n    * @param {string} mediaType mediaType of conference to retrieve. Default: this.MEDIATYPE.WEBRTC\n    * @returns {ng.IPromise<any>} a promise that resolves when conference are reterived\n    * @memberof WebConferenceService\n    */\n    retrieveWebConferences(mediaType = this.MEDIATYPE.WEBRTC) {\n        this.$log.info("[WebConferenceService] retrieveWebConferences with mediaType=" + mediaType);\n        return this.$q((resolve, reject) => {\n            if (!this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.WEBRTC_CONFERENCE_ALLOWED) && mediaType !== this.MEDIATYPE.WEBRTCSHARINGONLY) {\n                this.$log.warn("[WebConferenceService] retrieveWebConferences - user is not allowed");\n                reject(new Error("notAllowed"));\n                return;\n            }\n            let urlQueryParameters = "?format=full&userId=" + this.contactService.userContact.dbId;\n            if (angular.isDefined(mediaType)) {\n                urlQueryParameters += "&mediaType=" + mediaType;\n            }\n            this.$http({\n                method: "GET",\n                url: this.confProvPortalURL + "conferences" + urlQueryParameters,\n                headers: this.authService.getRequestHeader()\n            })\n                // Handle success response\n                .then((response) => {\n                let conferencesProvisionData = response.data.data;\n                this.$log.info("[WebConferenceService] retrieveWebConferences successfully");\n                resolve(conferencesProvisionData);\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "retrieveWebConferences failure: " + msg;\n                this.$log.error("[WebConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    ;\n    /**\n    * Method updateConference\n    * @public\n    * @param {string} confEndpointId ID of conference to update\n    * @param {any} confData data to update conference with\n    * @returns {ng.IPromise<any>} a promise that resolve when conference is updated\n    * @memberof WebConferenceService\n    */\n    updateConference(confEndpointId, confData) {\n        this.$log.info("[WebConferenceService] updateConference");\n        return this.$q((resolve, reject) => {\n            if (confEndpointId) {\n                this.$http({\n                    method: "PUT",\n                    url: this.confProvPortalURL + "conferences/" + confEndpointId,\n                    headers: this.authService.getRequestHeader(),\n                    data: confData\n                })\n                    .then((response) => {\n                    let conferenceData = response.data.data;\n                    let conference = this.Conference.createFromData(conferenceData);\n                    if (conferenceData.hasOwnProperty("id")) {\n                        if (this.conferenceEndpoints[conferenceData.id]) {\n                            delete this.conferenceEndpoints[conferenceData.id];\n                        }\n                        this.conferenceEndpoints[conferenceData.id] = conference;\n                    }\n                    this.$log.info("[WebConferenceService] updateConference successfully");\n                    resolve(conference);\n                }, (response) => {\n                    let msg = response.data ? response.data.errorDetails : response.data;\n                    let errorMessage = "updateConference failure: " + msg;\n                    this.$log.error("[WebConferenceService] " + errorMessage);\n                    reject(new Error(errorMessage));\n                });\n            }\n            else {\n                let errorMessage = "updateConference failure: No confEndpoint";\n                this.$log.error("[WebConferenceService] updateConference failure : No confEndpoint");\n                reject(new Error(errorMessage));\n            }\n        });\n    }\n    createVideoGalleryElements() {\n        this.videoGalleryElements = [];\n        for (let i = 1; i <= this.videoGalleryElementsNumber; i++) {\n            let obj = {\n                state: "free",\n                sessionId: "",\n                id: "videoGallery_" + i,\n                publisherId: "",\n                publisherJid: "",\n                subStreamLevel: null\n            };\n            this.videoGalleryElements.push(obj);\n        }\n    }\n    /**\n    * Method setVideoGalleryElementsNumber\n    * @public\n    * @param {Number} number [required] the number of gallery elements\n    * @memberof WebConferenceService\n    */\n    setVideoGalleryElementsNumber(number) {\n        this.videoGalleryElementsNumber = number;\n    }\n    /*******************************************************************/\n    /** ACCESSORS                                                       **/\n    /*******************************************************************/\n    getConferenceSessions() {\n        return this.conferenceSessions;\n    }\n    getConferenceEndpoints() {\n        return this.conferenceEndpoints;\n    }\n    addConferenceEndpoint(conferenceEndpointId, conferenceEndpoint) {\n        if (!conferenceEndpointId) {\n            this.$log.warn("[WebConferenceService] addConferenceEndpoint - missing conferenceEndpointId");\n            return;\n        }\n        this.conferenceEndpoints[conferenceEndpointId] = conferenceEndpoint;\n        return;\n    }\n    /*******************************************************************/\n    /** ACTION FUNCTIONS                                              **/\n    /*******************************************************************/\n    getConferenceIdToUse(room, mediaType = this.MEDIATYPE.WEBRTC) {\n        let webPontConferenceId = this.getPontConfIdForRoom(room, mediaType);\n        if (webPontConferenceId) {\n            return webPontConferenceId;\n        }\n        switch (mediaType) {\n            case this.MEDIATYPE.WEBRTC:\n                if (room.isUserModerator(this.contactService.userContact) && this.webrtcConferenceId) {\n                    return this.webrtcConferenceId;\n                }\n                break;\n            case this.MEDIATYPE.WEBRTCSHARINGONLY:\n                if (room.owner && this.webrtcSharingOnlyConferenceId) {\n                    return this.webrtcSharingOnlyConferenceId;\n                }\n                break;\n            default:\n                break;\n        }\n        return "";\n    }\n    isMyConference(conferenceId) {\n        return conferenceId && ((this.webrtcConferenceId && conferenceId === this.webrtcConferenceId) || (this.webrtcSharingOnlyConferenceId && conferenceId === this.webrtcSharingOnlyConferenceId));\n    }\n    /**\n    * Method startOrJoinWebConference\n    * @public\n    * @param {any} room [required] the room associted to this web conference\n    * @returns {ng.IPromise<{}>} structure containing the response data from server\n    * @memberof WebConferenceService\n    */\n    startOrJoinWebConference(room) {\n        return this.$q((resolve, reject) => {\n            if (!room) {\n                let error = new Error("[webConferenceService] startOrJoinWebConference error - missing parameters for room");\n                this.$log.error(error.message);\n                reject(error);\n                return;\n            }\n            let webPontConferenceId = this.getConferenceIdToUse(room, this.MEDIATYPE.WEBRTC);\n            if (!webPontConferenceId) {\n                let error = new Error("[webConferenceService] startOrJoinWebConference error - no available pont conference");\n                this.$log.error(error.message);\n                reject(error);\n                return;\n            }\n            this.$log.info("[WebConferenceService] startOrJoinWebConference -- " + webPontConferenceId);\n            if (this.makingCall) {\n                this.$log.warn("[webConferenceService] already starting a conference");\n                return this.$q.resolve();\n            }\n            this.makingCall = true;\n            this.makeSnapshotForConfId(webPontConferenceId, this.MEDIATYPE.WEBRTC)\n                .then(() => {\n                let conferenceSession = this.conferenceSessions[webPontConferenceId];\n                if (!this.isMyConference(webPontConferenceId) && (!conferenceSession || !conferenceSession.active)) {\n                    let error = new Error("[webConferenceService] startOrJoinWebConference error - no active conference to join");\n                    this.$log.error(error.message);\n                    reject(error);\n                    this.makingCall = false;\n                    return;\n                }\n                let role = this.isMyConference(webPontConferenceId) ? "moderator" : "member";\n                if (!conferenceSession || !conferenceSession.active) {\n                    resolve(this.startWebConference(room, webPontConferenceId));\n                    return;\n                }\n                //hide popup if still present\n                this.$rootScope.$broadcast("ON_CONFERENCE_ENDED_INVITATION", room);\n                //join on the pont conf attached to the room\n                resolve(this.joinWebConference(webPontConferenceId, role));\n                return;\n            }, () => {\n                this.makingCall = false;\n                let error = new Error("[webConferenceService] startOrJoinWebConference error on snapshot");\n                this.$log.error(error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method startOrJoinSharingOnlyConference\n    * @public\n    * @param {any} room [required] the room associted to this web conference\n    * @returns {ng.IPromise<{}>} structure containing the response data from server\n    * @memberof WebConferenceService\n    */\n    startOrJoinSharingOnlyConference(room) {\n        return this.$q((resolve, reject) => {\n            if (!room) {\n                let error = new Error("[webConferenceService] startOrJoinSharingOnlyConference error - missing parameters for room");\n                this.$log.error(error.message);\n                reject(error);\n                return;\n            }\n            let webPontConferenceId = this.getConferenceIdToUse(room, this.MEDIATYPE.WEBRTCSHARINGONLY);\n            if (!webPontConferenceId) {\n                let error = new Error("[webConferenceService] startOrJoinSharingOnlyConference error - no available pont conference");\n                this.$log.error(error.message);\n                reject(error);\n                return;\n            }\n            this.makeSnapshotForConfId(webPontConferenceId, this.MEDIATYPE.WEBRTCSHARINGONLY)\n                .then(() => {\n                let conferenceSession = this.conferenceSessions[webPontConferenceId];\n                if (!this.isMyConference(webPontConferenceId) && (!conferenceSession || !conferenceSession.active)) {\n                    let error = new Error("[webConferenceService] startOrJoinSharingOnlyConference error - no active conference to join");\n                    this.$log.error(error.message);\n                    reject(error);\n                    return;\n                }\n                let role = this.isMyConference(webPontConferenceId) ? "moderator" : "member";\n                if (!conferenceSession || !conferenceSession.active) {\n                    resolve(this.startSharingOnlyConference(room, webPontConferenceId));\n                    return;\n                }\n                //hide popup if still present\n                this.$rootScope.$broadcast("ON_CONFERENCE_ENDED_INVITATION", room);\n                //join on the pont conf attached to the room\n                resolve(this.joinSharingOnlyConference(webPontConferenceId, role, false));\n                return;\n            }, () => {\n                let error = new Error("[webConferenceService] startOrJoinSharingOnlyConference error on snapshot");\n                this.$log.error(error.message);\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method startWebConference\n    * @public\n    * @param {any} room [required] the room associtaed to this web conference\n    * @param {string} webPontConferenceId [required] the conferenceEndpointId to start\n    * @param {boolean} shouldSnapshotBeforeStart [optional] whether or not we should do a snapshot before starting\n    * @returns {ng.IPromise<any>} structure containing the response data from server\n    * @memberof WebConferenceService\n    */\n    startWebConference(room, webPontConferenceId, shouldSnapshotBeforeStart = false) {\n        if (!webPontConferenceId || !room) {\n            this.$log.error("[startWebConference] No webPontConferenceId or Room!");\n            this.$rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", {\n                popupTitle: "startConference",\n                popupBody: "startMeetingFailure",\n                okLabel: "ok"\n            });\n            return this.$q.reject();\n        }\n        this.makingCall = true;\n        this.$log.info("[webConferenceService] startWebConference wtih ID " + webPontConferenceId);\n        return this.$q((resolve) => {\n            if (shouldSnapshotBeforeStart) {\n                this.$log.debug("[webConferenceService] startWebConference - trigger snapshot for " + webPontConferenceId);\n                resolve(this.makeSnapshotForConfId(webPontConferenceId, this.MEDIATYPE.WEBRTC));\n            }\n            else {\n                resolve();\n            }\n        })\n            .then(() => {\n            // No need to start if conference is already active\n            if (this.conferenceSessions[webPontConferenceId].active) {\n                this.$log.info("[webConferenceService] startWebConference - No need to start an already active conference");\n                return this.joinWebConference(webPontConferenceId, "moderator", false);\n            }\n            this.conferenceSessions[webPontConferenceId].status = "ringing";\n            this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", this.conferenceSessions[webPontConferenceId]);\n            return this.$http({\n                method: "PUT",\n                url: this.confPortalURL + webPontConferenceId + "/start",\n                headers: this.authService.getRequestHeader(),\n                data: {\n                    mediaType: this.MEDIATYPE.WEBRTC,\n                    roomId: room.dbId\n                }\n            }).then(() => {\n                this.$log.info("[webConferenceService] startWebConference - success -- now joining the conference");\n                return this.joinWebConference(webPontConferenceId, "moderator", false);\n            }, \n            // Else handle error \n            (errorResponse) => {\n                this.makingCall = false;\n                this.$log.error("[webConferenceService] startWebConference wtih ID " + webPontConferenceId + " failure ... -- " + this.errorHelperService.getErrorFullMessage(errorResponse));\n                this.leaveWebConference(webPontConferenceId);\n                this.removeConferenceSession(webPontConferenceId);\n                this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT");\n                throw (this.errorHelperService.handleError(errorResponse));\n            });\n        })\n            .catch((err) => {\n            this.makingCall = false;\n            let errorMsg = "[webConferenceService] startWebConference - error on server, can\'t start conference -- ";\n            let msg = "startMeetingFailure";\n            if (err) {\n                if (err.errorDetailsCode === 403620) {\n                    msg = "startMeetingConflict";\n                }\n                if (err.errorDetailsLabel) {\n                    errorMsg += err.errorDetailsLabel;\n                }\n            }\n            this.$log.error(errorMsg);\n            this.$rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", {\n                popupTitle: "startConference",\n                popupBody: msg,\n                okLabel: "ok"\n            });\n            return this.$q.reject(err);\n        });\n    }\n    /**\n    * Method startSharingOnlyConference\n    * @public\n    * @param {any} room [required] the room associtaed to this web conference\n    * @param {string} webPontConferenceId [required] the conferenceEndpointId to start\n    * @param {string} role [optional] the role of the participant starting. Default: "moderator"\n    * @param {boolean} shouldJoin [optional] Whether join should be done after start. Default: true\n    * @returns {ng.IPromise<any>} structure containing the response data from server\n    * @memberof WebConferenceService\n    */\n    startSharingOnlyConference(room, webPontConferenceId, shouldJoin = true) {\n        if (this.makingCall) {\n            this.$log.warn("[webConferenceService] already starting a conference");\n            return this.$q.resolve();\n        }\n        if (!webPontConferenceId || !room) {\n            this.$log.error("[startSharingOnlyConference] No webPontConferenceId or Room!");\n            return this.$q.reject();\n        }\n        this.makingCall = true;\n        this.$log.info("[webConferenceService] startSharingOnlyConference wtih ID " + webPontConferenceId);\n        return this.makeSnapshotForConfId(webPontConferenceId, this.MEDIATYPE.WEBRTCSHARINGONLY)\n            .then(() => {\n            // No need to start if conference is already active\n            if (this.conferenceSessions[webPontConferenceId].active) {\n                this.$log.info("[webConferenceService] startSharingOnlyConference - No need to start an already active conference");\n                if (shouldJoin) {\n                    return this.$q.resolve(this.joinSharingOnlyConference(webPontConferenceId, "moderator", false));\n                }\n                else {\n                    return this.$q.resolve();\n                }\n            }\n            this.conferenceSessions[webPontConferenceId].status = "ringing";\n            this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", this.conferenceSessions[webPontConferenceId]);\n            let url = this.confPortalURL + webPontConferenceId + "/start";\n            return this.$q((resolve, reject) => {\n                this.$http({\n                    method: "PUT",\n                    url: url,\n                    headers: this.authService.getRequestHeader(),\n                    data: {\n                        mediaType: this.MEDIATYPE.WEBRTCSHARINGONLY,\n                        roomId: room.dbId\n                    }\n                })\n                    .then(() => {\n                    if (shouldJoin) {\n                        return this.joinSharingOnlyConference(webPontConferenceId, "moderator", false)\n                            .then(() => {\n                            resolve();\n                        });\n                    }\n                    else {\n                        resolve();\n                    }\n                }, (errorResponse) => {\n                    this.makingCall = false;\n                    this.$log.error("[webConferenceService] startSharingOnlyConference wtih ID " + webPontConferenceId + " failure ... -- " + this.errorHelperService.getErrorFullMessage(errorResponse));\n                    this.leaveWebConference(webPontConferenceId);\n                    this.removeConferenceSession(webPontConferenceId);\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT");\n                    reject(this.errorHelperService.handleError(errorResponse));\n                });\n            });\n        })\n            .catch((error) => {\n            this.makingCall = false;\n            this.$log.error("[webConferenceService] startSharingOnlyConference - error on server, can\'t start conference");\n            return this.$q.reject(error);\n        });\n    }\n    /**\n    * Method joinWebConference\n    * @public\n    * @param {string} webPontConferenceId [required] the conferenceEndpointId to join\n    * @param {string} role [required] the role of the participant starting\n    * @memberof WebConferenceService\n    */\n    joinWebConference(webPontConferenceId, role, shouldSnapshotBeforeJoin = false) {\n        this.$log.info("[webConferenceService] joinWebConference with ID " + webPontConferenceId + " and role " + role);\n        if (!webPontConferenceId) {\n            this.$log.error("[webConferenceService] joinWebConference - No webPontConferenceId !");\n            return this.$q.reject();\n        }\n        return this.$q((resolve) => {\n            if (shouldSnapshotBeforeJoin) {\n                this.$log.debug("[webConferenceService] joinWebConference - trigger snapshot for " + webPontConferenceId);\n                resolve(this.makeSnapshotForConfId(webPontConferenceId, this.MEDIATYPE.WEBRTC));\n            }\n            else {\n                resolve();\n            }\n        })\n            .then(() => {\n            return this.$q((resolve, reject) => {\n                this.makingCall = true;\n                this.createVideoGalleryElements();\n                this.conferenceSessions[webPontConferenceId].videoGallery = this.videoGalleryElements;\n                if (this.conferenceSessions[webPontConferenceId].status !== "ringing") {\n                    this.conferenceSessions[webPontConferenceId].status = "ringing";\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", this.conferenceSessions[webPontConferenceId]);\n                }\n                let id = "web_" + this.uuid4.generate();\n                let muted = "unmuted";\n                let url = this.confPortalURL + webPontConferenceId + "/join";\n                let params = { participant: { role: role, type: muted }, mediaType: this.MEDIATYPE.WEBRTC };\n                //get the user media before making JOIN to the conference\n                this.getUserMediaForSession(webPontConferenceId)\n                    .then((sessId) => {\n                    this.$http({ method: "POST", url: url, headers: this.authService.getRequestHeader(), data: params }).then((response) => {\n                        let data = response.data.data;\n                        this.jingleJid = data["jingleJid"];\n                        this.initCall(this.jingleJid, webPontConferenceId, id, this.MEDIATYPE.WEBRTC);\n                        this.conferenceSessions[webPontConferenceId].haveJoined = true;\n                        this.makingCall = false;\n                        resolve();\n                    }, (errorResponse) => {\n                        if (errorResponse) {\n                            let msg = errorResponse.data ? errorResponse.data.errorDetails : errorResponse.data;\n                            let errorMessage = "joinWebConference( confId=" + webPontConferenceId + ") failure: " + msg;\n                            this.$log.error("[conferenceService] " + errorMessage);\n                        }\n                        this.makingCall = false;\n                        let data = {\n                            popupTitle: "warning",\n                            popupBody: "joinMeetingFailure",\n                            okLabel: "ok"\n                        };\n                        if (errorResponse && errorResponse.data && errorResponse.data.errorDetailsCode === 403615) {\n                            data.popupBody = "maximumNumberConferenceParticipantsReach";\n                        }\n                        this.leaveWebConference(webPontConferenceId);\n                        delete this.conferenceSessions[webPontConferenceId];\n                        this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT");\n                        this.$rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", data);\n                        reject(this.errorHelperService.handleError(errorResponse));\n                    });\n                })\n                    .catch((reason) => {\n                    this.$log.error("[webConferenceService] joinWebConference - getUserMediaForSession reject -- " + reason);\n                    this.makingCall = false;\n                    if (reason !== "ignore") {\n                        this.leaveWebConference(webPontConferenceId);\n                    }\n                    reject();\n                });\n            });\n        })\n            .catch(() => {\n            this.makingCall = false;\n            this.$log.error("[webConferenceService] joinWebConference - error on server, can\'t join conference");\n            return this.$q.reject();\n        });\n    }\n    /**\n    * Method joinSharingOnlyConference\n    * @public\n    * @param {string} webPontConferenceId [required] the conferenceEndpointId to join\n    * @param {string} role [required] the role of the participant starting\n    * @param {boolean} shouldSnapshotBeforeJoin [optional] Whether or not method should do a snapshot before JOIN. Default: true.\n    * @memberof WebConferenceService\n    */\n    joinSharingOnlyConference(webPontConferenceId, role, shouldSnapshotBeforeJoin = true) {\n        this.$log.info("[webConferenceService] joinSharingOnlyConference with ID " + webPontConferenceId + " and role " + role);\n        if (!webPontConferenceId) {\n            this.$log.error("[webConferenceService] joinSharingOnlyConference - No webPontConferenceId !");\n            return this.$q.reject();\n        }\n        return this.$q((resolve) => {\n            if (shouldSnapshotBeforeJoin) {\n                this.$log.debug("[webConferenceService] joinSharingOnlyConference - trigger snapshot for " + webPontConferenceId);\n                resolve(this.makeSnapshotForConfId(webPontConferenceId, this.MEDIATYPE.WEBRTCSHARINGONLY));\n            }\n            else {\n                resolve();\n            }\n        })\n            .then(() => {\n            return this.$q((resolve, reject) => {\n                this.makingCall = true;\n                this.createVideoGalleryElements();\n                this.conferenceSessions[webPontConferenceId].videoGallery = this.videoGalleryElements;\n                if (this.conferenceSessions[webPontConferenceId].status !== "ringing") {\n                    this.conferenceSessions[webPontConferenceId].status = "ringing";\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", this.conferenceSessions[webPontConferenceId]);\n                }\n                let id = "web_" + this.uuid4.generate();\n                let muted = "muted";\n                let url = this.confPortalURL + webPontConferenceId + "/join";\n                let params = { participant: { role: role, type: muted }, mediaType: this.MEDIATYPE.WEBRTCSHARINGONLY };\n                this.$http({ method: "POST", url: url, headers: this.authService.getRequestHeader(), data: params }).then((response) => {\n                    let data = response.data.data;\n                    this.jingleJid = data["jingleJid"];\n                    this.$log.info("[webConferenceService] joinSharingOnlyConference with ID success - jingleJid: " + this.jingleJid);\n                    this.conferenceSessions[webPontConferenceId].jingleJid = this.jingleJid;\n                    this.conferenceSessions[webPontConferenceId].haveJoined = true;\n                    this.makingCall = false;\n                    resolve();\n                }, (errorResponse) => {\n                    if (errorResponse) {\n                        let msg = errorResponse.data ? errorResponse.data.errorDetails : errorResponse.data;\n                        let errorMessage = "joinSharingOnlyConference( confId=" + webPontConferenceId + ") failure: " + msg;\n                        this.$log.error("[conferenceService] " + errorMessage);\n                    }\n                    this.makingCall = false;\n                    let data = {\n                        popupTitle: "warning",\n                        popupBody: "joinMeetingFailure",\n                        okLabel: "ok"\n                    };\n                    if (errorResponse && errorResponse.data && errorResponse.data.errorDetailsCode === 403615) {\n                        data.popupBody = "maximumNumberConferenceParticipantsReach";\n                    }\n                    this.leaveWebConference(webPontConferenceId);\n                    delete this.conferenceSessions[webPontConferenceId];\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT");\n                    reject(this.errorHelperService.handleError(errorResponse));\n                });\n            });\n        })\n            .catch(() => {\n            this.makingCall = false;\n            this.$log.error("[webConferenceService] joinSharingOnlyConference - error on server, can\'t join conference");\n            return this.$q.reject();\n        });\n    }\n    /**\n    * Method stopWebConference\n    * @public\n    * @param room\n    * @returns {ng.IPromise<{}>}\n    * @memberof WebConferenceService\n    */\n    stopWebConference(room) {\n        return this.$q((resolve, reject) => {\n            if (!room) {\n                reject();\n            }\n            else {\n                let confId = room.getSFUConfEndpointId() ? room.getSFUConfEndpointId() : room.getSFUSharingConfEndpointId();\n                let url = this.confPortalURL + confId + "/stop";\n                this.$http({\n                    method: "PUT",\n                    url: url,\n                    headers: this.authService.getRequestHeader(),\n                    data: {\n                        mediaType: this.MEDIATYPE.WEBRTC,\n                        roomId: room.dbId\n                    }\n                }).then(() => { resolve(); }, (errorResponse) => { reject(this.errorHelperService.handleError(errorResponse)); });\n            }\n        });\n    }\n    /**\n    * Method getFreeVideoGalleryElement\n    * @public\n    * @returns any\n    * @memberof WebConferenceService\n    */\n    getFreeVideoGalleryElement(confId) {\n        this.$log.info("[webConferenceService] getFreeVideoGalleryElement " + confId);\n        let confSession = this.conferenceSessions[confId];\n        let result = null;\n        if (confSession) {\n            if (!confSession.videoGallery) {\n                this.createVideoGalleryElements();\n                confSession.videoGallery = this.videoGalleryElements;\n            }\n            for (let i = 0; i < confSession.videoGallery.length; i++) {\n                if (confSession.videoGallery[i].state === "free") {\n                    result = confSession.videoGallery[i];\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n    * Method askToAddSharingToConferenceSession\n    * @public\n    * @memberof WebConferenceService\n    * Used only on desktop application : choose which screen to share\n    */\n    askToAddSharingToConferenceSession(conversation, conferenceSession) {\n        let proceed = !this.videoService.askToAddSharing(conversation.id, "sharing");\n        //if TRUE, add sharing as we normally do; Else wait for centralizedService to call the function\n        if (proceed) {\n            this.addMediaToConferenceSession(conferenceSession, "sharing");\n        }\n    }\n    /**\n    * Method addMediaToConferenceSession\n    * @public\n    * @memberof WebConferenceService\n    * Add new Jingle session to existing ConferenceSession\n    */\n    addMediaToConferenceSession(conferenceSession, mediaType) {\n        if (!conferenceSession) {\n            return;\n        }\n        let mediaToGet = [mediaType];\n        let frameRate = 20;\n        if (mediaType !== "video") {\n            frameRate = 3;\n        }\n        if (mediaType === "sharing") {\n            this.contactService.setBusyState("dnd", "sharing");\n        }\n        this.$log.info("[webConferenceService] addMediaToConferenceSession to session " + conferenceSession.id + " with media " + mediaType);\n        this.videoService.getBrowserMedia(mediaToGet, 1920, 1080, frameRate)\n            .then((stream) => {\n            let streams = [stream];\n            let unifiedPlan = this.videoService.config.unifiedPlan;\n            let session = this.xmppService.connection.jingle.initiate(conferenceSession.jingleJid, this.xmppService.connection.jid, mediaType, streams, null, conferenceSession.id, null, unifiedPlan);\n            conferenceSession.sessions[session.sid] = session;\n            conferenceSession.localStreams.push(stream);\n            session.localStreamId = conferenceSession.localStreams.length - 1;\n            if (mediaType === "video") {\n                conferenceSession.hasLocalVideo = true;\n                conferenceSession.localVideoSessionId = session.sid;\n            }\n            else {\n                conferenceSession.hasLocalSharing = true;\n                conferenceSession.localSharingSessionId = session.sid;\n            }\n            this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n            //start getting stats for the session\n            this.videoService.callsStats[session.sid] = {};\n            this.updateStatisticsForSession(conferenceSession.id, session.sid);\n            this.statsIntervals.push(session.getStats(5000));\n        });\n    }\n    /**\n    * Method removeMediaFromConferenceSession\n    * @public\n    * @memberof WebConferenceService\n    * Remove Jingle session from existing ConferenceSession\n    */\n    removeMediaFromConferenceSession(conferenceSession, mediaType) {\n        if (!conferenceSession) {\n            return;\n        }\n        if (mediaType === "sharing") {\n            this.contactService.setBusyState("dnd", "audio");\n        }\n        if (conferenceSession.type === "webrtcSharingOnly") {\n            this.contactService.resetBusyState();\n        }\n        this.$log.info("[webConferenceService] removeMediaFromConferenceSession from session " + conferenceSession.id);\n        let sessionId = (mediaType === "video") ? conferenceSession.localVideoSessionId : conferenceSession.localSharingSessionId;\n        if (conferenceSession.sessions[sessionId]) {\n            let session = conferenceSession.sessions[sessionId];\n            //update the stats for the session before removing\n            this.updateStatisticsForSession(conferenceSession.id, sessionId);\n            this.videoService.disableAudioVideoMedia(session);\n            this.xmppService.connection.jingle.terminate(session.sid);\n            delete conferenceSession.sessions[sessionId];\n            delete conferenceSession.localStreams[session.localStreamId];\n            delete this.videoService.callsStats[sessionId];\n            if (mediaType === "video") {\n                conferenceSession.hasLocalVideo = false;\n                conferenceSession.localVideoSessionId = null;\n            }\n            else {\n                conferenceSession.hasLocalSharing = false;\n                conferenceSession.localSharingSessionId = null;\n            }\n        }\n        this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n    }\n    ;\n    /**\n    * Method dropRemoteVideoSession\n    * @public\n    * @memberof WebConferenceService\n    * Remove Remote Jingle video session from existing ConferenceSession\n    */\n    dropRemoteVideoSession(conferenceSession, sessionId) {\n        if (!conferenceSession) {\n            return;\n        }\n        this.$log.info("[webConferenceService] dropRemoteVideoSession fom conference " + conferenceSession.id + " and session " + sessionId);\n        if (conferenceSession.sessions[sessionId]) {\n            let session = conferenceSession.sessions[sessionId];\n            //update the stats for the session before removing\n            this.updateStatisticsForSession(conferenceSession.id, sessionId);\n            this.xmppService.connection.jingle.terminate(session.sid);\n            delete conferenceSession.sessions[sessionId];\n            delete this.videoService.callsStats[sessionId];\n        }\n        this.removeSessionFromVideoGallery(conferenceSession, sessionId);\n        this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n    }\n    /**\n    * Method getUserMediaForSession\n    * @private\n    * @memberof WebConferenceService\n    * Gets user media and adds it to the conference session\n    */\n    getUserMediaForSession(webPontConferenceId) {\n        return this.$q((resolve, reject) => {\n            let conference = this.conferenceSessions[webPontConferenceId];\n            if (!conference) {\n                reject();\n                return;\n            }\n            conference.status = "ringing";\n            conference.haveJoined = true;\n            this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conference);\n            let mediaToGet = ["audio"];\n            this.videoService.getBrowserMedia(mediaToGet)\n                .then((stream) => {\n                this.$log.info("[webConferenceService] getUserMediaForSession -- sucess");\n                let conf = this.conferenceSessions[webPontConferenceId];\n                if (!conf || conf.status === "ended") {\n                    this.$log.info("[webConferenceService] getUserMediaForSession -- missing conference");\n                    //conference does not exist anymore, stop stream\n                    this.disableMediaStream(stream);\n                    reject("conference does not exist anymore");\n                    return;\n                }\n                //conference exists, but we\'re already in the call -- ignore this get user media\n                if (!this.makingCall) {\n                    this.$log.info("[webConferenceService] getUserMediaForSession -- already in the conference -- ignore");\n                    this.disableMediaStream(stream);\n                    reject("ignore");\n                    return;\n                }\n                let streams = [stream];\n                conf.localStreams = streams;\n                resolve();\n            })\n                .catch(() => {\n                this.$log.error("[webConferenceService] getUserMediaForSession error -- getUserMedia failed");\n                let data = {\n                    popupTitle: "warning",\n                    popupBody: "devicePermission",\n                    okLabel: "ok"\n                };\n                this.$rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", data);\n                reject("failed to get user media");\n            });\n        });\n    }\n    /**\n    * Method disableMediaStream\n    * @private\n    * @memberof WebConferenceService\n    * Disables and clears a MediaStream object\n    */\n    disableMediaStream(stream) {\n        if (stream) {\n            stream.getTracks().forEach((track) => {\n                track.enabled = false;\n                track.stop();\n                track = null;\n            });\n            if (stream.stop) {\n                stream.stop();\n            }\n            stream = null;\n        }\n    }\n    /**\n    * Method initCall\n    * @private\n    * @memberof WebConferenceService\n    * Make Jingle audio call to join conference\n    */\n    initCall(jid, webPontConferenceId, callId, type) {\n        let conference = this.conferenceSessions[webPontConferenceId];\n        return this.$q((resolve) => {\n            if (!conference) {\n                // retrieve the conference session from server if not existing (should not happen that often)\n                this.$log.warn("[webConferenceService] initCall - no conferenceSession as though we are trying to init call");\n                resolve(this.makeSnapshotForConfId(webPontConferenceId, type));\n            }\n            resolve();\n        })\n            .then(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.videoService.setWebrtcConfiguration().catch(() => {\n                this.$log.error("[webConferenceService] initCall - setWebrtcConfiguration failed");\n            });\n            let unifiedPlan = this.videoService.config ? this.videoService.config.unifiedPlan : false;\n            let session = this.xmppService.connection.jingle.initiate(jid, this.xmppService.connection.jid, "audio", conference.localStreams, callId, webPontConferenceId, null, unifiedPlan);\n            conference.jingleJid = jid;\n            conference.sessions[session.sid] = session;\n            conference.status = "ringing";\n            //get statistics for the audio session\n            this.createStatisticsForSession(webPontConferenceId, session.sid);\n            this.statsIntervals.push(session.getStats(5000));\n            // this.$rootScope.$broadcast("ON_WEB_CONFERENCE_UPDATE_EVENT", conference);\n            this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conference);\n        }));\n    }\n    /**\n    * Method muteAudio\n    * @public\n    * @memberof WebConferenceService\n    * Mute audio (locally)\n    */\n    muteAudio(conversation, state) {\n        if (!conversation.webConferenceSession) {\n            this.$log.info("[webConferenceService] muteAudio trying to mute a non existing session ");\n            return;\n        }\n        for (let property in conversation.webConferenceSession.sessions) {\n            if (conversation.webConferenceSession.sessions.hasOwnProperty(property)) {\n                let session = conversation.webConferenceSession.sessions[property];\n                session.muteAudio(state);\n            }\n        }\n        conversation.isMutedAudio = state;\n        this.$rootScope.$broadcast("ON_CONVERSATION_CALL_MUTED_UPDATED_EVENT", {\n            conversation: conversation\n        });\n    }\n    ;\n    /**\n     * Method createStatisticsForSession\n     * @public\n     * @param {string} webConfId [required] the id of the conference\n     * @param {string} sessionId [required] the session id related to the conference\n     * @memberof WebConferenceService\n     * Creates a new entry for metrics on the server related to this session\n     */\n    createStatisticsForSession(webConfId, sessionId) {\n        this.$log.info("[webConferenceService] createStatisticsForSession for conf " + webConfId + " and session " + sessionId);\n        if (!webConfId || !sessionId) {\n            this.$log.warn("[webConferenceService] createStatisticsForSession -- missing parameters");\n            return;\n        }\n        this.videoService.callsStats[sessionId] = {};\n        let metrics = [];\n        metrics.push({ connectionId: sessionId, stats: this.videoService.callsStats[sessionId] });\n        this.videoService.createStatisticsForSession(webConfId, webConfId, "pending", metrics)\n            .then((id) => {\n            this.$log.info("[webConferenceService] createStatisticsForSession success " + id);\n            this.videoService.callsStats[sessionId].id = id;\n            this.conferenceSessions[webConfId].metricsId = id;\n            this.conferenceSessions[webConfId].metricsState = "pending";\n        })\n            .catch((error) => {\n            this.$log.error("[webConferenceService] createStatisticsForSession error for conf " + webConfId);\n        });\n    }\n    ;\n    /**\n     * Method updateStatisticsForSession\n     * @public\n     * @param {string} webConfId [required] the id of the conference\n     * @param {string} sessionId [required] the session id related to the conference\n     * @memberof WebConferenceService\n     * Updates the metrics for the given session which is part of the conference\n     */\n    updateStatisticsForSession(webConfId, sessionId) {\n        this.$log.info("[webConferenceService] updateStatisticsForSession for conf " + webConfId + " and session " + sessionId);\n        if (!webConfId || !sessionId) {\n            this.$log.warn("[webConferenceService] updateStatisticsForSession -- missing parameters");\n            return;\n        }\n        let webConference = this.conferenceSessions[webConfId];\n        if (!webConference || !webConference.metricsId) {\n            this.$log.warn("[webConferenceService] updateStatisticsForSession -- missing webConference or no metricsId");\n            return;\n        }\n        if (!webConference.metricsState) {\n            webConference.metricsState = "pending";\n        }\n        let metrics = [];\n        //check if statistics already exist\n        if (this.videoService.callsStats[sessionId]) {\n            metrics.push({ connectionId: sessionId, stats: this.videoService.callsStats[sessionId] });\n            this.videoService.updateStatisticsForCall(webConference.metricsId, webConfId, webConfId, webConference.metricsState, metrics);\n            return;\n        }\n    }\n    /**\n     * Method leaveWebConference\n     * @public\n     * @param {string} confId [required] the id of the conference to stop\n     * @memberof WebConferenceService\n     */\n    leaveWebConference(confId) {\n        this.$log.info(`[WebConferenceService] leaveWebConference - ${confId}`);\n        this.contactService.resetBusyState();\n        if (!confId) {\n            return;\n        }\n        let webConference = this.conferenceSessions[confId];\n        if (!webConference) {\n            this.$log.warn("[WebConferenceService] leaveWebConference - webConference does not exist");\n            return;\n        }\n        webConference.metricsState = "ended";\n        for (let property in webConference.sessions) {\n            if (webConference.sessions.hasOwnProperty(property)) {\n                let session = webConference.sessions[property];\n                //update the metrics for the conference\n                this.updateStatisticsForSession(webConference.id, session.sid);\n                this.videoService.disableAudioVideoMedia(session);\n                this.xmppService.connection.jingle.terminate(session.sid);\n                delete this.videoService.callsStats[session.sid];\n            }\n        }\n        webConference.cleanupSessionData();\n        this.createVideoGalleryElements();\n        webConference.videoGallery = this.videoGalleryElements;\n        webConference.sessions = {};\n        //clear all stats intervals\n        let statsInterval;\n        while (this.statsIntervals.length) {\n            statsInterval = this.statsIntervals.pop();\n            if (statsInterval) {\n                window.clearInterval(statsInterval);\n                statsInterval = null;\n            }\n        }\n        this.makingCall = false;\n        this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", webConference);\n        this.videoService.clearSrcObjectsFromElements();\n    }\n    /*******************************************************************/\n    /** HELPER FUNCTIONS                                              **/\n    /*******************************************************************/\n    attachDistantMediaStream(attach, conferenceSession) {\n        if (attach) {\n            let sessions = this.getRemoteVideoSessions(conferenceSession.id);\n            this.updateMainSessionIfNeeded(sessions);\n            this.$log.info("[WebConferenceService] attachDistantMediaStream for session " + conferenceSession.id);\n            let remoteSharingSession = this.getRemoteSharingSession(conferenceSession.id);\n            if (remoteSharingSession) {\n                remoteSharingSession.remoteStreams.forEach((track) => {\n                    if (track.getVideoTracks().length > 0) {\n                        this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), track, remoteSharingSession.sid);\n                    }\n                });\n                //unified plan\n                if (remoteSharingSession.remoteStreamsObject["0"]) {\n                    this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), remoteSharingSession.remoteStreamsObject["0"], remoteSharingSession.sid);\n                }\n            }\n            if (sessions.length) {\n                for (let sessionId in sessions) {\n                    if (sessions.hasOwnProperty(sessionId)) {\n                        if (sessions[sessionId].remoteStreams) {\n                            sessions[sessionId].remoteStreams.forEach((track) => {\n                                if (track.getVideoTracks().length > 0) {\n                                    if (!remoteSharingSession && sessions[sessionId].mainSession) {\n                                        this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), track, sessions[sessionId].sid);\n                                    }\n                                    //attach gallery videos\n                                    for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                                        if (conferenceSession.videoGallery[i].sessionId === sessions[sessionId].sid) {\n                                            this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#" + conferenceSession.videoGallery[i].id), track, conferenceSession.videoGallery[i].sessionId);\n                                            break;\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                        if (sessions[sessionId].remoteStreamsObject["0"]) {\n                            if (!remoteSharingSession && sessions[sessionId].mainSession) {\n                                this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), sessions[sessionId].remoteStreamsObject["0"], sessions[sessionId].sid);\n                            }\n                            //attach gallery videos\n                            for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                                if (conferenceSession.videoGallery[i].sessionId === sessions[sessionId].sid) {\n                                    this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#" + conferenceSession.videoGallery[i].id), sessions[sessionId].remoteStreamsObject["0"], conferenceSession.videoGallery[i].sessionId);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            let audioSession = this.getRemoteAudioSession(conferenceSession.id);\n            if (audioSession && audioSession.remoteStreams) {\n                audioSession.remoteStreams.forEach((track) => {\n                    if (track.getAudioTracks().length > 0) {\n                        this.videoService.RTC.attachMediaStream(angular.element("#globalAudioTag"), track);\n                    }\n                });\n            }\n            //audio session unified plan\n            if (audioSession && audioSession.remoteStreamsObject["0"]) {\n                this.videoService.RTC.attachMediaStream(angular.element("#globalAudioTag"), audioSession.remoteStreamsObject["0"]);\n            }\n        }\n    }\n    attachMainMediaStream(session) {\n        if (session) {\n            this.$log.info("[webConferenceService] attachMainMediaStream");\n            //show on big screen\n            session.remoteStreams.forEach((track) => {\n                if (track.getVideoTracks().length > 0) {\n                    //put sharing to big screen\n                    this.videoService.RTC.attachMediaStreamIfNeeded(angular.element("#largevideo"), track, session.sid);\n                }\n            });\n        }\n    }\n    updateMainSessionIfNeeded(sessions) {\n        this.$log.info("[webConferenceService] updateMainSessionIfNeeded");\n        if (sessions && sessions.length) {\n            let firstSession = null;\n            let shouldUpdateMainScreen = true;\n            for (let property in sessions) {\n                if (sessions.hasOwnProperty(property)) {\n                    if (!firstSession) {\n                        firstSession = sessions[property];\n                    }\n                    if (sessions[property].mainSession) {\n                        shouldUpdateMainScreen = false;\n                    }\n                }\n            }\n            if (shouldUpdateMainScreen) {\n                firstSession.mainSession = true;\n            }\n        }\n    }\n    /**\n    * Method getRelatedRoomToActiveConferenceSession\n    * @public\n    * @returns {any} the room object related to the active conference session or null if not found\n    * @memberof WebConferenceService\n    */\n    getRelatedRoomToActiveConferenceSession() {\n        return this.webConferenceRoom;\n    }\n    /**\n    * Method getRelatedRoomToActiveSharingOnlyConferenceSession\n    * @public\n    * @returns {any} the room object related to the active sharing only conference session or null if not found\n    * @memberof WebConferenceService\n    */\n    getRelatedRoomToActiveSharingOnlyConferenceSession() {\n        return this.webrtcSharingOnlyRoom;\n    }\n    /**\n    * Method getConferenceBySessionId\n    * @private\n    * @returns {any} the webConference object or null if not found\n    * @memberof WebConferenceService\n    */\n    getConferenceBySessionId(sessionId) {\n        let result = null;\n        for (let webConference in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(webConference) && this.conferenceSessions[webConference].sessions) {\n                for (let session in this.conferenceSessions[webConference].sessions) {\n                    if (this.conferenceSessions[webConference].sessions.hasOwnProperty(session)) {\n                        if (this.conferenceSessions[webConference].sessions[session].sid === sessionId) {\n                            result = this.conferenceSessions[webConference];\n                            return result;\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n    * Method getPontConfIdForRoom\n    * @private\n    * @memberof WebConferenceService\n    */\n    getPontConfIdForRoom(room, mediaType = this.MEDIATYPE.WEBRTC) {\n        if (room.confEndpoints && room.confEndpoints.length) {\n            for (let i = 0; i < room.confEndpoints.length; i++) {\n                if (room.confEndpoints[i].mediaType === mediaType) {\n                    return room.confEndpoints[i].confEndpointId;\n                }\n            }\n        }\n        return "";\n    }\n    getConferenceSessionById(confId) {\n        return this.conferenceSessions[confId];\n    }\n    getSfuConferenceSessionForRoom(room) {\n        var confSession = null;\n        if (room) {\n            confSession = this.conferenceSessions[room.getSFUConfEndpointId()];\n        }\n        return confSession;\n    }\n    updateWebConferenceInfos(endpoints) {\n        this.$log.info("[WebConferenceService] updateWebConferenceInfos");\n        // Get webConference info\n        Object.assign(this.conferenceEndpoints, endpoints);\n        this.webrtcConferenceId = this.getWebRtcConfEndpointId();\n        if (this.webrtcConferenceId) {\n            this.roomService.getRoomByConferenceEndpointId(this.webrtcConferenceId)\n                .then((conferenceRoom) => {\n                let name = "nothing";\n                if (conferenceRoom) {\n                    name = conferenceRoom.name;\n                }\n                this.webConferenceRoom = conferenceRoom;\n                this.$log.info("[WebConferenceService] === updateWebConferenceInfos : webrtcConferenceId is currently attached to " + name);\n            }, () => {\n                this.$log.info("[WebConferenceService] === updateWebConferenceInfos FAILURE ===");\n            });\n        }\n    }\n    updateWebSharingOnlyConferenceInfos(endpoints) {\n        this.$log.info("[WebConferenceService] updateWebSharingOnlyConferenceInfos");\n        // Get webConference info\n        Object.assign(this.conferenceEndpoints, endpoints);\n        this.webrtcSharingOnlyConferenceId = this.getWebRtcSharingOnlyConfEndpointId();\n        if (this.webrtcSharingOnlyConferenceId) {\n            this.roomService.getRoomByConferenceEndpointId(this.webrtcSharingOnlyConferenceId)\n                .then((conferenceRoom) => {\n                let name = conferenceRoom && conferenceRoom.name ? conferenceRoom.name : "nothing";\n                this.webrtcSharingOnlyRoom = conferenceRoom;\n                this.$log.info("[WebConferenceService] === updateWebSharingOnlyConferenceInfos : webrtcSharingOnlyConferenceId is currently attached to " + name);\n            }, () => {\n                this.$log.info("[WebConferenceService] === updateWebSharingOnlyConferenceInfos FAILURE ===");\n            });\n        }\n    }\n    updateWebConferenceRoom() {\n        this.webrtcConferenceId = this.getWebRtcConfEndpointId();\n        return this.$q((resolve, reject) => {\n            this.roomService.getRoomByConferenceEndpointId(this.webrtcConferenceId)\n                .then((conferenceRoom) => {\n                let name = "nothing";\n                if (conferenceRoom) {\n                    name = conferenceRoom.name;\n                }\n                this.webConferenceRoom = conferenceRoom;\n                this.$log.info("[WebConferenceService] === updateWebConferenceRoom : room is currently attached to " + name);\n                resolve();\n            }, () => {\n                this.$log.info("[WebConferenceService] === updateWebConferenceRoom FAILURE===");\n                reject();\n            });\n        });\n    }\n    /**\n    * Method getWebRtcConfEndpointId\n    * @public\n    * @returns {string} the user unique webrtc conference enpoint id\n    * @memberof WebConferenceService\n    */\n    getWebRtcConfEndpointId() {\n        for (let property in this.conferenceEndpoints) {\n            if (this.conferenceEndpoints.hasOwnProperty(property) && this.conferenceEndpoints[property].mediaType === this.MEDIATYPE.WEBRTC) {\n                return this.conferenceEndpoints[property].id;\n            }\n        }\n        return null;\n    }\n    /**\n    * Method getWebRtcSharingOnlyConfEndpointId\n    * @public\n    * @returns {string} the user unique webrtcSharingOnly  conference enpoint id\n    * @memberof WebConferenceService\n    */\n    getWebRtcSharingOnlyConfEndpointId() {\n        for (let property in this.conferenceEndpoints) {\n            if (this.conferenceEndpoints.hasOwnProperty(property) && this.conferenceEndpoints[property].mediaType === this.MEDIATYPE.WEBRTCSHARINGONLY) {\n                return this.conferenceEndpoints[property].id;\n            }\n        }\n        return null;\n    }\n    /**\n    * Method isJoinWebConferenceAllowed\n    * @public\n    * @returns {boolean} true if user is allowed to join a web conference\n    * @memberof WebConferenceService\n    */\n    isJoinWebConferenceAllowed() {\n        return true;\n        // return this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.WEBRTC_PARTICIPANT_ALLOWED);\n    }\n    /**\n     * Method getWebConference\n     * @public\n     * @param {string} confId [required] the id of the conference to get\n     * @returns {any} the webConference (if exists)\n     * @memberof WebConferenceService\n     */\n    getWebConference(confId) {\n        // Return the static conference !\n        if (!confId) {\n            return;\n        }\n        return this.conferenceSessions[confId];\n    }\n    /**\n     * Method removeConferenceSession\n     * @public\n     * @param {string} confId [required] the id of the conference to remove\n     * @memberof WebConferenceService\n     */\n    removeConferenceSession(confId) {\n        if (!confId) {\n            return;\n        }\n        this.removeAllJingleSessionsForConferenceSession(confId);\n        delete this.conferenceSessions[confId];\n        // Remove statsIntervals\n        let statsInterval;\n        while (this.statsIntervals.length) {\n            statsInterval = this.statsIntervals.pop();\n            if (statsInterval) {\n                this.$interval.cancel(statsInterval);\n                statsInterval = null;\n            }\n        }\n        this.makingCall = false;\n    }\n    ;\n    /**\n     * Method removeAllJingleSessionsForConferenceSession\n     * @public\n     * @param {string} confId [required] the id of the conference to remove\n     * @memberof WebConferenceService\n     */\n    removeAllJingleSessionsForConferenceSession(confId) {\n        if (!confId) {\n            return;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            conferenceSession.metricsState = "ended";\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let session = conferenceSession.sessions[property];\n                    //update the metrics related to the conference\n                    this.updateStatisticsForSession(conferenceSession.id, session.sid);\n                    delete this.videoService.callsStats[session.sid];\n                    this.videoService.disableAudioVideoMedia(session);\n                    this.xmppService.connection.jingle.terminate(session.sid);\n                }\n            }\n            conferenceSession.sessions = [];\n        }\n    }\n    ;\n    /**\n     * Method hasActiveConferenceSession\n     * @public\n     * @returns {boolean} Return true if user is already in another webrtc conference\n     * @memberof WebConferenceService\n     */\n    hasActiveConferenceSession() {\n        for (let property in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(property)\n                && this.conferenceSessions[property].type === this.MEDIATYPE.WEBRTC\n                && this.conferenceSessions[property].isActive()\n                && this.conferenceSessions[property].haveJoined) {\n                return true;\n            }\n        }\n        return false;\n    }\n    ;\n    /**\n    * Method getActiveConferenceSession\n    * @public\n    * @returns {any} Returns active webrtc conference session if any\n    * @memberof WebConferenceService\n    */\n    getActiveConferenceSession() {\n        let result = null;\n        for (let property in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(property)\n                && this.conferenceSessions[property].type === this.MEDIATYPE.WEBRTC\n                && this.conferenceSessions[property].isActive()\n                && this.conferenceSessions[property].haveJoined) {\n                result = this.conferenceSessions[property];\n            }\n        }\n        return result;\n    }\n    ;\n    /**\n     * Method hasActiveSharingOnlyConferenceSession\n     * @public\n     * @returns {boolean} Return true if user is already in another sharing only conference\n     * @memberof WebConferenceService\n     */\n    hasActiveSharingOnlyConferenceSession() {\n        for (let property in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(property)\n                && this.conferenceSessions[property].type === this.MEDIATYPE.WEBRTCSHARINGONLY\n                && this.conferenceSessions[property].isActive()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    ;\n    /**\n    * Method getActiveSharingOnlyConferenceSession\n    * @public\n    * @returns {any} Returns active webrtc conference session if any\n    * @memberof WebConferenceService\n    */\n    getActiveSharingOnlyConferenceSession() {\n        let result = null;\n        for (let property in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(property)\n                && this.conferenceSessions[property].type === this.MEDIATYPE.WEBRTCSHARINGONLY\n                && this.conferenceSessions[property].isActive()) {\n                result = this.conferenceSessions[property];\n            }\n        }\n        return result;\n    }\n    ;\n    /**\n     * Method hasIncomingVideoStream\n     * @public\n     * @param {string} confId [required] the id of the conference\n     * @returns {boolean} Return true if one of the remote publishers is sending video/sharing\n     * @memberof WebConferenceService\n     */\n    hasIncomingVideoStream(confId) {\n        if (!confId) {\n            return;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let session = conferenceSession.sessions[property];\n                    if (!session.isInitiator && (session.remoteType === "video" || session.remoteType === "sharing")) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    ;\n    /**\n     * Method getRemoteSessionsWithVideoOrSharingStreams\n     * @public\n     * @param {string} confId [required] the id of the conference\n     * @returns {Array<any>} Return remote video sessions\n     * @memberof WebConferenceService\n     */\n    getRemoteSessionsWithVideoOrSharingStreams(confId) {\n        let result = [];\n        if (!confId) {\n            return result;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let session = conferenceSession.sessions[property];\n                    if (!session.isInitiator && (session.remoteType === "video" || session.remoteType === "sharing")) {\n                        result.push(session);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Method getRemoteSharingSession\n     * @public\n     * @param {string} confId [required] the id of the conference\n     * @returns {any} Return remote sharing session\n     * @memberof WebConferenceService\n     */\n    getRemoteSharingSession(confId) {\n        let result = null;\n        if (!confId) {\n            return result;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let session = conferenceSession.sessions[property];\n                    if (!session.isInitiator && session.remoteType === "sharing") {\n                        result = session;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Method getRemoteVideoSessions\n     * @public\n     * @param {string} confId [required] the id of the conference\n     * @returns {Array<any>} Return remote video sessions\n     * @memberof WebConferenceService\n     */\n    getRemoteVideoSessions(confId) {\n        let result = [];\n        if (!confId) {\n            return result;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let session = conferenceSession.sessions[property];\n                    if (!session.isInitiator && session.remoteType === "video") {\n                        result.push(session);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Method getRemoteAudioSession\n     * @public\n     * @param {string} confId [required] the id of the conference\n     * @returns {any} Return remote audio session\n     * @memberof WebConferenceService\n     */\n    getRemoteAudioSession(confId) {\n        let result;\n        if (!confId) {\n            return result;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let session = conferenceSession.sessions[property];\n                    if (session.localType === "audio") {\n                        result = session;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Method getRemoteMainVideoSession\n     * @public\n     * @param {string} confId [required] the id of the conference\n     * @returns {Array<any>} Return the main-screen remote video session\n     * @memberof WebConferenceService\n     */\n    getRemoteMainVideoSession(confId) {\n        let sess;\n        if (!confId) {\n            return sess;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let session = conferenceSession.sessions[property];\n                    if (!session.isInitiator && session.remoteType === "video" && session.mainSession) {\n                        sess = session;\n                        break;\n                    }\n                }\n            }\n        }\n        return sess;\n    }\n    /*******************************************************************/\n    /** VIDEO GALLERY                                                 **/\n    /*******************************************************************/\n    /**\n     * Method isAlreadySubscribedToPublisher\n     * @public\n     * @param {string} confId [required] the id of the conferenceSession\n     * @param {string} publisherId [required] the publisher ID\n     * @returns {Boolean} Return true if we\'ve already subscribed to publisher\n     * @memberof WebConferenceService\n     */\n    isAlreadySubscribedToPublisher(confId, publisherId) {\n        if (!confId || !publisherId) {\n            return false;\n        }\n        let result = false;\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession && conferenceSession.videoGallery) {\n            for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                if (conferenceSession.videoGallery[i].publisherId === publisherId) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Method relatePublisherToElement\n     * @public\n     * @param {string} confId [required] the id of the conferenceSession\n     * @param {string} publisher [required] the publisher to relate\n     * @param {string} elementId [required] the element ID\n     * @memberof WebConferenceService\n     */\n    relatePublisherToElement(confId, publisher, elementId) {\n        if (!confId || !publisher || !elementId) {\n            return false;\n        }\n        this.$log.info("[WebConferenceService] relatePublisherToElement");\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                if (conferenceSession.videoGallery[i].id === elementId) {\n                    conferenceSession.videoGallery[i].state = "busy";\n                    conferenceSession.videoGallery[i].publisherId = publisher.participantId;\n                    conferenceSession.videoGallery[i].publisherJidIm = publisher.jid_im;\n                    conferenceSession.videoGallery[i].displayName = publisher.participantId;\n                    let contact = this.contactService.getContactByJid(publisher.jid_im);\n                    if (contact) {\n                        conferenceSession.videoGallery[i].displayName = contact.displayName;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * Method getRelatedPublisherToElement\n     * @public\n     * @param {string} confId [required] the ID of the conference\n     * @param {string} elementId [required] the element ID\n     * @returns {any} publisher object related to the element, if any; null otherwise\n     * @memberof WebConferenceService\n     */\n    getRelatedPublisherToElement(confId, elementId) {\n        if (!confId || !elementId) {\n            return null;\n        }\n        this.$log.info("[WebConferenceService] getRelatedPublisherToElement");\n        let result = null;\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession && conferenceSession.videoGallery) {\n            for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                if (elementId === conferenceSession.videoGallery[i].id && conferenceSession.videoGallery[i].publisherId) {\n                    result = conferenceSession.videoGallery[i];\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Method getRelatedElementToPublisher\n     * @public\n     * @param {string} confId [required] the ID of the conference\n     * @param {string} publisherId [required] the ID of the publisher\n     * @returns {any} video gallery object, if any; null otherwise\n     * @memberof WebConferenceService\n     */\n    getRelatedElementToPublisher(confId, publisherId) {\n        if (!confId || !publisherId) {\n            return null;\n        }\n        this.$log.info("[WebConferenceService] getRelatedPublisherToElement");\n        let element = null;\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession && conferenceSession.videoGallery) {\n            for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                if (conferenceSession.videoGallery[i].publisherId === publisherId) {\n                    element = conferenceSession.videoGallery[i];\n                    break;\n                }\n            }\n        }\n        return element;\n    }\n    /**\n     * Method relateSessionToPublisher\n     * @public\n     * @param {string} confId [required] the id of the conferenceSession\n     * @param {string} publisherId [required] the publisher ID\n     * @param {string} sessionId [required] the session ID\n     * @memberof WebConferenceService\n     */\n    relateSessionToPublisher(confId, publisherId, sessionId) {\n        if (!confId || !publisherId || !sessionId) {\n            return;\n        }\n        this.$log.info("[WebConferenceService] relateSessionToPublisher pubId " + publisherId + " sessionId " + sessionId);\n        let conferenceSession = this.conferenceSessions[confId];\n        if (conferenceSession) {\n            for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                if (publisherId === conferenceSession.videoGallery[i].publisherId && !conferenceSession.videoGallery[i].sessionId) {\n                    conferenceSession.videoGallery[i].sessionId = sessionId;\n                    break;\n                }\n            }\n            this.$log.info(conferenceSession.videoGallery);\n        }\n    }\n    /**\n     * Method removeSessionFromVideoGallery\n     * @public\n     * @param {any} conferenceSession [required] the conference session\n     * @param {string} sessionId [required] the session ID\n     * @memberof WebConferenceService\n     */\n    removeSessionFromVideoGallery(conferenceSession, sessionId) {\n        if (!conferenceSession || !sessionId) {\n            return;\n        }\n        if (!conferenceSession.videoGallery) {\n            this.createVideoGalleryElements();\n            conferenceSession.videoGallery = this.videoGalleryElements;\n        }\n        this.$log.info("[WebConferenceService] removeSessionFromVideoGallery for conference " + conferenceSession.id + " sessionId " + sessionId);\n        for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n            if (conferenceSession.videoGallery[i].sessionId === sessionId) {\n                conferenceSession.videoGallery[i].sessionId = "";\n                conferenceSession.videoGallery[i].state = "free";\n                conferenceSession.videoGallery[i].publisherId = "";\n                conferenceSession.videoGallery[i].publisherJidIm = "";\n                conferenceSession.videoGallery[i].displayName = "";\n            }\n        }\n    }\n    /**\n     * Method reInitialiseVideoGalleryElementById\n     * @public\n     * @param {any} conferenceSession [required] the conference session\n     * @param {string} elementId [required] the ID of the video gallery element\n     * @memberof WebConferenceService\n     */\n    reInitialiseVideoGalleryElementById(conferenceSession, elementId) {\n        if (!conferenceSession || !elementId) {\n            return;\n        }\n        if (!conferenceSession.videoGallery) {\n            this.createVideoGalleryElements();\n            conferenceSession.videoGallery = this.videoGalleryElements;\n        }\n        this.$log.info("[WebConferenceService] reInitialiseVideoGalleryElementById for conference " + conferenceSession.id + " elementId " + elementId);\n        for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n            if (conferenceSession.videoGallery[i].id === elementId) {\n                if (conferenceSession.videoGallery[i].sessionId) {\n                    this.dropRemoteVideoSession(conferenceSession, conferenceSession.videoGallery[i].sessionId);\n                }\n                conferenceSession.videoGallery[i].sessionId = "";\n                conferenceSession.videoGallery[i].state = "free";\n                conferenceSession.videoGallery[i].publisherId = "";\n                conferenceSession.videoGallery[i].publisherJidIm = "";\n                conferenceSession.videoGallery[i].displayName = "";\n                conferenceSession.videoGallery[i].subStreamLevel = null;\n            }\n        }\n    }\n    /**\n     * Method updateMainScreenSession\n     * @public\n     * @param {string} confId [required] the ID of the conference\n     * @param {string} sessionId [required] the session ID to be updated\n     * @memberof WebConferenceService\n     */\n    updateMainScreenSession(confId, sessionId) {\n        if (!confId || !sessionId) {\n            return;\n        }\n        this.$log.info("[WebConferenceService] updateMainScreenSession");\n        let conferenceSession = this.conferenceSessions[confId];\n        let session = null;\n        if (conferenceSession) {\n            for (let property in conferenceSession.sessions) {\n                if (conferenceSession.sessions.hasOwnProperty(property)) {\n                    let sess = conferenceSession.sessions[property];\n                    if (sessionId === sess.sid) {\n                        sess.mainSession = true;\n                        session = sess;\n                    }\n                    else {\n                        sess.mainSession = false;\n                    }\n                }\n            }\n        }\n        if (session) {\n            this.attachMainMediaStream(session);\n        }\n    }\n    /**\n     * Method getListOfAvailableRemoteVideoPublishers\n     * @public\n     * @param {string} confId [required] the conf ID\n     * @returns {Array<any>} Return list of remote video available publishers\n     * @memberof WebConferenceService\n     */\n    getListOfAvailableRemoteVideoPublishers(confId) {\n        if (!confId) {\n            return;\n        }\n        this.$log.info("[WebConferenceService] getListOfAvailableRemoteVideoPublishers");\n        let conferenceSession = this.conferenceSessions[confId];\n        let publishers = [];\n        if (conferenceSession) {\n            if (!conferenceSession.videoGallery) {\n                this.createVideoGalleryElements();\n                conferenceSession.videoGallery = this.videoGalleryElements;\n            }\n            publishers = conferenceSession.getListOfRemoteVideoPublishers();\n            publishers = publishers.filter((publisher) => {\n                for (let i = 0; i < conferenceSession.videoGallery.length; i++) {\n                    if (conferenceSession.videoGallery[i].publisherId === publisher.participantId) {\n                        return false;\n                    }\n                }\n                let contact = this.contactService.getContactByJid(publisher.jid_im);\n                if (contact) {\n                    publisher.displayName = contact.displayName;\n                }\n                else {\n                    publisher.displayName = publisher.participantId;\n                }\n                return true;\n            });\n        }\n        return publishers;\n    }\n    sendTransportReplaceForSession(sess, timeout) {\n        if (!sess) {\n            this.$log.warn("[WebConferenceService] sendTransportReplaceForSession missing session !");\n            return;\n        }\n        if (this.reconnecting) {\n            this.$log.warn("[WebConferenceService] sendTransportReplaceForSession already reconnecting !");\n            return;\n        }\n        let that = this;\n        this.reconnecting = true;\n        if (!timeout) {\n            timeout = 1000;\n        }\n        //Delay load to avoid black screen\n        this.$interval((session) => {\n            that.reconnecting = false;\n            if (that.connected && session && session.peerconnection && session.peerconnection.signalingState === "stable" && (session.peerconnection.iceConnectionState === "failed" || session.peerconnection.iceConnectionState === "disconnected")) {\n                that.$log.info("[WebConferenceService] sendTransportReplaceForSession for session " + session.sid);\n                session.connection = that.xmppService.connection;\n                session.reconnectSession();\n            }\n            //set the state to busy in case we\'ve lost it during the loss of network\n            if (session.type !== that.MEDIATYPE.WEBRTCSHARINGONLY) {\n                var state = session.hasLocalSharing ? "sharing" : "audio";\n                that.contactService.setBusyState("dnd", state);\n            }\n        }, timeout, 1, true, sess);\n    }\n    // /**\n    //  * Method setSpeakerDevice\n    //  * @public\n    //  * @memberof WebConferenceService\n    //  */\n    // public setSpeakerDevice() {\n    //     if (this.platformService.allowDevicesManagement() && angular.element("#globalAudioTag").length) {\n    //         this.platformService.getCurrentSpeaker().then((device) => {\n    //             let result = "default";\n    //             if (device && device.id) {\n    //                 result = " id " + device.id + " and label " + device.label;\n    //                 this.platformService.setSpeakerForElement(angular.element("#globalAudioTag")[0], "default")\n    //                     .then(() => {\n    //                         this.platformService.setSpeakerForElement(angular.element("#globalAudioTag")[0], device.id);\n    //                     });\n    //             }\n    //             else {\n    //                 this.platformService.setSpeakerForElement(angular.element("#globalAudioTag")[0], "default");\n    //             }\n    //             this.$log.info("[WebConferenceService] setSpeakerDevice " + result);\n    //         });\n    //     }\n    // }\n    /*******************************************************************/\n    /** EVENT HANDLERS                                                **/\n    /*******************************************************************/\n    onAudioProfileChangeEvent() {\n        this.$log.info("[WebConferenceService] onAudioProfileChangeEvent");\n        if (this.audioProfileChanging) {\n            this.$log.info("[WebConferenceService] onAudioProfileChangeEvent -- already changing");\n            return;\n        }\n        for (let key in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(key)) {\n                let conferenceSession = this.conferenceSessions[key];\n                for (let sessId in conferenceSession.sessions) {\n                    if (conferenceSession.sessions.hasOwnProperty(sessId)) {\n                        let session = conferenceSession.sessions[sessId];\n                        //if main audio session, should send transport-replace \n                        if (session.localType === "audio") {\n                            //send transport replace   \n                            this.audioProfileChanging = true;\n                            this.$interval((sess) => {\n                                this.audioProfileChanging = false;\n                                let mediaToGet = ["audio"];\n                                this.videoService.getBrowserMedia(mediaToGet)\n                                    .then((stream) => {\n                                    sess.removeStream(sess.localStreams[0]);\n                                    this.videoService.stopActiveAudioVideoStreams(sess);\n                                    sess.localStreams.push(stream);\n                                    sess.addStream(sess.localStreams[0]);\n                                    sess.sendTransportReplace();\n                                });\n                            }, 500, 1, true, session);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    onJingleError(sessionId) {\n        this.$log.info("[WebConferenceService] onJingleError -- " + sessionId);\n        let webConference = this.getConferenceBySessionId(sessionId);\n        if (webConference && webConference.sessions) {\n            let session = webConference.sessions[sessionId];\n            //if main audio session, should stop the conference\n            if (session.localType === "audio") {\n                this.leaveWebConference(webConference.id);\n            }\n            else {\n                //update the metrics for the conference\n                this.updateStatisticsForSession(webConference.id, sessionId);\n                //if a local video or sharing session, remove the session\n                if (webConference.localVideoSessionId === sessionId) {\n                    this.removeMediaFromConferenceSession(webConference, "video");\n                }\n                else if (webConference.localSharingSessionId === sessionId) {\n                    this.removeMediaFromConferenceSession(webConference, "sharing");\n                }\n                else {\n                    //remove session from the video Gallery and send update event\n                    this.removeSessionFromVideoGallery(webConference, sessionId);\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", webConference);\n                }\n            }\n        }\n    }\n    /**\n     * Method onIceConnectionFailedForSession\n     * @public\n     * @param {any} conferenceSession [required] the conference session impacted\n     * @param {string} sessionId [required] the id of the session\n     * @memberof WebConferenceService\n     */\n    onIceConnectionFailedForSession(conferenceSession, sessionId) {\n        this.$log.info("[WebConferenceService] onIceConnectionFailedForSession -- " + sessionId);\n        if (conferenceSession && conferenceSession.sessions) {\n            let session = conferenceSession.sessions[sessionId];\n            //if main audio session, should send transport-replace \n            if (session.localType === "audio") {\n                conferenceSession.status = "reconnecting";\n                this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n                if (this.connected) {\n                    // if we still have an active connection, send transport-replace\n                    this.sendTransportReplaceForSession(session, 1000);\n                }\n            }\n            else {\n                //if a local video or sharing session, remove the session\n                if (conferenceSession.localVideoSessionId === sessionId) {\n                    this.removeMediaFromConferenceSession(conferenceSession, "video");\n                }\n                else if (conferenceSession.localSharingSessionId === sessionId) {\n                    this.removeMediaFromConferenceSession(conferenceSession, "sharing");\n                }\n                else {\n                    //update the stats for the session before removing\n                    this.updateStatisticsForSession(conferenceSession.id, sessionId);\n                    delete this.videoService.callsStats[sessionId];\n                    //remove session from the video Gallery and send update event\n                    this.removeSessionFromVideoGallery(conferenceSession, sessionId);\n                    delete conferenceSession.sessions[sessionId];\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n                }\n            }\n        }\n    }\n    ;\n    /**\n     * Method onIncomingCall\n     * @public\n     * @param {string} sessionId [required] the id of the session\n     * @memberof WebConferenceService\n     */\n    onIncomingCall(sessionId) {\n        this.$log.info("[WebConferenceService] onIncomingCall -- " + sessionId);\n        // let webConfId = this.getWebRtcConfEndpointId();\n        let session = this.xmppService.connection.jingle.sessions[sessionId];\n        let pontConfId = session.confId;\n        let conferenceSession = this.conferenceSessions[pontConfId];\n        if (!conferenceSession) {\n            this.$log.error("[WebConferenceService] onIncomingCall no such conferenceSession " + pontConfId);\n            return;\n        }\n        conferenceSession.sessions[sessionId] = session;\n        session.localType = session.remoteType;\n        session.sendAnswer();\n        session.accept();\n        if (session.publisherId && session.remoteType !== "sharing") {\n            this.relateSessionToPublisher(pontConfId, session.publisherId, session.sid);\n        }\n        this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n        //start getting stats for the session\n        this.videoService.callsStats[session.sid] = {};\n        this.updateStatisticsForSession(conferenceSession.id, session.sid);\n        this.statsIntervals.push(session.getStats(5000));\n    }\n    /**\n     * Method onTerminatedCall\n     * @public\n     * @param {string} sessionId [required] the id of the session\n     * @memberof WebConferenceService\n     */\n    onTerminatedCall(sessionId) {\n        this.$log.info("[WebConferenceService] onTerminatedCall -- " + sessionId);\n        //TO DO DNI :\n        //When we receive session-terminate for our audio session, we should drop the participant\n        //from the conference;\n        //This can happen in case of crash Janus, for example.\n        let session = this.xmppService.connection.jingle.sessions[sessionId];\n        if (!session) {\n            let conferenceSession = this.getActiveConferenceSession() ? this.getActiveConferenceSession() : this.getActiveSharingOnlyConferenceSession();\n            if (conferenceSession && conferenceSession.sessions) {\n                //update the stats for the session before removing\n                let sess = conferenceSession.sessions[sessionId];\n                if (sess) {\n                    conferenceSession.metricsState = "ended";\n                    this.updateStatisticsForSession(conferenceSession.id, sessionId);\n                }\n                //When stopping the session, should check if it\'s video / sharing and update the model\n                if (sess && sess.localType === "audio") {\n                    //the audio session has been cut, drop the participant from the conference\n                    this.leaveWebConference(conferenceSession.id);\n                }\n                else if (conferenceSession.localVideoSessionId === sessionId) {\n                    this.removeMediaFromConferenceSession(conferenceSession, "video");\n                }\n                else if (conferenceSession.localSharingSessionId === sessionId) {\n                    this.removeMediaFromConferenceSession(conferenceSession, "sharing");\n                }\n                else {\n                    this.removeSessionFromVideoGallery(conferenceSession, sessionId);\n                    this.videoService.disableAudioVideoMedia(conferenceSession.sessions[sessionId]);\n                    delete conferenceSession.sessions[sessionId];\n                    delete this.videoService.callsStats[sessionId];\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n                }\n            }\n            return;\n        }\n        let pontConfId = session.confId;\n        let conferenceSession = this.conferenceSessions[pontConfId];\n        if (!conferenceSession) {\n            this.$log.error("[WebConferenceService] onTerminatedCall no such conferenceSession " + pontConfId);\n            return;\n        }\n        //update the stats for the session before removing\n        this.updateStatisticsForSession(conferenceSession.id, sessionId);\n        //When stopping the session, should check if it\'s video / sharing and update the model\n        if (conferenceSession.localVideoSessionId === sessionId) {\n            this.removeMediaFromConferenceSession(conferenceSession, "video");\n        }\n        else if (conferenceSession.localSharingSessionId === sessionId) {\n            this.removeMediaFromConferenceSession(conferenceSession, "sharing");\n        }\n        else {\n            //remove session from the video Gallery and send update event\n            this.removeSessionFromVideoGallery(conferenceSession, sessionId);\n            this.videoService.disableAudioVideoMedia(session);\n            this.xmppService.connection.jingle.terminate(session.sid);\n            delete conferenceSession.sessions[session.sid];\n            delete this.videoService.callsStats[sessionId];\n            this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", conferenceSession);\n        }\n    }\n    /**\n     * Method onConferenceCallSwitched\n     * @public\n     * @param {string} sessionId [required] the id of the session\n     * @memberof WebConferenceService\n     */\n    onConferenceCallSwitched(sessionId) {\n        this.$log.info("[WebConferenceService] onConferenceCallSwitched -- " + sessionId);\n        let conferenceSession = this.getActiveConferenceSession();\n        if (conferenceSession) {\n            this.leaveWebConference(conferenceSession.id);\n        }\n    }\n    /**\n     * Method onIceConnectionStateChange\n     * @public\n     * @param {string} sessionId [required] the id of the session\n     * @param {any} session [required] the related session\n     * @memberof WebConferenceService\n     */\n    onIceConnectionStateChange(sessionId, session) {\n        this.$log.info("[WebConferenceService] onIceConnectionStateChange for session " + sessionId);\n        let webConference = this.getConferenceBySessionId(sessionId);\n        try {\n            if (webConference && session.peerconnection) {\n                if (session.peerconnection.signalingState === "stable" && session.peerconnection.iceConnectionState === "connected") {\n                    this.$log.info("[WebConferenceService] ICE Connection established successfully");\n                    webConference.status = "connected";\n                    if (session.remoteStreams) {\n                        session.remoteStreams.forEach((track) => {\n                            if (track.getAudioTracks().length > 0) {\n                                this.videoService.RTC.attachMediaStream(angular.element("#globalAudioTag"), track);\n                                this.videoService.resetAudioOutputElement(true);\n                            }\n                        });\n                    }\n                    //event for the call area... do we need 2 events ?\n                    this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", webConference);\n                    this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", webConference);\n                }\n                if (session.peerconnection.signalingState === "stable" && session.peerconnection.iceConnectionState === "completed") {\n                    this.$log.info("[WebConferenceService] ICE Connection completed successfully");\n                    if (webConference.status !== "connected") {\n                        webConference.status = "connected";\n                        if (session.remoteStreams) {\n                            session.remoteStreams.forEach((track) => {\n                                if (track.getAudioTracks().length > 0) {\n                                    this.videoService.RTC.attachMediaStream(angular.element("#globalAudioTag"), track);\n                                    this.videoService.resetAudioOutputElement(true);\n                                }\n                            });\n                        }\n                        //event for the call area... do we need 2 events ?\n                        this.$rootScope.$broadcast("ON_CONFERENCE_UPDATED_EVENT", webConference);\n                        this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", webConference);\n                    }\n                }\n                if (session.peerconnection.signalingState === "stable" && session.peerconnection.iceConnectionState === "disconnected") {\n                    this.$log.info("[WebConferenceService] ICE Connection State disconnected");\n                    this.onIceConnectionFailedForSession(webConference, sessionId);\n                }\n                if (session.peerconnection.signalingState === "stable" && session.peerconnection.iceConnectionState === "failed") {\n                    this.$log.info("[WebConferenceService] ICE Connection State failed");\n                    this.onIceConnectionFailedForSession(webConference, sessionId);\n                }\n            }\n        }\n        catch (error) {\n            this.$log.error("[WebConferenceService] onIceConnectionStateChange error " + error);\n        }\n    }\n    /**\n    * Method updateOrCreateConferenceSession\n    * @public\n    * @param {string} confId [required] the conferenceID of the conferenceSession we are updating or creating\n    * @param {any} snapshotData [required] snapshot data for the update / creation\n    * @param {string} type [optional] type conferenceEndpoint to snapshot (useful to create internal conferenceSesseion object)\n    * @returns {any} the updated conferenceSession or null on error\n    * @memberof WebConferenceService\n    */\n    updateOrCreateConferenceSession(confId, snapshotData, type = "webrtc") {\n        this.$log.debug("[webConferenceService] updateOrCreateConferenceSession for " + confId);\n        if (!confId || !snapshotData || !snapshotData.data) {\n            this.$log.error("[webConferenceService] updateOrCreateConferenceSession - Not enough data");\n            return null;\n        }\n        let conferenceSession = this.conferenceSessions[confId];\n        if (!conferenceSession) {\n            this.$log.debug("[webConferenceService] updateOrCreateConferenceSession - create new conferencesession with id " + confId + "and data: \\n" + JSON.stringify(snapshotData.data));\n            conferenceSession = this.ConferenceSession.createFromData(confId, [], snapshotData.data.active, type);\n            this.conferenceSessions[confId] = conferenceSession;\n            // Emit event to notify conference state data update\n            this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", conferenceSession);\n        }\n        else if (snapshotData.data.active !== conferenceSession.active) {\n            this.$log.debug( true ? "active" : undefined);\n            conferenceSession.updateActiveState(snapshotData.data.active);\n            // Emit event to notify conference state data update\n            this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", conferenceSession);\n        }\n        if (snapshotData.data.participants) {\n            this.$log.debug("[webConferenceService] updateOrCreateConferenceSession - (is active : " + conferenceSession.active + ") update participants for " + confId + " with:\\n" + JSON.stringify(snapshotData.data.participants));\n            // Note: we are not smart, we always update participants on update. \n            conferenceSession.updateParticipants(snapshotData.data.participants)\n                .then(() => {\n                this.$rootScope.$broadcast("ON_CONFERENCE_PARTICIPANT_EVENT", conferenceSession);\n            });\n        }\n        return conferenceSession;\n    }\n    /**\n    * Method updateOrCreateWebConferenceEndpoint\n    * @public\n    * @param {any} conferenceData [required] conference data for the update / creation\n    * @returns {any} the updated conferenceEndpoint or null on error\n    * @memberof WebConferenceService\n    */\n    updateOrCreateWebConferenceEndpoint(conferenceData) {\n        this.$log.info("[WebConferenceService] updateOrCreateWebConferenceEndpoint for " + conferenceData.id);\n        if (!conferenceData) {\n            this.$log.error("[WebConferenceService] updateOrCreateWebConferenceEndpoint - no conference data !");\n            return null;\n        }\n        if (conferenceData.mediaType !== this.MEDIATYPE.WEBRTC && conferenceData.mediaType !== this.MEDIATYPE.WEBRTCSHARINGONLY) {\n            this.$log.error("[WebConferenceService] updateOrCreateWebConferenceEndpoint - wrong mediaType:" + conferenceData.mediaType);\n            return null;\n        }\n        let conference = this.Conference.createFromData(conferenceData);\n        this.conferenceEndpoints[conferenceData.id] = conference;\n        if (conference.mediaType === this.MEDIATYPE.WEBRTC) {\n            this.updateWebConferenceInfos([conference]);\n        }\n        else {\n            this.updateWebSharingOnlyConferenceInfos([conference]);\n        }\n        return this.conferenceEndpoints[conferenceData.id];\n    }\n    /**\n    * Method makeSnapshotForConfId\n    * @public\n    * @param {string} confId [required] the conferenceID of the conference we snapshot\n    * @param {string} mediaType [required] real mediaType of snapshot (snapshot API only supports webrtc ...)\n    * @returns {ng.IPromise<any>} a promise containing the result of the request or error\n    * @memberof WebConferenceService\n    */\n    makeSnapshotForConfId(confId = null, mediaType) {\n        if (!confId) {\n            let errorMsg = "[webConferenceService] makeSnapshotForConfId - No confId !!";\n            this.$log.error(errorMsg);\n            return this.$q.reject(errorMsg);\n        }\n        let confSession = this.conferenceSessions[confId];\n        if (confSession && confSession.active && confSession.haveJoined) {\n            this.$log.debug("[WebConferenceService] makeSnapshotForConfId skipped, already joined");\n            return this.$q.resolve(confSession);\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "GET",\n                url: this.confPortalURL + confId + "/snapshot?mediaType=webrtc",\n                headers: this.authService.getRequestHeader()\n            }).then((response) => {\n                this.$log.info("[webConferenceService] makeSnapshotForConfId success for confId " + confId);\n                let snapshotData = response.data;\n                this.updateOrCreateConferenceSession(confId, snapshotData, mediaType);\n                resolve(snapshotData["data"]);\n            })\n                .catch((errorResponse) => {\n                this.$log.info("[webConferenceService] makeSnapshotForConfId failure for confID " + confId);\n                if (errorResponse.status === 404) {\n                    this.$log.error("[webConferenceService] makeSnapshotForConfId - confId " + confId + " not found on server");\n                }\n                else {\n                    this.$log.error("[webConferenceService] makeSnapshotForConfId - inconsistent object on server");\n                    // TODO : popup error ?\n                }\n                // Cleanup conferenceSession stored if we have one\n                if (this.conferenceSessions[confId]) {\n                    this.removeConferenceSession(confId);\n                }\n                reject();\n            });\n        });\n    }\n    /**\n    * Method refreshConferenceSessions\n    * @public Method re refreshes all the conferenceSessions stored inside the service by doing a snapshot on them\n    * @returns {ng.IPromise<any>} a promise containing the result of the request or error\n    * @memberof WebConferenceService\n    */\n    refreshConferenceSessions() {\n        this.$log.info("[webConferenceService] refreshConferenceSessions");\n        return this.$q((resolve, reject) => {\n            let promiseArray = [];\n            for (let key in this.conferenceSessions) {\n                if (this.conferenceSessions.hasOwnProperty(key)) {\n                    let conferenceSession = this.conferenceSessions[key];\n                    promiseArray.push(this.makeSnapshotForConfId(conferenceSession.id, conferenceSession.type));\n                }\n            }\n            this.$q.all(promiseArray)\n                .then(() => {\n                this.$log.info("[webConferenceService] refreshConferenceSessions -- success");\n                resolve();\n            })\n                .catch(() => {\n                this.$log.error("[webConferenceService] refreshConferenceSessions -- error -- cleaning up all sessions");\n                this.removeAllConferenceSessions();\n                reject();\n            });\n        });\n    }\n    /**\n    * Method removeAllConferenceSessions\n    * @private Method removes all conferenceSessions stored in the service\n    * @memberof WebConferenceService\n    */\n    removeAllConferenceSessions() {\n        this.$log.info("[webConferenceService] removeAllConferenceSessions");\n        for (let key in this.conferenceSessions) {\n            if (this.conferenceSessions.hasOwnProperty(key)) {\n                this.removeConferenceSession(key);\n            }\n        }\n    }\n    /**\n    * Method getConferenceSessionForRoom\n    * @public\n    * @param {any[]} roomConfEndpoints array containing list of conference of room\n    * @returns {ng.IPromise<any>} a promise that resolves when snapshots are done\n    * @memberof WebConferenceService\n    * Returns session for room if any\n    * */\n    getConferenceSessionForRoom(roomConfEndpoints) {\n        let sfuSession = null;\n        if (roomConfEndpoints && roomConfEndpoints.length) {\n            for (let i = 0; i < roomConfEndpoints.length; i++) {\n                if (roomConfEndpoints[i].mediaType === this.MEDIATYPE.WEBRTC || roomConfEndpoints[i].mediaType === this.MEDIATYPE.WEBRTCSHARINGONLY) {\n                    sfuSession = this.conferenceSessions[roomConfEndpoints[i].confEndpointId];\n                }\n            }\n        }\n        return sfuSession;\n    }\n}\nWebConferenceService.$inject = ["$q", "$rootScope", "$log", "$http", "uuid4", "$interval", "authService", "xmppService", "videoService", "roomService", "errorHelperService", "ConferenceSession", "contactService", "platformService", "Conference", "profileService"];\n;\nangular.module("rainbow").service("webConferenceService", WebConferenceService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/conference/webConferenceService.ts?')},function(module,exports){eval('/// <reference path="./webConferenceService.ts" />\n/// <reference path="./pstnConferenceService.ts" />\n/// <reference path="../serviceInterface.ts" />\n/// <reference path="../../models/common/httpResult.ts" />\n/**\n * @ngdoc service\n * @module rainbow\n * @name ConferenceService\n * @description Rainbow ConferenceService provides conference services\n */\nclass ConferenceService {\n    /************************************************************/\n    /** LIFECYCLE STUFF                                        **/\n    /************************************************************/\n    constructor($q, $log, $rootScope, $interval, $translate, $http, xmppService, authService, Conference, profileService, contactService, webConferenceService, pstnConferenceService, roomService, errorHelperService) {\n        this.$q = $q;\n        this.$log = $log;\n        this.$rootScope = $rootScope;\n        this.$interval = $interval;\n        this.$translate = $translate;\n        this.$http = $http;\n        this.xmppService = xmppService;\n        this.authService = authService;\n        this.Conference = Conference;\n        this.profileService = profileService;\n        this.contactService = contactService;\n        this.webConferenceService = webConferenceService;\n        this.pstnConferenceService = pstnConferenceService;\n        this.roomService = roomService;\n        this.errorHelperService = errorHelperService;\n        this.MEDIATYPE = {\n            PSTNAUDIO: "pstnAudio",\n            WEBRTC: "webrtc",\n            WEBRTCSHARINGONLY: "webrtcSharingOnly"\n        };\n        this.started = false;\n        this.isRegeneratingPersonalMeeting = false;\n        // Conferences data\n        this.listeners = [];\n        this.conferenceRef = null;\n        this.conferenceMngtRef = null;\n        this.pgiConferenceProvisionRef = null;\n    }\n    start(stats) {\n        return this.$q((resolve) => {\n            let startDate = performance.now();\n            this.$log.info("[ConferenceService] === STARTING ===");\n            this.confProvPortalURL = config.restServerUrl + "/api/rainbow/confprovisioning/v1.0/";\n            this.confPortalURL = config.restServerUrl + "/api/rainbow/conference/v1.0/conferences/";\n            this.computePstnConferencePremission();\n            this.attachHandlers();\n            this.pstnConferenceService.retrievePstnPhoneNumbers();\n            return this.retrieveConferences(null, false)\n                .then(() => {\n                if (!this.pstnConferenceService.pstnInstantConferenceEndpoint) {\n                    return this.$q.when();\n                }\n                return this.retrieveConferenceUser(this.contactService.userContact.dbId);\n            })\n                .then(() => {\n                return this.makeSnapshots();\n            })\n                .then(() => {\n                if (!this.pstnConferenceService.isPstnConferenceAvailable) {\n                    return this.$q.when();\n                }\n                return this.initializePersonalMeeting();\n            })\n                .then(() => {\n                this.started = true;\n                let startDuration = Math.round(performance.now() - startDate);\n                stats.push({ service: "conferenceService", startDuration: startDuration });\n                this.$log.info("[ConferenceService] === STARTED (" + startDuration + " ms) ===");\n                resolve();\n            })\n                .catch((error) => {\n                this.$log.info("[ConferenceService] === STARTING FAILURE === " + error.message);\n                resolve();\n            });\n        });\n    }\n    stop() {\n        return this.$q((resolve) => {\n            this.$log.info("");\n            this.$log.info("[ConferenceService] === STOPPING ===");\n            if (this.listeners) {\n                this.listeners.forEach((listener) => {\n                    listener();\n                });\n            }\n            this.isRegeneratingPersonalMeeting = false;\n            this.started = false;\n            this.$log.info("[ConferenceService] === STOPPED ===");\n            resolve();\n        });\n    }\n    attachHandlers() {\n        this.$log.info("[ConferenceService] attachHandlers");\n        if (this.conferenceRef) {\n            this.xmppService.connection.deleteHandler(this.conferenceRef);\n            this.conferenceRef = null;\n        }\n        this.conferenceRef = this.xmppService.connection.addHandler((stanza) => { return this.onConferenceUpdate(stanza); }, "jabber:iq:conference", "message", null);\n        if (this.conferenceMngtRef) {\n            this.xmppService.connection.deleteHandler(this.conferenceMngtRef);\n            this.conferenceMngtRef = null;\n        }\n        this.conferenceMngtRef = this.xmppService.connection.addHandler((stanza) => { return this.onConferenceManagement(stanza); }, null, "message", "management");\n        // Detect profile changes to retreieve conference related information\n        this.listeners.push(this.$rootScope.$on("ON_PROFILE_FEATURES_UPDATED", () => {\n            this.onMyProfileFeaturesChanged();\n        }));\n    }\n    reconnectService() {\n        this.$log.info("[ConferenceService] reconnectService");\n        this.attachHandlers();\n        this.isRegeneratingPersonalMeeting = false;\n        // Make snapshots on all conference sessions to update their state\n        this.refreshConferenceSessions();\n    }\n    /**\n    * Method onMyProfileFeaturesChanged\n    * @private\n    * @returns {any}\n    * @memberof ConferenceService\n    */\n    onMyProfileFeaturesChanged() {\n        let wasPstnConferenceAvailable = this.pstnConferenceService.isPstnConferenceAvailable;\n        this.computePstnConferencePremission();\n        if (wasPstnConferenceAvailable) {\n            if (!this.pstnConferenceService.isPstnConferenceAvailable) {\n                // Conference rights have been removed, so we notify the user\n                this.$rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", { popupTitle: "information", popupBody: "pgiRightsRemovedWarning", okLabel: "ok" });\n            }\n        }\n        else {\n            if (this.pstnConferenceService.isPstnConferenceAvailable) {\n                return this.retrieveConferences(null, false)\n                    .then(() => {\n                    if (!this.pstnConferenceService.pstnInstantConferenceEndpoint) {\n                        return this.$q.when();\n                    }\n                    return this.retrieveConferenceUser(this.contactService.userContact.dbId);\n                })\n                    .then(() => {\n                    return this.initializePersonalMeeting();\n                })\n                    .then(() => {\n                    return this.makeSnapshots();\n                });\n            }\n        }\n    }\n    ;\n    /**\n    * Method computePstnConferencePremission\n    * @public\n    * @memberof PstnConferenceService\n    * Compute user\'s permission for using Pstn (PGI) conferencing\n    */\n    computePstnConferencePremission() {\n        let isConferenceAllowed = this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.CONFERENCE_ALLOWED);\n        let isConferenceProvisioningOnGoing = true; // true here to make sure that case of an inactive profile is handled\n        let profiles = this.profileService.getMyProfiles();\n        if (profiles && profiles.length > 0) {\n            profiles.forEach((profile) => {\n                if (profile.profileName.toLowerCase().indexOf("conference") !== -1 && profile.status.toLowerCase().indexOf("active") !== -1) {\n                    if (profile.provisioningNeeded && profile.provisioningNeeded.length > 0) {\n                        profile.provisioningNeeded.forEach((provisioning) => {\n                            if (provisioning.providerType.toLowerCase().indexOf("pgi") !== -1) {\n                                isConferenceProvisioningOnGoing = provisioning.provisioningOngoing;\n                                if (isConferenceProvisioningOnGoing) {\n                                    this.$log.info("[ConferenceService] computePstnConferencePremission - pgi provisioning on going");\n                                    // add handler to change pstn conference availability \n                                    if (this.pgiConferenceProvisionRef) {\n                                        this.xmppService.connection.deleteHandler(this.pgiConferenceProvisionRef);\n                                        this.pgiConferenceProvisionRef = null;\n                                    }\n                                    this.pgiConferenceProvisionRef = this.xmppService.connection.addHandler((stanza) => { return this.onConferenceProvisionUpdate(stanza); }, null, "message", "management");\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        this.pstnConferenceService.isPstnConferenceAvailable = isConferenceAllowed && !isConferenceProvisioningOnGoing;\n        this.$rootScope.$broadcast("ON_CONFERENCE_FEATURES_UPDATED");\n    }\n    /**\n    * Method onConferenceProvisionUpdate\n    * @private\n    * @param {any} stanza [required]\n    * @returns true\n    * @memberof PstnConferenceService\n    * Method triggered when provisionning for PGI is complete\n    */\n    onConferenceProvisionUpdate(stanza) {\n        let stanzaElem = $(stanza);\n        if (stanzaElem.find("confuseractivated ").length > 0) {\n            if (this.pgiConferenceProvisionRef) {\n                this.xmppService.connection.deleteHandler(this.pgiConferenceProvisionRef);\n                this.pgiConferenceProvisionRef = null;\n            }\n            this.pstnConferenceService.isPstnConferenceAvailable = this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.CONFERENCE_ALLOWED);\n            if (this.pstnConferenceService.isPstnConferenceAvailable) {\n                this.retrieveConferences(null, false)\n                    .then(() => {\n                    if (!this.pstnConferenceService.pstnInstantConferenceEndpoint) {\n                        return this.$q.when();\n                    }\n                    return this.retrieveConferenceUser(this.contactService.userContact.dbId);\n                })\n                    .then(() => {\n                    return this.initializePersonalMeeting();\n                })\n                    .then(() => {\n                    return this.makeSnapshots();\n                });\n            }\n            this.$rootScope.$broadcast("ON_CONFERENCE_FEATURES_UPDATED");\n        }\n        return true;\n    }\n    /************************************************************/\n    /** ACCESSORS                                              **/\n    /************************************************************/\n    getPstnInstantConferenceEndpoint() {\n        return this.pstnConferenceService.pstnInstantConferenceEndpoint;\n    }\n    getPstnInstantConferenceEndpointId() {\n        return this.pstnConferenceService.pstnInstantConferenceEndpoint ? this.pstnConferenceService.pstnInstantConferenceEndpoint.id : -1;\n    }\n    getPstnConferenceUser() {\n        return this.pstnConferenceService.pstnConferenceUser;\n    }\n    getWebConferenceEndpoints() {\n        return this.webConferenceService.conferenceEndpoints;\n    }\n    /************************************************************/\n    /** Conference STUFF                                       **/\n    /************************************************************/\n    /**\n    * Method makeSnapshotsForList\n    * @public\n    * @param {any[]} confEndpointsList array containing list of conference for which we are doing a snapshot\n    * @returns {ng.IPromise<any>} a promise that resolves when snapshots are done\n    * @memberof ConferenceService\n    */\n    makeSnapshotsForList(confEndpointsList) {\n        return this.$q((resolve) => {\n            this.$log.info("[ConferenceService] makeSnapshotsForList");\n            if (!confEndpointsList || !confEndpointsList.length) {\n                resolve();\n                return;\n            }\n            let promiseArray = [];\n            for (let i = 0; i < confEndpointsList.length; i++) {\n                promiseArray.push(this.makeSnapshotForConfId(confEndpointsList[i].confEndpointId, confEndpointsList[i].mediaType));\n            }\n            this.$q.all(promiseArray)\n                .finally(() => {\n                resolve(this.getConferenceSessionForRoom(confEndpointsList));\n            });\n        });\n    }\n    ;\n    /**\n    * Method getConferenceSessionForRoom\n    * @public\n    * @param {any[]} roomConfEndpoints array containing list of conference of room\n    * @returns {any} the conferenceSession found (with priority for the PSTN) !\n    * @memberof ConferenceService\n    * */\n    getConferenceSessionForRoom(roomConfEndpoints) {\n        let pstnSession = null;\n        let sfuSession = null;\n        if (roomConfEndpoints && roomConfEndpoints.length) {\n            for (let i = 0; i < roomConfEndpoints.length; i++) {\n                if (roomConfEndpoints[i].mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                    pstnSession = this.pstnConferenceService.conferenceSessions[roomConfEndpoints[i].confEndpointId];\n                }\n                else {\n                    sfuSession = this.webConferenceService.conferenceSessions[roomConfEndpoints[i].confEndpointId];\n                }\n            }\n        }\n        return pstnSession ? pstnSession : sfuSession;\n    }\n    /**\n    * Method getMatchingConferenceSession\n    * @public\n    * @param {any[]} roomConfEndpoints array containing list of conference of room\n    * @param {string} id id of conference to find\n    * @returns {any} the conferenceSession found\n    * @memberof ConferenceService\n    * */\n    getMatchingConferenceSession(roomConfEndpoints, id) {\n        let confSession = null;\n        if (roomConfEndpoints && roomConfEndpoints.length) {\n            for (let i = 0; i < roomConfEndpoints.length; i++) {\n                if (roomConfEndpoints[i].confEndpointId === id) {\n                    confSession = roomConfEndpoints[i].mediaType === this.MEDIATYPE.PSTNAUDIO ? this.pstnConferenceService.conferenceSessions[id] : this.webConferenceService.conferenceSessions[id];\n                }\n            }\n        }\n        return confSession;\n    }\n    /**\n    * Method makeSnapshots\n    * @private\n    * @returns {ng.IPromise<any>} a promise that resolves when snapshots are done\n    * @memberof ConferenceService\n    */\n    makeSnapshots() {\n        this.$log.info("[ConferenceService] makeSnapshots");\n        return this.$q((resolve) => {\n            let snapshotPromiseList = [];\n            // Make snapshot for instant conference\n            if (this.pstnConferenceService.pstnInstantConferenceEndpoint) {\n                snapshotPromiseList.push(this.makeSnapshotForConfId(this.pstnConferenceService.pstnInstantConferenceEndpoint.id, this.pstnConferenceService.pstnInstantConferenceEndpoint.mediaType));\n            }\n            // Make snapshot for webrtc and webrtcSharingOnly conferences\n            for (let property in this.webConferenceService.conferenceEndpoints) {\n                if (this.webConferenceService.conferenceEndpoints.hasOwnProperty(property)) {\n                    let pontConf = this.webConferenceService.conferenceEndpoints[property];\n                    snapshotPromiseList.push(this.makeSnapshotForConfId(pontConf.id, pontConf.mediaType));\n                }\n            }\n            this.$q.all(snapshotPromiseList)\n                .finally(() => {\n                this.$log.info("[ConferenceService] makeSnapshots done");\n                resolve();\n            });\n        });\n    }\n    ;\n    /**\n    * Method retrieveConferenceUser\n    * @public\n    * @param {string} userId [required] ID of user\n    * @returns {ng.IPromise<any>} a promise that resolves with conferenceUser or error\n    * @memberof ConferenceService\n    */\n    retrieveConferenceUser(userId) {\n        return this.pstnConferenceService.retrieveConferenceUser(userId);\n    }\n    /**\n    * Method onConferenceUpdate\n    * @private\n    * @param {any} stanza [required]\n    * @returns true\n    * @memberof ConferenceService\n    * Method triggered on updates for conference\n    */\n    onConferenceUpdate(stanza) {\n        this.$log.info("[ConferenceService] onConferenceUpdate message: " + stanza.innerHTML);\n        let conferenceIdElem = $(stanza).find("conference-id");\n        let conferenceId = conferenceIdElem.text();\n        let mediaTypeElem = $(stanza).find("media-type");\n        let mediaType = this.MEDIATYPE.PSTNAUDIO;\n        if (mediaTypeElem && mediaTypeElem.length && mediaTypeElem.text) {\n            mediaType = $(mediaTypeElem[0]).text();\n        }\n        if (conferenceId) {\n            let conferenceSession = null;\n            if (mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                conferenceSession = this.pstnConferenceService.conferenceSessions[conferenceId];\n            }\n            else {\n                conferenceSession = this.webConferenceService.conferenceSessions[conferenceId];\n            }\n            if (!conferenceSession) {\n                this.$log.info("[ConferenceService] no such session for ID " + conferenceId);\n                switch (mediaType) {\n                    case "webrtc":\n                        break;\n                    case "webrtcsharing": // WTF ? mediaType should be webrtcSharingOnly !\n                        let publisherElem = $(stanza).find("publisher");\n                        let jid_im = publisherElem.find("jid-im").text();\n                        let publisherId = publisherElem.find("publisher-id").text();\n                        let publisher = {\n                            participantId: publisherId,\n                            mediaType: mediaType,\n                            jid_im: jid_im\n                        };\n                        this.subscribeToPublisher(conferenceId, publisher);\n                        break;\n                    default:\n                        //this.makeSnapshotForConfId(conferenceId);\n                        break;\n                }\n            }\n            //for SFU conference, but not joined with this user, ignore updates\n            else if (conferenceSession.type === this.MEDIATYPE.WEBRTC && !conferenceSession.haveJoined) {\n                //ignore\n            }\n            else {\n                this.updateConferenceSession(stanza, conferenceSession);\n            }\n        }\n        return true;\n    }\n    /**\n    * Method onConferenceManagement\n    * @private\n    * @param {any} stanza [required]\n    * @returns true\n    * @memberof ConferenceService\n    * Method triggered on updates for management of conference\n    */\n    onConferenceManagement(stanza) {\n        try {\n            let confendpointElem = $(stanza).find("confendpoint");\n            if (confendpointElem.length && confendpointElem.attr("action") === "update") {\n                this.$log.info("[ConferenceService] onConferenceManagement - update of conference");\n                let confendpointidElem = $(stanza).find("confendpointid");\n                let conferenceId = confendpointidElem.text();\n                this.retrieveConference(conferenceId, true)\n                    .then(() => {\n                    this.$rootScope.$broadcast("ON_CONFERENCE_DATA_UPDATED_EVENT", conferenceId);\n                });\n                return true;\n            }\n            return true;\n        }\n        catch (error) {\n            return true;\n        }\n    }\n    /**\n    * Method makeSnapshotForConfId\n    * @public\n    * @param {string} confId [required] ID of conference we are snapshoting\n    * @param {string} type [optional] mediaType of conference we are snapshoting. Default: pstnAudio\n    * @returns {ng.IPromise<any>} a promise that resolves when snapshot and session creation/update are done\n    * @memberof ConferenceService\n    */\n    makeSnapshotForConfId(confId, type = this.MEDIATYPE.PSTNAUDIO) {\n        this.$log.info("[ConferenceService] makeSnapshotForConfId " + confId);\n        return this.$q((resolve, reject) => {\n            if (!confId) {\n                let error = new Error("[ConferenceService] makeSnapshotForConfId missing conf ID !");\n                this.$log.error(error.message);\n                reject(error);\n                return;\n            }\n            let confSession = null;\n            switch (type) {\n                case this.MEDIATYPE.PSTNAUDIO:\n                    confSession = this.pstnConferenceService.conferenceSessions[confId];\n                    break;\n                case this.MEDIATYPE.WEBRTC:\n                case this.MEDIATYPE.WEBRTCSHARINGONLY:\n                    confSession = this.webConferenceService.conferenceSessions[confId];\n                    break;\n                default:\n                    this.$log.info("[ConferenceService] makeSnapshotForConfId : unknown type " + type);\n                    break;\n            }\n            if (confSession && confSession.active && confSession.haveJoined) {\n                this.$log.debug("[ConferenceService] makeSnapshotForConfId skipped, already joined");\n                resolve(confSession);\n                return;\n            }\n            let mediaType = (type === this.MEDIATYPE.WEBRTC || type === this.MEDIATYPE.WEBRTCSHARINGONLY) ? this.MEDIATYPE.WEBRTC : this.MEDIATYPE.PSTNAUDIO;\n            this.$http({\n                method: "GET",\n                url: this.confPortalURL + confId + "/snapshot?mediaType=" + mediaType,\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.$log.info("[ConferenceService] makeSnapshotForConfId success for confId " + confId);\n                let conferenceData = response.data;\n                if (mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                    this.pstnConferenceService.updateOrCreateConferenceSession(confId, conferenceData);\n                }\n                else {\n                    this.webConferenceService.updateOrCreateConferenceSession(confId, conferenceData, type);\n                }\n                resolve(conferenceData.data);\n            })\n                .catch((errorResponse) => {\n                this.$log.info("[ConferenceService] makeSnapshotForConfId failure for confID " + confId);\n                if (errorResponse.status === 404) {\n                    this.$log.error("[ConferenceService] makeSnapshotForConfId - confId " + confId + " not found on server");\n                }\n                else {\n                    this.$log.error("[ConferenceService] makeSnapshotForConfId - inconsistent object on server");\n                    // TODO : popup error ?\n                }\n                if (mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                    delete this.pstnConferenceService.conferenceSessions[confId];\n                }\n                else {\n                    delete this.webConferenceService.conferenceSessions[confId];\n                }\n                let error = this.errorHelperService.handleError(errorResponse);\n                reject(error);\n            });\n        });\n    }\n    /**\n    * Method retrieveConferences\n    * @public\n    * @param {string} mediaType [optional] mediaType of conference(s) to retrive.\n    * @param {boolean} scheduled [optional] whether it is a scheduled conference or not\n    * @param {boolean} provisioning [optional] whether it is a conference that is in provisioning state or not\n    * @returns {ng.IPromise<any>} a promise that resolves when conference are retrieved. Note: If no parameter is specified, then all mediaTypes are retrieved\n    * @memberof ConferenceService\n    */\n    retrieveConferences(mediaType, scheduled, provisioning) {\n        this.$log.info("[ConferenceService] retrieveConferences with mediaType=" + mediaType + " and scheduled=" + scheduled);\n        switch (mediaType) {\n            case this.MEDIATYPE.PSTNAUDIO:\n                return this.pstnConferenceService.retrievePstnConferences(scheduled, provisioning);\n            case this.MEDIATYPE.WEBRTC:\n            case this.MEDIATYPE.WEBRTCSHARINGONLY:\n                return this.webConferenceService.retrieveWebConferences(mediaType);\n            default:\n                break;\n        }\n        return this.$q((resolve, reject) => {\n            if (!this.pstnConferenceService.isPstnConferenceAvailable && !(this.profileService.isFeatureEnabled(this.profileService.FeaturesEnum.WEBRTC_CONFERENCE_ALLOWED))) {\n                this.$log.warn("[ConferenceService] retrieveConferences - user is not allowed");\n                reject(new Error("notAllowed"));\n                return;\n            }\n            let urlParameters = "conferences?format=full&userId=" + this.contactService.userContact.dbId;\n            if (angular.isDefined(scheduled)) {\n                urlParameters += "&scheduled=" + scheduled;\n            }\n            this.$http({\n                method: "GET",\n                url: this.confProvPortalURL + urlParameters,\n                headers: this.authService.getRequestHeader()\n            })\n                // Handle success response\n                .then((response) => {\n                let conferencesProvisionData = response.data.data;\n                for (let conferenceData of conferencesProvisionData) {\n                    switch (conferenceData.mediaType) {\n                        case this.MEDIATYPE.PSTNAUDIO:\n                            this.pstnConferenceService.updateOrCreatePstnConferenceEndpoint(conferenceData);\n                            break;\n                        case this.MEDIATYPE.WEBRTC:\n                        case this.MEDIATYPE.WEBRTCSHARINGONLY:\n                            this.webConferenceService.updateOrCreateWebConferenceEndpoint(conferenceData);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                this.$log.info("[ConferenceService] retrieveConferences successfully");\n                resolve(conferencesProvisionData);\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "retrieveConferences failure: " + msg;\n                this.$log.error("[ConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    ;\n    /**\n    * Method retrieveConference\n    * @public\n    * @param {string} confId [required] ID of conference  to retrieve\n    * @returns {ng.IPromise<any>} a promise that resolves when conference is retrieved\n    * @memberof ConferenceService\n    */\n    retrieveConference(confId, force = false) {\n        this.$log.info("[ConferenceService] retrieveConference");\n        if (!confId) {\n            this.$log.warn("[ConferenceService] retrieveConference - missing confID");\n            return this.$q.reject(new Error("retrieveConference - missing confID"));\n        }\n        return this.$q((resolve, reject) => {\n            // We do not retrieve conference from server if it has already been done before\n            if (this.pstnConferenceService.pstnConferenceEndpoints[confId] && !force) {\n                resolve(this.pstnConferenceService.pstnConferenceEndpoints[confId]);\n                return;\n            }\n            if (this.webConferenceService.conferenceEndpoints[confId]) {\n                resolve(this.webConferenceService.conferenceEndpoints[confId]);\n                return;\n            }\n            this.$http({\n                method: "GET",\n                url: this.confProvPortalURL + "conferences/" + confId,\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                let conferenceData = response.data.data;\n                if (conferenceData && conferenceData.hasOwnProperty("id")) {\n                    let conference = this.Conference.createFromData(conferenceData);\n                    if (conferenceData.mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                        this.pstnConferenceService.pstnConferenceEndpoints[conferenceData.id] = conference;\n                    }\n                    else {\n                        this.webConferenceService.conferenceEndpoints[conferenceData.id] = conference;\n                    }\n                }\n                this.$log.info("[ConferenceService] retrieveConference successfully");\n                resolve(conferenceData);\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "retrieveConference failure: " + msg;\n                this.$log.error("[ConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    ;\n    /**\n    * Method updateConferenceSession\n    * @private\n    * @param {any} stanza [required] stanza of message received to update conference session\n    * @param {any} conferenceSession [required] conference session updated\n    * @returns {boolean} true\n    * @memberof ConferenceService\n    */\n    updateConferenceSession(stanza, conferenceSession) {\n        this.$log.info("[ConferenceService] updateConferenceSession");\n        // handle conference state\n        let conferenceStateElem = $(stanza).find("conference-state");\n        if (conferenceStateElem.length) {\n            let activeElem = conferenceStateElem.find("active");\n            let isConferenceActive = (activeElem.text() === "true");\n            let talkerActiveElem = conferenceStateElem.find("talker-active");\n            let isTalkerActive = (talkerActiveElem.text() === "true");\n            let recordingStartedElem = conferenceStateElem.find("recording-started");\n            let isRecordingStarted = (recordingStartedElem.text() === "true");\n            let lockElem = conferenceStateElem.find("lock");\n            let isLock = (lockElem.text() === "true");\n            this.updateState(conferenceSession, isConferenceActive, isTalkerActive, isRecordingStarted, isLock);\n        }\n        // handle talkers\n        let talkersElem = $(stanza).find("talkers");\n        if (talkersElem.length) {\n            let talkers = [];\n            talkersElem.find("participant-id").each((__index, talker) => {\n                let talkerParticipantidElem = $(talker);\n                let talkerParticipantId = talkerParticipantidElem.text();\n                talkers.push(talkerParticipantId);\n            });\n            this.updateTalkers(conferenceSession, talkers);\n        }\n        // handle participants creation/updates\n        let participantsElem = $(stanza).find("participants");\n        if (participantsElem.length === 0) {\n            participantsElem = $(stanza).find("updated-participants");\n        }\n        if (!participantsElem.length) {\n            participantsElem = $(stanza).find("added-participants");\n        }\n        if (participantsElem.length) {\n            let participants = [];\n            participantsElem.find("participant").each((__index, participant) => {\n                let participantElem = $(participant);\n                let participantId = participantElem.find("participant-id").text();\n                let jid_im = participantElem.find("jid-im").text();\n                let phoneNumber = participantElem.find("phone-number").text();\n                let role = participantElem.find("role").text();\n                let mute = participantElem.find("mute").text();\n                let hold = participantElem.find("hold").text();\n                let cnxState = participantElem.find("cnx-state").text();\n                participants.push({\n                    participantId: participantId,\n                    jid_im: jid_im,\n                    phoneNumber: phoneNumber,\n                    participantRole: role,\n                    mute: (mute === "on"),\n                    held: (hold === "on"),\n                    participantState: cnxState,\n                });\n            });\n            // Only update participants of session if list is not empty\n            if (participants.length > 0) {\n                this.createOrUpdateParticipants(conferenceSession, participants);\n            }\n        }\n        // handle participants removals\n        let removedParticipantsElem = $(stanza).find("removed-participants");\n        if (removedParticipantsElem.length) {\n            let removedParticipants = [];\n            removedParticipantsElem.find("participant-id").each((__index, removedParticipant) => {\n                let removedParticipantIdElem = $(removedParticipant);\n                let removedParticipantId = removedParticipantIdElem.text();\n                removedParticipants.push(removedParticipantId);\n            });\n            this.removeParticipants(conferenceSession, removedParticipants);\n        }\n        let updatedPublishers = $(stanza).find("added-publishers");\n        if (updatedPublishers.length) {\n            updatedPublishers.find("publisher").each((__index, publisher) => {\n                let publisherElem = $(publisher);\n                let publisherId = publisherElem.find("publisher-id").text();\n                let mediaType = publisherElem.find("media-type").text();\n                let jid_im = publisherElem.find("jid-im").text();\n                this.addPublisher(conferenceSession, publisherId, mediaType, jid_im);\n            });\n            this.$rootScope.$broadcast("ON_CONFERENCE_PUBLISHER_UPDATED", conferenceSession);\n        }\n        let removedPublishers = $(stanza).find("removed-publishers");\n        if (removedPublishers.length) {\n            removedPublishers.find("publisher").each((__index, publisher) => {\n                let publisherElem = $(publisher);\n                let publisherId = publisherElem.find("participant-id").text();\n                let mediaType = publisherElem.find("media-type").text();\n                for (let i = 0; i < conferenceSession.publishers.length; i++) {\n                    let pub = conferenceSession.publishers[i];\n                    if (pub.participantId === publisherId && pub.mediaType === mediaType) {\n                        conferenceSession.publishers.splice(i, 1);\n                        break;\n                    }\n                }\n                //in case we\'re subscibed to this publisher, remove the session and free the related element\n                if (this.webConferenceService.isAlreadySubscribedToPublisher(conferenceSession.id, publisherId)) {\n                    this.$log.info("[ConferenceService] removed-publishers : subscribed to this publisher, so re-init the element");\n                    let element = this.webConferenceService.getRelatedElementToPublisher(conferenceSession.id, publisherId);\n                    if (element) {\n                        this.webConferenceService.reInitialiseVideoGalleryElementById(conferenceSession, element.id);\n                    }\n                }\n            });\n            this.$rootScope.$broadcast("ON_CONFERENCE_PUBLISHER_UPDATED", conferenceSession);\n        }\n        let publishers = $(stanza).find("publishers");\n        if (publishers.length) {\n            publishers.find("publisher").each((__index, publisher) => {\n                let publisherElem = $(publisher);\n                let publisherId = publisherElem.find("publisher-id").text();\n                let mediaType = publisherElem.find("media-type").text();\n                let jid_im = publisherElem.find("jid-im").text();\n                this.addPublisher(conferenceSession, publisherId, mediaType, jid_im);\n            });\n            this.$rootScope.$broadcast("ON_CONFERENCE_PUBLISHER_UPDATED", conferenceSession);\n        }\n        return true;\n    }\n    /**\n    * Method updateState\n    * @private\n    * @param {any} conferenceSession [required] conference session updated\n    * @param {boolean} isConferenceActive [required] from session update received: whether the conference is active\n    * @param {boolean} isTalkerActive [required] from session update received: whether the talker is active\n    * @param {boolean} isRecordingStarted [required] from session update received: whether the recording is started or not\n    * @param {boolean} lock [optional] whether conference session is locked or not\n    * @memberof ConferenceService\n    */\n    updateState(conferenceSession, isConferenceActive, isTalkerActive, isRecordingStarted, lock = false) {\n        if (!isConferenceActive) {\n            this.contactService.resetBusyState();\n        }\n        // Do something special when conference state goes from active to inactive and we are not owner\n        if (conferenceSession.active && !isConferenceActive) {\n            if (this.contactService.userContact.guestMode && conferenceSession.type !== this.MEDIATYPE.WEBRTCSHARINGONLY) {\n                this.$rootScope.$broadcast("ON_OPEN_POPUP", "concludeInvitationEndMeeting");\n            }\n            else {\n                let rooms = this.roomService.findRoomsWithConfId(conferenceSession.id);\n                if (rooms && rooms.length) {\n                    if (!rooms[0].owner) {\n                        switch (conferenceSession.type) {\n                            case this.MEDIATYPE.WEBRTCSHARINGONLY:\n                                // We show nothing\n                                break;\n                            case this.MEDIATYPE.PSTNAUDIO:\n                            case this.MEDIATYPE.WEBRTC:\n                            default:\n                                // If user is still connected, display popup\n                                if (conferenceSession.isParticipantConnectedByJid(this.contactService.userContact.dbId)) {\n                                    let displayName = _escape(rooms[0].ownerContact.displayName);\n                                    let roomName = _escape(rooms[0].name);\n                                    let message = this.$translate.instant("meetingEndBy", { owner: displayName, meeting: roomName });\n                                    this.$rootScope.$broadcast("GLOBAL_NOTIFY_MESSAGE_EVENT", message);\n                                }\n                                break;\n                        }\n                    }\n                    else {\n                        if (conferenceSession.id === this.getPstnInstantConferenceEndpointId()) {\n                            this.$rootScope.$broadcast("ON_OPEN_RENAME_MEETING_POPUP", { meetingRoomId: rooms[0].dbId, confEndpointId: this.getPstnInstantConferenceEndpointId() });\n                        }\n                    }\n                }\n            }\n            conferenceSession.participants = [];\n            conferenceSession.status = "ended";\n        }\n        conferenceSession.updateStateFromData(isConferenceActive, isTalkerActive, isRecordingStarted, lock);\n        //emit event to notify conference state data update\n        this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", conferenceSession);\n    }\n    /**\n    * Method updateTalkers\n    * @private\n    * @param {any} conferenceSession [required] conference session updated\n    * @param {any[]} talkers\n    * @memberof ConferenceService\n    */\n    updateTalkers(conferenceSession, talkers) {\n        conferenceSession.updateTalkers(talkers);\n        //emit event to notify conference talker data update\n        this.$rootScope.$broadcast("ON_CONFERENCE_TALKER_EVENT", conferenceSession);\n    }\n    /**\n    * Method createOrUpdateParticipants\n    * @private\n    * @param {any} conferenceSession [required] conference session updated\n    * @param {any[]} participants\n    * @memberof ConferenceService\n    */\n    createOrUpdateParticipants(conferenceSession, participants) {\n        conferenceSession.updateParticipants(participants)\n            .then((result) => {\n            if (conferenceSession.participants.find((participant) => { return (participant.jid_im === this.contactService.userContact.id && participant.state !== "disconnected"); })) {\n                if (conferenceSession.type === this.MEDIATYPE.WEBRTC) {\n                    var state = conferenceSession.hasLocalSharing ? "sharing" : "audio";\n                    this.contactService.setBusyState("dnd", state);\n                }\n            }\n            //emit event to notify conference participant data update\n            this.$rootScope.$broadcast("ON_CONFERENCE_PARTICIPANT_EVENT", conferenceSession);\n            //if a new participant has joined the webrtc conference, play sound\n            if (conferenceSession.type === "webrtc" && result) {\n                this.$rootScope.$broadcast("ON_WEB_CONFENRECE_PARTICIPANT_JOINED_EVENT", conferenceSession);\n            }\n        });\n    }\n    /**\n    * Method removeParticipants\n    * @private\n    * @param {any} conferenceSession [required] conference session updated\n    * @param {any[]} removedParticipants\n    * @memberof ConferenceService\n    */\n    removeParticipants(conferenceSession, removedParticipants) {\n        conferenceSession.removeParticipants(removedParticipants);\n        // If I\'m not in conferenceSerssion anymore\n        if (!conferenceSession.participants.find((participant) => { return (participant.jid_im === this.contactService.userContact.id); })) {\n            // reset presence\n            this.contactService.resetBusyState();\n            switch (conferenceSession.type) {\n                case this.MEDIATYPE.WEBRTC:\n                    this.webConferenceService.removeAllJingleSessionsForConferenceSession(conferenceSession.id);\n                    if (conferenceSession.active) {\n                        let room = this.roomService.findRoomsWithConfId(conferenceSession.id);\n                        if (room.length && !this.webConferenceService.isMyConference(conferenceSession.id)) {\n                            let name = _escape(room[0].name);\n                            let message = this.$translate.instant("meetingDisconnect", { meeting: name });\n                            this.$rootScope.$broadcast("GLOBAL_NOTIFY_MESSAGE_EVENT", message);\n                        }\n                    }\n                    conferenceSession.cleanupSessionData();\n                    break;\n                case this.MEDIATYPE.WEBRTCSHARINGONLY:\n                    this.webConferenceService.removeAllJingleSessionsForConferenceSession(conferenceSession.id);\n                    conferenceSession.cleanupSessionData();\n                    break;\n                case this.MEDIATYPE.PSTNAUDIO:\n                default:\n                    break;\n            }\n        }\n        //emit event to notify conference participant data update\n        this.$rootScope.$broadcast("ON_CONFERENCE_PARTICIPANT_EVENT", conferenceSession);\n    }\n    /**\n    * Method addPublisher\n    * @private\n    * @param {any} conferenceSession [required] conference session updated\n    * @param {string} publisherId ID of publisher to be added\n    * @param {string} mediaType mediaType of publisher to add\n    * @param {string} jid jid_im of publisher\n    * @memberof ConferenceService\n    */\n    addPublisher(conferenceSession, publisherId, mediaType, jid) {\n        let toAdd = true;\n        for (let i = 0; i < conferenceSession.publishers.length; i++) {\n            let pub = conferenceSession.publishers[i];\n            if (pub.participantId === publisherId && pub.mediaType === mediaType) {\n                toAdd = false;\n                break;\n            }\n        }\n        let publisher = {\n            participantId: publisherId,\n            mediaType: mediaType,\n            jid_im: jid\n        };\n        if (toAdd) {\n            conferenceSession.publishers.push(publisher);\n        }\n        if (toAdd && mediaType === "video") {\n            //check if we\'ve available video gallery element for that user\n            let element = this.webConferenceService.getFreeVideoGalleryElement(conferenceSession.id);\n            if (element && !this.webConferenceService.isAlreadySubscribedToPublisher(conferenceSession.id, publisher.participantId)) {\n                this.$log.info("[ConferenceService] will subscribe to publisher " + conferenceSession.id + " for id " + publisherId + "and element id " + element.id + " in few moments");\n                //block element\n                element.state = "busy";\n                element.publisherId = publisher.participantId;\n                this.$interval((confSession, newPublisher, elemToSubscribe) => {\n                    //if we should still subscribe to this user, do it\n                    if (elemToSubscribe.state === "busy" && elemToSubscribe.publisherId === newPublisher.participantId) {\n                        this.$log.info("[ConferenceService] subscribe to publisher " + confSession.id + " for id " + newPublisher.participantId + "and element id " + elemToSubscribe.id);\n                        this.subscribeToPublisher(confSession.id, newPublisher, elemToSubscribe.id)\n                            .catch(() => {\n                            this.$log.error("[ConferenceService] subscribe to publisher failed, reset the video gallery element with id " + elemToSubscribe.id);\n                            this.webConferenceService.reInitialiseVideoGalleryElementById(confSession, elemToSubscribe.id);\n                        });\n                    }\n                }, 2500, 1, true, conferenceSession, publisher, element);\n            }\n        }\n    }\n    /**\n    * Method stopConference\n    * @public\n    * @param {string} confId ID of conference to stop\n    * @param {string} type mediaType of conference to stop\n    * @param {string} roomId ID of room\n    * @returns {ng.IPromise<any>} a promise that resolves when conference is stopped or error\n    * @memberof ConferenceService\n    */\n    stopConference(confId = "", type = this.MEDIATYPE.PSTNAUDIO, roomId = "") {\n        this.$log.info("[ConferenceService] stopConference( confId=" + confId + ", type=" + type + ")");\n        if (!confId || (!roomId && type !== this.MEDIATYPE.PSTNAUDIO)) {\n            this.$log.warn("[ConferenceService] stopConference missing conf ID or roomID");\n            return this.$q.reject();\n        }\n        // Check if conferenceSession is active before stoping it\n        let conferenceSession = this.pstnConferenceService.conferenceSessions[confId] ? this.pstnConferenceService.conferenceSessions[confId] : this.webConferenceService.conferenceSessions[confId];\n        if (!conferenceSession || !conferenceSession.isActive()) {\n            this.$log.warn("[ConferenceService] stopConference - no active conference session to stop");\n            return this.$q.reject();\n        }\n        return this.$q((resolve, reject) => {\n            this.$http({\n                method: "PUT",\n                url: this.confPortalURL + confId + "/stop",\n                headers: this.authService.getPostHeader(),\n                data: {\n                    mediaType: type,\n                    roomId: roomId\n                }\n            })\n                .then(() => {\n                this.contactService.resetBusyState();\n                let session = null;\n                if (type === this.MEDIATYPE.PSTNAUDIO) {\n                    session = this.pstnConferenceService.conferenceSessions[confId];\n                }\n                else {\n                    session = this.webConferenceService.conferenceSessions[confId];\n                }\n                if (session) {\n                    this.updateState(session, false, false, false);\n                    session.cleanupSessionData();\n                    this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", session);\n                }\n                this.$log.info("[ConferenceService] stopConference( confId=" + confId + ") successfully");\n                resolve();\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "stopConference( confId=" + confId + ") failure: " + msg;\n                this.$log.error("[ConferenceService] " + errorMessage);\n                if (response.data.errorDetailsCode !== 404000) {\n                    this.$rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", {\n                        popupTitle: "warning",\n                        popupBody: "stopMeetingFailure",\n                        okLabel: "ok"\n                    });\n                }\n                else {\n                    //404 means that the session is already ended, clear all parameters if any\n                    let session = null;\n                    if (type === this.MEDIATYPE.PSTNAUDIO) {\n                        session = this.pstnConferenceService.conferenceSessions[confId];\n                    }\n                    else {\n                        session = this.webConferenceService.conferenceSessions[confId];\n                    }\n                    if (session) {\n                        session.active = false;\n                        session.participants = [];\n                        this.removeConferenceSession(session);\n                        this.$rootScope.$broadcast("ON_CONFERENCE_STATE_EVENT", session);\n                    }\n                }\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method removeConferenceSession\n    * @public\n    * @param {any} conferenceSession conferenceSession to be removed from local conferenceSessions\n    * @memberof ConferenceService\n    */\n    removeConferenceSession(conferenceSession = null) {\n        if (conferenceSession) {\n            if (conferenceSession.type === this.MEDIATYPE.WEBRTC || conferenceSession.type === this.MEDIATYPE.WEBRTCSHARINGONLY) {\n                this.webConferenceService.removeConferenceSession(conferenceSession.id);\n            }\n            else {\n                delete this.pstnConferenceService.conferenceSessions[conferenceSession.id];\n            }\n        }\n    }\n    /**\n    * Method disconnectsParticipant\n    * @public\n    * @param {string} confId ID of conference to stop\n    * @param {string} participantId ID of participant to disconnect\n    * @param {string} type mediaType of conference to stop. Default: this.MEDIATYPE.PSTNAUDIO\n    * @returns {ng.IPromise<any>} a promise that resolves when participant is disconnected or error\n    * @memberof ConferenceService\n    */\n    disconnectsParticipant(confId, participantId, mediaType = this.MEDIATYPE.PSTNAUDIO) {\n        if (!confId || !participantId) {\n            this.$log.warn("[ConferenceService] disconnectsParticipant missing conf ID or participantId");\n            return this.$q.reject();\n        }\n        return this.$q((resolve, reject) => {\n            this.$log.info("[ConferenceService] disconnectsParticipant( confId=" + confId + "participantId=" + participantId + ")");\n            this.$http({\n                method: "DELETE",\n                url: this.confPortalURL + confId + "/participants/" + participantId + "?mediaType=" + mediaType,\n                headers: this.authService.getRequestHeader()\n            })\n                .then(() => {\n                this.$log.info("[ConferenceService] disconnectsParticipant( confId=" + confId + "participantId=" + participantId + ") successfully");\n                resolve();\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "disconnectsParticipant( confId=" + confId + "participantId=" + participantId + ") failure: " + msg;\n                this.$log.error("[ConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method updateConference\n    * @public\n    * @param {string} confEndpointId ID of conference to update\n    * @param {any} confData data to update conference with\n    * @param {string} mediaType mediaType of conference to update. Default: this.MEDIATYPE.PSTNAUDIO\n    * @returns {ng.IPromise<any>} a promise that resolve when conference is updated\n    * @memberof ConferenceService\n    */\n    updateConference(confEndpointId, confData, mediaType = this.MEDIATYPE.PSTNAUDIO) {\n        if (mediaType === this.MEDIATYPE.PSTNAUDIO) {\n            return this.pstnConferenceService.updateConference(confEndpointId, confData);\n        }\n        else {\n            this.webConferenceService.updateConference(confEndpointId, confData);\n        }\n    }\n    /**\n    * Method updateConferenceState\n    * @public\n    * @param {string} confId ID of conference\n    * @param {string} option update data ( could be on of: mute, unmute, hold, retrieve)\n    * @param {string} mediaType mediaType of conferenceSession to update. Default: this.MEDIATYPE.PSTNAUDIO\n    * @returns {ng.IPromise<any>} a promise that resolve when particpant state is updated\n    * @memberof ConferenceService\n    */\n    updateConferenceState(confId, option, mediaType = this.MEDIATYPE.PSTNAUDIO) {\n        this.$log.info("[ConferenceService] updateConferenceState( confId=" + confId + ", option=" + option + " mediaType=" + mediaType + ")");\n        if (!confId || !option) {\n            this.$log.error("[ConferenceService] updateConferenceState - missing a parameter");\n            return this.$q.reject();\n        }\n        return this.$q((resolve, reject) => {\n            let conferenceSession = null;\n            if (mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                conferenceSession = this.pstnConferenceService.conferenceSessions[confId];\n            }\n            else {\n                conferenceSession = this.webConferenceService.conferenceSessions[confId];\n            }\n            if (!conferenceSession) {\n                this.$log.error("[ConferenceService] updateConferenceState - no corresponding conference session to update");\n                reject();\n                return;\n            }\n            this.$http({\n                method: "PUT",\n                url: this.confPortalURL + confId + "/update",\n                headers: this.authService.getRequestHeader(),\n                data: { option: option, mediaType: conferenceSession.type },\n            })\n                .then((response) => {\n                let conferenceData = response.data.data;\n                this.$log.info("[ConferenceService] updateConferenceState( confId=" + confId + ") successfully");\n                resolve(conferenceData);\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "updatsConferenceState( confId=" + confId + ") failure: " + msg;\n                this.$log.error("[ConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    ;\n    /**\n    * Method updateParticipantState\n    * @public\n    * @param {string} confId ID of conference\n    * @param {string} participantId ID of particpant to update\n    * @param {string} option update data ( could be on of: mute, unmute, hold, retrieve)\n    * @param {string} mediaType (optional) mediaType of conferenceSession to update. Default: this.MEDIATYPE.PSTNAUDIO\n    * @param {string} media (optional) type of media to be updated (video/sharing)\n    * @param {string} bitRate (optional) the max bitrate to be set (0 is unlimited)\n    * @param {string} subStreamLevel (optional) set new sub-stream level. Only available for publishers and in simulcast mode\n    * @param {string} publisherId (optional) the publisher id related to the update\n    * @returns {ng.IPromise<any>} a promise that resolve when particpant state is updated\n    * @memberof ConferenceService\n    */\n    updateParticipantState(confId, participantId, option, mediaType = this.MEDIATYPE.PSTNAUDIO, media = null, bitRate = null, subStreamLevel = null, publisherId = null) {\n        this.$log.info("[ConferenceService] updateParticipantState( confId=" + confId + "participantId=" + participantId + " option=" + option + " mediaType=" + mediaType + ")");\n        if (!confId || !participantId || !option) {\n            this.$log.error("[ConferenceService] updateParticipantState - missing a parameter");\n            return this.$q.reject();\n        }\n        return this.$q((resolve, reject) => {\n            let conferenceSession = null;\n            if (mediaType === this.MEDIATYPE.PSTNAUDIO) {\n                conferenceSession = this.pstnConferenceService.conferenceSessions[confId];\n            }\n            else {\n                conferenceSession = this.webConferenceService.conferenceSessions[confId];\n            }\n            if (!conferenceSession) {\n                this.$log.error("[ConferenceService] updateParticipantState - no corresponding conference session to update");\n                reject();\n                return;\n            }\n            let data = { option: option, mediaType: conferenceSession.type };\n            if (media) {\n                data["media"] = media;\n            }\n            if (bitRate) {\n                data["bitRate"] = bitRate;\n            }\n            if (publisherId) {\n                data["publisherId"] = publisherId;\n            }\n            if (subStreamLevel) {\n                data["subStreamLevel"] = subStreamLevel;\n            }\n            this.$http({\n                method: "PUT",\n                url: this.confPortalURL + confId + "/participants/" + participantId,\n                headers: this.authService.getRequestHeader(),\n                data: data,\n            })\n                .then((response) => {\n                let status = response.data;\n                this.$log.info("[ConferenceService] updateParticipantState( confId=" + confId + "participantId=" + participantId + ") successfully");\n                resolve(status);\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "updateParticipantState( confId=" + confId + "participantId=" + participantId + ") failure: " + msg;\n                this.$log.error("[ConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /************************************************************/\n    /** PSTN (PGI) STUFF                                        **/\n    /************************************************************/\n    /**\n    * Method retrievePstnPhoneNumbers\n    * @public\n    * @returns {any} a promise that resolves with an object containing the phone numbers for PGi dial in or error\n    * @memberof ConferenceService\n    */\n    retrievePstnPhoneNumbers(shouldFormatResults = false) {\n        return this.pstnConferenceService.retrievePstnPhoneNumbers(shouldFormatResults);\n    }\n    /**\n    * Method joinPstnConference\n    * @public\n    * @param {string} confId [required] ID of conference to join\n    * @param {string} participantPhoneNumber [required] phone number to join\n    * @param {any} participant [required] {role, type} role: moderator or member. type: muted or unmuted\n    * @param {string} country [optional] Country where the called number is from. If not provided, the user\'s country is taken\n    * @param {any} room [optional] room to which conference is attached\n    * @returns {ng.IPromise<any>} a promise that resolves when joined or error\n    * @memberof ConferenceService\n    */\n    joinPstnConference(confId, participantPhoneNumber, participant, country, room) {\n        return this.$q((resolve, reject) => {\n            this.$log.info("[ConferenceService] joinPstnConference with ( confId = " + confId + " participantPhoneNumber = " + participantPhoneNumber + " country = " + country + " )");\n            if (!confId || !room) {\n                this.$log.error("[ConferenceService] joinPstnConference - missing parameter");\n                reject(new Error("[ConferenceService] joinPstnConference - missing parameter"));\n                return;\n            }\n            resolve(this.pstnConferenceService.initiatesCallParticipant(confId, participantPhoneNumber, participant, country));\n        });\n    }\n    ;\n    /**\n    * Method generateNewPersonalMeeting\n    * @private\n    * @param {boolean} shouldReset [optional] defaulted to false, whether or not we should reinitialize the conference codes and open Invite\n    * @memberof ConferenceService\n    */\n    generateNewPersonalMeeting(shouldReset = false) {\n        // Avoid cleaning loop\n        if (this.isRegeneratingPersonalMeeting) {\n            this.$log.debug("[ConferenceService] generateNewPersonalMeeting - Already cleaning");\n            return this.$q.resolve();\n        }\n        this.isRegeneratingPersonalMeeting = true;\n        return this.$q((resolve) => {\n            // Specific PGi case for instant meeting: we do the cleaning work here\n            this.$log.debug("[ConferenceService] generateNewPersonalMeeting - Create room to host new personal meeting");\n            return this.roomService.createRoom(this.$translate.instant("namePersonalConference", { name: this.contactService.userContact.displayName }), "", "none", null, true, "pstnAudio")\n                .then((newRoom) => {\n                this.$log.debug("[ConferenceService] generateNewPersonalMeeting - Attach conference endpoint to meeting");\n                return this.roomService.addRoomConferenceEndPoint(newRoom, this.getPstnInstantConferenceEndpoint(), this.MEDIATYPE.PSTNAUDIO);\n            })\n                .then((newRoom) => {\n                this.$log.debug("[ConferenceService] generateNewPersonalMeeting - Binding open-invite to new personal meeting");\n                return this.roomService.bindOpenInviteIdToRoom(newRoom);\n            })\n                .then((newRoom) => {\n                this.isRegeneratingPersonalMeeting = false;\n                if (shouldReset) {\n                    this.$log.debug("[ConferenceService] generateNewPersonalMeeting - Reset open-invite");\n                    this.roomService.resetOpenInviteId(newRoom.dbId)\n                        .then(() => {\n                        this.$log.debug("[ConferenceService] generateNewPersonalMeeting - Reset conference codes of new personal meeting");\n                        this.updateConference(this.getPstnInstantConferenceEndpointId(), { resetPasswords: true }, "pstnAudio")\n                            .then(() => {\n                            resolve();\n                        });\n                    });\n                }\n                else {\n                    resolve();\n                }\n            })\n                .catch(() => {\n                this.isRegeneratingPersonalMeeting = false;\n                this.$log.error("[ConferenceService] Something went wrong when trying to regenerate new personal meeting");\n                resolve();\n            });\n        });\n    }\n    /**\n    * Method initializePersonalMeeting\n    * @private\n    * Method initialize user\'s personal meeting, making sure that room to which is bound the openInviteID has a non-scheduled conference attached to it. If not, reinitialize the whole thing.\n    * @memberof ConferenceService\n    */\n    initializePersonalMeeting() {\n        return this.$q((resolve) => {\n            return this.roomService.retrievePersonalAudioRoom()\n                .then((room) => {\n                if (room && room.isMeetingRoom() && !room.conference.scheduled && room.getPstnConfEndpointId()) {\n                    resolve(room);\n                }\n                else {\n                    this.$log.warn("[ConferenceService] Open-Invite room does not meet the requirements, regenerating it ...");\n                    resolve(this.generateNewPersonalMeeting());\n                }\n            })\n                .catch(() => {\n                this.$log.warn("[ConferenceService] initializePersonalMeeting - something went wrong");\n                resolve();\n            });\n        });\n    }\n    retrievePersonalMeeting() {\n        return this.$q((resolve, reject) => {\n            return this.roomService.retrievePersonalAudioRoom()\n                .then((room) => {\n                resolve(room);\n            })\n                .catch(() => {\n                if (this.pstnConferenceService.isPstnConferenceAvailable) {\n                    this.$log.warn("[ConferenceService] retrievePersonalMeeting - Creating room and attaching open-invite-id");\n                    return this.roomService.createRoom(this.$translate.instant("namePersonalConference", { name: this.contactService.userContact.displayName }), "", "none", null, true, "pstnAudio")\n                        .then((newRoom) => {\n                        return this.roomService.addRoomConferenceEndPoint(newRoom, this.getPstnInstantConferenceEndpoint(), this.MEDIATYPE.PSTNAUDIO);\n                    })\n                        .then((newRoom) => {\n                        return this.roomService.bindOpenInviteIdToRoom(newRoom);\n                    })\n                        .then((newRoom) => { resolve(newRoom); })\n                        .catch(() => {\n                        reject(new Error("[ConferenceService] retrievePersonalMeeting - error regenerating personal meeting"));\n                    });\n                }\n                else {\n                    reject(new Error("[ConferenceService] retrievePersonalMeeting - not enough priviledges"));\n                }\n            });\n        });\n    }\n    /************************************************************/\n    /** WEBRTC/SFU STUFF                                        **/\n    /************************************************************/\n    /**\n    * Method subscribeToPublisher\n    * @public\n    * @param {string} confId [required] ID of conference to which we are wubscribing for\n    * @param {Object} publisher [required] the publisher we are subscribing to\n    * @param {string} elementId [optional] ID of an element to which we can related the publisher to\n    * @returns {ng.IPromise<any>} a promise that resolves when subscription is done\n    * @memberof ConferenceService\n    * Methos used to subscribe to a give,n publisher in the contaxt of a SFU conference\n    */\n    subscribeToPublisher(confId = "", publisher = null, elementId = "") {\n        return this.$q((resolve, reject) => {\n            // Missing parameters, return\n            if (!confId || !publisher) {\n                this.$log.warn("[ConferenceService] subscribeToPublisher missing parameters !! Ignore !");\n                resolve();\n                return;\n            }\n            this.$log.info("[ConferenceService] subscribeToPublisher for confId " + confId + " and publisher " + publisher.participantId);\n            if (elementId) {\n                this.webConferenceService.relatePublisherToElement(confId, publisher, elementId);\n            }\n            this.$http({\n                method: "POST",\n                url: this.confPortalURL + confId + "/participants/" + publisher.participantId + "/subscribe",\n                headers: this.authService.getRequestHeader()\n            })\n                .then((response) => {\n                this.$log.info("[ConferenceService] subscribeToPublisher successfully");\n                resolve(response.data);\n            }, (response) => {\n                let msg = response.data ? response.data.errorDetails : response.data;\n                let errorMessage = "subscribeToPublisher failure: " + msg;\n                this.$log.error("[ConferenceService] " + errorMessage);\n                reject(new Error(errorMessage));\n            });\n        });\n    }\n    /**\n    * Method isUserContactInCall\n    * @public\n    * @returns {boolean} true if user is in webrtc call, false otherwise\n    * @memberof ConferenceService\n    */\n    isUserContactInCall() {\n        for (let property in this.webConferenceService.conferenceSessions) {\n            if (this.webConferenceService.conferenceSessions.hasOwnProperty(property)) {\n                let webSession = this.webConferenceService.conferenceSessions[property];\n                if (webSession.isParticipantConnectedByJid(this.contactService.userContact.jid)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n    * Method stopAllConferencesFromRoom\n    * @public\n    * @returns {ng.IPromise<any>}\n    * @memberof ConferenceService\n    */\n    stopAllConferencesFromRoom(room) {\n        var stopConferenceArray = [];\n        var pstnConfId = room.getPstnConfEndpointId();\n        var webSharingConfId = room.getSFUSharingConfEndpointId();\n        var sfuConfId = room.getSFUConfEndpointId();\n        if (pstnConfId) {\n            stopConferenceArray.push(this.stopConference(pstnConfId));\n        }\n        if (webSharingConfId) {\n            stopConferenceArray.push(this.stopConference(webSharingConfId, "webrtc"));\n        }\n        if (sfuConfId) {\n            stopConferenceArray.push(this.stopConference(sfuConfId, "webrtc"));\n        }\n        return this.$q.all(stopConferenceArray);\n    }\n    ;\n    /**\n    * Method refreshConferenceSessions\n    * @public Method re refreshes all the conferenceSessions stored inside the service by doing a snapshot on them\n    * @returns {ng.IPromise<any>} a promise containing the result of the request or error\n    * @memberof ConferenceService\n    */\n    refreshConferenceSessions() {\n        let promoseArray = [];\n        promoseArray.push(this.webConferenceService.refreshConferenceSessions());\n        promoseArray.push(this.pstnConferenceService.refreshConferenceSessions());\n        return this.$q.all(promoseArray);\n    }\n}\nConferenceService.$inject = [\n    "$q",\n    "$log",\n    "$rootScope",\n    "$interval",\n    "$translate",\n    "$http",\n    "xmppService",\n    "authService",\n    "Conference",\n    "profileService",\n    "contactService",\n    "webConferenceService",\n    "pstnConferenceService",\n    "roomService",\n    "errorHelperService"\n];\nangular.module("rainbow").service("conferenceService", ConferenceService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/conference/conferenceService.ts?')},function(module,exports){eval('angular.module("rainbow").service("profileService", ["$q", "$rootScope", "$log", "$http", "$interval", "Offer", "authService", "contactService", "xmppService", function ($q, $rootScope, $log, $http, $interval, Offer, authService, contactService, xmppService) {\n  "use strict";\n\n  var service = this;\n  service.FeaturesEnum = {\n    COMPANY_ADMIN_COUNT: "COMPANY_ADMIN_COUNT",\n    COMPANY_LOGO_MODIFICATION: "COMPANY_LOGO_MODIFICATION",\n    COMPANY_DOMAIN_NAME_MODIFICATION: "COMPANY_DOMAIN_NAME_MODIFICATION",\n    COMPANY_DETAILS_MODIFICATION: "COMPANY_DETAILS_MODIFICATION",\n    COMPANY_SINGLE_SIGN_ON_SAML: "COMPANY_SINGLE_SIGN_ON_SAML",\n    COMPANY_SINGLE_SIGN_ON_OIDC: "COMPANY_SINGLE_SIGN_ON_OIDC",\n    WEBRTC_FOR_MOBILE: "WEBRTC_FOR_MOBILE",\n    BUBBLE_PARTICIPANT_COUNT: "BUBBLE_PARTICIPANT_COUNT",\n    TELEPHONY_BASIC_CALL: "TELEPHONY_BASIC_CALL",\n    TELEPHONY_SECOND_CALL: "TELEPHONY_SECOND_CALL",\n    TELEPHONY_TRANSFER_CALL: "TELEPHONY_TRANSFER_CALL",\n    TELEPHONY_CONFERENCE_CALL: "TELEPHONY_CONFERENCE_CALL",\n    TELEPHONY_DEFLECT_CALL: "TELEPHONY_DEFLECT_CALL",\n    TELEPHONY_PHONE_BOOK: "TELEPHONY_PHONE_BOOK",\n    TELEPHONY_VOICE_MAIL: "TELEPHONY_VOICE_MAIL",\n    TELEPHONY_CALL_FORWARD: "TELEPHONY_CALL_FORWARD",\n    TELEPHONY_NOMADIC: "TELEPHONY_NOMADIC",\n    CONFERENCE_PARTICIPANT_COUNT: "CONFERENCE_PARTICIPANT_COUNT",\n    CONFERENCE_PARTICIPANT_ALLOWED: "CONFERENCE_PARTICIPANT_ALLOWED",\n    WEBRTC_CONFERENCE_ALLOWED: "WEBRTC_CONFERENCE_ALLOWED",\n    WEBRTC_CONFERENCE_PARTICIPANT_COUNT: "WEBRTC_CONFERENCE_PARTICIPANT_COUNT",\n    WEBRTC_PARTICIPANT_ALLOWED: "WEBRTC_PARTICIPANT_ALLOWED",\n    CONFERENCE_ALLOWED: "CONFERENCE_ALLOWED",\n    CONFERENCE_DIAL_OUT: "CONFERENCE_DIAL_OUT",\n    CONFERENCE_RECORDING: "CONFERENCE_RECORDING",\n    MSO365_CALENDAR_PRESENCE: "MSO365_CALENDAR_PRESENCE",\n    MSO365_DIRECTORY_PROVISIONING: "MSO365_DIRECTORY_PROVISIONING",\n    MSO365_DIRECTORY_SEARCH: "MSO365_DIRECTORY_SEARCH",\n    MS_OUTLOOK_PLUGIN: "MS_OUTLOOK_PLUGIN",\n    MS_SKYPE_PLUGIN: "MS_SKYPE_PLUGIN",\n    FILE_SHARING_QUOTA_GB: "FILE_SHARING_QUOTA_GB",\n    GOOGLE_CALENDAR_PRESENCE: "GOOGLE_CALENDAR_PRESENCE",\n    WEBRTC_P2P_RECORDING: "WEBRTC_P2P_RECORDING",\n    BUBBLE_PROMOTE_MEMBER: "BUBBLE_PROMOTE_MEMBER",\n    BUBBLE_GUESTS_ALLOWED: "BUBBLE_GUESTS_ALLOWED",\n    TELEPHONY_WEBRTC_GATEWAY: "TELEPHONY_WEBRTC_GATEWAY",\n    TELEPHONY_WEBRTC_PSTN_CALLING: "TELEPHONY_WEBRTC_PSTN_CALLING",\n    ANALYTICS_DASHBOARD_EC: "ANALYTICS_DASHBOARD_EC",\n    ANALYTICS_DASHBOARD_BP: "ANALYTICS_DASHBOARD_BP",\n    TELEPHONY_CALL_SUBJECT: "CALL_SUBJECT",\n    CHANNEL_CREATE: "CHANNEL_CREATE",\n    CHANNEL_CREATE_ADMIN_ROLE_BYPASS: "CHANNEL_CREATE_ADMIN_ROLE_BYPASS",\n    CHANNEL_ACTIVATED: "CHANNEL_ACTIVATED",\n    MANAGE_ANDROID_TV: "MANAGE_ANDROID_TV",\n    USE_ANDROID_TV: "USE_ANDROID_TV",\n    MASSPRO_USER_PROVISIONING_CSV: "MASSPRO_USER_PROVISIONING_CSV",\n    SEARCH_BY_TAGS: "SEARCH_BY_TAGS",\n    TELEPHONY_3DPARTY_ASSOC: "TELEPHONY_3DPARTY_ASSOC",\n    WEBCLIENT_UI_2_0: "WEBCLIENT_UI_2_0"\n  };\n  /*********************************************************************/\n\n  /** LIFECYCLE STUFF                                                 **/\n\n  /*********************************************************************/\n\n  service.started = false;\n\n  service.start = function (stats) {\n    $log.info("");\n    $log.info("[profileService] === STARTING ===");\n    service.features = {};\n    service.profiles = [];\n    service.mainOffers = [];\n    service.thirdPartyApps = null;\n    var startDate = performance.now();\n    service.attachHandlers();\n    return $q(function (resolve, reject) {\n      // Fetch profile from server\n      service.getServerProfile().then(function () {\n        // Consider service as started\n        service.started = true;\n        var startDuration = Math.round(performance.now() - startDate);\n        stats.push({\n          service: "profileService",\n          startDuration: startDuration\n        });\n        $log.info("[profileService] === STARTED (" + startDuration + " ms) ===");\n        $rootScope.$broadcast("ON_PROFILE_FEATURES_UPDATED");\n        resolve();\n      })["catch"](function (error) {\n        $log.info("[profileService] === STARTING FAILURE === " + error.message);\n        reject(error);\n      });\n    });\n  };\n\n  service.stop = function () {\n    $log.info("[profileService] === STOPPING ===");\n    service.detachHandlers();\n    service.started = false;\n    $log.info("[profileService] === STOPPED ===");\n    return $q.when();\n  };\n\n  service.attachHandlers = function () {\n    service.detachHandlers();\n    $log.info("[profileService] attachHandlers");\n    this.profileEventHandler = xmppService.addHandler(service.onManagementMessageReceived, null, "message", "management");\n  };\n\n  service.detachHandlers = function () {\n    $log.info("[profileService] detachHandlers");\n\n    if (this.profileEventHandler) {\n      xmppService.deleteHandler(this.profileEventHandler);\n      this.profileEventHandler = null;\n    }\n  };\n\n  service.restart = function () {\n    $log.info("[profileService] === RESTART ===");\n    service.attachHandlers(); //resend the features for the desktop client\n\n    service.onUserUpdateNeeded();\n  };\n\n  service.onManagementMessageReceived = function (stanza) {\n    try {\n      var userprofileElem = $(stanza).find("userprofile");\n      $log.info("[profileService] onManagementMessageReceived  -- on userprofile management message received");\n\n      if (userprofileElem.length) {\n        switch (userprofileElem.attr("action")) {\n          case "create":\n          case "update":\n          case "delete":\n            service.onUserUpdateNeeded();\n            break;\n\n          default:\n            $log.info("[profileService] onManagementMessageReceived  -- unknown action");\n            break;\n        }\n      }\n\n      return true;\n    } catch (error) {\n      $log.error("[profileService] onManagementMessageReceived ERROR " + error);\n      return true;\n    }\n  };\n\n  service.onUserUpdateNeeded = function () {\n    //wait 3 seconds before requesting the featureProfile for this user; ignore events in the meantime\n    if (service.timer) {\n      return;\n    }\n\n    service.timer = $interval(function () {\n      service.getServerProfile().then(function () {\n        $rootScope.$broadcast("ON_PROFILE_FEATURES_UPDATED");\n        service.timer = null;\n      })["catch"](function (error) {\n        service.timer = null;\n        $log.info("[profileService] === onUserUpdateNeeded FAILURE === " + error.message); // reject(error);\n      });\n    }, 3000, 1);\n  };\n  /*********************************************************************/\n\n  /** PROFILE API STUFF                                          **/\n\n  /*********************************************************************/\n\n\n  service.getServerProfile = function () {\n    return $q.all([service.getServerProfiles(), service.getServerProfilesFeatures()]);\n  };\n\n  service.getServerProfiles = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/profiles",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        service.profiles = [];\n        service.mainOffers = [];\n        response.data.data.forEach(function (profileData) {\n          $log.debug("[profileService] getServerProfiles === response ===" + profileData); //store profile data\n\n          service.profiles.push(profileData);\n          var offer = Offer.createFromProfileData(profileData);\n\n          if (offer.isExclusive || offer.isDefault) {\n            service.mainOffers.push(offer);\n          }\n        });\n        service.mainOffers.sort(Offer.offerComparator);\n        resolve();\n      }, function error(response) {\n        var errorMessage = "getServerProfiles failure: no server response";\n\n        if (response) {\n          errorMessage = "getServerProfiles failure: " + JSON.stringify(response);\n        }\n\n        $log.error("[profileService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.getServerProfilesFeatures = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId + "/profiles/features",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        service.features = {};\n        response.data.data.forEach(function (featureData) {\n          $log.debug("[profileService] getServerProfilesFeatures === response ===" + JSON.stringify(featureData)); //store feature data\n\n          if (featureData.hasOwnProperty("featureUniqueRef")) {\n            service.features[featureData.featureUniqueRef] = featureData;\n          }\n        });\n        resolve();\n      }, function error(response) {\n        var errorMessage = "getServerProfilesFeatures failure: no server response";\n\n        if (response) {\n          errorMessage = "getServerProfilesFeatures failure: " + JSON.stringify(response);\n        }\n\n        $log.error("[profileService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /*********************************************************************/\n\n  /** USER DATA API STUFF                                             **/\n\n  /*********************************************************************/\n\n\n  service.getUserData = function getUserData() {\n    return authService.getUserData();\n  };\n\n  service.setUserData = function setUserData(params) {\n    return $q(function (resolve, reject) {\n      var url = config.restServerUrl + "/api/rainbow/enduser/v1.0/users/" + contactService.userContact.dbId;\n      $http({\n        method: "PUT",\n        url: url,\n        headers: authService.getRequestHeader(),\n        data: params\n      }).then(function success(result) {\n        $log.info("[profileService] setUserData " + JSON.stringify(params) + " -- success");\n        resolve(result.data);\n      }, function failure(response) {\n        var errorMessage = "setUserData failure: no server response";\n\n        if (response) {\n          errorMessage = "setUserData failure: " + JSON.stringify(response);\n        }\n\n        $log.error("[profileService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /**\n         * APIs for GUI components\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.isFeatureEnabled = function (featureUniqueRef, features) {\n    if (!features) {\n      features = service.features;\n    }\n\n    if (service.started && features.hasOwnProperty(featureUniqueRef) && features[featureUniqueRef].hasOwnProperty("featureType") && features[featureUniqueRef].featureType === "boolean" && features[featureUniqueRef].hasOwnProperty("isEnabled")) {\n      var enabled = features[featureUniqueRef].isEnabled;\n      $log.debug("[profileService] isFeatureEnabled(" + featureUniqueRef + "): " + enabled);\n      return enabled;\n    }\n\n    $log.info("[profileService] isFeatureEnabled(" + featureUniqueRef + "): service not started or feature not enabled");\n    return false;\n  };\n\n  service.getFeatureLimitMax = function (featureUniqueRef) {\n    if (service.started && service.features.hasOwnProperty(featureUniqueRef) && service.features[featureUniqueRef].hasOwnProperty("featureType") && service.features[featureUniqueRef].featureType === "number" && service.features[featureUniqueRef].hasOwnProperty("limitMax")) {\n      var limitMax = service.features[featureUniqueRef].limitMax;\n      $log.debug("[profileService] getFeatureLimitMax(" + featureUniqueRef + "): " + limitMax);\n      return limitMax;\n    }\n\n    $log.info("[profileService] getFeatureLimitMax(" + featureUniqueRef + "): service not started or feature not enabled");\n    return 0;\n  };\n\n  service.getFeatureLimitMin = function (featureUniqueRef) {\n    if (service.started && service.features.hasOwnProperty(featureUniqueRef) && service.features[featureUniqueRef].hasOwnProperty("featureType") && service.features[featureUniqueRef].featureType === "number" && service.features[featureUniqueRef].hasOwnProperty("limitMin")) {\n      var limitMin = service.features[featureUniqueRef].limitMin;\n      $log.debug("[profileService] getFeatureLimitMin(" + featureUniqueRef + "): " + limitMin);\n      return limitMin;\n    }\n\n    $log.info("[profileService] getFeatureLimitMin(" + featureUniqueRef + "): service not started or feature not enabled");\n    return 0;\n  };\n  /**\n   * Returns the profile "Enterprise", "Business", "Essential" or null (if none of them)\n   */\n\n\n  service.getMyProfileOffer = function () {\n    if (service.mainOffers.length > 0) {\n      return service.mainOffers.slice(-1)[0];\n    }\n\n    return null;\n  };\n\n  service.getMyProfileName = function () {\n    var profile = this.getMyProfileOffer();\n\n    if (profile) {\n      return profile.name;\n    }\n\n    return null;\n  };\n  /**\n         * APIs for GUI components\n         * Used by SDK (public)\n   */\n\n\n  service.getMyProfiles = function () {\n    var profiles = [];\n\n    if (service.started) {\n      //TODO return a simplified profile object ???\n      profiles = service.profiles;\n    } else {\n      $log.warn("[profileService] getMyProfiles(): service not started");\n    }\n\n    return profiles;\n  };\n  /**\n         * Used by SDK (public)\n         * Warning when modifying this method\n         */\n\n\n  service.getMyProfileFeatures = function () {\n    var profileFeatures = {};\n\n    if (service.started) {\n      //return a simplified feature object with featureType, limitMin, limitMax and isEnabled properties only\n      Object.keys(service.features).forEach(function (featureUniqueRef) {\n        var originalFeature = service.features[featureUniqueRef];\n        var feature = {};\n        Object.keys(originalFeature).filter(function (featureProperty) {\n          return featureProperty === "featureUniqueRef" || featureProperty === "featureType" || featureProperty === "limitMin" || featureProperty === "limitMax" || featureProperty === "isEnabled";\n        }).forEach(function (featureProperty) {\n          feature[featureProperty] = originalFeature[featureProperty];\n        });\n        profileFeatures[featureUniqueRef] = feature;\n      });\n    } else {\n      $log.warn("[profileService] getMyProfileFeatures(): service not started");\n    }\n\n    return profileFeatures;\n  };\n  /*\n  * Get The list of the Third Party Application that have access to this Rainbow Account\n  * Parameter force in order to refresh the list\n  */\n\n\n  service.getThirdPartyApps = function (force) {\n    return $q(function (resolve, reject) {\n      //we\'ve already asked the server for the list\n      if (service.thirdPartyApps !== null && !force) {\n        $log.info("[profileService] getThirdPartyApps -- from cache");\n        return resolve(service.thirdPartyApps);\n      }\n\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/authentication/v1.0/oauth/tokens?format=medium",\n        headers: authService.getRequestHeader()\n      }).then(function (response) {\n        $log.info("[profileService] getThirdPartyApps from server -- success");\n\n        if (response.data && response.data.data) {\n          service.thirdPartyApps = response.data.data;\n        } else {\n          service.thirdPartyApps = [];\n        }\n\n        resolve(service.thirdPartyApps);\n      })["catch"](function (error) {\n        var errorMessage = "getThirdPartyApps from server failed -- no answer from server";\n\n        if (error) {\n          errorMessage = "getThirdPartyApps from server failed -- " + JSON.stringify(error);\n        }\n\n        $log.error("[profileService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n  /*\n  * Revoke the access of a third-party application from Rainbow\n  * The tokenId should be sent as a parameter\n  */\n\n\n  service.revokeThirdPartyAccess = function (tokenId) {\n    return $q(function (resolve, reject) {\n      if (!tokenId) {\n        $log.warn("[profileService] revokeThirdPartyAccess missing token");\n        return reject();\n      }\n\n      $log.info("[profileService] revokeThirdPartyAccess with token -- " + tokenId);\n      $http({\n        method: "DELETE",\n        url: config.restServerUrl + "/api/rainbow/authentication/v1.0/oauth/tokens/" + tokenId,\n        headers: authService.getRequestHeader()\n      }).then(function () {\n        $log.info("[profileService] revokeThirdPartyAccess -- success");\n        service.thirdPartyApps.forEach(function (app, index) {\n          if (app.id === tokenId) {\n            service.thirdPartyApps.splice(index, 1);\n          }\n        });\n        resolve(service.thirdPartyApps);\n      })["catch"](function (error) {\n        var errorMessage = "revokeThirdPartyAccess from server failed -- no answer from server";\n\n        if (error) {\n          errorMessage = "revokeThirdPartyAccess from server failed -- " + JSON.stringify(error);\n        }\n\n        $log.error("[profileService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/profileService.js?')},function(module,exports){eval('angular.module("rainbow").service("updatingService", ["$http", "$log", "$rootScope", "$interval", "helpersService", "centralizedService", "videoService", "telephonyService", "webConferenceService", function ($http, $log, $rootScope, $interval, helpersService, centralizedService, videoService, telephonyService, webConferenceService) {\n  "use strict"; // Store context\n\n  var service = this;\n  service.url = window.location.origin + "/app/" + version + "/js/version.js";\n  service.started = false;\n  /*****************************************************/\n\n  /**  INITIALIZATION STUFF                           **/\n\n  /*****************************************************/\n\n  service.start = function () {\n    $log.info("[updatingService] === STARTING ===");\n    service.started = true;\n    $log.info("[updatingService] === STARTED ===");\n\n    if (service.url.indexOf("localhost") !== -1) {\n      $log.info("[updatingService] Do not start on localhost");\n      return;\n    }\n\n    if (service.interval) {\n      $interval.cancel(service.interval);\n    }\n\n    service.interval = $interval(service.checkUpdate, 600000);\n\n    if (centralizedService.isDesktopApp()) {\n      //workaround for update on Desktop versions <= 1.35.4.0\n      if (service.intervalDesktop) {\n        $interval.cancel(service.intervalDesktop);\n      }\n\n      service.intervalDesktop = $interval(service.checkUpdateForDesktop, 600000);\n    }\n  };\n\n  service.checkUpdate = function () {\n    $log.info("[updatingService] - Checking if a new version is online...");\n    $http({\n      method: "GET",\n      url: service.url + "?rand=" + helpersService.randomString()\n    }).then(function successCallback() {\n      $log.info("[updatingService] - The web client is up to date");\n    }, function errorCallback(response) {\n      var isInVideoCall = videoService.isUserContactInCall();\n      var isInTelephonyCall = telephonyService.getActiveCall();\n      var isInConferenceCall = webConferenceService.hasActiveConferenceSession();\n\n      if (response.status === 404) {\n        if (!isInVideoCall && !isInTelephonyCall && !isInConferenceCall) {\n          $log.info("[updatingService] - Update available !");\n          $rootScope.$broadcast("ON_AVAILABLE_UPDATE");\n        } else {\n          $log.warn("[updatingService] - Update available but user is in call !");\n        }\n      } else {\n        $log.info("[updatingService] - An unknow error has been encountered.");\n      }\n    });\n  };\n\n  service.checkUpdateForDesktop = function () {\n    var version = centralizedService.containerVersion();\n    $log.info("[updatingService] - Checking if a new desktop version is available... " + version); //DNI : correction on some desktop clients where the desktop version is unknown ?? !!\n\n    if (!version) {\n      var userAgent = navigator.userAgent.substring(navigator.userAgent.indexOf("Rainbow"));\n\n      if (userAgent) {\n        version = userAgent.split("/")[1];\n      }\n    } //DNI : if still no version, do not show popup\n\n\n    if (!version) {\n      $log.error("[updatingService] - no desktop version found !! ");\n      return;\n    }\n\n    var temp = version.split("."); //should update all versions <= 1.35.4.0\n\n    if (parseInt(temp[1], 10) < 35 || parseInt(temp[1], 10) === 35 && parseInt(temp[2], 10) <= 4) {\n      $log.info("[updatingService] - should update from version " + version);\n      var data = {\n        popupTitle: "updatingDesktopTitle",\n        popupBody: "updatingDesktopMessage",\n        okLabel: "download",\n        okLink: config.autorizationMicrosoftLink,\n        blockingPopup: true\n      };\n\n      if (navigator.platform.toUpperCase().indexOf("MAC") >= 0) {\n        data.okLink = config.clientsURL.mac;\n      } else {\n        data.okLink = config.clientsURL.windows;\n      }\n\n      $rootScope.$broadcast("ON_OPEN_GLOBAL_POPUP", data);\n    }\n  };\n\n  service.stop = function () {\n    $log.info("[updatingService] === STOPPING ===");\n    service.started = false;\n\n    if (service.interval) {\n      $interval.cancel(service.interval);\n    }\n\n    if (service.intervalDesktop) {\n      $interval.cancel(service.intervalDesktop);\n    }\n\n    $log.info("[updatingService] === STOPPED ===");\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/updatingService.js?')},function(module,exports){eval('function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nangular.module("rainbow").service("calendarService", ["$q", "$rootScope", "$log", "$http", "$interval", "authService", "contactService", "xmppService", "errorHelperService", "profileService", "conversationService", "settingsService", "$localStorage", function ($q, $rootScope, $log, $http, $interval, authService, contactService, xmppService, errorHelperService, profileService, conversationService, settingsService, $localStorage) {\n  "use strict";\n  /*********************************************************************/\n\n  /** LIFECYCLE STUFF                                                 **/\n\n  /*********************************************************************/\n\n  var that = this;\n  this.intervalID = null;\n\n  this.start = function (stats) {\n    $log.info("");\n    $log.info("[calendarService] === STARTING ===");\n    var startDate = performance.now();\n    that.serviceActivated = false;\n    that.serviceState = null;\n    that.calendarState = null;\n    that.autorizationLink = "";\n    that.calendaRejectIfBusyActivated = false; // Listen \'out of office\' status for roster contacts\n\n    $log.info("[calendarService] listen \'out of office\' status for roster contacts");\n    $interval(that.getAutoReplyForEachContact, 5000, 1);\n    that.intervalID = $interval(that.updateAutoReplyForEachContact, 900000); // Get profileService calendar features\n\n    that.officeCalendarPresenceEnabled = profileService.isFeatureEnabled(profileService.FeaturesEnum.MSO365_CALENDAR_PRESENCE);\n    that.googleCalendarPresenceEnabled = profileService.isFeatureEnabled(profileService.FeaturesEnum.GOOGLE_CALENDAR_PRESENCE);\n    that.calendarPresenceEnabled = that.officeCalendarPresenceEnabled || that.googleCalendarPresenceEnabled;\n    $log.info("[calendarService] calendar presence status from profileService : " + that.calendarPresenceEnabled); // Get userSettings calendar prompt status\n\n    that.disableCalendarPresencePrompt = settingsService.getSetting("disableCalendarPresence") === "true";\n    $log.info("[calendarService] calendar presence prompt status from userSettings : " + !that.disableCalendarPresencePrompt); // Update stat information\n\n    var startDuration = Math.round(performance.now() - startDate);\n    stats.push({\n      service: "calendarService",\n      startDuration: startDuration\n    });\n    $log.info("[calendarService] === STARTED (" + startDuration + " ms) ===");\n\n    if (that.calendarPresenceEnabled && !contactService.userContact.guestMode) {\n      // Listen for calendar xmpp management messages\n      that.attachHandlers(); // Listen to calendar presence changes\n\n      that.calendarPresenceChangeListener = $rootScope.$on("ON_ROSTER_PRESENCE_CHANGED_EVENT", that.onCalendarPresenceChange);\n      that.connectionStateChangeListener = $rootScope.$on("ON_CONNECTION_STATE_CHANGE_EVENT", that.onConnectionStateChange); // Get get and handle calendar state\n\n      that.getCalendarState().then(function () {\n        if (that.serviceState === "enabled") {\n          that.handleEnableState();\n        }\n      })["catch"](function (error) {\n        that.serviceActivated = false;\n        that.serviceState === "failed";\n        $log.error("[calendarService] === STARTING FAILURE === " + error.message);\n      });\n    }\n\n    return $q.when();\n  };\n\n  this.attachHandlers = function () {\n    $log.info("[calendarService] attachHandlers");\n\n    if (that.messageHandlerRef) {\n      xmppService.deleteHandler(that.messageHandlerRef);\n      that.messageHandlerRef = null;\n    }\n\n    that.messageHandlerRef = xmppService.addHandler(function (stanza) {\n      that.onUpdateMessageReceived(stanza);\n      return true;\n    }, "jabber:iq:configuration", "message", null);\n  };\n\n  this.stop = function () {\n    $log.info("[calendarService] === STOPPING ===");\n    that.serviceActivated = false; // Remove listeners\n\n    if (that.calendarPresenceChangeListener) {\n      that.calendarPresenceChangeListener();\n    }\n\n    if (that.connectionStateChangeListener) {\n      that.connectionStateChangeListener();\n    }\n\n    if (that.messageHandlerRef) {\n      xmppService.deleteHandler(that.messageHandlerRef);\n      that.messageHandlerRef = null;\n    }\n\n    if (that.intervalID) {\n      $interval.cancel(that.intervalID);\n    }\n\n    $log.info("[calendarService] === STOPPED ===");\n    return $q.when();\n  };\n\n  this.onConnectionStateChange = function (__event, state) {\n    if (state === "connected") {\n      $log.info("[calendarService] onConnectionStateChange state:" + state);\n      that.getCalendarState().then(function () {\n        if (that.serviceState === "enabled") {\n          that.handleEnableState();\n        }\n\n        if (that.serviceState === "consent_required") {\n          that.handleConsentRequiredState();\n        }\n      })["catch"](function (error) {\n        that.serviceActivated = false;\n        that.serviceState === "failed";\n        $log.error("[calendarService] === FAILURE === " + error.message);\n      });\n    }\n  };\n\n  this.handleEnableState = function () {\n    var date = this.calendarState.until ? new Date(this.calendarState.until) : null;\n    var status = this.calendarState.busy ? "dnd" : "online";\n    var message = this.calendarState.busy ? "busy" : "";\n    that.updateCalendarPresenceForUser(contactService.userContact.jid, status, date, message);\n  };\n\n  this.handleConsentRequiredState =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee() {\n    var registrationParams;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return that.getRegistrationParams(false);\n\n          case 2:\n            registrationParams = _context.sent;\n            $rootScope.$broadcast("ON_OPEN_CALENDARSELECTION_POPUP", registrationParams);\n\n          case 4:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  /*********************************************************************/\n\n  /** EVENT LISTENERS                                                 **/\n\n  /*********************************************************************/\n\n  this.onUpdateMessageReceived = function (stanza) {\n    var info = $(stanza).find("calendar");\n\n    if (info.length) {\n      that.serviceState = info.attr("status");\n      that.serviceActivated = that.serviceState === "enabled";\n      $rootScope.$broadcast("ON_CALENDAR_STATUS_CHANGE", that.serviceActivated);\n      $log.info("[calendarService] onUpdateMessageReceived with state : " + that.serviceState);\n\n      if (that.serviceState === "consent_required") {\n        that.handleConsentRequiredState();\n      }\n    }\n\n    return true;\n  };\n\n  this.onCalendarPresenceChange = function (__event, attr) {\n    if (contactService.isTelJid(attr.jid) && contactService.getRessourceFromJid(attr.jid) === "calendar") {\n      var jid_im = contactService.getImJid(attr.jid);\n\n      if (jid_im) {\n        $log.info("[calendarService] onCalendarPresenceChange -- status: " + attr.status + " -- until: " + attr.until + " -- message: " + attr.message);\n        that.updateCalendarPresenceForUser(jid_im, attr.status, attr.until, attr.message);\n      }\n    }\n  };\n  /*********************************************************************/\n\n  /** OUT OF OFFICE STUFF                                             **/\n\n  /*********************************************************************/\n\n\n  this.updateAutoReplyForEachContact = function () {\n    // Update my Out of Office information\n    that.getAutoReplyInfoForContact(contactService.userContact); // Update the Out of Office information for each conversation\n\n    that.getAutoReplyForEachContact();\n  };\n\n  this.getAutoReplyForEachContact = function () {\n    $log.info("[calendarService] getAutoReplyForEachContact");\n    conversationService.getConversations().forEach(function (conversation) {\n      if (conversation.contact !== null) {\n        that.getAutoReplyInfoForContact(conversation.contact);\n      }\n    });\n  };\n\n  this.getAutoReplyInfoForContact = function (contact) {\n    return $q(function (resolve, reject) {\n      // Test if user has calendar state activated\n      if (!contact.calendarState.status) {\n        $log.info("[calendarService] getAutoReplyInfoForContact user has no calendar state");\n        resolve();\n        return;\n      } // Test if state has been asked recently\n\n\n      if (contact.calendarState.lastUpdate) {\n        var duration = moment.duration(contact.calendarState.lastUpdate.diff(moment()));\n        var diff = Math.abs(Math.floor(duration.asMinutes()));\n\n        if (diff < 15) {\n          $log.info("[calendarService] getAutoReplyInfoForContact state has been updated in the last 15min");\n          resolve();\n          return;\n        }\n      }\n\n      contact.calendarState.lastUpdate = moment();\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/calendar/v1.0/automatic_reply?userid=" + contact.dbId,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        that.treatOutOfOfficeState(response.data, contact);\n        $log.info("[calendarService] getAutoReplyInfoForContact success for contact " + contact.dbId);\n        resolve();\n      }, function error(response) {\n        var err = errorHelperService.handleError(response);\n        $log.error("[calendarService] " + errorHelperService.getErrorFullMessage(response, "getAutoReplyInfoForContact"));\n        reject(err);\n      });\n    });\n  };\n  /*********************************************************************/\n\n  /** PRIVATE REST REQUEST                                            **/\n\n  /*********************************************************************/\n\n\n  this.getCalendarState = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/calendar/v1.0",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var successMessage = "[calendarService] getCalendarState success -- ";\n        var calendarInfo = response.data;\n\n        if (calendarInfo.status === "busy" || calendarInfo.status === "free" || calendarInfo.status === "out_of_office") {\n          that.serviceState = "enabled";\n          that.calendarState = calendarInfo;\n          successMessage += that.serviceState + " " + that.calendarState.status;\n        } else {\n          that.serviceState = calendarInfo.status;\n          that.calendarState = null;\n          successMessage += that.serviceState;\n        }\n\n        $log.info(successMessage);\n        resolve(response.data);\n      }, function error() {\n        $log.error("[calendarService] getCalendarState failure -- CalendarService portal not responding");\n        reject();\n      });\n    });\n  };\n\n  this.getRegistrationParams = function (fromSettings) {\n    return $q(function (resolve) {\n      $log.info("[calendarService] getRegistrationParams");\n      var promiseArray = [];\n\n      if (that.officeCalendarPresenceEnabled) {\n        promiseArray.push(that.getCalendarRegistrationInfo("office365"));\n      }\n\n      if (that.googleCalendarPresenceEnabled) {\n        promiseArray.push(that.getCalendarRegistrationInfo("googleCalendar"));\n      }\n\n      $q.all(promiseArray)["finally"](function () {\n        if (that.autorizationGoogleLink || that.autorizationMicrosoftLink) {\n          $log.info("[calendarService] getRegistrationParams -- show registration popup or tooltip");\n          resolve({\n            authentMicrosoftUrl: that.autorizationMicrosoftLink,\n            authentGoogleUrl: that.autorizationGoogleLink,\n            fromSettings: fromSettings\n          });\n        } else {\n          $log.error("[calendarService] getRegistrationParams -- no calendar provider response");\n          resolve();\n        }\n      });\n    });\n  };\n\n  this.getCalendarRegistrationInfo = function (type) {\n    var calendarRedirect = "o365";\n    var calendarType = "office365";\n\n    if (type === "googleCalendar") {\n      calendarRedirect = "gcal";\n      calendarType = "google";\n    }\n\n    return $q(function (resolve, reject) {\n      var lang = settingsService.getAppliLanguage().code;\n      $http({\n        method: "POST",\n        url: config.restServerUrl + "/api/rainbow/calendar/v1.0/register",\n        headers: authService.getRequestHeader(),\n        data: {\n          "type": calendarType,\n          "callback": window.location.origin + "/redirectO365.html?provider=" + calendarRedirect + "&lang=" + lang\n        }\n      }).then(function success(response) {\n        $log.info("[calendarService] getCalendarRegistrationInfo for " + type + " -- success");\n        that.autorizationLink = response.data.url;\n\n        if (type === "googleCalendar") {\n          that.autorizationGoogleLink = that.autorizationLink;\n        } else {\n          that.autorizationMicrosoftLink = that.autorizationLink;\n        }\n\n        resolve(that.autorizationLink);\n      }, function error(response) {\n        $log.error("[calendarService] getCalendarRegistrationInfo failure");\n        $log.error(response);\n        reject();\n      });\n    });\n  };\n\n  this.deactivateCalendar = function () {\n    $log.info("[calendarService] deactivateCalendar");\n    return $q(function (resolve, reject) {\n      $http({\n        method: "DELETE",\n        url: config.restServerUrl + "/api/rainbow/calendar/v1.0",\n        headers: authService.getRequestHeader()\n      }).then(function success() {\n        $log.info("[calendarService] deactivateCalendar success");\n        that.serviceActivated = false;\n        resolve();\n      }, function error(response) {\n        $log.error("[calendarService] deactivateCalendar failure");\n        $log.error(response);\n        reject();\n      });\n    });\n  };\n  /*********************************************************/\n\n  /**                 PRIVATE FUNCTIONS                   **/\n\n  /*********************************************************/\n\n\n  this.updateCalendarPresenceForUser = function (jid, status, date, message) {\n    contactService.getOrCreateContact(jid).then(function (contact) {\n      contact.calendarState.status = status;\n      contact.calendarState.message = message; // Compute date\n\n      var mdate = null;\n\n      if (status !== "online" && !date) {\n        date = new Date();\n      }\n\n      if (date) {\n        mdate = moment(date);\n      }\n\n      contact.calendarState.mdate = mdate;\n\n      if (mdate) {\n        if (mdate.isSame(moment(), "d")) {\n          contact.calendarState.until = mdate.format("LT");\n          contact.calendarState.untilDate = false;\n        } else {\n          contact.calendarState.until = mdate.format("ll");\n          contact.calendarState.untilDate = true;\n        }\n      } else {\n        if (!date) {\n          date = new Date();\n        }\n\n        contact.calendarState.until = date;\n        contact.calendarState.untilDate = false;\n      }\n\n      if (contactService.isUserContact(contact)) {\n        $log.info("[calendarService] updateCalendarPresenceForUser for my user : " + status + " until " + date);\n\n        if (!that.serviceActivated && status !== "offline") {\n          that.serviceActivated = true;\n          $rootScope.$broadcast("ON_CALENDAR_STATUS_CHANGE", that.serviceActivated);\n        }\n\n        that.getAutoReplyInfoForContact(contactService.userContact);\n      } else {\n        $log.info("[calendarService] updateCalendarPresenceForUser for user : " + jid + " with : " + status + " until " + date);\n      }\n\n      $rootScope.$broadcast("ON_CONTACT_CALENDAR_STATUS_CHANGE", contact);\n    })["catch"](function (error) {\n      $log.error("[calendarService] updateCalendarPresenceForUser failure for user " + jid + " with error : " + error);\n    });\n  };\n\n  this.treatOutOfOfficeState = function (data, contact) {\n    $log.info("[calendarService] treatOutOfOfficeState for user : " + contact.jid + " with data enabled " + data.enabled + " and date end " + data.end);\n\n    if (data.enabled) {\n      contact.calendarState.autoReplyOn = true;\n      contact.calendarState.autoReplyInfos = {};\n\n      if (data.message_text) {\n        contact.calendarState.autoReplyInfos.message = data.message_text;\n      }\n\n      if (data.end) {\n        var mdate = moment(data.end);\n        contact.calendarState.autoReplyInfos.mdate = mdate;\n\n        if (mdate) {\n          if (mdate.isSame(moment(), "d")) {\n            contact.calendarState.autoReplyInfos.until = mdate.format("LT");\n            contact.calendarState.autoReplyInfos.untilDate = false;\n          } else {\n            contact.calendarState.autoReplyInfos.until = mdate.format("ll");\n            contact.calendarState.autoReplyInfos.untilDate = true;\n          }\n        } else {\n          contact.calendarState.autoReplyInfos.until = data.end;\n          contact.calendarState.autoReplyInfos.untilDate = true;\n        }\n      }\n\n      $rootScope.$broadcast("ON_CALENDAR_STATUS_CHANGE", that.serviceActivated);\n    } else {\n      contact.calendarState.autoReplyOn = false;\n      contact.calendarState.autoReplyInfos = {};\n    }\n\n    $rootScope.$broadcast("ON_CONTACT_CALENDAR_STATUS_CHANGE", contact);\n  };\n\n  this.calendarCancelCallback = function () {\n    that.serviceActivated = false;\n    settingsService.setSetting("disableCalendarPresence", true);\n    contactService.setUserSettings({\n      "promptForCalendarPresence": false\n    });\n    $rootScope.$broadcast("ON_CALENDAR_STATUS_CHANGE", false);\n  };\n\n  this.calendarLaterCallback = function () {\n    that.serviceActivated = false;\n    $rootScope.$broadcast("ON_CALENDAR_STATUS_CHANGE", false);\n  };\n\n  this.setCalendarRejectIfBusy = function (state) {\n    that.calendaRejectIfBusyActivated = false;\n  };\n\n  this.getCalendarRejectIfBusy = function () {\n    return that.calendaRejectIfBusyActivated;\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/calendar/calendarService.js?')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @ngdoc service\n * @module rainbow\n * @name MeetingService\n * @requires $q\n * @requires $log\n * @requires roomService\n * @requires contactService\n * @requires pstnConferenceService\n * @requires $http\n * @requires authService\n * @requires errorHelperService\n * @requires conferenceService\n * @requires webConferenceService\n *\n * @description Rainbow MeetingService provides interface to create and manage meetings\n */\nObject.defineProperty(exports, "__esModule", { value: true });\n/// <reference path="./serviceInterface.ts" />\nclass MeetingService {\n    constructor($q, $log, roomService, contactService, pstnConferenceService, conferenceService, orderByFilter, webConferenceService) {\n        this.$q = $q;\n        this.$log = $log;\n        this.roomService = roomService;\n        this.contactService = contactService;\n        this.pstnConferenceService = pstnConferenceService;\n        this.conferenceService = conferenceService;\n        this.orderByFilter = orderByFilter;\n        this.webConferenceService = webConferenceService;\n        this.started = false;\n        this.meetings = [];\n        this.listeners = [];\n    }\n    //////////////////////////////////////////////////////////////////\n    /////////////// Implementation of ServiceInterface ///////////////\n    start(stats) {\n        return this.$q((resolve) => {\n            let startDate = performance.now();\n            this.$log.info("[MeetingService] === STARTING ===");\n            this.updateMeetingLists();\n            this.updateAvailableMeetingsState();\n            this.started = true;\n            var startDuration = Math.round(performance.now() - startDate);\n            stats.push({ service: "MeetingService", startDuration: startDuration });\n            this.$log.info("[MeetingService] === STARTED (" + startDuration + " ms) ===");\n            resolve();\n        });\n    }\n    stop() {\n        this.$log.info("[MeetingService] === STOPPING ===");\n        this.meetings = [];\n        if (this.started) {\n            this.started = false;\n        }\n        if (this.listeners) {\n            this.listeners.forEach((listenerDestroy) => {\n                listenerDestroy();\n            });\n        }\n        this.$log.info("[MeetingService] === STOPPED ===");\n        return this.$q.when();\n    }\n    /**\n     * Method returns the last activity date of a given  meeting\n     *\n     * @private\n     * @param {any} meeting\n     * @returns momentjs object\n     * @memberof MeetingService\n     */\n    getLastActivityDateDate(meeting) {\n        return moment(meeting.lastActivityDate);\n    }\n    /**\n     * Method compares two dates\n     *\n     * @private\n     * @param {any} dateA\n     * @param {any} dateB :\n     * @returns -1 when first date is same or before the second one, 1 otherwise\n     * @memberof MeetingService\n     */\n    sortByDate(dateA, dateB) {\n        var res = 1;\n        if (dateA && dateB) {\n            res = dateB.value - dateA.value;\n        }\n        return res;\n    }\n    updateMeetingLists() {\n        this.meetings = [];\n        this.meetings = this.orderByFilter(this.roomService.getRooms().filter((room) => {\n            return room.isMeetingRoom() && room.status !== this.roomService.RoomUserStatus.REJECTED && room.status !== this.roomService.RoomUserStatus.DELETED;\n        }), this.getLastActivityDateDate, false, this.sortByDate);\n    }\n    updateAvailableMeetingsState() {\n        let availableMeetings = this.getMeetingsWithConference();\n        let confendpointList = [];\n        for (let meeting of availableMeetings) {\n            if (meeting.owner && meeting.confEndpoints.length) {\n                confendpointList = confendpointList.concat(meeting.confEndpoints);\n            }\n        }\n        this.conferenceService.makeSnapshotsForList(confendpointList);\n    }\n    getMeetingsWithConference() {\n        return this.meetings.filter((meeting) => {\n            return meeting.status !== "invited"\n                && meeting.getPstnConfEndpointId();\n        });\n    }\n    getInstantMeetingsWithoutConference() {\n        return this.meetings.filter((meeting) => {\n            return meeting.status !== "invited"\n                && meeting.conference && !meeting.conference.scheduled\n                && !meeting.getPstnConfEndpointId();\n        });\n    }\n    getMeetingInvitations() {\n        return this.meetings.filter((meeting) => {\n            return meeting.status === "invited";\n        });\n    }\n    getActiveMeetings() {\n        this.updateMeetingLists();\n        return this.meetings.filter((meeting) => {\n            let confId = meeting.getPstnConfEndpointId();\n            if (!meeting.conference.scheduled && confId) {\n                let confSession = this.pstnConferenceService.getConferenceSessionById(confId);\n                if (confSession && confSession.isActive()) {\n                    return true;\n                }\n            }\n            return false;\n        });\n    }\n    endMeeting(meeting) {\n        // Do this cleanup everytime\n        let sharingConfId = meeting.getSFUSharingConfEndpointId();\n        let sharingConfSession = this.webConferenceService.getConferenceSessionById(sharingConfId);\n        if (sharingConfSession && sharingConfSession.isActive()) {\n            this.webConferenceService.stopWebConference(meeting);\n        }\n        return this.conferenceService.stopConference(this.conferenceService.getPstnInstantConferenceEndpointId());\n    }\n    attendeeExitsMeeting(meeting) {\n        if (meeting.owner) {\n            return this.$q.reject();\n        }\n        let promiseArray = [];\n        let confId = meeting.getPstnConfEndpointId();\n        if (confId) {\n            let conferenceSession = this.pstnConferenceService.getConferenceSessionById(confId);\n            if (conferenceSession) {\n                let confParticipant = conferenceSession.getConnectedParticipantByJid(this.contactService.userContact.jid);\n                if (confParticipant) {\n                    promiseArray.push(this.conferenceService.disconnectsParticipant(confId, confParticipant.participantId, "pstnAudio"));\n                }\n            }\n        }\n        promiseArray.push(this.roomService.participantCloseRoom(meeting));\n        return this.$q.all(promiseArray);\n    }\n    acceptMeetingInvitation(meeting) {\n        return this.roomService.acceptRoomInvitation(meeting)\n            .then(() => {\n            this.conferenceService.makeSnapshotForConfId(meeting.getPstnConfEndpointId(), "pstnAudio");\n            return this.roomService.getServerRoom(meeting.dbId);\n        });\n    }\n    declineMeetingInvitation(meeting) {\n        return this.roomService.declineRoomInvitation(meeting);\n    }\n    startMeeting(meeting) {\n        let confId = meeting.getPstnConfEndpointId();\n        if (confId) {\n            return this.pstnConferenceService.initiatesAudio(confId);\n        }\n        else {\n            let error = new Error("[MeetingService] No confEndpoint associated to meeting");\n            this.$log.error(error.message);\n            return this.$q.reject();\n        }\n    }\n    updateMeetingName(meeting, newName) {\n        let conferenceId = meeting.getPstnConfEndpointId();\n        return this.conferenceService.updateConference(conferenceId, { name: newName })\n            .finally(() => {\n            meeting.name = newName;\n            return this.roomService.ownerUpdateRoomNameAndDescription(meeting);\n        });\n    }\n}\nMeetingService.$inject = [\n    "$q",\n    "$log",\n    "roomService",\n    "contactService",\n    "pstnConferenceService",\n    "conferenceService",\n    "orderByFilter",\n    "webConferenceService"\n];\nexports.MeetingService = MeetingService;\nangular.module("rainbow").service("meetingService", MeetingService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/meetingService.ts?')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @ngdoc service\n * @module rainbow\n * @name RecordsService\n * @requires $q\n * @requires $log\n * @requires fileServerService\n * @requires fileStorageService\n * @requires xmppService\n * @description Rainbow RecordsService provides interface to manipulate stream from XmppService and record them\n */\nObject.defineProperty(exports, "__esModule", { value: true });\n/// <reference path="./serviceInterface.ts" />\nconst ts_ebml_1 = __webpack_require__(132);\n;\nclass RecordsService {\n    constructor($q, $rootScope, $log, fileServerService, fileStorageService, xmppService, $interval, $window) {\n        this.$q = $q;\n        this.$rootScope = $rootScope;\n        this.$log = $log;\n        this.fileServerService = fileServerService;\n        this.fileStorageService = fileStorageService;\n        this.xmppService = xmppService;\n        this.$interval = $interval;\n        this.$window = $window;\n        this.started = false;\n        this.recording = false;\n        this.upload = false;\n        this.filename = "";\n        this.recordStopOrigin = "LOCAL";\n        this.metadataBuf = new ArrayBuffer(0);\n        this.last_duration = 0;\n        this.clusterPtrs = [];\n    }\n    start() {\n        this.started = false;\n        this.recording = false;\n        this.recorder = null;\n        this.chunk = null;\n        // this.data = [];\n        this.data = new Blob([], { type: "video/webm" });\n        this.audioContext = null;\n        // this.recordBuffer = null;\n        this.recordFile = null;\n        this.decoder = new ts_ebml_1.Decoder();\n        this.reader = new ts_ebml_1.Reader();\n        this.initConversationRecordContext();\n        this.$log.info("[RecordsService] start");\n        return this.$q.when();\n    }\n    stop() {\n        this.$log.info("[RecordsService stop");\n        if (this.started) {\n            this.started = false;\n        }\n        return this.$q.when();\n    }\n    /**\n     * Method called when data are available in MediaRecorder\n     * @private\n     * @param {any} event received as response from MediaRecorder\n     *\n     * @memberof RecordsService\n     */\n    onDataAvailable(event) {\n        this.$log.info("[RecordService] >onDataAvailable: size = " + event.data.size);\n        if (event.data.size > 0) {\n            this.chunk = event.data;\n            this.data = new Blob([this.data, this.chunk], { type: this.chunk.type });\n            // var url = window.URL.createObjectURL(this.data);\n            // var a = document.createElement("a");\n            // document.body.appendChild(a);\n            // a.style = "display: none";\n            // a.href = url;\n            // a.download = "afile";\n            // a.click();\n            // window.URL.revokeObjectURL(url);\n        }\n    }\n    /**\n     * Method check if browser supports recording\n     * @private\n     *\n     * @memberof RecordsService\n     */\n    canRecord() {\n        try {\n            if (!!MediaRecorder) {\n                return true;\n            }\n            return false;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Method create blob from data\n     * @private\n     *\n     * @memberof RecordsService\n     */\n    onStop() {\n        // Open-point : why is the video forced in mp4 ?\n        // this.recordBuffer = new Blob(this.data, { type: "video/webm" });\n        //for firefox\n        this.$log.info(\'[RecordService] On stop recording\');\n        if (navigator.mediaDevices.getUserMedia && this.$window.mozRTCPeerConnection) {\n            this.onStopCreateFileFromBlob(this.data);\n            this.updatedBlob = this.data;\n        }\n        //for chrome\n        else if (navigator.mediaDevices.getUserMedia && this.$window.webkitRTCPeerConnection) {\n            if (this.chunk) {\n                this.injectMetadata(this.chunk).then((result) => {\n                    this.updatedBlob = result;\n                    this.onStopCreateFileFromBlob(this.updatedBlob);\n                });\n            }\n        }\n    }\n    onCreateFileFromBlobForSafari(blob) {\n        this.updatedBlob = blob;\n        this.$log.info(\'[RecordService] Size of updatedBlob : \' + blob.size);\n        this.filename = this.filename.replace("mp4", "wav");\n        this.recordFile = { name: this.filename, extension: "wav", size: blob.size };\n        // this.data = [];\n        this.recording = false;\n        this.recorder = null;\n        this.chunk = null;\n        this.$rootScope.$broadcast("ON_OPEN_RECORDINGFILESTORAGE_POPUP", this.recordFile, this.recordStopOrigin);\n        //SDK Event\n        this.$rootScope.$broadcast("ON_WEBRTC_RECORD_SAVED", this.recordFile, blob, this.recordStopOrigin);\n        this.recordStopOrigin = "LOCAL"; //reset as default value  \n    }\n    onStopCreateFileFromBlob(blob) {\n        this.$log.info(\'[RecordService] Size of updatedBlob : \' + blob.size);\n        this.recordFile = { name: this.filename, extension: "mp4", size: blob.size };\n        // this.data = [];\n        this.recording = false;\n        this.recorder = null;\n        this.chunk = null;\n        this.$rootScope.$broadcast("ON_OPEN_RECORDINGFILESTORAGE_POPUP", this.recordFile, this.recordStopOrigin);\n        //SDK Event\n        this.$rootScope.$broadcast("ON_WEBRTC_RECORD_SAVED", this.recordFile, blob, this.recordStopOrigin);\n        this.recordStopOrigin = "LOCAL"; //reset as default value  \n    }\n    readAsArrayBuffer(blob) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.readAsArrayBuffer(blob);\n            reader.onloadend = () => { resolve(reader.result); };\n            reader.onerror = (ev) => { reject(); };\n        });\n    }\n    injectMetadata(blob) {\n        var defered = this.$q.defer();\n        const decoder = new ts_ebml_1.Decoder();\n        const reader = new ts_ebml_1.Reader();\n        reader.logging = false;\n        reader.drop_default_duration = false;\n        this.readAsArrayBuffer(blob).then((buffer) => {\n            // @ts-ignore\n            const elms = decoder.decode(buffer);\n            elms.forEach((elm) => { reader.read(elm); });\n            reader.stop();\n            var refinedMetadataBuf = ts_ebml_1.tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);\n            // @ts-ignore\n            var body = buffer.slice(reader.metadataSize);\n            const result = new Blob([refinedMetadataBuf, body], { type: blob.type });\n            defered.resolve(result);\n        });\n        return defered.promise;\n    }\n    /**\n     * Method close the audioContext\n     * @private\n     *\n     * @memberof RecordsService\n     */\n    closeAudioContext() {\n        if (this.audioContext) {\n            if (this.audioContext.destination) {\n                this.audioContext.destination.disconnect();\n            }\n            if (this.audioContext.state !== "closed") {\n                this.audioContext.close();\n                this.audioContext = null;\n            }\n        }\n    }\n    /**\n     * Method clean record structure after storage completion\n     * @private\n     *\n     * @memberof RecordsService\n     */\n    cleanRecord() {\n        if (this.recording !== false) {\n            this.$log.error("[RecordsService] Unexpected record cleaning while recording not stopped");\n        }\n        else {\n            this.updatedBlob = null;\n            this.recordFile = null;\n            this.data = null;\n        }\n    }\n    /**\n     * Method called after error occured on MediaRecorder\n     * @private\n     * @param {any} event contains error message\n     *\n     * @memberof RecordsService\n     */\n    onError(event) {\n        this.$log.error("[RecordService] error : " + event.message || false);\n        this.recording = false;\n        this.stopConvTimer();\n        //SDK Event\n        this.$rootScope.$broadcast("ON_WEBRTC_RECORD_ERROR");\n    }\n    /**\n     * Method create a MediaRecorder with local and remote stream from conversation\n     * @public\n     * @param {string} callID [required] conversation ID\n     * @param {boolean} upload used to upload the records on fileStorage [default : true]\n     * @param {boolean} onlyAudio used to record only audio stream\n     * @param {string} mimeType specify which mime type need to be used [default : video/webm;codecs=vp9 (if available)]\n     */\n    createRecord(callID, sourceStream = "REMOTE", upload = false, filename = "", onlyAudio = false, mimeType) {\n        let options = null;\n        let localStreams = null;\n        let remoteStreams = null;\n        let stream = null;\n        let videoStream = null;\n        let audioStream = null;\n        let tracks = [];\n        this.recorder = null;\n        this.upload = upload;\n        this.filename = filename;\n        let streamsAvailable = false;\n        let localIndexSharing = null;\n        let localIndexAudioVideo = null;\n        let remoteIndexSharing = null;\n        let remoteIndexAudioVideo = null;\n        let isSafari = (adapter.default.browserDetails.browser === "safari");\n        let largvideo = document.getElementById("largevideo");\n        this.decoder = new ts_ebml_1.Decoder();\n        this.reader = new ts_ebml_1.Reader();\n        this.data = new Blob([], { type: "video/webm" });\n        this.last_duration = 0;\n        this.clusterPtrs = [];\n        if (isSafari) {\n            mimeType = "audio/wave";\n        }\n        if (mimeType && MediaRecorder.isTypeSupported(mimeType)) {\n            options = { mimeType: mimeType };\n        }\n        else if (onlyAudio) {\n            if (MediaRecorder.isTypeSupported("audio/webm")) {\n                options = { mimeType: "audio/webm" };\n            }\n        }\n        else {\n            if (MediaRecorder.isTypeSupported("video/webm;codecs=vp8")) {\n                options = { mimeType: "video/webm\\; codecs=vp8" };\n            }\n            else if (MediaRecorder.isTypeSupported("video/webm;codecs=vp9")) {\n                options = { mimeType: "video/webm\\; codecs=vp9" };\n            }\n            else if (MediaRecorder.isTypeSupported("video/webm;codecs=h264")) {\n                options = { mimeType: "video/webm\\; codecs=h264" };\n            }\n            else if (MediaRecorder.isTypeSupported("video/mpeg")) {\n                options = { mimeType: "video/mpeg" };\n            }\n            // options = { mimeType: "video/x-matroska;codecs=avc1" };\n        }\n        if (options !== null) {\n            this.$log.info("[RecordsService] createRecord -- mimeType used " + options.mimeType);\n            var sess = this.xmppService.connection.jingle.sessions[callID];\n            localStreams = this.xmppService.connection.jingle.sessions[callID].localStreams;\n            remoteStreams = sess.remoteStreams;\n            streamsAvailable = (localStreams && localStreams.length && localStreams[0] !== null) || (remoteStreams && remoteStreams.length && remoteStreams[0] !== null);\n            if (this.recorder === null && streamsAvailable) {\n                let i;\n                let tmpIndexSharing = null;\n                for (i = 0; i < remoteStreams.length; i++) {\n                    if (remoteStreams[i] && remoteStreams[i] != null) {\n                        tmpIndexSharing = i;\n                        remoteStreams[i].getAudioTracks().forEach((element) => {\n                            tracks.push(element);\n                            remoteIndexAudioVideo = i;\n                            tmpIndexSharing = null;\n                        });\n                        if (tmpIndexSharing !== null) {\n                            remoteIndexSharing = tmpIndexSharing;\n                        }\n                    }\n                }\n                tmpIndexSharing = null;\n                for (i = 0; i < localStreams.length; i++) {\n                    if (localStreams[i] && localStreams[i] != null) {\n                        tmpIndexSharing = i;\n                        localStreams[i].getAudioTracks().forEach((element) => {\n                            tracks.push(element);\n                            localIndexAudioVideo = i;\n                            tmpIndexSharing = null;\n                        });\n                        if (tmpIndexSharing !== null) {\n                            localIndexSharing = tmpIndexSharing;\n                        }\n                    }\n                }\n                if (this.audioContext) {\n                    this.$log.error("[RecordsService] anomaly audio Context not previously released");\n                    this.closeAudioContext();\n                }\n                if (tracks.length) {\n                    if (isSafari) {\n                        audioStream = new MediaStream();\n                        tracks.forEach((track) => { audioStream.addTrack(track); });\n                    }\n                    else {\n                        this.audioContext = new AudioContext();\n                        let sources = tracks.map((t) => this.audioContext.createMediaStreamSource(new MediaStream([t])));\n                        let dest = this.audioContext.createMediaStreamDestination();\n                        /*let audio = new AudioContext() as any;\n                        let sources = tracks.map(t => audio.createMediaStreamSource(new MediaStream([t])));\n                        let dest = audio.createMediaStreamDestination();*/\n                        sources.forEach((source) => source.connect(dest));\n                        // stream = new MediaStream(dest.stream);\n                        audioStream = dest.stream;\n                    }\n                }\n                this.reader.addListener("metadata", ({ data }) => {\n                    this.$log.info("[RecordsService] Reader listener metadataBuf");\n                    // this.metadataBuf = new EBML.Encoder().encode(data);\n                });\n                this.reader.addListener("duration", ({ timecodeScale, duration }) => {\n                    this.last_duration = duration;\n                });\n                this.reader.addListener("cluster_ptr", (ptr) => {\n                    this.clusterPtrs.push(ptr);\n                });\n                if (!onlyAudio && !isSafari) {\n                    videoStream = new MediaStream();\n                    if (sourceStream === "LOCAL" && localIndexSharing !== null) {\n                        var videoTracks = localStreams[localIndexSharing].getVideoTracks();\n                        videoTracks.forEach((element) => {\n                            // stream.addTrack(element);\n                            videoStream.addTrack(element);\n                        });\n                    }\n                    else { //REMOTE default case\n                        if (remoteIndexSharing !== null) {\n                            remoteStreams[remoteIndexSharing].getVideoTracks().forEach((element) => {\n                                // stream.addTrack(element);\n                                videoStream.addTrack(element);\n                            });\n                        }\n                        else {\n                            // let remoteVideoTracks = remoteStreams[remoteIndexAudioVideo].getVideoTracks();\n                            // remoteVideoTracks.forEach((element) => {\n                            //     stream.addTrack(element);\n                            // });\n                            remoteStreams[remoteIndexAudioVideo].getVideoTracks().forEach((element) => {\n                                // stream.addTrack(element);\n                                videoStream.addTrack(element);\n                            });\n                        }\n                    }\n                }\n                if (audioStream && videoStream) {\n                    stream = new MediaStream([\n                        ...audioStream.getTracks(),\n                        ...videoStream.getTracks(),\n                    ]);\n                }\n                else if (audioStream && !videoStream) {\n                    stream = audioStream;\n                }\n                else {\n                    stream = videoStream;\n                }\n                if (isSafari) {\n                    this.recorder = new MediaRecorder(stream);\n                    this.recorder.addEventListener(\'dataavailable\', function (e) {\n                        console.error(e);\n                        // audio.src = URL.createObjectURL(e.data)\n                        console.log(this);\n                        this.onCreateFileFromBlobForSafari(e.data);\n                    }.bind(this));\n                    this.recorder.onstop = this.onStop.bind(this);\n                    this.recorder.onerror = this.onError.bind(this);\n                }\n                else {\n                    this.recorder = new MediaRecorder(stream, options);\n                    this.recorder.ondataavailable = this.onDataAvailable.bind(this);\n                    this.recorder.onstop = this.onStop.bind(this);\n                    this.recorder.onerror = this.onError.bind(this);\n                }\n            }\n            else {\n                this.$log.error("[RecordsService] Cannot get Stream");\n                return false;\n            }\n        }\n        else {\n            this.$log.error("[RecordsService] Codecs : " + mimeType + " are not available for the navigator");\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Method upload current record file to server\n     */\n    uploadFile() {\n        return this.$q((resolve, reject) => {\n            let buffer = this.updatedBlob;\n            let file = this.recordFile;\n            let UploadError = "";\n            if (this.recording !== false) {\n                this.$log.error("[RecordsService] Unexpected uploading file when recording not stopped");\n                UploadError = "recording not stopped pb";\n                reject(UploadError);\n            }\n            if (file.size === 0) {\n                this.$log.error("[RecordsService] error uploading empty file");\n                UploadError = "empty file pb";\n                reject(UploadError);\n            }\n            this.fileStorageService.createFileDescriptor(file.name, file.extension, file.size)\n                .then((fileDescriptor) => {\n                // Upload file\n                var message;\n                this.fileServerService.uploadAFileByChunk(fileDescriptor, buffer, message, () => { })\n                    .then((success) => {\n                    this.$log.info("[RecordsService] uploadFile success");\n                    this.cleanRecord();\n                    resolve();\n                })\n                    .catch((errorUpload) => {\n                    this.$log.error("[RecordsService] Unexpected error while uploading file", errorUpload);\n                    UploadError = "server pb";\n                    reject(UploadError);\n                });\n            })\n                .catch((error) => {\n                this.$log.error("[RecordsService] Unexpected error while creating file descriptor!", error);\n                UploadError = "file descriptor pb";\n                reject(UploadError);\n            });\n        });\n    }\n    /**\n     * Method setRecordStopOrigin\n     * @public\n     * @memberof RecordsService\n     */\n    setRecordStopOrigin(recordStopSource) {\n        if (recordStopSource && recordStopSource !== "") {\n            this.recordStopOrigin = recordStopSource;\n        }\n    }\n    /**\n     * Method current file storage on the PC with centralizedService.fileSaver\n     */\n    localSaveFile() {\n        let buffer = this.updatedBlob;\n        let file = this.recordFile;\n        if (this.recording !== false) {\n            this.$log.error("[RecordsService] Unexpected file local storage when recording not stopped");\n            return;\n        }\n        this.downloadFile(buffer, null, null, file.name, true);\n        this.cleanRecord();\n    }\n    /**\n     * Method download file on the PC by using centralizedService.fileSaver\n     * Will be overwritten by centralizedService at startup\n     */\n    downloadFile(blob, conversation_id, message_id, filename, browse) {\n        this.$log.info("[RecordsService] downloadFile -- default function");\n    }\n    /**\n     * Method start recording conversation\n     * @public\n     * @memberof RecordsService\n     */\n    startRecording(timeslice) {\n        if (this.recorder !== null) {\n            timeslice ? this.recorder.start(timeslice) : this.recorder.start();\n            this.recording = true;\n            this.startConvTimer();\n        }\n    }\n    /**\n     * Method stop recording conversation\n     * @public\n     * @memberof RecordsService\n     */\n    stopRecording() {\n        if (this.recorder !== null) {\n            this.recorder.stop();\n            this.recording = false;\n            this.closeAudioContext();\n        }\n        this.stopConvTimer();\n        this.initConversationRecordContext();\n    }\n    /**\n     * Method pause or resume recording\n     * @public\n     * @memberof RecordsServices\n     */\n    pauseResumeRecording() {\n        if (this.recorder !== null) {\n            if (this.recorder.state === "recording") {\n                this.recorder.pause();\n                this.conversationRecordContext.pause = true;\n                this.stopConvTimer();\n            }\n            else {\n                this.recorder.resume();\n                this.conversationRecordContext.pause = false;\n                this.startConvTimer();\n            }\n        }\n    }\n    /**\n     * Method changes the default callback for ondataavailable\n     * @public\n     * @param {void} callback method to handle data available on the MediaRecorder\n     *\n     * @memberof RecordsService\n     */\n    setOnDataAvailableCallback(callback) {\n        if (this.recorder !== null) {\n            this.recorder.ondataavailable = callback;\n        }\n    }\n    /**\n     * Method changes the default callback for onerror\n     * @public\n     * @param {void} callback method to handle onerror on the MediaRecorder\n     *\n     * @memberof RecordsService\n     */\n    setOnErrorCallback(callback) {\n        if (this.recorder !== null) {\n            this.recorder.onerror = callback;\n        }\n    }\n    /**\n     * Method changes the default callback for onpause\n     * @public\n     * @param {void} callback method to handle onpause on the MediaRecorder\n     *\n     * @memberof RecordsService\n     */\n    setOnPauseCallback(callback) {\n        if (this.recorder !== null) {\n            this.recorder.onpause = callback;\n        }\n    }\n    /**\n     * Method changes the default callback for onresume\n     * @public\n     * @param {void} callback method to handle onresume on the MediaRecorder\n     *\n     * @memberof RecordsService\n     */\n    setOnResumeCallback(callback) {\n        if (this.recorder !== null) {\n            this.recorder.onresume = callback;\n        }\n    }\n    /**\n     * Method changes the default callback for on onstart\n     * @public\n     * @param {void} callback method to handle onstart on the MediaRecorder\n     *\n     * @memberof RecordsService\n     */\n    setOnStartCallback(callback) {\n        if (this.recorder !== null) {\n            this.recorder.onstart = callback;\n        }\n    }\n    /**\n     * Method changes the default callback for on onstop\n     * @public\n     * @param {void} callback method to handle onstop on the MediaRecorder\n     *\n     * @memberof RecordsService\n     */\n    setOnStopCallback(callback) {\n        if (this.recorder !== null) {\n            this.recorder.onstop = callback;\n        }\n    }\n    /**\n     * Method\n     * @public\n     * @memberof RecordsService\n     */\n    initConversationRecordContext() {\n        this.conversationRecordContext = {\n            conversationId: "",\n            recorder: false,\n            pause: false,\n            actualRecordTime: 0,\n            updateTimer: null,\n            recordStopSource: "LOCAL",\n        };\n    }\n    /**\n     * Method\n     * @public\n     * @param {string} conversationId\n     * @memberof RecordsService\n     */\n    getConversationRecordContext(conversationId) {\n        if (conversationId === this.conversationRecordContext.conversationId) {\n            return this.conversationRecordContext;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Method\n     * @public\n     * @param {string} conversationId\n     * @memberof RecordsService\n     */\n    setConversationRecordContext(conversationId, recorder, pause, actualRecordTime, recordStopSource) {\n        if (conversationId && conversationId !== "") {\n            //store the conv value\n            this.conversationRecordContext.conversationId = conversationId;\n            this.conversationRecordContext.recorder = recorder && this.recording;\n            this.conversationRecordContext.pause = pause;\n            this.conversationRecordContext.actualRecordTime = actualRecordTime;\n            this.conversationRecordContext.recordStopSource = recordStopSource;\n        }\n    }\n    /**\n     * Method\n     * @private\n     * @memberof RecordsService\n     */\n    startConvTimer() {\n        this.conversationRecordContext.updateTimer = this.$interval(() => {\n            this.conversationRecordContext.actualRecordTime++;\n        }, 1000);\n    }\n    ;\n    /**\n      * Method\n      * @private\n      * @memberof RecordsService\n      */\n    stopConvTimer() {\n        if (this.conversationRecordContext.updateTimer !== null) {\n            this.$interval.cancel(this.conversationRecordContext.updateTimer);\n            this.conversationRecordContext.updateTimer = null;\n        }\n    }\n    ;\n}\nRecordsService.$inject = ["$q", "$rootScope", "$log", "fileServerService", "fileStorageService", "xmppService", "$interval", "$window"];\nangular.module("rainbow").service("recordsService", RecordsService);\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/recordsService.ts?')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar EBMLDecoder_1 = __webpack_require__(133);\nexports.Decoder = EBMLDecoder_1.default;\nvar EBMLEncoder_1 = __webpack_require__(17);\nexports.Encoder = EBMLEncoder_1.default;\nvar EBMLReader_1 = __webpack_require__(142);\nexports.Reader = EBMLReader_1.default;\nvar tools = __webpack_require__(7);\nexports.tools = tools;\nvar version = __webpack_require__(144).version;\nexports.version = version;\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ts-ebml/lib/index.js?')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar tools_1 = __webpack_require__(7);\nvar int64_buffer_1 = __webpack_require__(16);\nvar tools = __webpack_require__(7);\nvar schema = __webpack_require__(18);\nvar byEbmlID = schema.byEbmlID;\n// https://www.matroska.org/technical/specs/index.html\nvar State;\n(function (State) {\n    State[State["STATE_TAG"] = 1] = "STATE_TAG";\n    State[State["STATE_SIZE"] = 2] = "STATE_SIZE";\n    State[State["STATE_CONTENT"] = 3] = "STATE_CONTENT";\n})(State || (State = {}));\nvar EBMLDecoder = (function () {\n    function EBMLDecoder() {\n        this._buffer = new tools_1.Buffer(0);\n        this._tag_stack = [];\n        this._state = State.STATE_TAG;\n        this._cursor = 0;\n        this._total = 0;\n        this._schema = byEbmlID;\n        this._result = [];\n    }\n    EBMLDecoder.prototype.decode = function (chunk) {\n        this.readChunk(chunk);\n        var diff = this._result;\n        this._result = [];\n        return diff;\n    };\n    EBMLDecoder.prototype.readChunk = function (chunk) {\n        // 読みかけの(読めなかった) this._buffer と 新しい chunk を合わせて読み直す\n        this._buffer = tools.concat([this._buffer, new tools_1.Buffer(chunk)]);\n        while (this._cursor < this._buffer.length) {\n            // console.log(this._cursor, this._total, this._tag_stack);\n            if (this._state === State.STATE_TAG && !this.readTag()) {\n                break;\n            }\n            if (this._state === State.STATE_SIZE && !this.readSize()) {\n                break;\n            }\n            if (this._state === State.STATE_CONTENT && !this.readContent()) {\n                break;\n            }\n        }\n    };\n    EBMLDecoder.prototype.getSchemaInfo = function (tagNum) {\n        return this._schema[tagNum] || {\n            name: "unknown",\n            level: -1,\n            type: "unknown",\n            description: "unknown"\n        };\n    };\n    /**\n     * vint された parsing tag\n     * @return - return false when waiting for more data\n     */\n    EBMLDecoder.prototype.readTag = function () {\n        // tag.length が buffer の外にある\n        if (this._cursor >= this._buffer.length) {\n            return false;\n        }\n        // read ebml id vint without first byte\n        var tag = tools_1.readVint(this._buffer, this._cursor);\n        // tag が読めなかった\n        if (tag == null) {\n            return false;\n        }\n        // >>>>>>>>>\n        // tag 識別子\n        //const tagStr = this._buffer.toString("hex", this._cursor, this._cursor + tag.length);\n        //const tagNum = parseInt(tagStr, 16);\n        // 上と等価\n        var buf = this._buffer.slice(this._cursor, this._cursor + tag.length);\n        var tagNum = buf.reduce(function (o, v, i, arr) { return o + v * Math.pow(16, 2 * (arr.length - 1 - i)); }, 0);\n        var schema = this.getSchemaInfo(tagNum);\n        var tagObj = {\n            EBML_ID: tagNum.toString(16),\n            schema: schema,\n            type: schema.type,\n            name: schema.name,\n            level: schema.level,\n            tagStart: this._total,\n            tagEnd: this._total + tag.length,\n            sizeStart: this._total + tag.length,\n            sizeEnd: null,\n            dataStart: null,\n            dataEnd: null,\n            dataSize: null,\n            data: null\n        };\n        // | tag: vint | size: vint | data: Buffer(size) |\n        this._tag_stack.push(tagObj);\n        // <<<<<<<<\n        // ポインタを進める\n        this._cursor += tag.length;\n        this._total += tag.length;\n        // 読み込み状態変更\n        this._state = State.STATE_SIZE;\n        return true;\n    };\n    /**\n     * vint された現在のタグの内容の大きさを読み込む\n     * @return - return false when waiting for more data\n     */\n    EBMLDecoder.prototype.readSize = function () {\n        // tag.length が buffer の外にある\n        if (this._cursor >= this._buffer.length) {\n            return false;\n        }\n        // read ebml datasize vint without first byte\n        var size = tools_1.readVint(this._buffer, this._cursor);\n        // まだ読めない\n        if (size == null) {\n            return false;\n        }\n        // >>>>>>>>>\n        // current tag の data size 決定\n        var tagObj = this._tag_stack[this._tag_stack.length - 1];\n        tagObj.sizeEnd = tagObj.sizeStart + size.length;\n        tagObj.dataStart = tagObj.sizeEnd;\n        tagObj.dataSize = size.value;\n        if (size.value === -1) {\n            // unknown size\n            tagObj.dataEnd = -1;\n            if (tagObj.type === "m") {\n                tagObj.unknownSize = true;\n            }\n        }\n        else {\n            tagObj.dataEnd = tagObj.sizeEnd + size.value;\n        }\n        // <<<<<<<<\n        // ポインタを進める\n        this._cursor += size.length;\n        this._total += size.length;\n        this._state = State.STATE_CONTENT;\n        return true;\n    };\n    /**\n     * データ読み込み\n     */\n    EBMLDecoder.prototype.readContent = function () {\n        var tagObj = this._tag_stack[this._tag_stack.length - 1];\n        // master element は子要素を持つので生データはない\n        if (tagObj.type === \'m\') {\n            // console.log(\'content should be tags\');\n            tagObj.isEnd = false;\n            this._result.push(tagObj);\n            this._state = State.STATE_TAG;\n            // この Mastert Element は空要素か\n            if (tagObj.dataSize === 0) {\n                // 即座に終了タグを追加\n                var elm = Object.assign({}, tagObj, { isEnd: true });\n                this._result.push(elm);\n                this._tag_stack.pop(); // スタックからこのタグを捨てる\n            }\n            return true;\n        }\n        // waiting for more data\n        if (this._buffer.length < this._cursor + tagObj.dataSize) {\n            return false;\n        }\n        // タグの中身の生データ\n        var data = this._buffer.slice(this._cursor, this._cursor + tagObj.dataSize);\n        // 読み終わったバッファを捨てて読み込んでいる部分のバッファのみ残す\n        this._buffer = this._buffer.slice(this._cursor + tagObj.dataSize);\n        tagObj.data = data;\n        // >>>>>>>>>\n        switch (tagObj.type) {\n            //case "m": break;\n            // Master-Element - contains other EBML sub-elements of the next lower level\n            case "u":\n                tagObj.value = data.readUIntBE(0, data.length);\n                break;\n            // Unsigned Integer - Big-endian, any size from 1 to 8 octets\n            case "i":\n                tagObj.value = data.readIntBE(0, data.length);\n                break;\n            // Signed Integer - Big-endian, any size from 1 to 8 octets\n            case "f":\n                tagObj.value = tagObj.dataSize === 4 ? data.readFloatBE(0) :\n                    tagObj.dataSize === 8 ? data.readDoubleBE(0) :\n                        (console.warn("cannot read " + tagObj.dataSize + " octets float. failback to 0"), 0);\n                break;\n            // Float - Big-endian, defined for 4 and 8 octets (32, 64 bits)\n            case "s":\n                tagObj.value = data.toString("ascii");\n                break; // ascii\n            //  Printable ASCII (0x20 to 0x7E), zero-padded when needed\n            case "8":\n                tagObj.value = data.toString("utf8");\n                break;\n            //  Unicode string, zero padded when needed (RFC 2279)\n            case "b":\n                tagObj.value = data;\n                break;\n            // Binary - not interpreted by the parser\n            case "d":\n                tagObj.value = tools_1.convertEBMLDateToJSDate(new int64_buffer_1.Int64BE(data).toNumber());\n                break;\n        }\n        if (tagObj.value === null) {\n            throw new Error("unknown tag type:" + tagObj.type);\n        }\n        this._result.push(tagObj);\n        // <<<<<<<<\n        // ポインタを進める\n        this._total += tagObj.dataSize;\n        // タグ待ちモードに変更\n        this._state = State.STATE_TAG;\n        this._cursor = 0;\n        this._tag_stack.pop(); // remove the object from the stack\n        while (this._tag_stack.length > 0) {\n            var topEle = this._tag_stack[this._tag_stack.length - 1];\n            // 親が不定長サイズなので閉じタグは期待できない\n            if (topEle.dataEnd < 0) {\n                this._tag_stack.pop(); // 親タグを捨てる\n                return true;\n            }\n            // 閉じタグの来るべき場所まで来たかどうか\n            if (this._total < topEle.dataEnd) {\n                break;\n            }\n            // 閉じタグを挿入すべきタイミングが来た\n            if (topEle.type !== "m") {\n                throw new Error("parent element is not master element");\n            }\n            var elm = Object.assign({}, topEle, { isEnd: true });\n            this._result.push(elm);\n            this._tag_stack.pop();\n        }\n        return true;\n    };\n    return EBMLDecoder;\n}());\nexports.default = EBMLDecoder;\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ts-ebml/lib/EBMLDecoder.js?')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?")},function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(Buffer) {var tools = {\n    readVint: function(buffer, start) {\n        start = start || 0;\n        for (var length = 1; length <= 8; length++) {\n            if (buffer[start] >= Math.pow(2, 8 - length)) {\n                break;\n            }\n        }\n        if (length > 8) {\n            throw new Error("Unrepresentable length: " + length + " " +\n                buffer.toString(\'hex\', start, start + length));\n        }\n        if (start + length > buffer.length) {\n            return null;\n        }\n        var value = buffer[start] & (1 << (8 - length)) - 1;\n        for (var i = 1; i < length; i++) {\n            if (i === 7) {\n                if (value >= Math.pow(2, 53 - 8) && buffer[start + 7] > 0) {\n                    return {\n                        length: length,\n                        value: -1\n                    };\n                }\n            }\n            value *= Math.pow(2, 8);\n            value += buffer[start + i];\n        }\n        return {\n            length: length,\n            value: value\n        };\n    },\n\n    writeVint: function(value) {\n        if (value < 0 || value > Math.pow(2, 53)) {\n            throw new Error("Unrepresentable value: " + value);\n        }\n        for (var length = 1; length <= 8; length++) {\n            if (value < Math.pow(2, 7 * length) - 1) {\n                break;\n            }\n        }\n        var buffer = new Buffer(length);\n        for (var i = 1; i <= length; i++) {\n            var b = value & 0xFF;\n            buffer[length - i] = b;\n            value -= b;\n            value /= Math.pow(2, 8);\n        }\n        buffer[0] = buffer[0] | (1 << (8 - length));\n        return buffer;\n    }\n};\n\nmodule.exports = tools;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12).Buffer))\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ebml/lib/ebml/tools.js?')},function(module,exports,__webpack_require__){eval("var BufferReader = __webpack_require__(140)\n\nvar XIPH_LACING = 1\nvar EBML_LACING = 3\nvar FIXED_SIZE_LACING = 2\n\nmodule.exports = function (buffer) {\n  var block = {}\n  var reader = new BufferReader(buffer)\n\n  block.trackNumber = reader.nextUIntV()\n  block.timecode = reader.nextInt16BE()\n\n  var flags = reader.nextUInt8()\n\n  block.invisible = !!(flags & 0x8)\n\n  // only valid for SimpleBlock\n  block.keyframe = !!(flags & 0x80)\n  block.discardable = !!(flags & 0x1)\n\n  var lacing = (flags & 0x6) >> 1\n\n  block.frames = readLacedData(reader, lacing)\n\n  return block\n}\n\nfunction readLacedData (reader, lacing) {\n  if (!lacing) return [reader.nextBuffer()]\n\n  var i, frameSize\n  var frames = []\n  var framesNum = reader.nextUInt8() + 1 // number of frames\n\n  if (lacing === FIXED_SIZE_LACING) {\n    // remaining data should be divisible by the number of frames\n    if (reader.length % framesNum !== 0) throw new Error('Fixed-Size Lacing Error')\n\n    frameSize = reader.length / framesNum\n    for (i = 0; i < framesNum; i++) {\n      frames.push(reader.nextBuffer(frameSize))\n    }\n    return frames\n  }\n\n  var frameSizes = []\n\n  if (lacing === XIPH_LACING) {\n    for (i = 0; i < framesNum - 1; i++) {\n      var val\n      frameSize = 0\n      do {\n        val = reader.nextUInt8()\n        frameSize += val\n      } while (val === 0xff)\n      frameSizes.push(frameSize)\n    }\n  } else if (lacing === EBML_LACING) {\n    // first frame\n    frameSize = reader.nextUIntV()\n    frameSizes.push(frameSize)\n\n    // middle frames\n    for (i = 1; i < framesNum - 1; i++) {\n      frameSize += reader.nextIntV()\n      frameSizes.push(frameSize)\n    }\n  }\n\n  for (i = 0; i < framesNum - 1; i++) {\n    frames.push(reader.nextBuffer(frameSizes[i]))\n  }\n\n  // last frame (remaining buffer)\n  frames.push(reader.nextBuffer())\n\n  return frames\n}\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ebml-block/index.js?")},function(module,exports,__webpack_require__){eval("var vint = __webpack_require__(141)\n\nfunction BufferReader (buffer) {\n  this.buffer = buffer\n  this.offset = 0\n}\n\n// a super limited subset of the node buffer API\nBufferReader.prototype.nextInt16BE = function () {\n  var value = this.buffer.readInt16BE(this.offset)\n  this.offset += 2\n  return value\n}\n\nBufferReader.prototype.nextUInt8 = function () {\n  var value = this.buffer.readUInt8(this.offset)\n  this.offset += 1\n  return value\n}\n\n// EBML variable sized integers\nBufferReader.prototype.nextUIntV = function () {\n  var v = vint(this.buffer, this.offset)\n  this.offset += v.length\n  return v.value\n}\n\nBufferReader.prototype.nextIntV = function () {\n  var v = vint(this.buffer, this.offset, true)\n  this.offset += v.length\n  return v.value\n}\n\n// buffer slice\nBufferReader.prototype.nextBuffer = function (length) {\n  var buffer = length\n    ? this.buffer.slice(this.offset, this.offset + length)\n    : this.buffer.slice(this.offset)\n  this.offset += length || this.length\n  return buffer\n}\n\n// remaining bytes to read\nObject.defineProperty(BufferReader.prototype, 'length', {\n  get: function () { return this.buffer.length - this.offset }\n})\n\nmodule.exports = BufferReader\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ebml-block/lib/buffer-reader.js?")},function(module,exports){eval("// https://github.com/themasch/node-ebml/blob/master/lib/ebml/tools.js\nmodule.exports = function (buffer, start, signed) {\n  start = start || 0\n  for (var length = 1; length <= 8; length++) {\n    if (buffer[start] >= Math.pow(2, 8 - length)) {\n      break\n    }\n  }\n  if (length > 8) {\n    throw new Error('Unrepresentable length: ' + length + ' ' +\n      buffer.toString('hex', start, start + length))\n  }\n  if (start + length > buffer.length) {\n    return null\n  }\n  var i\n  var value = buffer[start] & (1 << (8 - length)) - 1\n  for (i = 1; i < length; i++) {\n    if (i === 7) {\n      if (value >= Math.pow(2, 53 - 8) && buffer[start + 7] > 0) {\n        return {\n          length: length,\n          value: -1\n        }\n      }\n    }\n    value *= Math.pow(2, 8)\n    value += buffer[start + i]\n  }\n  if (signed) {\n    value -= Math.pow(2, length * 7 - 1) - 1\n  }\n  return {\n    length: length,\n    value: value\n  }\n}\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ebml-block/lib/vint.js?")},function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\nvar events_1 = __webpack_require__(143);\nvar tools = __webpack_require__(7);\n/**\n * This is an informal code for reference.\n * EBMLReader is a class for getting information to enable seeking Webm recorded by MediaRecorder.\n * So please do not use for regular WebM files.\n */\nvar EBMLReader = (function (_super) {\n    __extends(EBMLReader, _super);\n    function EBMLReader() {\n        var _this = _super.call(this) || this;\n        _this.logGroup = "";\n        _this.hasLoggingStarted = false;\n        _this.metadataloaded = false;\n        _this.chunks = [];\n        _this.stack = [];\n        _this.segmentOffset = 0;\n        _this.last2SimpleBlockVideoTrackTimecode = [0, 0];\n        _this.last2SimpleBlockAudioTrackTimecode = [0, 0];\n        _this.lastClusterTimecode = 0;\n        _this.lastClusterPosition = 0;\n        _this.timecodeScale = 1000000; // webm default TimecodeScale is 1ms\n        _this.metadataSize = 0;\n        _this.metadatas = [];\n        _this.cues = [];\n        _this.firstVideoBlockRead = false;\n        _this.firstAudioBlockRead = false;\n        _this.currentTrack = { TrackNumber: -1, TrackType: -1, DefaultDuration: null, CodecDelay: null };\n        _this.trackTypes = [];\n        _this.trackDefaultDuration = [];\n        _this.trackCodecDelay = [];\n        _this.trackInfo = { type: "nothing" };\n        _this.ended = false;\n        _this.logging = false;\n        _this.use_duration_every_simpleblock = false;\n        _this.use_webp = false;\n        _this.use_segment_info = true;\n        _this.drop_default_duration = true;\n        return _this;\n    }\n    /**\n     * emit final state.\n     */\n    EBMLReader.prototype.stop = function () {\n        this.ended = true;\n        this.emit_segment_info();\n        // clean up any unclosed Master Elements at the end of the stream.\n        while (this.stack.length) {\n            this.stack.pop();\n            if (this.logging) {\n                console.groupEnd();\n            }\n        }\n        // close main group if set, logging is enabled, and has actually logged anything.\n        if (this.logging && this.hasLoggingStarted && this.logGroup) {\n            console.groupEnd();\n        }\n    };\n    /**\n     * emit chunk info\n     */\n    EBMLReader.prototype.emit_segment_info = function () {\n        var data = this.chunks;\n        this.chunks = [];\n        if (!this.metadataloaded) {\n            this.metadataloaded = true;\n            this.metadatas = data;\n            var videoTrackNum = this.trackTypes.indexOf(1); // find first video track\n            var audioTrackNum = this.trackTypes.indexOf(2); // find first audio track\n            this.trackInfo = videoTrackNum >= 0 && audioTrackNum >= 0 ? { type: "both", trackNumber: videoTrackNum }\n                : videoTrackNum >= 0 ? { type: "video", trackNumber: videoTrackNum }\n                    : audioTrackNum >= 0 ? { type: "audio", trackNumber: audioTrackNum }\n                        : { type: "nothing" };\n            if (!this.use_segment_info) {\n                return;\n            }\n            this.emit("metadata", { data: data, metadataSize: this.metadataSize });\n        }\n        else {\n            if (!this.use_segment_info) {\n                return;\n            }\n            var timecode = this.lastClusterTimecode;\n            var duration = this.duration;\n            var timecodeScale = this.timecodeScale;\n            this.emit("cluster", { timecode: timecode, data: data });\n            this.emit("duration", { timecodeScale: timecodeScale, duration: duration });\n        }\n    };\n    EBMLReader.prototype.read = function (elm) {\n        var _this = this;\n        var drop = false;\n        if (this.ended) {\n            // reader is finished\n            return;\n        }\n        if (elm.type === "m") {\n            // 閉じタグの自動挿入\n            if (elm.isEnd) {\n                this.stack.pop();\n            }\n            else {\n                var parent_1 = this.stack[this.stack.length - 1];\n                if (parent_1 != null && parent_1.level >= elm.level) {\n                    // 閉じタグなしでレベルが下がったら閉じタグを挿入\n                    this.stack.pop();\n                    // From http://w3c.github.io/media-source/webm-byte-stream-format.html#webm-media-segments\n                    // This fixes logging for webm streams with Cluster of unknown length and no Cluster closing elements.\n                    if (this.logging) {\n                        console.groupEnd();\n                    }\n                    parent_1.dataEnd = elm.dataEnd;\n                    parent_1.dataSize = elm.dataEnd - parent_1.dataStart;\n                    parent_1.unknownSize = false;\n                    var o = Object.assign({}, parent_1, { name: parent_1.name, type: parent_1.type, isEnd: true });\n                    this.chunks.push(o);\n                }\n                this.stack.push(elm);\n            }\n        }\n        if (elm.type === "m" && elm.name == "Segment") {\n            if (this.segmentOffset != 0) {\n                console.warn("Multiple segments detected!");\n            }\n            this.segmentOffset = elm.dataStart;\n            this.emit("segment_offset", this.segmentOffset);\n        }\n        else if (elm.type === "b" && elm.name === "SimpleBlock") {\n            var _a = tools.ebmlBlock(elm.data), timecode = _a.timecode, trackNumber = _a.trackNumber, frames_1 = _a.frames;\n            if (this.trackTypes[trackNumber] === 1) {\n                if (!this.firstVideoBlockRead) {\n                    this.firstVideoBlockRead = true;\n                    if (this.trackInfo.type === "both" || this.trackInfo.type === "video") {\n                        var CueTime = this.lastClusterTimecode + timecode;\n                        this.cues.push({ CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                        this.emit("cue_info", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: this.lastClusterTimecode });\n                        this.emit("cue", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                    }\n                }\n                this.last2SimpleBlockVideoTrackTimecode = [this.last2SimpleBlockVideoTrackTimecode[1], timecode];\n            }\n            else if (this.trackTypes[trackNumber] === 2) {\n                if (!this.firstAudioBlockRead) {\n                    this.firstAudioBlockRead = true;\n                    if (this.trackInfo.type === "audio") {\n                        var CueTime = this.lastClusterTimecode + timecode;\n                        this.cues.push({ CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                        this.emit("cue_info", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: this.lastClusterTimecode });\n                        this.emit("cue", { CueTrack: trackNumber, CueClusterPosition: this.lastClusterPosition, CueTime: CueTime });\n                    }\n                }\n                this.last2SimpleBlockAudioTrackTimecode = [this.last2SimpleBlockAudioTrackTimecode[1], timecode];\n            }\n            if (this.use_duration_every_simpleblock) {\n                this.emit("duration", { timecodeScale: this.timecodeScale, duration: this.duration });\n            }\n            if (this.use_webp) {\n                frames_1.forEach(function (frame) {\n                    var startcode = frame.slice(3, 6).toString("hex");\n                    if (startcode !== "9d012a") {\n                        return;\n                    }\n                    ; // VP8 の場合\n                    var webpBuf = tools.VP8BitStreamToRiffWebPBuffer(frame);\n                    var webp = new Blob([webpBuf], { type: "image/webp" });\n                    var currentTime = _this.duration;\n                    _this.emit("webp", { currentTime: currentTime, webp: webp });\n                });\n            }\n        }\n        else if (elm.type === "m" && elm.name === "Cluster" && elm.isEnd === false) {\n            this.firstVideoBlockRead = false;\n            this.firstAudioBlockRead = false;\n            this.emit_segment_info();\n            this.emit("cluster_ptr", elm.tagStart);\n            this.lastClusterPosition = elm.tagStart;\n        }\n        else if (elm.type === "u" && elm.name === "Timecode") {\n            this.lastClusterTimecode = elm.value;\n        }\n        else if (elm.type === "u" && elm.name === "TimecodeScale") {\n            this.timecodeScale = elm.value;\n        }\n        else if (elm.type === "m" && elm.name === "TrackEntry") {\n            if (elm.isEnd) {\n                this.trackTypes[this.currentTrack.TrackNumber] = this.currentTrack.TrackType;\n                this.trackDefaultDuration[this.currentTrack.TrackNumber] = this.currentTrack.DefaultDuration;\n                this.trackCodecDelay[this.currentTrack.TrackNumber] = this.currentTrack.CodecDelay;\n            }\n            else {\n                this.currentTrack = { TrackNumber: -1, TrackType: -1, DefaultDuration: null, CodecDelay: null };\n            }\n        }\n        else if (elm.type === "u" && elm.name === "TrackType") {\n            this.currentTrack.TrackType = elm.value;\n        }\n        else if (elm.type === "u" && elm.name === "TrackNumber") {\n            this.currentTrack.TrackNumber = elm.value;\n        }\n        else if (elm.type === "u" && elm.name === "CodecDelay") {\n            this.currentTrack.CodecDelay = elm.value;\n        }\n        else if (elm.type === "u" && elm.name === "DefaultDuration") {\n            // media source api は DefaultDuration を計算するとバグる。\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n            // chrome 58 ではこれを回避するために DefaultDuration 要素を抜き取った。\n            // chrome 58 以前でもこのタグを抜き取ることで回避できる\n            if (this.drop_default_duration) {\n                console.warn("DefaultDuration detected!, remove it");\n                drop = true;\n            }\n            else {\n                this.currentTrack.DefaultDuration = elm.value;\n            }\n        }\n        else if (elm.name === "unknown") {\n            console.warn(elm);\n        }\n        if (!this.metadataloaded && elm.dataEnd > 0) {\n            this.metadataSize = elm.dataEnd;\n        }\n        if (!drop) {\n            this.chunks.push(elm);\n        }\n        if (this.logging) {\n            this.put(elm);\n        }\n    };\n    Object.defineProperty(EBMLReader.prototype, "duration", {\n        /**\n         * DefaultDuration が定義されている場合は最後のフレームのdurationも考慮する\n         * 単位 timecodeScale\n         *\n         * !!! if you need duration with seconds !!!\n         * ```js\n         * const nanosec = reader.duration * reader.timecodeScale;\n         * const sec = nanosec / 1000 / 1000 / 1000;\n         * ```\n         */\n        get: function () {\n            if (this.trackInfo.type === "nothing") {\n                console.warn("no video, no audio track");\n                return 0;\n            }\n            // defaultDuration は 生の nano sec\n            var defaultDuration = 0;\n            // nanoseconds\n            var codecDelay = 0;\n            var lastTimecode = 0;\n            var _defaultDuration = this.trackDefaultDuration[this.trackInfo.trackNumber];\n            if (typeof _defaultDuration === "number") {\n                defaultDuration = _defaultDuration;\n            }\n            else {\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22\n                // default duration がないときに使う delta\n                if (this.trackInfo.type === "both") {\n                    if (this.last2SimpleBlockAudioTrackTimecode[1] > this.last2SimpleBlockVideoTrackTimecode[1]) {\n                        // audio diff\n                        defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n                        // audio delay\n                        var delay = this.trackCodecDelay[this.trackTypes.indexOf(2)]; // 2 => audio\n                        if (typeof delay === "number") {\n                            codecDelay = delay;\n                        }\n                        // audio timecode\n                        lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n                    }\n                    else {\n                        // video diff\n                        defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n                        // video delay\n                        var delay = this.trackCodecDelay[this.trackTypes.indexOf(1)]; // 1 => video\n                        if (typeof delay === "number") {\n                            codecDelay = delay;\n                        }\n                        // video timecode\n                        lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n                    }\n                }\n                else if (this.trackInfo.type === "video") {\n                    defaultDuration = (this.last2SimpleBlockVideoTrackTimecode[1] - this.last2SimpleBlockVideoTrackTimecode[0]) * this.timecodeScale;\n                    var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 2 => audio\n                    if (typeof delay === "number") {\n                        codecDelay = delay;\n                    }\n                    lastTimecode = this.last2SimpleBlockVideoTrackTimecode[1];\n                }\n                else if (this.trackInfo.type === "audio") {\n                    defaultDuration = (this.last2SimpleBlockAudioTrackTimecode[1] - this.last2SimpleBlockAudioTrackTimecode[0]) * this.timecodeScale;\n                    var delay = this.trackCodecDelay[this.trackInfo.trackNumber]; // 1 => video\n                    if (typeof delay === "number") {\n                        codecDelay = delay;\n                    }\n                    lastTimecode = this.last2SimpleBlockAudioTrackTimecode[1];\n                } // else { not reached }\n            }\n            // convert to timecodescale\n            var duration_nanosec = ((this.lastClusterTimecode + lastTimecode) * this.timecodeScale) + defaultDuration - codecDelay;\n            var duration = duration_nanosec / this.timecodeScale;\n            return Math.floor(duration);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EBMLReader.prototype.addListener = function (event, listener) {\n        return _super.prototype.addListener.call(this, event, listener);\n    };\n    EBMLReader.prototype.put = function (elm) {\n        if (!this.hasLoggingStarted) {\n            this.hasLoggingStarted = true;\n            if (this.logging && this.logGroup) {\n                console.groupCollapsed(this.logGroup);\n            }\n        }\n        if (elm.type === "m") {\n            if (elm.isEnd) {\n                console.groupEnd();\n            }\n            else {\n                console.group(elm.name + ":" + elm.tagStart);\n            }\n        }\n        else if (elm.type === "b") {\n            // for debug\n            //if(elm.name === "SimpleBlock"){\n            //const o = EBML.tools.ebmlBlock(elm.value);\n            //console.log(elm.name, elm.type, o.trackNumber, o.timecode);\n            //}else{\n            console.log(elm.name, elm.type);\n            //}\n        }\n        else {\n            console.log(elm.name, elm.tagStart, elm.type, elm.value);\n        }\n    };\n    return EBMLReader;\n}(events_1.EventEmitter));\nexports.default = EBMLReader;\n;\n;\n;\n;\n\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ts-ebml/lib/EBMLReader.js?')},function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/events/events.js?")},function(module){eval('module.exports = JSON.parse("{\\"_from\\":\\"ts-ebml@^2.0.2\\",\\"_id\\":\\"ts-ebml@2.0.2\\",\\"_inBundle\\":false,\\"_integrity\\":\\"sha512-V/HdlCn3FITQrFHQlVE02XtfMiRLab2QB/YOCfkbJWqiFYG/j5v7gHKV+wem6g0PD6/uxXs5oxMQfDXILmts/Q==\\",\\"_location\\":\\"/ts-ebml\\",\\"_phantomChildren\\":{},\\"_requested\\":{\\"type\\":\\"range\\",\\"registry\\":true,\\"raw\\":\\"ts-ebml@^2.0.2\\",\\"name\\":\\"ts-ebml\\",\\"escapedName\\":\\"ts-ebml\\",\\"rawSpec\\":\\"^2.0.2\\",\\"saveSpec\\":null,\\"fetchSpec\\":\\"^2.0.2\\"},\\"_requiredBy\\":[\\"/\\"],\\"_resolved\\":\\"https://registry.npmjs.org/ts-ebml/-/ts-ebml-2.0.2.tgz\\",\\"_shasum\\":\\"5e2c65b35ee6f1c030f51668666f3c018f4d9578\\",\\"_spec\\":\\"ts-ebml@^2.0.2\\",\\"_where\\":\\"/home/konrad/web/sdk/dependencies_otliteclient\\",\\"author\\":{\\"name\\":\\"legokichi duckscallion\\"},\\"bin\\":{\\"ts-ebml\\":\\"./lib/cli.js\\"},\\"bugs\\":{\\"url\\":\\"https://github.com/legokichi/ts-ebml/issues\\"},\\"bundleDependencies\\":false,\\"dependencies\\":{\\"buffer\\":\\"^5.0.7\\",\\"commander\\":\\"^2.11.0\\",\\"ebml\\":\\"^2.2.1\\",\\"ebml-block\\":\\"^1.1.0\\",\\"events\\":\\"^1.1.1\\",\\"int64-buffer\\":\\"^0.1.9\\",\\"matroska\\":\\"^2.2.3\\"},\\"deprecated\\":false,\\"description\\":\\"ebml decoder and encoder\\",\\"devDependencies\\":{\\"@types/commander\\":\\"^2.9.1\\",\\"@types/qunit\\":\\"^2.0.31\\",\\"browserify\\":\\"^13.1.0\\",\\"empower\\":\\"^1.2.3\\",\\"espower-cli\\":\\"^1.1.0\\",\\"power-assert\\":\\"^1.4.4\\",\\"power-assert-formatter\\":\\"^1.4.1\\",\\"qunit-tap\\":\\"^1.5.1\\",\\"qunitjs\\":\\"^2.4.0\\",\\"tslint\\":\\"^3.15.1\\",\\"typedoc\\":\\"^0.5.3\\",\\"typescript\\":\\"^2.4.2\\",\\"watchify\\":\\"^3.7.0\\"},\\"homepage\\":\\"https://github.com/legokichi/ts-ebml#readme\\",\\"keywords\\":[\\"ebml\\",\\"webm\\",\\"mkv\\",\\"matrosika\\",\\"webp\\"],\\"license\\":\\"MIT\\",\\"main\\":\\"./lib/index.js\\",\\"name\\":\\"ts-ebml\\",\\"repository\\":{\\"type\\":\\"git\\",\\"url\\":\\"git+https://github.com/legokichi/ts-ebml.git\\"},\\"scripts\\":{\\"browserify\\":\\"browserify lib/index.js --standalone EBML -o dist/EBML.js\\",\\"build\\":\\"npm run clean   && tsc    -p .; npm run browserify\\",\\"check\\":\\"tsc -w --noEmit -p ./\\",\\"clean\\":\\"rm -rf lib/* dist/* test/*.js; mkdir -p dist\\",\\"doc\\":\\"typedoc --mode modules --out doc --disableOutputCheck\\",\\"example\\":\\"tsc; browserify lib/example_seekable.js -o test/example_seekable.js\\",\\"examples\\":\\"tsc; for file in `find lib -name \'example_*.js\' -type f -printf \'%f\\\\\\\\n\'`; do browserify lib/$file -o test/$file; done\\",\\"examples_bsd\\":\\"tsc; for file in `find lib -name \'example_*.js\' -type f -print`; do browserify lib/$(basename $file) -o test/$(basename $file); done\\",\\"init\\":\\"npm run update; npm run mkdir; npm run build\\",\\"lint\\":\\"tslint -c ./tslint.json --project ./tsconfig.json --type-check\\",\\"mkdir\\":\\"mkdir lib dist 2>/dev/null\\",\\"reset\\":\\"rm -rf node_modules\\",\\"setup\\":\\"npm install -g http-server;\\",\\"start\\":\\"http-server . -s & tsc -w -p .& watchify lib/example_seekable.js -o test/example_seekable.js\\",\\"stop\\":\\"killall -- node */tsc -w -p\\",\\"test\\":\\"tsc; espower lib/test.js > lib/test.tmp; mv -f lib/test.tmp lib/test.js; browserify lib/test.js -o test/test.js\\",\\"update\\":\\"npm run reset; npm update\\",\\"watchify\\":\\"watchify lib/index.js --standalone EBML -o dist/EBMl.js -v\\"},\\"typings\\":\\"./lib/index.d.ts\\",\\"version\\":\\"2.0.2\\"}");\n\n//# sourceURL=webpack:///./dependencies_otliteclient/node_modules/ts-ebml/package.json?')},function(module,exports){eval('(function () {\n  "use strict";\n\n  angular.module("rainbow").service("phonebookService", ["$q", "$rootScope", "$log", "$http", "contactService", "authService", "orderByFilter", "profileService", "conversationService", "utilService", function ($q, $rootScope, $log, $http, contactService, authService, orderByFilter, profileService, conversationService, utilService) {\n    /**\n         \t * SEARCH\n          \t */\n    this.search = function (searchText, limit) {\n      return $q(function (resolve, reject) {\n        //check if phonebook search is allowed by profile else no result\n        if (!profileService.isFeatureEnabled(profileService.FeaturesEnum.TELEPHONY_PHONE_BOOK)) {\n          $log.info("[phonebookService] search from phonebook not allowed for the user profile");\n          var emptyresult = [];\n          resolve(emptyresult);\n          return;\n        }\n\n        if (!searchText || searchText === "") {\n          $log.info("[phonebookService] search from phonebook not allowed for empty string");\n          var emptyresult = [];\n          resolve(emptyresult);\n          return;\n        }\n\n        if (!limit) {\n          limit = 20;\n        }\n\n        $log.info("[phonebookService] search PBXContact from phonebook with text " + utilService.anonymizeString(searchText) + " and limit " + limit); // Send request\n\n        var serverUrl = config.restServerUrl + "/api/rainbow/search/v1.0/phonebooks?limit=" + limit + "&name=" + encodeURIComponent(searchText);\n        $http({\n          method: "GET",\n          url: serverUrl,\n          headers: authService.getRequestHeader()\n        }) // Handle success response\n        .then(function (response) {\n          var contactsData = response.data.phoneBooks;\n          $log.info("[phonebookService] search find " + contactsData.length + " phonebooks contact(s)");\n          var contacts = [];\n          contactsData.forEach(function (contactData) {\n            // Ignore userContact\n            //if (contactService.isUserContactJid(contactData.jid_im)) { return; }\n            // create temporary contact\n            var contact = contactService.createBasicContact(null, contactData.number);\n            contact.updateName(contactData.firstName, contactData.lastName);\n            contact.getAvatar(); //contactService.dbContacts[contactData.id] = contact; //OP : to be or not stored in db ???\n            //contact.dbId = contactData.id;\n            //conversationService.computeCapabilitiesForContact(contact, false);\n\n            contacts.push(contact);\n          });\n          contacts = orderByFilter(contacts, "_displayName", false);\n          resolve(contacts);\n        }, // Handle error\n        function (err) {\n          if (err.data) {\n            if (err.data.errorCode === 401) {\n              $rootScope.$broadcast("ON_SESSION_EXPIRED_NOTIFICATION_EVENT");\n            }\n\n            $log.warn("[phonebookService] search failure " + err.data.errorMsg);\n          }\n\n          reject(new Error("phonebook service failure"));\n        });\n      });\n    };\n  }]);\n})();\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/phonebookService.js?')},function(module,exports){eval('angular.module("rainbow").service("adminCompanyService", ["$q", "$log", "$http", "$rootScope", "authService", "errorHelperService", "Company", "contactService", "settingsService", "Site", "CompanyInvitation", "pushImageHelperService", "CompanyRequest", "companyService", "Bot", function ($q, $log, $http, $rootScope, authService, errorHelperService, Company, contactService, settingsService, Site, CompanyInvitation, pushImageHelperService, CompanyRequest, companyService, Bot) {\n  "use strict";\n\n  var service = this;\n  /********************************************************/\n\n  /** LIFE CYCLE STUFF                                   **/\n\n  /********************************************************/\n\n  service.start = function () {\n    $log.info("[adminCompanyService] === STARTING ===");\n    service.portalURL = config.restServerUrl + "/api/rainbow/admin/v1.0/";\n    $log.info("[adminCompanyService] === STARTED ===");\n    return $q.when();\n  };\n\n  service.stop = function () {\n    $log.info("[adminCompanyService] === STOPPING ===");\n    $log.info("[adminCompanyService] === STOPPED ===");\n    return $q.when();\n  };\n  /********************************************************/\n\n  /** GET COMPANIES                                      **/\n\n  /********************************************************/\n\n\n  service.getCompanies = function (organisationId, page, pageSize, searchName, format, bpId, status, isBP, bpType, offerCanBeSold, searchReference, noLogo) {\n    var defered = $q.defer();\n    var adminContact = contactService.userContact; // If not superAdmin, bp_admin or orgaAdmin --\x3e company admin or site admin\n\n    if (!adminContact.isSuperadmin() && !adminContact.isBusinessAdmin() && !adminContact.isBPAdmin() && !adminContact.isOrganizationAdmin()) {\n      return service.getCompany(adminContact.company.id).then(function (company) {\n        return {\n          companies: [company]\n        };\n      });\n    } // Else superadmin, bp_admin or orgaAdmin\n\n\n    var url = service.portalURL + "companies?format=" + (format ? format : "full");\n\n    if (organisationId) {\n      url += "&organisationId=" + organisationId;\n    }\n\n    if (page && pageSize) {\n      url += "&offset=" + pageSize * (page - 1);\n    }\n\n    if (pageSize) {\n      url += "&limit=" + pageSize;\n    }\n\n    if (searchName) {\n      url += "&name=" + searchName;\n    }\n\n    if (bpId) {\n      url += "&bpId=" + bpId;\n    }\n\n    if (status) {\n      if (Array.isArray(status)) {\n        status.forEach(function (value) {\n          url += "&status=" + value;\n        });\n      } else {\n        url += "&status=" + status;\n      }\n    }\n\n    if (isBP !== undefined && isBP !== null) {\n      url += "&isBP=" + isBP;\n    }\n\n    if (bpType) {\n      url += "&bpType=" + bpType;\n    }\n\n    if (offerCanBeSold) {\n      // filter companies list on companies having subscribed to offers for which canBeSold is true\n      url += "&offerCanBeSold=" + offerCanBeSold;\n    }\n\n    if (searchReference) {\n      url += "&externalReference=" + searchReference;\n    }\n\n    $http({\n      method: "GET",\n      url: url,\n      headers: authService.getRequestHeader()\n    }).then(function successCallback(response) {\n      var data = response.data.data;\n      $log.info("[adminCompanyService] getCompanies success");\n      var companies = [];\n      data.forEach(function (orgData) {\n        var company = Company.createFromData(orgData); // Load asynchronously company logo (not banner!)\n\n        if (angular.isUndefined(noLogo) || !noLogo) {\n          companyService.getCompanyLogo(company);\n        }\n\n        companies.push(company);\n      });\n      defered.resolve({\n        companies: companies,\n        limit: response.data.limit,\n        offset: response.data.offset,\n        total: response.data.total\n      });\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanies"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** GET ALL COMPANIES                                  **/\n\n  /********************************************************/\n\n\n  service.getAllCompaniesSmall = function (organisationId, bpId, status, isBP, bpType) {\n    return service.getAllCompanies(organisationId, bpId, status, isBP, bpType, "small");\n  };\n\n  service.getAllCompanies = function (organisationId, bpId, status, isBP, bpType, format) {\n    var limit = 1000; // maximum of companies that can be requested to the server\n\n    return $q(function (resolve, reject) {\n      var result; // Get first page of companies and the total number of companies to retrieve\n\n      service.getCompanies(organisationId, 1, limit, null, format, bpId, status, isBP, bpType).then(function (response) {\n        result = response;\n\n        if (response.total > response.limit) {\n          var totalPages = Math.ceil(response.total / limit); // List of page numbers to get (remove first page that was already gotten)\n\n          var pages = Array.apply(null, Array(totalPages - 1));\n          pages = pages.map(function (__unused, index) {\n            return index + 2;\n          }); // fill array with page numbers to request\n          // Serialize promises by chunks (avoids more requests than the server can handle)\n\n          var chunks = [];\n\n          while (pages.length > 0) {\n            chunks.push(pages.splice(0, 5));\n          } // chunk size must be less than 10 to avoid internal system error\n\n\n          return chunks.reduce(function (promiseChain, requests) {\n            // Parallelize chunks\n            return promiseChain.then(function () {\n              var promisesArray = requests.map(function (page) {\n                return service.getCompanies(organisationId, page, limit, null, format, bpId, status, isBP, bpType).then(function (next) {\n                  response.companies = response.companies.concat(next.companies);\n                  response.limit += next.limit;\n                });\n              }); // return chain\n\n              return $q.all(promisesArray);\n            });\n          }, $q.resolve());\n        }\n      }).then(function () {\n        resolve(result);\n      })["catch"](function (error) {\n        reject(error);\n      });\n    });\n  };\n  /********************************************************/\n\n  /** GET COMPANY                                        **/\n\n  /********************************************************/\n\n\n  service.getCompany = function (companyId, format) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/" + companyId + "?format=" + (format ? format : "full"),\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] getCompany success");\n        var data = response.data.data;\n        var company = Company.createFromData(data); // Load asynchronously company logo and banner\n\n        companyService.getCompanyLogo(company);\n        companyService.getCompanyBanner(company);\n        resolve(company);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompany"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** GET DEFAULT COMPANY                                **/\n\n  /********************************************************/\n\n\n  service.getDefaultCompany = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/default",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] getDefaultCompany success");\n        var data = response.data.data;\n        var company = Company.createFromData(data);\n        resolve(company);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getDefaultCompany"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** SEARCH COMPANIES                                   **/\n\n  /********************************************************/\n\n\n  service.searchCompanies = function (searchValue) {\n    var defered = $q.defer();\n    var searchValueLC = searchValue.toLowerCase();\n    service.getCompanies().then(function (result) {\n      var filteredCompanies = result.companies.filter(function (company) {\n        return company.name.toLowerCase().indexOf(searchValueLC) > -1;\n      }); //why is this search implemented locally and not on server side by using searcName param of getCompanies() ??\n\n      defered.resolve(filteredCompanies);\n    });\n    return defered.promise;\n  };\n  /**\n   * CREATE COMPANY\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.createCompany = function (company) {\n    // Remove unwanted and undefined optional properties from data that must not be sent to the server\n    var companyData = Company.prune(company, contactService.userContact);\n    var defered = $q.defer();\n    $http({\n      method: "POST",\n      url: service.portalURL + "companies",\n      headers: authService.getRequestHeader(),\n      data: companyData\n    }).then(function successCallback(response) {\n      $log.info("[adminCompanyService] createCompany success");\n      var newcompany = Company.createFromData(response.data.data);\n      $rootScope.$broadcast("ADMIN_COMPANIES_CHANGE");\n      defered.resolve(newcompany);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "createCompany"));\n    });\n    return defered.promise;\n  };\n\n  service.createCompanyEndUser = function (company) {\n    // Remove unwanted and undefined optional properties from data that must not be sent to the server\n    var companyData = Company.prune(company, contactService.userContact);\n    var defered = $q.defer();\n    $http({\n      method: "POST",\n      url: config.restServerUrl + "/api/rainbow/enduser/v1.0/companies",\n      headers: authService.getRequestHeader(),\n      data: companyData\n    }).then(function successCallback(response) {\n      $log.info("[adminCompanyService] createCompany success");\n      var data = response.data.data;\n      var newcompany = Company.createFromData(data);\n      defered.resolve(newcompany);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "createCompanyEndUser"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** UPDATE COMPANY                                     **/\n\n  /********************************************************/\n\n\n  service.updateCompany = function (company) {\n    // Remove unwanted and undefined optional properties from data that must not be sent to the server\n    var companyData = Company.prune(company, contactService.userContact);\n    var defered = $q.defer();\n    $http({\n      method: "PUT",\n      url: service.portalURL + "companies/" + company.id,\n      headers: authService.getRequestHeader(),\n      data: companyData\n    }).then(function successCallback(response) {\n      $log.info("[adminCompanyService] updateCompany success");\n      var data = response.data.data;\n      var updatedCompany = Company.createFromData(data);\n      defered.resolve(updatedCompany); // Broadcast change event (needed by company service in order to update company cache)\n\n      $rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", company.id);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "updateCompany"));\n    });\n    return defered.promise;\n  };\n  /**\n   * ADD VISIBILITY COMPANY\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.addVisibility = function (companyId, visibleByCompany) {\n    var defered = $q.defer();\n    $http({\n      method: "POST",\n      url: service.portalURL + "companies/" + companyId + "/visible-by/" + visibleByCompany,\n      headers: authService.getRequestHeader()\n    }).then(function successCallback() {\n      $log.info("[adminCompanyService] addVisibility success");\n      defered.resolve();\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "addVisibility"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** REMOVE VISIBILITY COMPANY                          **/\n\n  /********************************************************/\n\n\n  service.removeVisibility = function (companyId, visibleByCompany) {\n    var defered = $q.defer();\n    $http({\n      method: "DELETE",\n      url: service.portalURL + "companies/" + companyId + "/visible-by/" + visibleByCompany,\n      headers: authService.getRequestHeader()\n    }).then(function successCallback() {\n      $log.info("[adminCompanyService] removeVisibility success");\n      defered.resolve();\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "removeVisibility"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** GET ALL SITE COMPANY                               **/\n\n  /********************************************************/\n\n\n  service.getAllSiteCompany = function (companyId) {\n    var defered = $q.defer();\n    $http({\n      method: "GET",\n      url: service.portalURL + "companies/" + companyId + "/sites",\n      headers: authService.getRequestHeader()\n    }).then(function successCallback(response) {\n      $log.info("[adminCompanyService] getAllSiteCompany success");\n      var data = response.data.data;\n      var sites = [];\n      data.forEach(function (element) {\n        var site = Site.createFromData(element);\n        sites.push(site);\n      });\n      defered.resolve(sites);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getAllSiteCompany"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** GET COMPANY ADMINISTRATORS                         **/\n\n  /********************************************************/\n\n\n  service.getCompanyAdministrators = function (companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/" + companyId + "/administrators",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] getCompanyAdministrators success");\n        var data = response.data.data;\n        var adminUsers = [];\n        data.forEach(function (adminUserData) {\n          var adminUser = {\n            id: adminUserData.id\n          };\n          adminUsers.push(adminUser);\n        });\n        resolve(adminUsers);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanyAdministrators"));\n      });\n    });\n  };\n  /**\n   * DELETE COMPANY\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.deleteCompany = function (companyId) {\n    var defered = $q.defer();\n    $http({\n      method: "DELETE",\n      url: service.portalURL + "companies/" + companyId,\n      headers: authService.getRequestHeader()\n    }).then(function successCallback() {\n      $log.info("[adminCompanyService] deleteCompany success");\n      defered.resolve();\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "deleteCompany"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** COMPANY LOGO STUFF                                 **/\n\n  /********************************************************/\n\n\n  service.pushLogo = function (companyId, logoImg, shape) {\n    return $q(function (resolve, reject) {\n      var pushServiceURL = service.portalURL + "companies/" + companyId + "/avatar";\n      (angular.isDefined(logoImg) && logoImg !== null ? pushImageHelperService.pushImage(pushServiceURL, logoImg) : $q.resolve()).then(function () {\n        //$rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", companyId);\n        return service.getCompany(companyId);\n      }).then(function (company) {\n        company.avatarShape = shape; // Update image shape\n\n        return service.updateCompany(company);\n      }).then(function () {\n        $rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", companyId);\n        $log.info("[adminCompanyService] pushLogo success");\n        resolve();\n      })["catch"](function (error) {\n        reject(error);\n      });\n    });\n  };\n\n  service.deleteLogo = function (companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "companies/" + companyId + "/avatar",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback() {\n        $rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", companyId); // Reset image shape to default\n\n        service.getCompany(companyId).then(function (company) {\n          company.avatarShape = "circle";\n          return service.updateCompany(company);\n        }).then(function () {\n          $log.info("[adminCompanyService] deleteLogo success");\n          resolve();\n        })["catch"](function (error) {\n          reject(error);\n        });\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "deleteLogo"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** COMPANY BANNER STUFF                               **/\n\n  /********************************************************/\n\n\n  service.pushBanner = function (companyId, bannerImg, params) {\n    return $q(function (resolve, reject) {\n      var pushServiceURL = service.portalURL + "companies/" + companyId + "/banner";\n      return pushImageHelperService.pushImage(pushServiceURL, bannerImg, params).then(function () {\n        $rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", companyId);\n        resolve();\n      })["catch"](function (error) {\n        reject(error);\n      });\n    });\n  };\n\n  service.deleteBanner = function (companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "companies/" + companyId + "/banner",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback() {\n        $rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", companyId);\n        $log.info("[adminCompanyService] deleteBanner success");\n        resolve();\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "deleteBanner"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** COMPANY BOTS STUFF                                 **/\n\n  /********************************************************/\n\n\n  service.getCompanySupportBot = function (companyId) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "bots/rainbow-support";\n\n      if (companyId) {\n        url += "?companyId=" + companyId;\n      }\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[companyService] getCompanySupportBot success");\n        var supportBot = Bot.create(response.data.data);\n        resolve(supportBot); // return \'Emily\' support bot\n      })["catch"](function errorCallback(response) {\n        var errorMessage = "getCompanySupportBot failure " + response.data.errorDetails + " with status " + response.status;\n        $log.error("[companyService] " + errorMessage);\n        reject(new Error(errorMessage));\n      });\n    });\n  };\n\n  service.pushCompanyBotAvatar = function (botId, companyId, avatarImg) {\n    return $q(function (resolve, reject) {\n      var pushServiceURL = service.portalURL + "bots/" + botId + "/companies/" + companyId + "/avatar";\n      (angular.isDefined(avatarImg) && avatarImg !== null ? pushImageHelperService.pushImage(pushServiceURL, avatarImg) : $q.resolve()).then(function () {\n        // $rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", companyId);\n        $log.info("[adminCompanyService] pushCompanyBotAvatar success");\n        resolve();\n      })["catch"](function (error) {\n        reject(error);\n      });\n    });\n  };\n\n  service.deleteCompanyBotAvatar = function (botId, companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "bots/" + botId + "/companies/" + companyId + "/avatar",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback() {\n        // $rootScope.$broadcast("ON_COMPANY_CHANGE_EVENT", companyId);\n        $log.info("[adminCompanyService] deleteCompanyBotAvatar success");\n        resolve();\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[botService] " + errorHelperService.getErrorFullMessage(response, "deleteCompanyBotAvatar"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** INVITATION TO JOIN A COMPANY                       **/\n\n  /********************************************************/\n\n\n  service.getCompanyInvitations = function (companyId, page, pageSize) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "companies/" + companyId + "/join-companies/invitations?format=medium&status=pending declined&limit=" + pageSize;\n\n      if (page) {\n        url += "&offset=" + pageSize * (page - 1);\n      }\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var invitations = [];\n        response.data.data.forEach(function (invitationData) {\n          var invitation = CompanyInvitation.createFromData(invitationData);\n          invitations.push(invitation);\n        });\n        $log.info("[adminCompanyService] getCompanyInvitations success (found " + invitations.length + " invitation(s))");\n        resolve({\n          invitations: invitations,\n          total: response.data.total\n        });\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanyInvitations"));\n      });\n    });\n  };\n\n  service.joinCompanyInvitation = function (companyId, email, invitedUserId, customMessage, invitedToBeCompanyAdmin, invitedToBeBpAdmin) {\n    var defered = $q.defer();\n    var lang = settingsService.getAppliLanguageCodeForServer();\n    var data = {\n      lang: lang\n    };\n\n    if (customMessage) {\n      data.customMessage = customMessage;\n    }\n\n    if (invitedUserId) {\n      data.invitedUserId = invitedUserId;\n    } else if (email) {\n      data.email = email;\n    }\n\n    if (invitedToBeCompanyAdmin) {\n      data.invitedToBeCompanyAdmin = invitedToBeCompanyAdmin;\n    }\n\n    if (invitedToBeBpAdmin) {\n      data.invitedToBeBpAdmin = invitedToBeBpAdmin;\n    }\n\n    $http({\n      method: "POST",\n      url: service.portalURL + "companies/" + companyId + "/join-companies/invitations",\n      headers: authService.getRequestHeader(),\n      data: data\n    }).then(function successCallback() {\n      $log.info("[adminCompanyService] joinCompanyInvitation success");\n      defered.resolve();\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "joinCompanyInvitation"));\n    });\n    return defered.promise;\n  };\n\n  service.cancelJoinCompanyInvitation = function (companyId, invitationId) {\n    var defered = $q.defer();\n    $http({\n      method: "POST",\n      url: service.portalURL + "companies/" + companyId + "/join-companies/invitations/" + invitationId + "/cancel",\n      headers: authService.getRequestHeader()\n    }).then(function successCallback(response) {\n      var invitation = CompanyInvitation.createFromData(response.data.data);\n      $log.info("[adminCompanyService] cancelJoinCompanyInvitation success");\n      defered.resolve(invitation);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "cancelJoinCompanyInvitation"));\n    });\n    return defered.promise;\n  };\n\n  service.resendJoinCompanyInvitation = function (companyId, invitationId) {\n    var defered = $q.defer();\n    $http({\n      method: "POST",\n      url: service.portalURL + "companies/" + companyId + "/join-companies/invitations/" + invitationId + "/re-send",\n      headers: authService.getRequestHeader()\n    }).then(function successCallback(response) {\n      var invitation = CompanyInvitation.createFromData(response.data.data);\n      $log.info("[adminCompanyService] resendJoinCompanyInvitation success");\n      defered.resolve(invitation);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "resendJoinCompanyInvitation"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** REQUEST TO JOIN A COMPANY                          **/\n\n  /********************************************************/\n\n\n  service.getCompanyJoinRequests = function (companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/" + companyId + "/join-companies/requests?format=medium&status=pending",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var companyRequests = [];\n        response.data.data.forEach(function (companyRequestData) {\n          var companyRequest = CompanyRequest.createFromData(companyRequestData);\n          companyRequests.push(companyRequest);\n        });\n        $log.info("[adminCompanyService] getCompanyJoinRequests success (found " + response.data.total + " invitation(s))");\n        resolve({\n          companyRequests: companyRequests,\n          total: response.data.total\n        });\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanyJoinRequests"));\n      });\n    });\n  };\n\n  service.getJoinCompanyRequest = function (companyId, joinCompanyRequestId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/" + companyId + "/join-companies/requests/" + joinCompanyRequestId + "?status=pending",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var joinCompanyRequest = CompanyRequest.createFromData(response.data.data);\n        $log.info("[adminCompanyService] getJoinCompanyRequest success");\n        resolve(joinCompanyRequest);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getJoinCompanyRequest"));\n      });\n    });\n  };\n\n  service.acceptCompanyJoinRequests = function (companyId, joinCompanyRequestId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + "companies/" + companyId + "/join-companies/requests/" + joinCompanyRequestId + "/accept",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var joinCompanyRequest = CompanyRequest.createFromData(response.data.data);\n        $log.info("[adminCompanyService] acceptCompanyJoinRequests success");\n        resolve(joinCompanyRequest);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "acceptCompanyJoinRequests"));\n        reject(error);\n      });\n    });\n  };\n\n  service.declineCompanyJoinRequests = function (companyId, joinCompanyRequestId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + "companies/" + companyId + "/join-companies/requests/" + joinCompanyRequestId + "/decline",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var joinCompanyRequest = CompanyRequest.createFromData(response.data.data);\n        $log.info("[adminCompanyService] declineCompanyJoinRequests success");\n        resolve(joinCompanyRequest);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "declineCompanyJoinRequests"));\n        reject(error);\n      });\n    });\n  };\n\n  service.getOAuthConsentUrl = function () {\n    var lang = settingsService.getAppliLanguage().code;\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/office365/v1.0/consent?callback=" + window.location.origin + "/redirectO365.html?provider=o365&lang=" + lang,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var consentUrl = response.data.url;\n        $log.info("[adminCompanyService] getOAuthConsentUrl success: " + consentUrl);\n        resolve(consentUrl);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getOAuthConsentUrl"));\n        reject(error);\n      });\n    });\n  };\n  /********************************************************/\n\n  /** GET/SET COMPANY CONFERENCE SETTINGS                **/\n\n  /********************************************************/\n\n\n  service.getCompanyConferenceSettings = function (companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/" + companyId + "/settings/conferences",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] getCompanyConferenceSettings success");\n        var data = response.data.data;\n        resolve(data);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanyConferenceSettings"));\n      });\n    });\n  };\n\n  service.setCompanyConferenceSettings = function (companyId, confDialOutEnabled) {\n    return $q(function (resolve, reject) {\n      var conferenceSettingData = {\n        confDialOutDisabled: !confDialOutEnabled\n      };\n      $http({\n        method: "PUT",\n        url: service.portalURL + "companies/" + companyId + "/settings/conferences",\n        headers: authService.getRequestHeader(),\n        data: conferenceSettingData\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] setCompanyConferenceSettings success");\n        var data = response.data.data;\n        resolve(data);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "setCompanyConferenceSettings"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** COMPANY SINGLE SIGN-ON SETTINGS                    **/\n\n  /********************************************************/\n\n\n  service.getCompanySAMLConfigurationFile = function (companyId) {\n    return $q(function (resolve, reject) {\n      authService.getCompanySAMLConfiguration(companyId).then(function (data) {\n        var blob = new Blob([data], {\n          type: "application/xml"\n        });\n        resolve(blob);\n      })["catch"](function (response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanySAMLConfigurationFile"));\n      });\n    });\n  };\n\n  service.createCompanySingleSignOnServerConfig = function (companyId, singleSignOnType, config) {\n    return $q(function (resolve, reject) {\n      config.type = singleSignOnType;\n      $http({\n        method: "POST",\n        url: service.portalURL + "companies/" + companyId + "/settings/sso",\n        headers: authService.getRequestHeader(),\n        data: config\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] createCompanySingleSignOnServerConfig success");\n        var config = response.data.data;\n        resolve(config);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "createCompanySingleSignOnServerConfig"));\n      });\n    });\n  };\n\n  service.deleteCompanySingleSignOnServerConfig = function (companyId, singleSignOnType) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "DELETE",\n        url: service.portalURL + "companies/" + companyId + "/settings/sso/" + singleSignOnType,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback() {\n        $log.info("[adminCompanyService] deleteCompanySingleSignOnServerConfig success");\n        resolve();\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "deleteCompanySingleSignOnServerConfig"));\n      });\n    });\n  };\n\n  service.getCompanySingleSignOnServerConfig = function (companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/" + companyId + "/settings/sso",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] getCompanySingleSignOnServerConfig success");\n        var configArray = response.data.data ? response.data.data : response.data;\n        resolve(configArray);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanySingleSignOnServerConfig"));\n      });\n    });\n  };\n\n  service.updateCompanySingleSignOnServerConfig = function (companyId, singleSignOnType, config) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "PUT",\n        url: service.portalURL + "companies/" + companyId + "/settings/sso/" + singleSignOnType,\n        headers: authService.getRequestHeader(),\n        data: config\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] updateCompanySingleSignOnConfig success");\n        var config = response.data.data;\n        resolve(config);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "updateCompanySingleSignOnConfig"));\n      });\n    });\n  };\n\n  service.getCompanyBpBusinessTypes = function () {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/bpbusinesstypes",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] getCompanyBpBusinessTypes success");\n        var config = response.data.data;\n        resolve(config);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getCompanyBpBusinessTypes"));\n      });\n    });\n  };\n\n  service.getVoIPSettingsForCompany = function (companyId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: service.portalURL + "companies/" + companyId + "/settings/webrtcs",\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminCompanyService] getVoIPSettingsForCompany success");\n        var settings = response.data.data;\n        resolve(settings);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "getVoIPSettingsForCompany"));\n      });\n    });\n  };\n\n  service.createVoIPSettingsForCompany = function (companyId, settings) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "POST",\n        url: service.portalURL + "companies/" + companyId + "/settings/webrtcs",\n        headers: authService.getRequestHeader(),\n        data: settings\n      }).then(function successCallback(__response) {\n        resolve();\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "createVoIPSettingsForCompany"));\n        reject(error);\n      });\n    });\n  };\n\n  service.updateVoIPSettingsForCompany = function (companyId, settingsId, settings) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "PUT",\n        url: service.portalURL + "companies/" + companyId + "/settings/webrtcs/" + settingsId,\n        headers: authService.getRequestHeader(),\n        data: settings\n      }).then(function successCallback(__response) {\n        resolve();\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        $log.error("[adminCompanyService] " + errorHelperService.getErrorFullMessage(response, "createVoIPSettingsForCompany"));\n        reject(error);\n      });\n    });\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/admin/adminCompanyService.js?')},function(module,exports){eval('angular.module("rainbow").service("adminUserService", ["$q", "$log", "$http", "authService", "errorHelperService", "Company", "User", "Site", "Organisation", "userInfoService", "contactService", "PhoneNumber", function ($q, $log, $http, authService, errorHelperService, Company, User, Site, Organisation, userInfoService, contactService, PhoneNumber) {\n  "use strict";\n\n  var service = this;\n  /********************************************************/\n\n  /** LIFE CYCLE STUFF                                   **/\n\n  /********************************************************/\n\n  service.start = function () {\n    $log.info("[adminUserService] === STARTING ===");\n    service.portalURL = config.restServerUrl + "/api/rainbow/admin/v1.0/";\n    $log.info("[adminUserService] === STARTED ===");\n    return $q.when();\n  };\n\n  service.stop = function () {\n    $log.info("[adminUserService] === STOPPING ===");\n    $log.info("[adminUserService] === STOPPED ===");\n    return $q.when();\n  };\n  /********************************************************/\n\n  /** GET USERS                                          **/\n\n  /********************************************************/\n\n\n  service.getUsersByEmail = function (source, email) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "users?format=full";\n\n      if (source && source instanceof Organisation) {\n        url += "&organisationId=" + source.id;\n      }\n\n      if (source && source instanceof Company) {\n        url += "&companyId=" + source.id;\n      }\n\n      if (source && source instanceof Site) {\n        url += "&siteId=" + source.id;\n      }\n\n      if (email) {\n        url += "&email=" + encodeURIComponent(email);\n      }\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var data = response.data.data;\n        $log.info("[adminUserService] getUsersByEmail success (find " + response.data.total + " user(s))");\n        var users = [];\n        data.forEach(function (userData) {\n          var user = User.createFromData(userData);\n          users.push(user);\n        });\n        resolve({\n          users: users,\n          total: response.data.total\n        });\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "getUsersByEmail"));\n      });\n    });\n  };\n\n  service.getUsers = function (source, page, pageSize, searchPattern, isTerminated, isAdministrator, noDefaultValues, searchByTag) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "users?format=full&limit=" + pageSize;\n\n      if (source && source instanceof Organisation) {\n        url += "&organisationId=" + source.id;\n      }\n\n      if (source && source instanceof Company) {\n        url += "&companyId=" + source.id;\n      }\n\n      if (source && source instanceof Site) {\n        url += "&siteId=" + source.id;\n      }\n\n      if (page) {\n        url += "&offset=" + pageSize * (page - 1);\n      }\n\n      if (searchPattern && !searchByTag) {\n        url += "&displayName=" + encodeURIComponent(searchPattern) + "&useEmails=true";\n      }\n\n      if (searchPattern && searchByTag) {\n        url += "&tags=" + encodeURIComponent(searchPattern);\n      }\n\n      if (isTerminated !== undefined && isTerminated !== null) {\n        url += "&isTerminated=" + isTerminated;\n      }\n\n      if (isAdministrator) {\n        url += "&roles=admin&roles=bp_admin&roles=bp_finance&roles=superadmin&roles=business_admin";\n      }\n\n      url += "&sortField=reverseDisplayName"; // always sort by user\'s lastname\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var data = response.data.data;\n        $log.info("[adminUserService] getUsers success (find " + response.data.total + " user(s))");\n        var users = [];\n        data.forEach(function (userData) {\n          var user = User.createFromData(userData, noDefaultValues);\n          users.push(user);\n        });\n        resolve({\n          users: users,\n          limit: response.data.limit,\n          offset: response.data.offset,\n          total: response.data.total\n        });\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "getUsers"));\n      });\n    });\n  };\n  /**\n    * Warning!! This API uses the search portal. Used to search users belonging to the "default" company.\n   */\n\n\n  service.searchUsers = function (source, page, pageSize, searchPattern) {\n    return $q(function (resolve, reject) {\n      var url = config.restServerUrl + "/api/rainbow/search/v1.0/users?limit=" + pageSize;\n\n      if (source) {\n        url += "&companyId=" + source.id;\n      }\n\n      if (page) {\n        url += "&offset=" + pageSize * (page - 1);\n      }\n\n      if (searchPattern) {\n        url += "&displayName=" + encodeURIComponent(searchPattern);\n      }\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var data = response.data.data;\n        $log.info("[adminUserService] searchUsers success (find " + response.data.total + " user(s))");\n        var users = [];\n        data.forEach(function (userData) {\n          var user = User.createFromData(userData);\n          users.push(user);\n        });\n        resolve({\n          users: users,\n          total: response.data.total\n        });\n      }, function failure(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "searchUsers"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** GET USER                                           **/\n\n  /********************************************************/\n\n\n  service.getUser = function (userId) {\n    var defered = $q.defer();\n    $http({\n      method: "GET",\n      url: service.portalURL + "users/" + userId,\n      headers: authService.getRequestHeader()\n    }).then(function successCallback(response) {\n      $log.info("[adminUserService] getUser success");\n      var data = response.data.data;\n      var user = User.createFromData(data);\n      defered.resolve(user);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "getUser"));\n    });\n    return defered.promise;\n  };\n  /**\n   * CREATE USER\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.createUser = function (user) {\n    // Remove unwanted and undefined optional properties from data that must not be sent to the server\n    var userData = User.prune(user, contactService.userContact);\n    var defered = $q.defer();\n    $http({\n      method: "POST",\n      url: service.portalURL + "users",\n      headers: authService.getRequestHeader(),\n      data: userData\n    }).then(function successCallback(response) {\n      var newuser = User.createFromData(response.data.data);\n      $log.info("[adminUserService] createUser success");\n      defered.resolve(newuser);\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "createUser"));\n    });\n    return defered.promise;\n  };\n  /**\n   * DELETE USER\n   * Used by SDK (public)\n   * Warning when modifying this method\n   */\n\n\n  service.deleteUser = function (user) {\n    var defered = $q.defer();\n    $http({\n      method: "DELETE",\n      url: service.portalURL + "users/" + user.id,\n      headers: authService.getRequestHeader()\n    }).then(function successCallback() {\n      $log.info("[adminUserService] deleteUser success");\n      defered.resolve();\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "deleteUser"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** UPDATE USER                                        **/\n\n  /********************************************************/\n\n\n  service.updateUser = function (user) {\n    // Remove unwanted and undefined optional properties from data that must not be sent to the server\n    var userData = User.prune(user, contactService.userContact);\n    var defered = $q.defer();\n    $http({\n      method: "PUT",\n      url: service.portalURL + "users/" + user.id,\n      headers: authService.getRequestHeader(),\n      data: userData\n    }).then(function successCallback() {\n      $log.info("[adminUserService] updateUser success");\n      defered.resolve();\n    }, function errorCallback(response) {\n      var error = errorHelperService.handleError(response);\n      defered.reject(error);\n      $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "updateUser"));\n    });\n    return defered.promise;\n  };\n  /********************************************************/\n\n  /** GET USER IMAGE                                     **/\n\n  /********************************************************/\n\n\n  service.getUserAvatar = function (user) {\n    var color = userInfoService.computeUserColor(user.firstName + " " + user.lastName).color;\n    userInfoService.getAvatarImage(user.id, user.initials, color, 50, user.lastAvatarUpdateDate).then(function (image) {\n      user.image = image;\n    });\n  };\n  /********************************************************/\n\n  /** EXTRACT TELEPHONY INF                              **/\n\n  /********************************************************/\n\n\n  service.expandTelephonyInfo = function (user) {\n    var result = {};\n\n    if (user.phoneNumbers) {\n      user.phoneNumbers.forEach(function (phoneNumber) {\n        var number = phoneNumber.number;\n        var numberCan = phoneNumber.numberE164;\n        var deviceType = phoneNumber.deviceType;\n\n        switch (phoneNumber.type) {\n          case "work":\n            if (deviceType === "landline") {\n              if (phoneNumber.isCloudPbxDDI) {\n                result.phonePro = phoneNumber.number;\n                result.phoneProCan = phoneNumber.numberE164;\n                result.phoneProDdiNumber = PhoneNumber.createFromData(phoneNumber);\n              } else if (result.phoneProNumber && result.phoneProNumber.systemId) {// a phone extension linked to a system (only one allowed) has already been registered; \n                // do not override\n              } else {\n                if (!result.phoneProDdiNumber) {\n                  //do not override DDI number coming from DDI phonenumber array entry (cloud-pbx only)\n                  result.phonePro = number;\n                  result.phoneProCan = numberCan;\n                }\n\n                result.phoneProExt = phoneNumber.shortNumber;\n                result.phoneProIsMonitored = phoneNumber.isMonitored;\n                result.phoneProNumber = PhoneNumber.createFromData(phoneNumber);\n              }\n            }\n\n            if (deviceType === "mobile") {\n              result.mobilePro = number;\n              result.mobileProCan = numberCan;\n            }\n\n            break;\n\n          case "home":\n            if (deviceType === "landline") {\n              result.phonePerso = number;\n              result.phonePersoCan = numberCan;\n            }\n\n            if (deviceType === "mobile") {\n              result.mobilePerso = number;\n              result.mobilePersoCan = numberCan;\n            }\n\n            break;\n\n          case "rainbow":\n            result.rainbowPhoneNumber = number;\n            break;\n\n          default:\n            break;\n        }\n      });\n    }\n\n    return result;\n  };\n\n  service.getAllUsers = function (source, noDefaultValues) {\n    var limit = 1000; // maximum of users that can be requested to the server\n\n    return $q(function (resolve, reject) {\n      var result; // Get first page of users and the total number of users to retrieve\n\n      service.getUsers(source, 1, limit, undefined, undefined, undefined, noDefaultValues).then(function (response) {\n        result = response;\n\n        if (response.total > response.limit) {\n          var totalPages = Math.ceil(response.total / limit); // List of page numbers to get (remove first page that was already gotten)\n\n          var pages = Array.apply(null, Array(totalPages - 1));\n          pages = pages.map(function (__unused, index) {\n            return index + 2;\n          }); // fill array with page numbers to request\n          // Serialize promises by chunks (possibly too much requests than the server can support)\n\n          var chunks = [];\n\n          while (pages.length > 0) {\n            chunks.push(pages.splice(0, 5));\n          } // chunk size must be less than 10 to avoid internal system error\n\n\n          return chunks.reduce(function (promiseChain, requests) {\n            // Parallelize chunks\n            return promiseChain.then(function () {\n              var promisesArray = requests.map(function (page) {\n                return service.getUsers(source, page, limit, undefined, undefined, undefined, noDefaultValues).then(function (data) {\n                  result.users = result.users.concat(data.users);\n                  result.limit += data.limit;\n                });\n              }); // return chain\n\n              return $q.all(promisesArray);\n            });\n          }, $q.resolve());\n        }\n      }).then(function () {\n        resolve(result);\n      })["catch"](function (error) {\n        reject(error);\n      });\n    });\n  };\n  /********************************************************/\n\n  /** USER TAGS                                     **/\n\n  /********************************************************/\n\n\n  service.getUserTags = function (companyId) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "users/tags";\n\n      if (companyId) {\n        url += "?companyId=" + companyId;\n      }\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var tags = response.data.data.tags || [];\n        $log.info("[adminUserService] getUserTags success (find " + tags.length + "tags(s))");\n        resolve(tags);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "getUserTags"));\n      });\n    });\n  };\n\n  service.getUserTagsStats = function (companyId) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "users/tags/stats";\n\n      if (companyId) {\n        url += "?companyId=" + companyId;\n      }\n\n      $http({\n        method: "GET",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        var tagsStats = response.data.data.stats || [];\n        $log.info("[adminUserService] getUserTagsStats success (find " + tagsStats.length + "tags(s))");\n        resolve(tagsStats);\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "getUserTagsStats"));\n      });\n    });\n  };\n\n  service.renameUserTag = function (tag, newTagName, companyId) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "users/tags?tag=" + encodeURIComponent(tag);\n\n      if (companyId) {\n        url += "&companyId=" + companyId;\n      }\n\n      $http({\n        method: "PUT",\n        url: url,\n        headers: authService.getRequestHeader(),\n        data: {\n          newTagName: newTagName\n        }\n      }).then(function successCallback(response) {\n        $log.info("[adminUserService] renameUserTag success => old tag: " + tag + " => new tag: " + newTagName + ": found " + response.data.data.found + " occurence(s)");\n        resolve();\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "renameUserTag"));\n      });\n    });\n  };\n\n  service.deleteUserTag = function (tag, companyId) {\n    return $q(function (resolve, reject) {\n      var url = service.portalURL + "users/tags?tag=" + encodeURIComponent(tag);\n\n      if (companyId) {\n        url += "&companyId=" + companyId;\n      }\n\n      $http({\n        method: "DELETE",\n        url: url,\n        headers: authService.getRequestHeader()\n      }).then(function successCallback(response) {\n        $log.info("[adminUserService] deleteUserTag success (tag " + tag + ": found " + response.data.data.found + " occurence(s)");\n        resolve();\n      }, function errorCallback(response) {\n        var error = errorHelperService.handleError(response);\n        reject(error);\n        $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "deleteUserTag"));\n      });\n    });\n  };\n  /********************************************************/\n\n  /** USER FEATURES                                      **/\n\n  /********************************************************/\n\n\n  service.getUserProfilesFeatures = function (userId) {\n    return $q(function (resolve, reject) {\n      $http({\n        method: "GET",\n        url: config.restServerUrl + "/api/rainbow/admin/v1.0/users/" + userId + "/profiles/features",\n        headers: authService.getRequestHeader()\n      }).then(function success(response) {\n        var features = {};\n        response.data.data.forEach(function (featureData) {\n          $log.debug("[adminUserService] getUserProfilesFeatures === response ===" + JSON.stringify(featureData));\n\n          if (featureData.hasOwnProperty("featureUniqueRef")) {\n            features[featureData.featureUniqueRef] = featureData;\n          }\n        });\n        resolve(features);\n      }, function error(response) {\n        if (response.status === 404) {\n          $log.debug("[adminUserService] getUserProfilesFeatures : features found for user: " + userId);\n          resolve();\n        } else {\n          var error = errorHelperService.handleError(response);\n          reject(error);\n          $log.error("[adminUserService] " + errorHelperService.getErrorFullMessage(response, "getUserProfilesFeatures"));\n        }\n      });\n    });\n  };\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/services/admin/adminUserService.js?')},function(module,exports){eval('//import * as emojione from "../../cache/emojione/emojioneV1.js";\nangular.module("rainbow").filter("emojione", ["$sce", "$sanitize", function ($sce, $sanitize) {\n  "use strict";\n\n  return function (input) {\n    if (!angular.isString(input)) {\n      return input;\n    }\n\n    var temp = input.split(" ");\n    temp.forEach(function (item, index) {\n      if (this[index] !== "" && this[index].indexOf("http://") === -1 && this[index].indexOf("https://") === -1) {\n        this[index] = emojione.shortnameToImage(this[index]);\n      }\n    }, temp);\n    input = temp.join(" ");\n    return $sanitize($sce.trustAsHtml(input));\n  };\n}]);\nangular.module("rainbow").filter("emojiUnicodeToShort", function () {\n  "use strict";\n\n  return function (input) {\n    if (!angular.isString(input)) {\n      return input;\n    }\n\n    var temp = input.split(" ");\n    temp.forEach(function (__item, index) {\n      if (this[index] !== "" && this[index].indexOf("http://") === -1 && this[index].indexOf("https://") === -1) {\n        this[index] = emojione.toShort(this[index]);\n      }\n    }, temp);\n    input = temp.join(" ");\n    return input;\n  };\n});\nangular.module("rainbow").filter("emojiShortToUnicode", function () {\n  "use strict";\n\n  return function (input) {\n    if (!angular.isString(input)) {\n      return input;\n    }\n\n    var temp = input.split(" ");\n    temp.forEach(function (__item, index) {\n      if (this[index] !== "" && this[index].indexOf("http://") === -1 && this[index].indexOf("https://") === -1) {\n        this[index] = emojione.shortnameToUnicode(this[index]);\n      }\n    }, temp);\n    input = temp.join(" ");\n    return input;\n  };\n});\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/extensions/filters/emojiFilter.js?')},function(module,exports){eval('angular.module("rainbow").factory("PromiseQueue", ["$log", function ($log) {\n  "use strict"; // Static factories\n\n  PromiseQueue.create = function () {\n    return new PromiseQueue();\n  }; // Constructor\n\n\n  function PromiseQueue() {\n    var that = this;\n    this.queue = [];\n    this.started = false;\n\n    this.add = function (promise) {\n      this.queue.push(promise);\n\n      if (!this.started) {\n        this.started = true;\n        this.execute();\n      }\n    };\n\n    this.execute = function () {\n      var promise = this.queue.shift();\n\n      if (promise) {\n        try {\n          that.timeoutPromise(20000, promise) // the promise will time out after 20 sec\n          .then(function () {\n            that.execute();\n          })["catch"](function (error) {\n            var errorMessage = error && error.message ? error.message : "Unknown error"; //no need to dump statck : it is already dumped by promise s own error handling\n\n            $log.error("[PromiseQueue] execute failure -- " + errorMessage);\n            that.execute();\n          }); // Note : finally cannot be used here because the use of Promise.race in timeoutPromise() is not compatible with\n          // a browser which does not support nativelly Promise.finally (such as the desktop client using Chromium 61)\n          // If the chromium version of the desktop client goes to version 63 or higher, the finally can be added here\n          // (and the calls to that.execute() must be removed from .then() and .catch())\n          //.finally(function() { that.execute(); });\n        } catch (error) {\n          var errorMessage = error && error.message ? error.message : "Unknown error";\n          var errorStack = error && error.stack ? error.stack : "Unknown stack";\n          $log.error("[PromiseQueue] execution exception  -- " + errorMessage + " : " + errorStack);\n          that.execute();\n        }\n      } else {\n        this.started = false;\n      }\n    };\n\n    that.timeoutPromise = function (ms, promise) {\n      var timeoutId; // Create a promise that rejects in <ms> milliseconds\n\n      var timeout = new Promise(function (resolve, reject) {\n        timeoutId = setTimeout(function () {\n          reject(new Error("Timed out in " + ms + "ms."));\n        }, ms);\n      }); // Returns a race between our timeout and the passed in promise\n\n      return Promise.race([promise(), timeout]).then(function (value) {\n        clearTimeout(timeoutId);\n        return value;\n      });\n    };\n  }\n\n  return PromiseQueue;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/components/promiseQueue/promiseQueue.js?')},function(module,exports){eval('angular.module("rainbow").factory("TransfertPromiseQueue", ["$log", "$q", function ($log, $q) {\n  "use strict"; // Static factories\n\n  TransfertPromiseQueue.create = function () {\n    $log.debug("[TransfertPromiseQueue] >create");\n    return new TransfertPromiseQueue();\n  }; // Constructor\n\n\n  function TransfertPromiseQueue() {\n    var that = this;\n    that.fileQueue = [];\n\n    that.clearContext = function () {\n      that.currentId = null;\n      that.currentQueue = [];\n      that.promiseCompletion = undefined;\n      that.promiseReject = undefined;\n      that.initialQueueSize = 0;\n      that.promisesDone = 0;\n      that.chunkErrorCounter = 0;\n      that.currentPromise = undefined;\n    }; // Current File informations :\n\n\n    that.clearContext();\n\n    that.addPromiseArray = function (id, promiseArray, promiseCompletion, promiseReject) {\n      $log.debug("[TransfertPromiseQueue] adding promiseArray");\n      var promiseInfos = {};\n      promiseInfos.id = id;\n      promiseInfos.promiseArray = promiseArray;\n      promiseInfos.promiseCompletion = promiseCompletion;\n      promiseInfos.promiseReject = promiseReject;\n\n      if (that.fileQueue.length === 0 && !that.currentPromise) {\n        $log.debug("[TransfertPromiseQueue] configuring file to transfert: " + promiseInfos.promiseArray.length);\n        that.fileQueue.push(promiseInfos);\n        that.popFileQueue();\n      } else {\n        that.fileQueue.push(promiseInfos);\n        $log.debug("[TransfertPromiseQueue] adding PromiseArray in FileQueue: " + that.fileQueue.length);\n      }\n\n      $log.debug("[TransfertPromiseQueue] adding promise on FileQueue: " + that.fileQueue.length);\n      return $q;\n    };\n\n    that.popFileQueue = function () {\n      if (that.fileQueue.length > 0) {\n        $log.debug("[TransfertPromiseQueue] go to next file");\n        var promiseInfos = that.fileQueue.shift();\n        that.currentId = promiseInfos.id;\n        that.currentQueue = promiseInfos.promiseArray;\n        that.promiseCompletion = promiseInfos.promiseCompletion;\n        that.promiseReject = promiseInfos.promiseReject;\n        that.initialQueueSize = that.currentQueue.length;\n        that.promisesDone = 0;\n        that.chunkErrorCounter = 0;\n        that.currentPromise = that.currentQueue.shift();\n        that.execute();\n      } else {\n        $log.debug("[TransfertPromiseQueue] no more file to transfert");\n        that.clearContext();\n      }\n    };\n\n    that.execute = function () {\n      $log.debug("[TransfertPromiseQueue] execute"); //that.currentPromise = that.currentQueue.shift();\n\n      if (that.currentPromise) {\n        $log.debug("[TransfertPromiseQueue] performing promise: " + that.promisesDone);\n        that.currentPromise().then(function () {\n          $log.debug("[TransfertPromiseQueue] promise success go to next one");\n          that.promisesDone++;\n          that.chunkErrorCounter = 0;\n\n          if (that.promisesDone >= that.initialQueueSize) {\n            if (that.promiseCompletion) {\n              that.promiseCompletion();\n            }\n\n            that.popFileQueue();\n          } else {\n            that.currentPromise = that.currentQueue.shift();\n            that.execute();\n          }\n        })["catch"](function (error) {\n          var errorMessage = error && error.message ? error.message : "Unknown error";\n          $log.error("[TransfertPromiseQueue] failure executing promise -- " + errorMessage); // Manage Retry of chunk\n\n          that.chunkErrorCounter++;\n\n          if (error && error.errorDetailsCode >= 500 && that.chunkErrorCounter <= 3) {\n            that.execute();\n          } else {\n            $log.error("[TransfertPromiseQueue] 3 chunk failed - ABORT File Upload");\n            that.promiseReject(error);\n            that.popFileQueue();\n          }\n        });\n      } else {\n        $log.debug("[TransfertPromiseQueue] no promise to perform");\n        that.currentPromise = undefined;\n      }\n    };\n\n    that.isTransferInProgress = function () {\n      $log.debug("[TransfertPromiseQueue] >isTransferInProgress: " + that.fileQueue.length + "/" + that.currentQueue.length);\n      return that.fileQueue.length > 0 || that.currentQueue.length > 0 || that.currentPromise;\n    };\n\n    that.cancelAllTransfers = function () {\n      $log.debug("[TransfertPromiseQueue] cancelAllTransfers");\n      that.fileQueue = [];\n      that.currentQueue = [];\n    };\n\n    that.cancelCurrentFiletransfer = function (id) {\n      $log.debug("[TransfertPromiseQueue] cancelCurrentFiletransfer");\n\n      if (that.currentId === id) {\n        $log.debug("[TransfertPromiseQueue] cancelling current promise");\n        that.popFileQueue();\n      } else {\n        // Find corresponding File Promise to remove from FileQueue :\n        var promiseFound = that.fileQueue.find(function (currentPromiseInfos) {\n          return currentPromiseInfos.id === id;\n        });\n\n        if (promiseFound) {\n          var promisePos = that.fileQueue.indexOf(promiseFound);\n          $log.debug("[TransfertPromiseQueue] promise to remove at position=" + promisePos);\n          that.fileQueue.splice(promisePos, 1);\n        }\n      }\n    };\n  }\n\n  return TransfertPromiseQueue;\n}]);\n\n//# sourceURL=webpack:///./dependencies_otliteclient/app/components/promiseQueue/transfertPromiseQueue.js?')},function(module,exports){eval('// Register sdk module \nwindow.sdk = angular.module("sdk", ["pascalprecht.translate", "ngSanitize", "ngFileSaver", "angular-jwt", "uuid4", "rainbow", "rainbowAdmin"], function () {\n  "use strict";\n});\n\n//# sourceURL=webpack:///./src/sdkLoader.js?')},function(module,exports){eval('/**\n * Enum for SDK values.\n * @module sdk\n * @readonly\n * @enum {number}\n * @property {number} SDK.OK Constant representing OK\n * @property {number} SDK.ERROR Constant representing a general error\n * @property {number} SDK.ERRORUNAUTHORIZED Constant representing a login error\n * @property {number} SDK.ERRORXMPP Constant representing an xmpp error\n * @property {number} SDK.ERRORBADREQUEST Constant representing an request error (bad parameter)\n * @property {number} SDK.ERRORUNSUPPORTED Constant representing an error when the feature called is not supported\n * @property {number} SDK.ERRORNOTFOUND Constant representing an error when the object to retrieve is not found\n */\nvar code = {\n  "OK": 1,\n  "ERROR": -1,\n  "ERRORUNAUTHORIZED": -2,\n  "ERRORXMPP": -4,\n  "ERRORXMPPJID": -8,\n  "ERRORBADREQUEST": -16,\n  "ERRORUNSUPPORTED": -32,\n  "ERRORNOTFOUND": -64\n};\nsdk.constant("SDK", code);\n\n//# sourceURL=webpack:///./src/sdkConstant.js?')},function(module,exports){eval('sdk.remoteConsole = {\n  debug: false,\n  log: false,\n  info: false,\n  warn: false,\n  error: false\n};\nsdk.hasVerboseLog = false;\nsdk.useAngularEvents = false;\nsdk.hasBeenLaunchedFromConfig = false;\nsdk.key = {\n  appID: "",\n  appSecret: "",\n  host: "openrainbow.com"\n};\nsdk.config(["consoleLogsProvider", "$provide", "$httpProvider", "$translateProvider", function (consoleLogsProvider, $provide, $httpProvider, $translateProvider) {\n  "use strict";\n  /**********************************************************************/\n\n  /** LOGS CONFIGURATION                                               **/\n\n  /**********************************************************************/\n\n  var utc = function utc(now) {\n    var datestring = now.toDateString() + " " + ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);\n    return datestring;\n  };\n\n  $provide.decorator("$log", ["$delegate", function ($delegate) {\n    var origDebug = $delegate.debug;\n\n    $delegate.debug = function () {\n      var args = [].slice.call(arguments);\n\n      if (sdk.remoteConsole.debug) {\n        console.re.debug(args[0]);\n      }\n\n      if (sdk.hasVerboseLog) origDebug.apply(null, args);\n      consoleLogsProvider.setLogs(["[" + utc(new Date()) + "]"] + "debug : " + args + "\\n");\n    };\n\n    var origLog = $delegate.log;\n\n    $delegate.log = function () {\n      var args = [].slice.call(arguments);\n\n      if (sdk.remoteConsole.log) {\n        console.re.log(args[0]);\n      }\n\n      if (sdk.hasVerboseLog) origLog.apply(null, args);\n      consoleLogsProvider.setLogs(["[" + utc(new Date()) + "]"] + "log : " + args + "\\n");\n    };\n\n    var origInfo = $delegate.info;\n\n    $delegate.info = function () {\n      var args = [].slice.call(arguments);\n\n      if (sdk.remoteConsole.info) {\n        console.re.info(args[0]);\n      }\n\n      if (sdk.hasVerboseLog) origInfo.apply(null, args);\n      consoleLogsProvider.setLogs(["[" + utc(new Date()) + "]"] + "info : " + args + "\\n");\n    };\n\n    var origWarn = $delegate.warn;\n\n    $delegate.warn = function () {\n      var args = [].slice.call(arguments);\n\n      if (sdk.remoteConsole.warn) {\n        console.re.warn(args[0]);\n      }\n\n      origWarn.apply(null, args);\n      consoleLogsProvider.setLogs(["[" + utc(new Date()) + "]"] + "warn : " + args + "\\n");\n    };\n\n    var origError = $delegate.error;\n\n    $delegate.error = function () {\n      var args = [].slice.call(arguments);\n\n      if (sdk.remoteConsole.error) {\n        console.re.error(args[0]);\n      }\n\n      origError.apply(null, args);\n      consoleLogsProvider.setLogs(["[" + utc(new Date()) + "]"] + "error : " + args + "\\n");\n    };\n\n    $delegate.webrtc = function () {\n      var args = [].slice.call(arguments);\n      var logs = "rtcweb : " + args[0];\n      args[0] = "%c " + utc(new Date()) + " | RTCWEB | " + args[0];\n      args[args.length] = "color:green";\n\n      if (sdk.remoteConsole.log) {\n        console.re.log(args[0]);\n      }\n\n      origDebug.apply(null, args);\n      consoleLogsProvider.setLogs(["[" + utc(new Date()) + "]"] + logs + "\\n");\n    };\n\n    $delegate.sdk = function () {\n      var args = [].slice.call(arguments);\n      var logs = "RBW-SDK : " + args[0];\n      args[0] = "%c " + utc(new Date()) + " | RBW-SDK | " + args[0];\n      args[args.length] = "color:green";\n\n      if (sdk.remoteConsole.log) {\n        console.re.log(args[0]);\n      }\n\n      origDebug.apply(null, args);\n      consoleLogsProvider.setLogs(["[" + utc(new Date()) + "]"] + logs + "\\n");\n    };\n\n    return $delegate;\n  }]); // Enable CORS\n\n  $httpProvider.defaults.useXDomain = true;\n  $translateProvider.useSanitizeValueStrategy(null);\n}]);\nsdk.run([function () {\n  "use strict";\n}]);\nsdk.provider("consoleLogs", [function () {\n  "use strict"; // To memorize all logs\n\n  this.logsBuffer = [];\n  this.logsMaxLength = 2000000; // 2 Mo\n\n  this.$get = function () {\n    var logsBuffer = this.logsBuffer;\n    return {\n      getLogs: function getLogs() {\n        return logsBuffer;\n      }\n    };\n  };\n\n  this.cleanBuffer = function () {\n    //limit length of the inner console\n    if (this.logsBuffer.length > this.logsMaxLength) {\n      this.logsBuffer = this.logsBuffer.slice(-this.logsMaxLength); // negative number to select from the end of the string\n    }\n  };\n\n  this.setLogs = function (logs) {\n    if (this.logsBuffer === 1000) {\n      this.logsBuffer.shift();\n    }\n\n    this.logsBuffer.push(logs);\n  };\n}]);\n\n//# sourceURL=webpack:///./src/sdkCore.js?')},function(module,exports){eval('// DEFAULT CONFIG\nwindow.config = {\n  xmpp: {\n    "protocol": "wss",\n    "server": "sandbox.openrainbow.com",\n    "port": "443",\n    "pingInterval": "60000"\n  },\n  webservices: {\n    "protocol": "https",\n    "server": "sandbox.openrainbow.com",\n    "port": "443"\n  },\n  cpaas: {\n    "protocol": "https",\n    "server": "",\n    "port": "8887"\n  }\n};\n\n//# sourceURL=webpack:///./src/sdkConfig.js?')},function(module,exports){eval("/**\n * @module\n * @name SDK\n * @description\n *      This is the glue that binds all the SDK for Web services together. From that entry class, you can access to all the services and events integrated into this SDK for Web.\n *      In addition to that, this module logs in the browser console some interesting information about the application environment.\n */\nvar sdkService = angular.module('sdk').service('rainbowSDK', ['$log', '$q', '$rootScope', 'connectionService', 'presenceService', 'contactsService', 'conversationsService', 'imService', 'pbxService', 'webRTCService', 'bubblesService', 'groupsService', 'callsLogService', 'userProfileService', 'settingsService', 'favoritesService', 'filesStorageService', 'capabilitiesService', 'channelsService', 'adminService', 'SDK', function test($log, $q, $rootScope, connectionService, presenceService, contactsService, conversationsService, imService, pbxService, webRTCService, bubblesService, groupsService, callsLogService, userProfileService, settingsService, favoritesService, filesStorageService, capabilitiesService, channelsService, adminService, __SDK) {\n  'use strict';\n\n  var that = this;\n  var eventHandler = null;\n  this.isReady = false;\n  /**\n   * @public\n   * @event RAINBOW_ONREADY\n   * @description\n   *      This event is fired when the SDK services is initialized and ready to be used\n   */\n\n  this.RAINBOW_ONREADY = 'ready';\n  /**\n   * @public\n   * @event RAINBOW_ONLOADED\n   * @description\n   *      This event is fired when the SDK services has been correctly loaded <br/>\n   *      This event is only fired when the SDK is launched from a configuration file (i.e. angular app using the config.file)\n   */\n\n  this.RAINBOW_ONLOADED = 'loaded';\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Connection service\n   */\n\n  this.connection = connectionService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Presence service\n   */\n\n  this.presence = presenceService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Contacts service\n   */\n\n  this.contacts = contactsService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Conversations service\n   */\n\n  this.conversations = conversationsService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Conversations service\n   */\n\n  this.im = imService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Telephony service\n   */\n\n  this.telephony = pbxService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the WebRTC service\n   */\n\n  this.webRTC = webRTCService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Bubbles service\n   */\n\n  this.bubbles = bubblesService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Groups service\n   */\n\n  this.groups = groupsService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Calls log service\n   */\n\n  this.callsLog = callsLogService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the UserProfile service\n   */\n\n  this.userProfile = userProfileService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Favorites service\n   */\n\n  this.favorites = favoritesService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the File Storage service\n   */\n\n  this.fileStorage = filesStorageService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Capabilities service\n   */\n\n  this.caps = capabilitiesService;\n  /**\n   * @public\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Channel service\n   */\n\n  this.channels = channelsService;\n  /**\n   * @private\n   * @member {Object}\n   * @instance\n   * @description\n   *    Access to the Admin service (tests only)\n   */\n\n  this.admin = adminService;\n  /**\n   * @public\n   * @method\n   * @instance\n   * @description\n   *    Return the version of the SDK\n   * @return {string} The SDK version\n   */\n\n  this.version = function version() {\n    return window.sdkversion;\n  };\n  /**\n   * @public\n   * @method\n   * @instance\n   * @description\n   *    Return the mode used 'sdk' or 'rainbow'\n   * @return {string} The mode in which this SDK is used\n   */\n\n\n  this.mode = function mode() {\n    return settingsService.getSetting('apiMode');\n  };\n  /**\n   * @public\n   * @method\n   * @instance\n   * @description\n   *    Allows to have verbose logs when using the SDK\n   * @param {boolean} boolHasVerboseLog   True to activate verbose log. False elsewhere\n   */\n\n\n  this.setVerboseLog = function setVerboseLog(boolHasVerboseLog) {\n    sdk.hasVerboseLog = boolHasVerboseLog;\n    return sdk.hasVerboseLog;\n  };\n  /**\n   * @public\n   * @since 1.19.0\n   * @method\n   * @instance\n   * @description\n   *    Allows to use Angular based events mechanism\n   * @param {boolean} boolUseAngularEvents   True to use Angular based events mechanism (i.e. based on $broadcast and $on...)\n   */\n\n\n  this.useAngularEvents = function useAngularEvents(boolUseAngularEvents) {\n    sdk.useAngularEvents = boolUseAngularEvents;\n    return sdk.useAngularEvents;\n  };\n  /**\n   * @private\n   * @method\n   * @instance\n   * @description\n   *    Initialize the SDK with the application ID and application secret key obtained from the developer web site and filled into the configuration file\n   * @param {string} strApplicationID   The application ID obtained from the developer web site\n   * @param {string} strApplicationSecret   The application secret key obtained from the developer web site\n   */\n\n\n  this.setKeyFromConfig = function setKey(strApplicationID, strApplicationSecret) {\n    $log.sdk('SDKSrv     | [initialize ] :: Linked to application ID ' + strApplicationID + ' from configuration file');\n    sdk.key.appID = strApplicationID;\n    sdk.key.appSecret = strApplicationSecret;\n    return true;\n  };\n  /**\n   * @private\n   * @method\n   * @instance\n   * @description\n   *    Inform the SDK that it has been launched from a configuration file (i.e. the launched)\n   * @param {boolean} boolFromConfig   True if the SDK has been launched from the configuration file\n   */\n\n\n  this.hasBeenLaunchedFromConfig = function hasBeenLaunchedFromConfig(boolFromConfig) {\n    var fromConfig = boolFromConfig ? 'YES' : 'NO';\n    $log.sdk('SDKSrv     | [initialize ] :: SDK lauched from a configuration file ' + fromConfig);\n    sdk.hasBeenLaunchedFromConfig = boolFromConfig;\n    return sdk.hasBeenLaunchedFromConfig;\n  };\n  /**\n   * @public\n   * @since 1.18.0\n   * @method\n   * @instance\n   * @description\n   *    Initialize the SDK with the application ID and application secret key obtained from the developer web site and filled into the configuration file. <br/>\n   * @param {string} strApplicationID   The application ID obtained from the developer web site\n   * @param {string} strApplicationSecret   The application secret key obtained from the developer web site\n   */\n\n\n  this.initialize = function initialize(strApplicationID, strApplicationSecret) {\n    var defered = $q.defer();\n\n    if (strApplicationID && strApplicationID.length > 0) {\n      sdk.key.appID = strApplicationID;\n      $log.sdk('SDKSrv     | [initialize ] :: Initialize the SDK for the application ' + sdk.key.appID + '...');\n    } else {\n      $log.sdk('SDKSrv     | [initialize ] :: Initialize the SDK without an application key...');\n    }\n\n    if (strApplicationSecret && strApplicationSecret.length > 0) {\n      sdk.key.appSecret = strApplicationSecret;\n    }\n\n    initializeFirstStep().then(function () {\n      $log.sdk('SDKSrv     | [initialize ] :: Initialize step 1/2 ok');\n      intializeSecondStep().then(function () {\n        $log.sdk('SDKSrv     | [initialize ] :: Initialize step 2/2 ok');\n        $log.sdk('SDKSrv     | [initialize ] :: SDK Initialized successfully!');\n        defered.resolve();\n      });\n    });\n    return defered.promise;\n  };\n\n  var initializeFirstStep = function initializeFirstStep() {\n    var defered = $q.defer();\n\n    if (!that.isReady) {\n      var handler = $rootScope.$on('RAINBOW_INTERNAL_READY', function () {\n        handler();\n        defered.resolve();\n      });\n    } else {\n      defered.resolve();\n    }\n\n    return defered.promise;\n  };\n\n  var intializeSecondStep = function intializeSecondStep() {\n    var defered = $q.defer();\n    DetectRTC.load(function () {\n      initialize_auto();\n      defered.resolve();\n    });\n    return defered.promise;\n  };\n\n  this.load = function load() {\n    $log.sdk('SDKSrv     | [initialize ] :: Rainbow SDK loaded!');\n    var sdkEvent = new CustomEvent(that.RAINBOW_ONLOADED);\n    document.dispatchEvent(sdkEvent);\n  };\n\n  this.ready = function ready() {\n    $log.sdk('SDKSrv     | [initialize ] :: Rainbow SDK ready!');\n    var sdkEvent = new CustomEvent(that.RAINBOW_ONREADY);\n    document.dispatchEvent(sdkEvent);\n  };\n\n  var initialize_auto = function initialize_auto() {\n    $log.sdk('SDKSrv     | [initialize ] :: Initializing the Rainbow SDK...');\n    $log.sdk('SDKSrv     | [initialize ] :: -----------------------------');\n    $log.sdk('SDKSrv     | [initialize ] :: Platform    | ' + DetectRTC.osName + ' ' + DetectRTC.osVersion);\n    $log.sdk('SDKSrv     | [initialize ] :: Screen      | ' + window.screen.width + 'x' + window.screen.height);\n    $log.sdk('SDKSrv     | [initialize ] :: Cookie      | ' + navigator.cookieEnabled);\n    $log.sdk('SDKSrv     | [initialize ] :: Java        | ' + navigator.javaEnabled());\n    $log.sdk('SDKSrv     | [initialize ] :: Server      | ' + config.webservices.server);\n    $log.sdk('SDKSrv     | [initialize ] :: Version WEB | ' + window.version);\n    $log.sdk('SDKSrv     | [initialize ] :: Version SDK | ' + window.sdkversion);\n    $log.sdk('SDKSrv     | [initialize ] :: Browser     | ' + DetectRTC.browser.name + ' ' + DetectRTC.browser.fullVersion);\n    $log.sdk('SDKSrv     | [initialize ] :: Microphone  | ' + DetectRTC.hasMicrophone);\n    $log.sdk('SDKSrv     | [initialize ] :: Camera      | ' + DetectRTC.hasWebcam);\n    $log.sdk('SDKSrv     | [initialize ] :: Speakers    | ' + DetectRTC.hasSpeakers);\n    $log.sdk('SDKSrv     | [initialize ] :: WebRTC      | ' + DetectRTC.isWebRTCSupported);\n    $log.sdk('SDKSrv     | [initialize ] :: Mode        | ' + that.mode());\n    $log.sdk('SDKSrv     | [initialize ] :: verboseLog  | ' + sdk.hasVerboseLog);\n    $log.sdk('SDKSrv     | [initialize ] :: ng-events   | ' + sdk.useAngularEvents);\n    $log.sdk('SDKSrv     | [initialize ] :: launcher    | ' + sdk.hasBeenLaunchedFromConfig);\n    $log.sdk('SDKSrv     | [initialize ] :: appID       | ' + sdk.key.appID);\n    $log.sdk('SDKSrv     | [initialize ] :: -----------------------------');\n    $log.sdk('SDKSrv     | [initialize ] :: Initialized!');\n    that.ready();\n  };\n\n  var start = function start() {\n    //Set the global Object\n    window.rainbowSDK = that; // Set the API mode\n\n    settingsService.setSetting('apiMode', 'sdk'); // Fix default server to use\n\n    config.webservices.currentServer = config.webservices.server;\n    that.isReady = true;\n    $rootScope.$broadcast('RAINBOW_INTERNAL_READY');\n  };\n\n  $log.sdk('SDKSrv     | [           ] :: Welcome to the Rainbow SDK for Web!');\n  start();\n  $rootScope.$on('$destroy', function () {\n    if (eventHandler) {\n      eventHandler();\n    }\n  });\n}]);\n\n//# sourceURL=webpack:///./src/sdkService.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\nvar chrome_shim_namespaceObject = {};\n__webpack_require__.r(chrome_shim_namespaceObject);\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimGetUserMedia\", function() { return shimGetUserMedia; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimGetDisplayMedia\", function() { return shimGetDisplayMedia; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimMediaStream\", function() { return shimMediaStream; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimOnTrack\", function() { return shimOnTrack; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimGetSendersWithDtmf\", function() { return shimGetSendersWithDtmf; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimSenderReceiverGetStats\", function() { return shimSenderReceiverGetStats; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimAddTrackRemoveTrackWithNative\", function() { return shimAddTrackRemoveTrackWithNative; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimAddTrackRemoveTrack\", function() { return shimAddTrackRemoveTrack; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"shimPeerConnection\", function() { return shimPeerConnection; });\n__webpack_require__.d(chrome_shim_namespaceObject, \"fixNegotiationNeeded\", function() { return fixNegotiationNeeded; });\nvar edge_shim_namespaceObject = {};\n__webpack_require__.r(edge_shim_namespaceObject);\n__webpack_require__.d(edge_shim_namespaceObject, \"shimGetUserMedia\", function() { return getusermedia_shimGetUserMedia; });\n__webpack_require__.d(edge_shim_namespaceObject, \"shimGetDisplayMedia\", function() { return getdisplaymedia_shimGetDisplayMedia; });\n__webpack_require__.d(edge_shim_namespaceObject, \"shimPeerConnection\", function() { return edge_shim_shimPeerConnection; });\n__webpack_require__.d(edge_shim_namespaceObject, \"shimReplaceTrack\", function() { return shimReplaceTrack; });\nvar firefox_shim_namespaceObject = {};\n__webpack_require__.r(firefox_shim_namespaceObject);\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimGetUserMedia\", function() { return firefox_getusermedia_shimGetUserMedia; });\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimGetDisplayMedia\", function() { return firefox_getdisplaymedia_shimGetDisplayMedia; });\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimOnTrack\", function() { return firefox_shim_shimOnTrack; });\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimPeerConnection\", function() { return firefox_shim_shimPeerConnection; });\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimSenderGetStats\", function() { return shimSenderGetStats; });\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimReceiverGetStats\", function() { return shimReceiverGetStats; });\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimRemoveStream\", function() { return shimRemoveStream; });\n__webpack_require__.d(firefox_shim_namespaceObject, \"shimRTCDataChannel\", function() { return shimRTCDataChannel; });\nvar safari_shim_namespaceObject = {};\n__webpack_require__.r(safari_shim_namespaceObject);\n__webpack_require__.d(safari_shim_namespaceObject, \"shimLocalStreamsAPI\", function() { return shimLocalStreamsAPI; });\n__webpack_require__.d(safari_shim_namespaceObject, \"shimRemoteStreamsAPI\", function() { return shimRemoteStreamsAPI; });\n__webpack_require__.d(safari_shim_namespaceObject, \"shimCallbacksAPI\", function() { return shimCallbacksAPI; });\n__webpack_require__.d(safari_shim_namespaceObject, \"shimGetUserMedia\", function() { return safari_shim_shimGetUserMedia; });\n__webpack_require__.d(safari_shim_namespaceObject, \"shimConstraints\", function() { return shimConstraints; });\n__webpack_require__.d(safari_shim_namespaceObject, \"shimRTCIceServerUrls\", function() { return shimRTCIceServerUrls; });\n__webpack_require__.d(safari_shim_namespaceObject, \"shimTrackEventTransceiver\", function() { return shimTrackEventTransceiver; });\n__webpack_require__.d(safari_shim_namespaceObject, \"shimCreateOfferLegacy\", function() { return shimCreateOfferLegacy; });\nvar common_shim_namespaceObject = {};\n__webpack_require__.r(common_shim_namespaceObject);\n__webpack_require__.d(common_shim_namespaceObject, \"shimRTCIceCandidate\", function() { return shimRTCIceCandidate; });\n__webpack_require__.d(common_shim_namespaceObject, \"shimMaxMessageSize\", function() { return shimMaxMessageSize; });\n__webpack_require__.d(common_shim_namespaceObject, \"shimSendThrowTypeError\", function() { return shimSendThrowTypeError; });\n__webpack_require__.d(common_shim_namespaceObject, \"shimConnectionState\", function() { return shimConnectionState; });\n__webpack_require__.d(common_shim_namespaceObject, \"removeAllowExtmapMixed\", function() { return removeAllowExtmapMixed; });\nvar adapter_core_namespaceObject = {};\n__webpack_require__.r(adapter_core_namespaceObject);\n__webpack_require__.d(adapter_core_namespaceObject, \"default\", function() { return adapter_core; });\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/utils.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = (e) => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        cb(modifiedEvent);\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    this._eventMap[cb] = wrappedCallback;\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[cb]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[cb];\n    delete this._eventMap[cb];\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return (bool) ? 'adapter.js logging disabled' :\n      'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\n\nfunction log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n      ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nfunction detectBrowser(window) {\n  const {navigator} = window;\n\n  // Returned result object.\n  const result = {browser: null, version: null};\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  if (navigator.mozGetUserMedia) { // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent,\n        /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent,\n        /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (navigator.mediaDevices &&\n      navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\n    result.browser = 'edge';\n    result.version = extractVersion(navigator.userAgent,\n        /Edge\\/(\\d+).(\\d+)$/, 2);\n  } else if (window.RTCPeerConnection &&\n      navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent,\n        /AppleWebKit\\/(\\d+)\\./, 1);\n  } else { // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nfunction compactObject(data) {\n  if (typeof data !== 'object') {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function(accumulator, key) {\n    const isObject = typeof data[key] === 'object';\n    const value = isObject ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObject && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n\n    return Object.assign(accumulator, {[key]: value});\n  }, {});\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nconst getusermedia_logging = log;\n\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  const browserDetails = detectBrowser(window);\n\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match =>\n              d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            getusermedia_logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    getusermedia_logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function(cs) {\n    return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n      if (c.audio && !stream.getAudioTracks().length ||\n          c.video && !stream.getVideoTracks().length) {\n        stream.getTracks().forEach(track => {\n          track.stop();\n        });\n        throw new DOMException('', 'NotFoundError');\n      }\n      return stream;\n    }, e => Promise.reject(shimError_(e))));\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\nfunction shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' +\n        'a function');\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function(constraints) {\n    return getSourceId(constraints)\n      .then(sourceId => {\n        const widthSpecified = constraints.video && constraints.video.width;\n        const heightSpecified = constraints.video && constraints.video.height;\n        const frameRateSpecified = constraints.video &&\n          constraints.video.frameRate;\n        constraints.video = {\n          mandatory: {\n            chromeMediaSource: 'desktop',\n            chromeMediaSourceId: sourceId,\n            maxFrameRate: frameRateSpecified || 3\n          }\n        };\n        if (widthSpecified) {\n          constraints.video.mandatory.maxWidth = widthSpecified;\n        }\n        if (heightSpecified) {\n          constraints.video.mandatory.maxHeight = heightSpecified;\n        }\n        return window.navigator.mediaDevices.getUserMedia(constraints);\n      });\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\n\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' &&\n        value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n\n\n\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = (e) => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers()\n                .find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {track: te.track};\n            }\n\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {receiver};\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers()\n                .find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {track};\n            }\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {receiver};\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n        if (sender) { // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nfunction shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n    wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams)\n      .map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\n\nfunction shimAddTrackRemoveTrack(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const browserDetails = detectBrowser(window);\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams = function() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n    delete this._reverseStreams[(this._streams[stream.id] ?\n        this._streams[stream.id].id : stream.id)];\n    delete this._streams[stream.id];\n  };\n\n  window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException(\n        'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n        'InvalidStateError');\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 ||\n        !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException(\n        'The adapter.js addTrack polyfill only supports a single ' +\n        ' stream which is associated with the specified track.',\n        'NotSupportedError');\n    }\n\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n    }\n\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track);\n\n      // Trigger ONN async.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find(s => s.track === track);\n  };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    window.RTCPeerConnection.prototype[method] = function() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    };\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription = function() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException(\n        'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n        'InvalidStateError');\n    }\n    // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.',\n          'InvalidAccessError');\n    }\n\n    // Search for the native stream the senders track belongs to.\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks()\n        .find(track => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\n\nfunction shimPeerConnection(window) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function(selector,\n      successCallback, errorCallback) {\n    const args = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof arguments[0] !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        args[1](makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        arguments[0]]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(successCallback, errorCallback);\n  };\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n      .forEach(function(method) {\n        const nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function() {\n          arguments[0] = new ((method === 'addIceCandidate') ?\n              window.RTCIceCandidate :\n              window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n\n  // support for addIceCandidate(null or undefined)\n  const nativeAddIceCandidate =\n      window.RTCPeerConnection.prototype.addIceCandidate;\n  window.RTCPeerConnection.prototype.addIceCandidate = function() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n}\n\nfunction fixNegotiationNeeded(window) {\n  wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (pc.signalingState !== 'stable') {\n      return;\n    }\n    return e;\n  });\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/edge/filtericeservers.js\n/*\n *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  let hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(server => {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n      }\n      const isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(url => {\n        // filter STUN unconditionally.\n        if (url.indexOf('stun:') === 0) {\n          return false;\n        }\n\n        const validTurn = url.startsWith('turn') &&\n            !url.startsWith('turn:[') &&\n            url.includes('transport=udp');\n        if (validTurn && !hasTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return validTurn && !hasTurn;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// EXTERNAL MODULE: ./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js\nvar rtcpeerconnection = __webpack_require__(19);\nvar rtcpeerconnection_default = /*#__PURE__*/__webpack_require__.n(rtcpeerconnection);\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/edge/getusermedia.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nfunction getusermedia_shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  const shimError_ = function(e) {\n    return {\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString() {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function(c) {\n    return origGetUserMedia(c).catch(e => Promise.reject(shimError_(e)));\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/edge/getdisplaymedia.js\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nfunction getdisplaymedia_shimGetDisplayMedia(window) {\n  if (!('getDisplayMedia' in window.navigator)) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    window.navigator.getDisplayMedia.bind(window.navigator.mediaDevices);\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/edge/edge_shim.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\n\n\n\n\nfunction edge_shim_shimPeerConnection(window) {\n  const browserDetails = detectBrowser(window);\n\n  if (window.RTCIceGatherer) {\n    if (!window.RTCIceCandidate) {\n      window.RTCIceCandidate = function(args) {\n        return args;\n      };\n    }\n    if (!window.RTCSessionDescription) {\n      window.RTCSessionDescription = function(args) {\n        return args;\n      };\n    }\n    // this adds an additional event listener to MediaStrackTrack that signals\n    // when a tracks enabled property was changed. Workaround for a bug in\n    // addStream, see below. No longer required in 15025+\n    if (browserDetails.version < 15025) {\n      const origMSTEnabled = Object.getOwnPropertyDescriptor(\n          window.MediaStreamTrack.prototype, 'enabled');\n      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n        set(value) {\n          origMSTEnabled.set.call(this, value);\n          const ev = new Event('enabled');\n          ev.enabled = value;\n          this.dispatchEvent(ev);\n        }\n      });\n    }\n  }\n\n  // ORTC defines the DTMF sender a bit different.\n  // https://github.com/w3c/ortc/issues/714\n  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = new window.RTCDtmfSender(this);\n          } else if (this.track.kind === 'video') {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n  // Edge currently only implements the RTCDtmfSender, not the\n  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*\n  if (window.RTCDtmfSender && !window.RTCDTMFSender) {\n    window.RTCDTMFSender = window.RTCDtmfSender;\n  }\n\n  const RTCPeerConnectionShim = rtcpeerconnection_default()(window,\n      browserDetails.version);\n  window.RTCPeerConnection = function(config) {\n    if (config && config.iceServers) {\n      config.iceServers = filterIceServers(config.iceServers,\n        browserDetails.version);\n      log('ICE servers after filtering:', config.iceServers);\n    }\n    return new RTCPeerConnectionShim(config);\n  };\n  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;\n}\n\nfunction shimReplaceTrack(window) {\n  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n  if (window.RTCRtpSender &&\n      !('replaceTrack' in window.RTCRtpSender.prototype)) {\n    window.RTCRtpSender.prototype.replaceTrack =\n        window.RTCRtpSender.prototype.setTrack;\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\nfunction firefox_getusermedia_shimGetUserMedia(window) {\n  const browserDetails = detectBrowser(window);\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    deprecated('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints =\n        MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nfunction firefox_getdisplaymedia_shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function(constraints) {\n    if (!(constraints && constraints.video)) {\n      const err = new DOMException('getDisplayMedia without video ' +\n          'constraints is undefined');\n      err.name = 'NotFoundError';\n      // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n      err.code = 8;\n      return Promise.reject(err);\n    }\n    if (constraints.video === true) {\n      constraints.video = {mediaSource: preferredMediaSource};\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n    return window.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\n\nfunction firefox_shim_shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      ('receiver' in window.RTCTrackEvent.prototype) &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nfunction firefox_shim_shimPeerConnection(window) {\n  const browserDetails = detectBrowser(window);\n\n  if (typeof window !== 'object' ||\n      !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n\n  // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n  ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n      .forEach(function(method) {\n        const nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function() {\n          arguments[0] = new ((method === 'addIceCandidate') ?\n              window.RTCIceCandidate :\n              window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n\n  // support for addIceCandidate(null or undefined)\n  const nativeAddIceCandidate =\n      window.RTCPeerConnection.prototype.addIceCandidate;\n  window.RTCPeerConnection.prototype.addIceCandidate = function() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function(\n    selector,\n    onSucc,\n    onErr\n  ) {\n    return nativeGetStats.apply(this, [selector || null])\n      .then(stats => {\n        if (browserDetails.version < 53 && !onSucc) {\n          // Shim only promise getStats with spec-hyphens in type names\n          // Leave callback version alone; misc old uses of forEach before Map\n          try {\n            stats.forEach(stat => {\n              stat.type = modernStatsTypes[stat.type] || stat.type;\n            });\n          } catch (e) {\n            if (e.name !== 'TypeError') {\n              throw e;\n            }\n            // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n            stats.forEach((stat, i) => {\n              stats.set(i, Object.assign({}, stat, {\n                type: modernStatsTypes[stat.type] || stat.type\n              }));\n            });\n          }\n        }\n        return stats;\n      })\n      .then(onSucc, onErr);\n  };\n}\n\nfunction shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function() {\n    return this.track ? this._pc.getStats(this.track) :\n        Promise.resolve(new Map());\n  };\n}\n\nfunction shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function() {\n    return this._pc.getStats(this.track);\n  };\n}\n\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection ||\n      'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream = function(stream) {\n    deprecated('removeStream', 'removeTrack');\n    this.getSenders().forEach(sender => {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        this.removeTrack(sender);\n      }\n    });\n  };\n}\n\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n\nfunction shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      return this._localStreams;\n    };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      stream.getTracks().forEach(track => _addTrack.call(this, track, stream));\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      if (stream) {\n        if (!this._localStreams) {\n          this._localStreams = [stream];\n        } else if (!this._localStreams.includes(stream)) {\n          this._localStreams.push(stream);\n        }\n      }\n      return _addTrack.call(this, track, stream);\n    };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      const index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n        return;\n      }\n      this._localStreams.splice(index, 1);\n      const tracks = stream.getTracks();\n      this.getSenders().forEach(sender => {\n        if (tracks.includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\n\nfunction shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams = function() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = (e) => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      const pc = this;\n      if (!this._onaddstreampoly) {\n        this.addEventListener('track', this._onaddstreampoly = function(e) {\n          e.streams.forEach(stream => {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            pc._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\n\nfunction shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const createOffer = prototype.createOffer;\n  const createAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n\n  prototype.createOffer = function(successCallback, failureCallback) {\n    const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n    const promise = createOffer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  prototype.createAnswer = function(successCallback, failureCallback) {\n    const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n    const promise = createAnswer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  let withCallback = function(description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n\n  withCallback = function(description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n\n  withCallback = function(candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\n\nfunction safari_shim_shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = (constraints) => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n\n  if (!navigator.getUserMedia && navigator.mediaDevices &&\n    navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints)\n      .then(cb, errcb);\n    }.bind(navigator);\n  }\n}\n\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({},\n      constraints,\n      {video: compactObject(constraints.video)}\n    );\n  }\n\n  return constraints;\n}\n\nfunction shimRTCIceServerUrls(window) {\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      const newIceServers = [];\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\n        let server = pcConfig.iceServers[i];\n        if (!server.hasOwnProperty('urls') &&\n            server.hasOwnProperty('url')) {\n          deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n      pcConfig.iceServers = newIceServers;\n    }\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in window.RTCPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\n\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      ('receiver' in window.RTCTrackEvent.prototype) &&\n      // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is\n      // defined for some reason even when window.RTCTransceiver is not.\n      !window.RTCTransceiver) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nfunction shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n      const audioTransceiver = this.getTransceivers().find(transceiver =>\n        transceiver.sender.track &&\n        transceiver.sender.track.kind === 'audio');\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === 'sendrecv') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('sendonly');\n          } else {\n            audioTransceiver.direction = 'sendonly';\n          }\n        } else if (audioTransceiver.direction === 'recvonly') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('inactive');\n          } else {\n            audioTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true &&\n          !audioTransceiver) {\n        this.addTransceiver('audio');\n      }\n\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n      const videoTransceiver = this.getTransceivers().find(transceiver =>\n        transceiver.sender.track &&\n        transceiver.sender.track.kind === 'video');\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === 'sendrecv') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('sendonly');\n          } else {\n            videoTransceiver.direction = 'sendonly';\n          }\n        } else if (videoTransceiver.direction === 'recvonly') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('inactive');\n          } else {\n            videoTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true &&\n          !videoTransceiver) {\n        this.addTransceiver('video');\n      }\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\n\n// EXTERNAL MODULE: ./node_modules/sdp/sdp.js\nvar sdp = __webpack_require__(8);\nvar sdp_default = /*#__PURE__*/__webpack_require__.n(sdp);\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/common_shim.js\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n      window.RTCIceCandidate.prototype)) {\n    return;\n  }\n\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate &&\n        args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substr(2);\n    }\n\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = sdp_default.a.parseCandidate(args.candidate);\n      const augmentedCandidate = Object.assign(nativeCandidate,\n          parsedCandidate);\n\n      // Add a serializer that does not serialize the extra attributes.\n      augmentedCandidate.toJSON = function() {\n        return {\n          candidate: augmentedCandidate.candidate,\n          sdpMid: augmentedCandidate.sdpMid,\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n          usernameFragment: augmentedCandidate.usernameFragment,\n        };\n      };\n      return augmentedCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\n\nfunction shimMaxMessageSize(window) {\n  if (window.RTCSctpTransport || !window.RTCPeerConnection) {\n    return;\n  }\n  const browserDetails = detectBrowser(window);\n\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n\n  const sctpInDescription = function(description) {\n    const sections = sdp_default.a.splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = sdp_default.a.parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application'\n          && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n\n  const getRemoteFirefoxVersion = function(description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n\n  const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize =\n          browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n\n  const getMaxMessageSize = function(description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox'\n         && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n\n    const match = sdp_default.a.matchPrefix(description.sdp,\n      'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substr(19), 10);\n    } else if (browserDetails.browser === 'firefox' &&\n                remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n\n  const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n    this._sctp = null;\n\n    if (sctpInDescription(arguments[0])) {\n      // Check if the remote is FF.\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n      // Get the maximum message size the local peer is capable of sending\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n      // Get the maximum message size of the remote peer.\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n      // Determine final maximum message size\n      let maxMessageSize;\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      }\n\n      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n      // attribute.\n      const sctp = {};\n      Object.defineProperty(sctp, 'maxMessageSize', {\n        get() {\n          return maxMessageSize;\n        }\n      });\n      this._sctp = sctp;\n    }\n\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\n\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection &&\n      'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' &&\n          pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' +\n          pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel =\n    window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel = function() {\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n  wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection ||\n      'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange',\n            this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange',\n            this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {\n    const origMethod = proto[method];\n    proto[method] = function() {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange',\n          this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\n\nfunction removeAllowExtmapMixed(window) {\n  /* remove a=extmap-allow-mixed for Chrome < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const browserDetails = detectBrowser(window);\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      desc.sdp = desc.sdp.split('\\n').filter((line) => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/adapter_factory.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n  // Browser shims.\n\n\n\n\n\n\n// Shimming starts here.\nfunction adapterFactory({window} = {}, options = {\n  shimChrome: true,\n  shimFirefox: true,\n  shimEdge: true,\n  shimSafari: true,\n}) {\n  // Utils.\n  const logging = log;\n  const browserDetails = detectBrowser(window);\n\n  const adapter = {\n    browserDetails,\n    commonShim: common_shim_namespaceObject,\n    extractVersion: extractVersion,\n    disableLog: disableLog,\n    disableWarnings: disableWarnings\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chrome_shim_namespaceObject || !shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chrome_shim_namespaceObject;\n\n      shimGetUserMedia(window);\n      shimMediaStream(window);\n      shimPeerConnection(window);\n      shimOnTrack(window);\n      shimAddTrackRemoveTrack(window);\n      shimGetSendersWithDtmf(window);\n      shimSenderReceiverGetStats(window);\n      fixNegotiationNeeded(window);\n\n      shimRTCIceCandidate(window);\n      shimConnectionState(window);\n      shimMaxMessageSize(window);\n      shimSendThrowTypeError(window);\n      removeAllowExtmapMixed(window);\n      break;\n    case 'firefox':\n      if (!firefox_shim_namespaceObject || !firefox_shim_shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefox_shim_namespaceObject;\n\n      firefox_getusermedia_shimGetUserMedia(window);\n      firefox_shim_shimPeerConnection(window);\n      firefox_shim_shimOnTrack(window);\n      shimRemoveStream(window);\n      shimSenderGetStats(window);\n      shimReceiverGetStats(window);\n      shimRTCDataChannel(window);\n\n      shimRTCIceCandidate(window);\n      shimConnectionState(window);\n      shimMaxMessageSize(window);\n      shimSendThrowTypeError(window);\n      break;\n    case 'edge':\n      if (!edge_shim_namespaceObject || !edge_shim_shimPeerConnection || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = edge_shim_namespaceObject;\n\n      getusermedia_shimGetUserMedia(window);\n      getdisplaymedia_shimGetDisplayMedia(window);\n      edge_shim_shimPeerConnection(window);\n      shimReplaceTrack(window);\n\n      // the edge shim implements the full RTCIceCandidate object.\n\n      shimMaxMessageSize(window);\n      shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safari_shim_namespaceObject || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safari_shim_namespaceObject;\n\n      shimRTCIceServerUrls(window);\n      shimCreateOfferLegacy(window);\n      shimCallbacksAPI(window);\n      shimLocalStreamsAPI(window);\n      shimRemoteStreamsAPI(window);\n      shimTrackEventTransceiver(window);\n      safari_shim_shimGetUserMedia(window);\n\n      shimRTCIceCandidate(window);\n      shimMaxMessageSize(window);\n      shimSendThrowTypeError(window);\n      removeAllowExtmapMixed(window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n}\n\n// CONCATENATED MODULE: ./node_modules/webrtc-adapter/src/js/adapter_core.js\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nconst adapter_core_adapter = adapterFactory({window});\n/* harmony default export */ var adapter_core = (adapter_core_adapter);\n\n// CONCATENATED MODULE: ./src/connectionService.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Connection\n * @description\n *      This service connects the user to Rainbow and listen to the connection state change.<br/><br/>\n *      The main methods or events proposed in that service allow to: <br/>\n *      - Sign-in to Rainbow, <br/>\n *      - Sign-out from Rainbow, <br/>\n *      - Listen to the connection state change with Rainbow to discover if the platform is accessible or not, <br/>\n *      - Listen to the SDK for Web loading state change for handling when the SDK can be used<br/>\n *      <br/>\n *      Please find the table of error return codes for Sign-in {result.code} below <br/>\n *  \t- 1, Ok<br/>\n *  \t- -1, Error<br/>\n *  \t- -2, Unauthorized<br/>\n *  \t- -4, Error on event socket<br/>\n *  \t- -8, Id error on event socket<br/>\n *  \t- -16, Bad request<br/>\n *  \t- -32, Unsupported<br/>\n *  \t- -64, Not found<br/>\n * @fires RAINBOW_ONCONNECTIONSTATECHANGED\n * @fires RAINBOW_ONSTARTED\n * @fires RAINBOW_ONSTOPPED\n * @fires RAINBOW_ONUSERTOKENRENEW\n * @fires RAINBOW_ONUSERTOKENRENEWFAILED\n * @fires RAINBOW_ONAPPTOKENRENEW\n * @fires RAINBOW_ONAPPTOKENRENEWFAILED\n */\nvar _$log = new WeakMap();\n\nvar _$rootScope = new WeakMap();\n\nvar _authService = new WeakMap();\n\nvar _xmppService = new WeakMap();\n\nvar _companyService = new WeakMap();\n\nvar _contactService = new WeakMap();\n\nvar _botService = new WeakMap();\n\nvar _fileServerService = new WeakMap();\n\nvar _fileStorageService = new WeakMap();\n\nvar _roomService = new WeakMap();\n\nvar _groupService = new WeakMap();\n\nvar _videoService = new WeakMap();\n\nvar _favoriteService = new WeakMap();\n\nvar _webrtcServiceEventHandler = new WeakMap();\n\nvar _telephonyService = new WeakMap();\n\nvar _conferenceService = new WeakMap();\n\nvar _pstnConferenceService = new WeakMap();\n\nvar _webConferenceService = new WeakMap();\n\nvar _conversationService = new WeakMap();\n\nvar _callLogService = new WeakMap();\n\nvar _platformService = new WeakMap();\n\nvar _invitationService = new WeakMap();\n\nvar _adminCompanyService = new WeakMap();\n\nvar _adminUserService = new WeakMap();\n\nvar _profileService = new WeakMap();\n\nvar _channelService = new WeakMap();\n\nvar _webrtcGatewayService = new WeakMap();\n\nvar _recordsService = new WeakMap();\n\nvar _SDK = new WeakMap();\n\nvar ConnectionService =\n/*#__PURE__*/\nfunction () {\n  _createClass(ConnectionService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'authService', 'xmppService', 'companyService', 'contactService', 'botService', 'fileServerService', 'fileStorageService', 'roomService', 'groupService', 'videoService', 'favoriteService', 'webrtcServiceEventHandler', 'telephonyService', 'conferenceService', 'pstnConferenceService', 'webConferenceService', 'conversationService', 'callLogService', 'platformService', 'invitationService', 'adminCompanyService', 'adminUserService', 'profileService', 'channelService', 'webrtcGatewayService', 'recordsService', 'SDK'];\n    }\n  }]);\n\n  function ConnectionService($log, $rootScope, authService, xmppService, companyService, contactService, botService, fileServerService, fileStorageService, roomService, groupService, videoService, favoriteService, webrtcServiceEventHandler, telephonyService, conferenceService, pstnConferenceService, webConferenceService, conversationService, callLogService, platformService, invitationService, adminCompanyService, adminUserService, profileService, channelService, webrtcGatewayService, recordsService, SDK) {\n    var _this = this;\n\n    _classCallCheck(this, ConnectionService);\n\n    this.logService = 'ConnectionService | ';\n    this.state = 'disconnected';\n    this.hostUsed = '';\n\n    _$log.set(this, $log);\n\n    _$rootScope.set(this, $rootScope);\n\n    _authService.set(this, authService);\n\n    _xmppService.set(this, xmppService);\n\n    _companyService.set(this, companyService);\n\n    _contactService.set(this, contactService);\n\n    _botService.set(this, botService);\n\n    _fileServerService.set(this, fileServerService);\n\n    _fileStorageService.set(this, fileStorageService);\n\n    _roomService.set(this, roomService);\n\n    _groupService.set(this, groupService);\n\n    _videoService.set(this, videoService);\n\n    _favoriteService.set(this, favoriteService);\n\n    _webrtcServiceEventHandler.set(this, webrtcServiceEventHandler);\n\n    _telephonyService.set(this, telephonyService);\n\n    _conferenceService.set(this, conferenceService);\n\n    _pstnConferenceService.set(this, pstnConferenceService);\n\n    _webConferenceService.set(this, webConferenceService);\n\n    _conversationService.set(this, conversationService);\n\n    _callLogService.set(this, callLogService);\n\n    _platformService.set(this, platformService);\n\n    _invitationService.set(this, invitationService);\n\n    _adminCompanyService.set(this, adminCompanyService);\n\n    _adminUserService.set(this, adminUserService);\n\n    _profileService.set(this, profileService);\n\n    _channelService.set(this, channelService);\n\n    _webrtcGatewayService.set(this, webrtcGatewayService);\n\n    _recordsService.set(this, recordsService);\n\n    _SDK.set(this, SDK);\n    /**\n     * This event is fired when the connection state to Rainbow has changed\n     * @event RAINBOW_ONCONNECTIONSTATECHANGED\n     * @param {String} status The new connection status\n     * @description\n     *      This event contains the current connection state. <br>\n     *      Can be one of the following values: RAINBOW_CONNECTIONINPROGRESS, RAINBOW_CONNECTIONCONNECTED or RAINBOW_CONNECTIONDISCONNECTED\n     */\n\n\n    this.RAINBOW_ONCONNECTIONSTATECHANGED = 'rainbowconnectionstatechanged';\n    /**\n     * @public\n     * @event RAINBOW_ONSTARTED\n     * @description\n     *      This event is fired when the SDK services have been started\n     */\n\n    this.RAINBOW_ONSTARTED = 'started';\n    /**\n     * @public\n     * @event RAINBOW_ONSIGNED\n     * @description\n     *      This event is fired when the authentication succeed (logged-in user information can be received)\n     */\n\n    this.RAINBOW_ONSIGNED = 'signed';\n    /**\n     * @public\n     * @event RAINBOW_ONSTOPPED\n     * @description\n     *      This event is fired when the SDK services have been stopped (no more usable)\n     */\n\n    this.RAINBOW_ONSTOPPED = 'stopped';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the connection state \"in progress\" (not yet connected)\n     */\n\n    this.RAINBOW_CONNECTIONINPROGRESS = 'inProgress';\n    /**\n     * @public\n     * @event RAINBOW_ONUSERTOKENRENEW\n     * @description\n     *      This event is fired when the user token was renewed (information: all went well)\n     */\n\n    this.RAINBOW_ONUSERTOKENRENEW = 'userTokenRenew';\n    /**\n     * @public\n     * @event RAINBOW_ONUSERTOKENRENEWFAILED\n     * @description\n     *      This event is fired when the user token reneval failed : up to you to retry to login or not (SDK Web won't do it)\n     */\n\n    this.RAINBOW_ONUSERTOKENRENEWFAILED = 'userTokenRenewFailed';\n    /**\n     * @public\n     * @event RAINBOW_ONAPPTOKENRENEW\n     * @description\n     *      This event is fired when the application token was renewed\n     */\n\n    this.RAINBOW_ONAPPTOKENRENEW = 'applicationTokenRenew';\n    /**\n     * @public\n     * @event RAINBOW_ONAPPTOKENRENEWFAILED\n     * @description\n     *      This event is fired when the application token reneval failed : up to you to retry to login or not (SDK Web won't do it)\n     */\n\n    this.RAINBOW_ONAPPTOKENRENEWFAILED = 'applicationTokenRenewFailed';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the connection state \"connected\"\n     */\n\n    this.RAINBOW_CONNECTIONCONNECTED = 'connected';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the connection state \"disconnected\"\n     */\n\n    this.RAINBOW_CONNECTIONDISCONNECTED = 'disconnected';\n    /**\n     * @private\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the name of the Rainbow Official host (i.e. 'openrainbow.com')\n     */\n\n    this.RAINBOW_OFFICIAL_HOST = 'openrainbow.com';\n    /**\n     * @private\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the name of the Rainbow Beta host (i.e. 'openrainbow.net')\n     */\n\n    this.RAINBOW_BETA_HOST = 'openrainbow.net';\n    /**\n     * @private\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the name of the Rainbow Dev host (i.e. 'openrainbow.org')\n     */\n\n    this.RAINBOW_DEV_HOST = 'openrainbow.org';\n    /**\n     * @private\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the name of the Rainbow Sandbox host used for developping with the SDK (i.e. 'openrainbow.com')\n     */\n\n    this.RAINBOW_SANDBOX_HOST = 'sandbox.openrainbow.com';\n    /**\n     * @private\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the name of the Rainbow CPaaS Preprod host used for developping with the SDK (i.e. 'openrainbow.com')\n     */\n\n    this.RAINBOW_CPAASPREPROD_HOST = 'cpaaspreprod.openrainbow.net';\n    /**\n     * @private\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the name of the Rainbow CN.COM host used for developping with the SDK (i.e. 'openrainbow.com')\n     */\n\n    this.RAINBOW_CHINA_HOST = 'openrainbow.cn.com';\n    /**\n     * @private\n     * @constant\n     * @type {string}\n     * @description\n     *      Public constant representing the name of the Sandbox CN.COM host used for developping with the SDK (i.e. 'openrainbow.cn.com')\n     */\n\n    this.RAINBOW_CHINASANDBOX_HOST = 'sandbox.openrainbow.cn.com';\n    /**\n     * @public\n     * @method signin\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow sandboxed environment from a Rainbow sandboxed user account that already exists<br/>\n     *    The Rainbow sandboxed environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strLogin Rainbow sandboxed user login\n     * @param {String} strPassword Rainbow sandboxed user password\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          If signin succeeded, it'll contain <br/>\n     *          - {result.label} = \"ok\",<br/>\n     *          - {result.account.userId} the user id, <br/>\n     *          - {result.account.companyId} as company id, <br/>\n     *          - {result.account.loginEmail} your login email, <br/>\n     *          - {result.account.roles} the user roles, a table of your roles like \"User\",\"Admin\", \"Guest\", ... <br/>\n     *          - {result.token} the token which may be saved to use it later with signinSandBoxWithToken(strToken) or signinOnRainbowOfficialWithToken(strToken)<br/>\n     *          In case of error, result will contain:<br/>\n     *          - {result.label} a label to try to explain the sign-in error,<br/>\n     *          - {result.code} see at top for existing values<br/>\n     */\n\n    this.signin = this.signin.bind(this);\n    /**\n     * @public\n     * @method signinOnRainbowOfficial\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow official environment from a Rainbow official user account that already exists<br/>\n     *    The Rainbow official environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strLogin Rainbow official user login\n     * @param {String} strPassword Rainbow official user password\n     * @return {Object} result If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowOfficial = this.signinOnRainbowOfficial.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowBeta\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow beta environment from a Rainbow beta user account that already exists<br/>\n     *    The Rainbow beta environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strLogin Rainbow beta user login\n     * @param {String} strPassword Rainbow beta user password\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowBeta = this.signinOnRainbowBeta.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowCPaasPreProd\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow CPaaS pre production environment from a Rainbow beta user account that already exists<br/>\n     *    The Rainbow beta environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strLogin Rainbow beta user login\n     * @param {String} strPassword Rainbow beta user password\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowCPaasPreProd = this.signinOnRainbowCPaasPreProd.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowDev\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow dev environment from a Rainbow dev user account that already exists<br/>\n     *    The Rainbow dev environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strLogin Rainbow dev user login\n     * @param {String} strPassword Rainbow dev user password\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowDev = this.signinOnRainbowDev.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowSandboxChina\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow Sandbox China from a Rainbow dev user account that already exists<br/>\n     *    The Rainbow sandboxed environment on cn.com will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strLogin Rainbow dev user login\n     * @param {String} strPassword Rainbow dev user password\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowSandboxChina = this.signinOnRainbowSandboxChina.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowHosted\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow hosted environment from a Rainbow hosted user account that already exists<br/>\n     *    The Rainbow hosted environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strLogin Rainbow hosted user login\n     * @param {String} strPassword Rainbow hosted user password\n     * @param {String} strHost Rainbow host to connect\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowHosted = this.signinOnRainbowHosted.bind(this);\n    /**\n     * @public\n     * @method signinSandBoxWithToken\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow sandboxed environment from a Rainbow sandboxed user account that already exists<br/>\n     *    The Rainbow sandboxed environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strToken Rainbow sandboxed user existing token\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinSandBoxWithToken = this.signinSandBoxWithToken.bind(this);\n    /**\n     * @public\n     * @method signinOnRainbowOfficialWithToken\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow official environment from a Rainbow official user account that already exists<br/>\n     *    The Rainbow official environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strToken Rainbow sandboxed user existing token\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowOfficialWithToken = this.signinOnRainbowOfficialWithToken.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowBetaWithToken\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow beta environment from a Rainbow beta user account that already exists<br/>\n     *    The Rainbow beta environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strToken Rainbow sandboxed user existing token\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowBetaWithToken = this.signinOnRainbowBetaWithToken.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowDevWithToken\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow dev environment from a Rainbow dev user account that already exists<br/>\n     *    The Rainbow dev environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strToken Rainbow sandboxed user existing token\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowDevWithToken = this.signinOnRainbowDevWithToken.bind(this);\n    /**\n     * @private\n     * @method signinOnRainbowHostedWithToken\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow hosted environment from a Rainbow hosted user account that already exists<br/>\n     *    The Rainbow hosted environment will be used to access the Rainbow Cloud Services\n     *    This method returns a promise\n     * @param {String} strToken Rainbow sandboxed user existing token\n     * @param {String} strHost Rainbow host to connect\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowHostedWithToken = this.signinOnRainbowHostedWithToken.bind(this);\n    /**\n     * @public\n     * @method signinOnRainbowWithOICD\n     * @instance\n     * @description\n     *    Allow to sign-in to Rainbow production environment by using OICD token that is to be exchanged against Rainbow Token\n     *    This method returns a promise\n     * @param {String} strToken OICD token generated by a third-party server\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinOnRainbowWithOICD = this.signinOnRainbowWithOICD.bind(this);\n    /**\n     * @private\n     * @method styleSignInWithRainbowButton\n     * @instance\n     * @description\n     *    Allows user to style the \"Sign in with Rainbow\" button automatically by calling this method\n     * @return {Boolean} If the method finds the corresponding elemement, it returns true after styling it. Otherwise, it returns false\n     */\n\n    this.styleSignInWithRainbowButton = this.styleSignInWithRainbowButton.bind(this);\n    /**\n     * @public\n     * @method signout\n     * @instance\n     * @description\n     *    Allow to sign-out from Rainbow<br/>\n     *    This method returns a promise\n     * @return {Object} If the promise is resolved, the object containing a success code or an object containing an error if the promise is rejected\n     */\n\n    this.signout = this.signout.bind(this);\n    /**\n     * @public\n     * @method updateUserPassword\n     * @since 1.45.0\n     * @instance\n     * @description\n     *    Change the password for the current connected user<br/>\n     *    If successful you will be disconnected from Rainbow and will have to sign in again.<br/>\n     *    All existing tokens with this user will also be revoked\n     * @param oldPassword [required] the user old password\n     * @param newPassword [required] the user new password\n     * @return {Object} A promise containing the result\n     */\n\n    this.updateUserPassword = this.updateUserPassword.bind(this);\n    /**\n     * @public\n     * @method getState\n     * @instance\n     * @description\n     *    Get the current connection state with the Rainbow Cloud Services\n     * @return {String} The connection state which can be: <br/>\n     *      - RAINBOW_CONNECTIONINPROGRESS, <br>\n     *      - RAINBOW_CONNECTIONCONNECTED, <br>\n     *      - RAINBOW_CONNECTIONDISCONNECTED\n     */\n\n    this.getState = this.getState.bind(this);\n    /**\n     * @public\n     * @method getToken\n     * @instance\n     * @description\n     *    Get the current token associated with the connection\n     * @return {String} The token\n     */\n\n    this.getToken = this.getToken.bind(this);\n    /**\n     * @public\n     * @method refreshToken\n     * @instance\n     * @description\n     *    Refresh the current token associated with the connection (maximum 7 times)\n     * @return {String} The token\n     */\n\n    this.refreshToken = this.refreshToken.bind(this);\n    /**\n     * @private\n     * @method signinToRainbow\n     * @instance\n     * @description\n     *    Private method to launch connection with either login/pass or token if given\n     *    Host should be set before this call.\n     * @param {String} strLogin Rainbow user login\n     * @param {String} strPassword Rainbow user password\n     * @param {String} strToken Rainbow user existing token\n     * @return {Object} If the promise is resolved, the object containing the user account information or an object containing an error if the promise is rejected<br/>\n     *          <br/>\n     *          See signin for {result} details\n     */\n\n    this.signinToRainbow = this.signinToRainbow.bind(this);\n    this.disconnectionHandler = this.disconnectionHandler.bind(this);\n    this.onConnectionStateChangeEvent = this.onConnectionStateChangeEvent.bind(this);\n    /* EVENT HANDLERS */\n\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONNECTION_STATE_CHANGE_EVENT', this.onConnectionStateChangeEvent));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_AUTH_TOKEN_RENEW', function () {\n      $(document).trigger(_this.RAINBOW_ONUSERTOKENRENEW), null;\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_AUTH_TOKEN_EXPIRE', function () {\n      $(document).trigger(_this.RAINBOW_ONUSERTOKENRENEWFAILED, null);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_AUTH_TOKEN_RENEW', function () {\n      $(document).trigger(_this.RAINBOW_ONAPPTOKENRENEW, null);\n    }));\n    $rootScope.$on($rootScope.$on('ON_AUTH_TOKEN_EXPIRE', function () {\n      $(document).trigger(_this.RAINBOW_ONAPPTOKENRENEWFAILED, null);\n    }));\n    window.addEventListener('beforeunload', function () {\n      $rootScope.$broadcast('ON_CONNECTION_STATE_CHANGE_EVENT', 'disconnected');\n      videoService.stop();\n      contactService.stop();\n      conversationService.stop();\n      groupService.stop();\n      telephonyService.stop();\n      fileServerService.stop();\n      fileStorageService.stop();\n      callLogService.stop();\n      xmppService.stop();\n      profileService.stop();\n      recordsService.stop();\n      channelService.stop();\n      webrtcGatewayService.stop();\n    });\n  }\n\n  _createClass(ConnectionService, [{\n    key: \"signin\",\n    value: function signin(strLogin, strPassword) {\n      this.hostUsed = this.RAINBOW_SANDBOX_HOST;\n      return this.signinToRainbow(strLogin, strPassword, null);\n    }\n  }, {\n    key: \"signinOnRainbowOfficial\",\n    value: function signinOnRainbowOfficial(strLogin, strPassword) {\n      this.hostUsed = this.RAINBOW_OFFICIAL_HOST;\n      return this.signinToRainbow(strLogin, strPassword, null);\n    }\n  }, {\n    key: \"signinOnRainbowBeta\",\n    value: function signinOnRainbowBeta(strLogin, strPassword) {\n      this.hostUsed = this.RAINBOW_BETA_HOST;\n      return this.signinToRainbow(strLogin, strPassword, null);\n    }\n  }, {\n    key: \"signinOnRainbowCPaasPreProd\",\n    value: function signinOnRainbowCPaasPreProd(strLogin, strPassword) {\n      this.hostUsed = this.RAINBOW_CPAASPREPROD_HOST;\n      return this.signinToRainbow(strLogin, strPassword, null);\n    }\n  }, {\n    key: \"signinOnRainbowDev\",\n    value: function signinOnRainbowDev(strLogin, strPassword) {\n      this.hostUsed = this.RAINBOW_DEV_HOST;\n      return this.signinToRainbow(strLogin, strPassword, null);\n    }\n  }, {\n    key: \"signinOnRainbowSandboxChina\",\n    value: function signinOnRainbowSandboxChina(strLogin, strPassword) {\n      this.hostUsed = this.RAINBOW_CHINASANDBOX_HOST;\n      return this.signinToRainbow(strLogin, strPassword, null);\n    }\n  }, {\n    key: \"signinOnRainbowHosted\",\n    value: function signinOnRainbowHosted(strLogin, strPassword, strHost) {\n      this.hostUsed = strHost;\n      return this.signinToRainbow(strLogin, strPassword, null);\n    }\n  }, {\n    key: \"signinSandBoxWithToken\",\n    value: function signinSandBoxWithToken(strToken) {\n      this.hostUsed = this.RAINBOW_SANDBOX_HOST;\n      return this.signinToRainbow(null, null, strToken);\n    }\n  }, {\n    key: \"signinOnRainbowOfficialWithToken\",\n    value: function signinOnRainbowOfficialWithToken(strToken) {\n      this.hostUsed = this.RAINBOW_OFFICIAL_HOST;\n      return this.signinToRainbow(null, null, strToken);\n    }\n  }, {\n    key: \"signinOnRainbowBetaWithToken\",\n    value: function signinOnRainbowBetaWithToken(strToken) {\n      this.hostUsed = this.RAINBOW_BETA_HOST;\n      return this.signinToRainbow(null, null, strToken);\n    }\n  }, {\n    key: \"signinOnRainbowDevWithToken\",\n    value: function signinOnRainbowDevWithToken(strToken) {\n      this.hostUsed = this.RAINBOW_DEV_HOST;\n      return this.signinToRainbow(null, null, strToken);\n    }\n  }, {\n    key: \"signinOnRainbowHostedWithToken\",\n    value: function signinOnRainbowHostedWithToken(strToken, strHost) {\n      this.hostUsed = strHost;\n      return this.signinToRainbow(null, null, strToken);\n    }\n  }, {\n    key: \"signinOnRainbowWithOICD\",\n    value: function signinOnRainbowWithOICD(strToken) {\n      var _this2 = this;\n\n      var $log = _$log.get(this);\n\n      var challenge = '';\n      var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n      var charactersLength = characters.length;\n\n      for (var i = 0; i < 30; i++) {\n        challenge += characters.charAt(Math.floor(Math.random() * charactersLength));\n      }\n\n      var url = \"https://openrainbow.com/api/rainbow/authentication/v1.0/oidc-client/jwt?id_token=\".concat(strToken, \"&challenge=\").concat(challenge);\n      return new Promise(function (resolve, reject) {\n        if (!strToken) {\n          $log.sdk(_this2.logService + '[signinOnRainbowWithOICD] :: Argument strToken is null or undefined');\n          return reject('Argument strToken is null or undefined');\n        } else {\n          var headersXrainbowAppAuth = window.btoa(unescape(encodeURIComponent(sdk.key.appID + ':' + window.SHA256(sdk.key.appSecret + challenge))));\n          headersXrainbowAppAuth = 'Basic ' + headersXrainbowAppAuth; //create Headers\n\n          var sdkHeaders = new Headers({\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'X-Rainbow-App-Auth': headersXrainbowAppAuth,\n            Accept: 'application/json'\n          });\n          fetch(url, {\n            method: 'get',\n            mode: 'cors',\n            headers: sdkHeaders\n          }).then(function (response) {\n            response.json().then(function (data) {\n              _this2.signinOnRainbowBetaWithToken(data.token).then(function (account) {\n                return resolve(account);\n              })[\"catch\"](function (err) {\n                return reject(err);\n              });\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"styleSignInWithRainbowButton\",\n    value: function styleSignInWithRainbowButton(color, size) {\n      var $log = _$log.get(this);\n\n      var el = document.querySelector('.SignInWithRainbow');\n\n      if (!el) {\n        $log.sdk(this.logService + '[styleSignInWithRainbowButton] :: Could not find a corresponding HTML element');\n        return false;\n      } else {\n        var width, height, backgroundSize, fontSize, backgroundColor, textColor;\n\n        if (!size) {\n          size = 'medium';\n        }\n\n        if (!color) {\n          color = 'blue';\n        }\n\n        if (color === 'blue') {\n          backgroundColor = '#1b85e0';\n          textColor = '#FFFFFF';\n        } else if (color === 'white') {\n          backgroundColor = '#FFFFFF';\n          textColor = '#1b85e0';\n        }\n\n        if (size === 'small') {\n          width = '200px';\n          height = '20px';\n          backgroundSize = '18px';\n          fontSize = '12px';\n        } else if (size === 'medium') {\n          width = '250px';\n          height = '30px';\n          backgroundSize = '26px';\n          fontSize = '16px';\n        } else if (size === 'large') {\n          width = '350px';\n          height = '40px';\n          backgroundSize = '34px';\n          fontSize = '22px';\n        }\n\n        el.style.backgroundColor = backgroundColor;\n        el.style.color = textColor;\n        el.style.width = width;\n        el.style.height = height;\n        el.style.fontSize = fontSize;\n        el.style.border = '0px';\n        el.style.borderRadius = '5px';\n        el.innerHTML = 'Sign in with Rainbow';\n        el.style.backgroundImage = \"url('https://hub.openrainbow.com/android-chrome-48x48.png')\";\n        el.style.backgroundPosition = 'left';\n        el.style.backgroundRepeat = 'no-repeat';\n        el.style.verticalAlign = 'middle';\n        el.style.backgroundSize = backgroundSize;\n        el.style.backgroundOrigin = 'content-box';\n        el.style.paddingLeft = '13px';\n        $log.sdk(this.logService + '[styleSignInWithRainbowButton] :: Styled a corresponding HTML element');\n        return true;\n      }\n    }\n  }, {\n    key: \"signout\",\n    value: function signout() {\n      var _this3 = this;\n\n      var $log = _$log.get(this);\n\n      var videoService = _videoService.get(this);\n\n      var webrtcServiceEventHandler = _webrtcServiceEventHandler.get(this);\n\n      var contactService = _contactService.get(this);\n\n      var botService = _botService.get(this);\n\n      var profileService = _profileService.get(this);\n\n      var conversationService = _conversationService.get(this);\n\n      var conferenceService = _conferenceService.get(this);\n\n      var webConferenceService = _webConferenceService.get(this);\n\n      var pstnConferenceService = _pstnConferenceService.get(this);\n\n      var callLogService = _callLogService.get(this);\n\n      var channelService = _channelService.get(this);\n\n      var telephonyService = _telephonyService.get(this);\n\n      var fileServerService = _fileServerService.get(this);\n\n      var fileStorageService = _fileStorageService.get(this);\n\n      var invitationService = _invitationService.get(this);\n\n      var groupService = _groupService.get(this);\n\n      var favoriteService = _favoriteService.get(this);\n\n      var roomService = _roomService.get(this);\n\n      var companyService = _companyService.get(this);\n\n      var adminCompanyService = _adminCompanyService.get(this);\n\n      var adminUserService = _adminUserService.get(this);\n\n      var webrtcGatewayService = _webrtcGatewayService.get(this);\n\n      var xmppService = _xmppService.get(this);\n\n      var recordsService = _recordsService.get(this);\n\n      var SDK = _SDK.get(this);\n\n      var result = {\n        code: SDK.OK,\n        label: 'OK'\n      };\n      $log.sdk(this.logService + '[signout] :: Trying to sign out');\n      return new Promise(function (resolve, reject) {\n        videoService.stop().then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Video service stopped');\n          return webrtcServiceEventHandler.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: WebRTCEventHandler service stopped');\n          return contactService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Contact service stopped');\n          return botService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Bot service stopped');\n          return profileService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Profile service stopped');\n          return conversationService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Conversation service stopped');\n          return conferenceService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Conference service stopped');\n          return webConferenceService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Web Conference service stopped');\n          return pstnConferenceService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: PTSN Conference service stopped');\n          return callLogService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: ChannelService service stopped');\n          return channelService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: CallLog service stopped');\n          return telephonyService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Telephony service stopped');\n          return fileServerService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: FileServer service stopped');\n          return fileStorageService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: FileStorage service stopped');\n          return invitationService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Invitation service stopped');\n          return groupService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Group service stopped');\n          return favoriteService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Favorite service stopped');\n          return roomService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Company service stopped');\n          return companyService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Admin Company service stopped');\n          return adminCompanyService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Admin User service stopped');\n          return adminUserService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Invitation service stopped');\n          return webrtcGatewayService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: webrtcGateway service stopped');\n          return xmppService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: Records service stopped');\n          return recordsService.stop();\n        }).then(function () {\n          $log.sdk(_this3.logService + '[signout] :: XMPP service stopped');\n          $log.sdk(_this3.logService + '[signout] :: Services Successfully unloaded!');\n          var sdkEvent = new CustomEvent(_this3.RAINBOW_ONSTOPPED);\n          document.dispatchEvent(sdkEvent);\n          return resolve(result);\n        })[\"catch\"](function (error) {\n          $log.sdk(_this3.logService + '[signout] :: An error occured during signout');\n          return reject(error);\n        });\n      });\n    }\n  }, {\n    key: \"updateUserPassword\",\n    value: function updateUserPassword(oldPassword, newPassword) {\n      var contactService = _contactService.get(this);\n\n      return contactService.updateUserPassword(oldPassword, newPassword, false);\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this.state;\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var authService = _authService.get(this);\n\n      return authService.token;\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken() {\n      var authService = _authService.get(this);\n\n      return authService.renewAuthToken(false);\n    }\n  }, {\n    key: \"signinToRainbow\",\n    value: function signinToRainbow(login, password, token) {\n      var _this4 = this;\n\n      var $log = _$log.get(this);\n\n      var $rootScope = _$rootScope.get(this);\n\n      var authService = _authService.get(this);\n\n      var videoService = _videoService.get(this);\n\n      var webrtcServiceEventHandler = _webrtcServiceEventHandler.get(this);\n\n      var contactService = _contactService.get(this);\n\n      var botService = _botService.get(this);\n\n      var profileService = _profileService.get(this);\n\n      var conversationService = _conversationService.get(this);\n\n      var conferenceService = _conferenceService.get(this);\n\n      var webConferenceService = _webConferenceService.get(this);\n\n      var pstnConferenceService = _pstnConferenceService.get(this);\n\n      var callLogService = _callLogService.get(this);\n\n      var channelService = _channelService.get(this);\n\n      var telephonyService = _telephonyService.get(this);\n\n      var fileServerService = _fileServerService.get(this);\n\n      var fileStorageService = _fileStorageService.get(this);\n\n      var invitationService = _invitationService.get(this);\n\n      var groupService = _groupService.get(this);\n\n      var favoriteService = _favoriteService.get(this);\n\n      var roomService = _roomService.get(this);\n\n      var companyService = _companyService.get(this);\n\n      var adminCompanyService = _adminCompanyService.get(this);\n\n      var adminUserService = _adminUserService.get(this);\n\n      var webrtcGatewayService = _webrtcGatewayService.get(this);\n\n      var xmppService = _xmppService.get(this);\n\n      var recordsService = _recordsService.get(this);\n\n      var platformService = _platformService.get(this);\n\n      var SDK = _SDK.get(this);\n\n      var withToken = false;\n      return new Promise(function (resolve, reject) {\n        if (!token) {\n          if (!login) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"Parameter 'login' is missing or empty\"\n            });\n          }\n\n          if (!password) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"Parameter 'password' is missing or empty\"\n            });\n          }\n        } else {\n          withToken = true;\n          login = null;\n          password = null;\n        }\n\n        $log.sdk(_this4.logService + '[signin] :: Rainbow host used ' + _this4.hostUsed);\n        if (withToken) $log.sdk(_this4.logService + '[signin] :: Trying to sign-in with given token');else $log.sdk(_this4.logService + '[signin] :: Tryng to sign-in');\n        var result = {\n          code: SDK.OK,\n          label: '',\n          account: null\n        }; // Remove previous credentials in sessionStore or localstorage if any\n\n        authService.removeCredentials();\n        authService.authenticateOnHost(login, password, _this4.hostUsed, {\n          appID: sdk.key.appID,\n          appSecret: sdk.key.appSecret\n        }, token).then(function () {\n          result.account = {};\n          result.label = 'ok';\n          result.account.userId = authService.userId;\n          result.account.companyId = authService.companyId;\n          result.account.loginEmail = authService.login;\n          result.account.roles = authService.userData.roles;\n          result.token = authService.token;\n          result.userData = authService.userData;\n          var stats = [];\n          $log.sdk(_this4.logService + '[signin] :: Successfully sign-in with  | ' + authService.jidIm);\n          var sdkEvent = new CustomEvent(_this4.RAINBOW_ONSIGNED, {\n            detail: result\n          });\n          document.dispatchEvent(sdkEvent); // Start token renewal\n\n          authService.startTokenSurvey();\n          $log.sdk(_this4.logService + '[signin] :: Start services...'); // Fix to catch the disconnection handler from the XMPP Service\n\n          xmppService.disconnectionHandler = _this4.disconnectionHandler;\n          xmppService.start(stats).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: XMPP service ready!');\n            return companyService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Company service ready!');\n            return adminCompanyService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Admin company service ready!');\n            return adminUserService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Admin user service ready!');\n            return contactService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Contact service ready!');\n            return profileService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Profile service ready!');\n            return invitationService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Invitation service ready!');\n            return fileServerService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: FileServer service ready!');\n            return fileStorageService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: FileStorage service ready!');\n            return roomService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Room service ready!');\n            return groupService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Group service ready!');\n            return favoriteService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Favorite service ready!');\n            return webrtcGatewayService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: WebrtcGateway service ready!');\n            return videoService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Video service ready!');\n            return webrtcServiceEventHandler.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: WebRTCEventHandler service ready!');\n            /*                    return calendarService.start(stats);\n            })\n            .then(function() {\n            $log.sdk(logService + \"[signin] :: Calendar service ready!\");*/\n\n            return telephonyService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Telephony service ready!');\n            return pstnConferenceService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: PSTN Conference service ready!');\n            return webConferenceService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Web Conference service ready!');\n            return conversationService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Conversation service ready!');\n            $log.sdk(_this4.logService + '[signin] :: Send initial presence');\n            contactService.sendPresenceFromConfiguration(); // return resolve();\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Initial presence sent !');\n            /*                    return usersService.start(stats);\n            })\n            .then(function() {\n            $log.sdk(logService + \"[signin] :: User service ready!\");*/\n\n            return callLogService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: CallLog service ready!');\n            return platformService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Platform service ready!');\n            /*                    return idleService.start(stats);\n            })\n            .then(function() {\n            $log.sdk(logService + \"[signin] :: Idle service ready!\");*/\n\n            return botService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Bot service ready!');\n            /*                    return ringingService.start(stats);\n            })\n            .then(function() {\n            $log.sdk(logService + \"[signin] :: Ringing service ready!\");*/\n\n            /*\t\t\t\t\t.then(function() { return companyInvitationService.start(perfStats); })\n            .then(function() { return companyRequestService.start(perfStats); })\n            .then(function() { return adminService.start(perfStats); })\n            .then(function() { return companyBpLinkInvitationService.start(perfStats); })\n            .then(function() { return companyBpLinkRequestService.start(perfStats); })\n            .then(function() { return extensionSharingService.start(perfStats); })\n            .then(function() { return updatingService.start(perfStats); })*/\n\n            return conferenceService.start(stats);\n          })\n          /*.then(function() { return massProvisioningService.start(perfStats); })\n          .then(function() { return meetingService.start(perfStats); })\n                   .then(function() { return windowService.start(perfStats); })*/\n          .then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Conference service ready!');\n            return recordsService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Records service ready!');\n            return channelService.start(stats);\n          }).then(function () {\n            $log.sdk(_this4.logService + '[signin] :: Channel service ready!');\n            /*.then(() => { return notifyService.start(perfStats); })\n            .then(() => { return emojiService.start(perfStats); })*/\n\n            $log.sdk(_this4.logService + '[signin] :: Services Successfully loaded!'); // XMPP service does not send 'connected' event anymore. Send it manually\n\n            $rootScope.$broadcast('ON_CONNECTION_STATE_CHANGE_EVENT', 'connected');\n            var sdkEvent_RAINBOW_ONSTARTED = new CustomEvent(_this4.RAINBOW_ONSTARTED, {\n              detail: result\n            });\n            document.dispatchEvent(sdkEvent_RAINBOW_ONSTARTED);\n            return resolve(result);\n          })[\"catch\"](function (__err) {\n            $log.sdk(_this4.logService + '[signin] :: Error during signin');\n            console.log('[SIGNIN ERROR]', __err);\n            result.code = SDK.ERRORXMPP;\n            result.label = 'errorXMPP';\n            result.account = null;\n            return reject(result);\n          });\n        })[\"catch\"](function () {\n          $log.sdk(_this4.logService + '[signin] :: Error during signin');\n          result.code = SDK.ERRORUNAUTHORIZED;\n          result.label = 'errorUnauthorized';\n          return reject(result);\n        });\n        /*}).catch(function(err) {\n            deferred.reject(err);\n        });*/\n      });\n    }\n  }, {\n    key: \"disconnectionHandler\",\n    value: function disconnectionHandler() {\n      var $log = _$log.get(this);\n\n      $log.sdk(this.logService + '[discHandler] :: Disconnected from the XMPP Rainbow Cloud Services');\n    }\n  }, {\n    key: \"onConnectionStateChangeEvent\",\n    value: function onConnectionStateChangeEvent(__event, status) {\n      var $log = _$log.get(this);\n\n      $log.sdk(this.logService + '[onChange] :: Connection state changed to ' + status);\n      this.state = status;\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCONNECTIONSTATECHANGED, {\n        detail: status\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }]);\n\n  return ConnectionService;\n}();\n// CONCATENATED MODULE: ./src/presenceService.js\nfunction presenceService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction presenceService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction presenceService_createClass(Constructor, protoProps, staticProps) { if (protoProps) presenceService_defineProperties(Constructor.prototype, protoProps); if (staticProps) presenceService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Presence\n * @description\n *      This service manages with your Rainbow presence and the presence of your contacts. The presence in Rainbow reflects your activity or the possibility or not to be joined in a conversation (using IM, an audio/video call or a PBX call).<br/><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Retrieve and set the presence of the connected user, <br/>\n *      - Retrieve the presence of the contacts, <br>\n *      - Listen to the contacts presence change <br>\n *\n * @fires RAINBOW_ONPRESENCECHANGED\n * @fires RAINBOW_ONCONTACTPRESENCECHANGED\n * @fires RAINBOW_ONRICHPRESENCECHANGED\n * @fires RAINBOW_ONCONTACTRICHPRESENCECHANGED\n */\nvar presenceService_$log = new WeakMap();\n\nvar presenceService_$rootScope = new WeakMap();\n\nvar presenceService_xmppService = new WeakMap();\n\nvar presenceService_contactService = new WeakMap();\n\nvar presenceService_SDK = new WeakMap();\n\nvar PresenceService =\n/*#__PURE__*/\nfunction () {\n  presenceService_createClass(PresenceService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'xmppService', 'contactService', 'SDK'];\n    }\n  }]);\n\n  function PresenceService($log, $rootScope, xmppService, contactService, SDK) {\n    var _this = this;\n\n    presenceService_classCallCheck(this, PresenceService);\n\n    presenceService_$log.set(this, $log);\n\n    presenceService_$rootScope.set(this, $rootScope);\n\n    presenceService_xmppService.set(this, xmppService);\n\n    presenceService_contactService.set(this, contactService);\n\n    presenceService_SDK.set(this, SDK);\n\n    this.logService = 'PresenceService | ';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Presence constant value for \"Online\" presence level\n     */\n\n    this.RAINBOW_PRESENCE_ONLINE = 'online';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Presence constant value for \"Away\" presence level\n     */\n\n    this.RAINBOW_PRESENCE_AWAY = 'away';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Presence constant value for \"Do not disturb\" presence level\n     */\n\n    this.RAINBOW_PRESENCE_DONOTDISTURB = 'dnd';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Presence constant value for \"Offline\" presence level\n     */\n\n    this.RAINBOW_PRESENCE_OFFLINE = 'xa';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Presence constant value for \"Busy\" presence level\n     */\n\n    this.RAINBOW_PRESENCE_BUSY = 'busy';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      Presence constant value for Unknown presence level\n     */\n\n    this.RAINBOW_PRESENCE_UNKNOW = 'unknow';\n    /**\n     * @public\n     * @event RAINBOW_ONCONTACTPRESENCECHANGED\n     * @param {Object} presence The presence object updated (jid, status, message, stamp)\n     * @description\n     *      This event is fired when the presence of a contact changes <b>on one of it's client (see jid)</b>\n     *      status may be <br/>\n     *          + \"unknow\",<br/>\n     *          + \"online\" (with message \"\" | \"mode=auto\"),<br/>\n     *          + \"away\" (with message \"\"),<br/>\n     *          + \"xa\" (with message \"\"| \"away\"),<br/>\n     *          + \"dnd\" (with message \"\" | \"audio\" | \"video\" | \"sharing\" | \"presentation\")<br/>\n     */\n\n    this.RAINBOW_ONCONTACTPRESENCECHANGED = 'rainbowcontactpresencechanged';\n    /**\n     * @public\n     * @event RAINBOW_ONPRESENCECHANGED\n     * @param {Object} presence The presence object updated (jid, status, message, stamp)\n     * @description\n     *      This event is fired when the presence of the connected user changes <br/>\n     *      status may be <br/>\n     *          + \"unknow\",<br/>\n     *          + \"online\" (with message \"\" | \"mode=auto\"),<br/>\n     *          + \"away\" (with message \"\" ),<br/>\n     *          + \"xa\" (with message \"\"| \"away\"),<br/>\n     *          + \"dnd\" (with message \"\" | \"audio\" | \"video\" | \"sharing\" | \"presentation\")<br/>\n     *      This event is also a confirmation from the server that the new presence value has been set\n     */\n\n    this.RAINBOW_ONPRESENCECHANGED = 'rainbowpresencechanged';\n    /**\n     * @public\n     * @event RAINBOW_ONCONTACTRICHPRESENCECHANGED\n     * @param {Contact} contact The contact object updated (with status, message and telStatus)\n     * @description\n     *      This event is fired when the <b>rich</b> presence of a contact changed</b>\n     *      In contact object, status may be <br/>\n     *          + \"busy\", (with message \"\" | \"phone\" | \"presentation\" | \"audio\" | \"video\" | \"sharing\"),<br/>\n     *          + \"offline\" (with message \"\"),<br/>\n     *          + \"away\" (with message \"\"),<br/>\n     *          + \"online\" (with message \"\"| \"mobile\" (PUSH)),<br/>\n     *          + \"offline\" (with message \"\")<br/>\n     */\n\n    this.RAINBOW_ONCONTACTRICHPRESENCECHANGED = 'rainbowcontactrichpresencechanged';\n    /**\n     * @public\n     * @event RAINBOW_ONRICHPRESENCECHANGED\n     * @param {Contact} contact The contact object updated (with status, message and telStatus)\n     * @description\n     *      This event is fired when the <b>rich</b> presence of the connected user changed<br/>\n     *      In contact object, status may be <br/>\n     *          + \"busy\", (with message \"\" | \"phone\" | \"presentation\" | \"audio\" | \"video\" | \"sharing\"),<br/>\n     *          + \"offline\" (with message \"\"),<br/>\n     *          + \"away\" (with message \"\"),<br/>\n     *          + \"online\" (with message \"\"| \"mobile\" (PUSH)),<br/>\n     *          + \"offline\" (with message \"\")<br/>\n     *      This event is also a confirmation from the server that the new presence value has been set\n     */\n\n    this.RAINBOW_ONRICHPRESENCECHANGED = 'rainbowrichpresencechanged';\n    /**\n     * @public\n     * @method setPresenceTo\n     * @instance\n     * @description\n     *    Allow to change the presence of the connected user manually <br/>\n     *    Only the following values are authorized: RAINBOW_PRESENCE_ONLINE, RAINBOW_PRESENCE_OFFLINE (invisible), RAINBOW_PRESENCE_DONOTDISTURB or RAINBOW_PRESENCE_AWAY\n     * @param {String} strPresenceState The presence value to set i.e: 'online', 'xa', or 'dnd'\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.setPresenceTo = this.setPresenceTo.bind(this);\n    $rootScope.$on('$destroy', $rootScope.$on('ON_ROSTER_PRESENCE_CHANGED_EVENT', function (event, json) {\n      return _this.onPresenceChangedEvent(event, json);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_UPDATE_CONTACT_RICH_STATUS_EVENT', function (event, contact) {\n      return _this.onRichPresenceChangedEvent(event, contact);\n    }));\n  }\n\n  presenceService_createClass(PresenceService, [{\n    key: \"setPresenceTo\",\n    value: function setPresenceTo(strPresenceState) {\n      var $log = presenceService_$log.get(this);\n\n      var SDK = presenceService_SDK.get(this);\n\n      var contactService = presenceService_contactService.get(this);\n\n      if (strPresenceState !== this.RAINBOW_PRESENCE_DONOTDISTURB && strPresenceState !== this.RAINBOW_PRESENCE_AWAY && strPresenceState !== this.RAINBOW_PRESENCE_OFFLINE && strPresenceState !== this.RAINBOW_PRESENCE_ONLINE) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strPresenceState' should be 'dnd', 'away', 'xa' (invisible) or 'online'\"\n        };\n      }\n\n      $log.sdk(this.logService + '[setPresenceTo] :: Set presence to ' + strPresenceState); // Call specific function in contactservice to manage call state\n\n      contactService.changeMyPresence(strPresenceState);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"onPresenceChangedEvent\",\n    value: function onPresenceChangedEvent(__event, json) {\n      var xmppService = presenceService_xmppService.get(this);\n\n      var $log = presenceService_$log.get(this);\n\n      var message = json.message || \"''\";\n\n      if (json.jid === xmppService.fullJid) {\n        $log.sdk(this.logService + '[onPresenceChangedEvent] :: Presence changed for me (' + json.jid + ') to  ' + json.status + ' | ' + message);\n        $(document).trigger(this.RAINBOW_ONPRESENCECHANGED, [json]);\n      } else {\n        $log.sdk(this.logService + '[onPresenceChangedEvent] :: Presence changed for contact (' + json.jid + ') to  ' + json.status + ' | ' + message);\n        $(document).trigger(this.RAINBOW_ONCONTACTPRESENCECHANGED, [json]);\n      }\n    }\n  }, {\n    key: \"onRichPresenceChangedEvent\",\n    value: function onRichPresenceChangedEvent(__event, contact) {\n      var xmppService = presenceService_xmppService.get(this);\n\n      var $log = presenceService_$log.get(this);\n\n      var message = contact.message || \"''\";\n      var telStatus = contact.telStatus || \"''\";\n\n      if (xmppService.fullJid.includes(contact.jid)) {\n        $log.sdk(this.logService + '[onPresenceChangedEvent] :: Rich Presence changed for myself to status ' + contact.status + ', message ' + message + ' and telStatus ' + telStatus);\n        $(document).trigger(this.RAINBOW_ONRICHPRESENCECHANGED, [contact]);\n      } else {\n        $log.sdk(this.logService + '[onPresenceChangedEvent] :: Rich Presence changed for contact (' + contact.jid + ') to status ' + contact.status + ', message ' + message + ' and telStatus ' + telStatus);\n        $(document).trigger(this.RAINBOW_ONCONTACTRICHPRESENCECHANGED, [contact]);\n      }\n    }\n  }]);\n\n  return PresenceService;\n}();\n// CONCATENATED MODULE: ./src/userProfileService.js\nfunction userProfileService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction userProfileService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction userProfileService_createClass(Constructor, protoProps, staticProps) { if (protoProps) userProfileService_defineProperties(Constructor.prototype, protoProps); if (staticProps) userProfileService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name UserProfile\n * @description\n *      This service manages with your Rainbow user profile and the presence of your contacts. <br/><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Updating the user firstname and lastname, <br/>\n *      - Updating the user phone number, <br>\n *      - Updating the user avatar (based on a file to send) <br>\n *\n */\nvar userProfileService_$log = new WeakMap();\n\nvar userProfileService_$rootScope = new WeakMap();\n\nvar userProfileService_contactService = new WeakMap();\n\nvar userProfileService_xmppService = new WeakMap();\n\nvar userProfileService_profileService = new WeakMap();\n\nvar userProfileService_adminUserService = new WeakMap();\n\nvar userProfileService_SDK = new WeakMap();\n\nvar UserProfileService =\n/*#__PURE__*/\nfunction () {\n  userProfileService_createClass(UserProfileService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'contactService', 'xmppService', 'profileService', 'adminUserService', 'SDK'];\n    }\n  }]);\n\n  function UserProfileService($log, $rootScope, contactService, xmppService, profileService, adminUserService, SDK) {\n    userProfileService_classCallCheck(this, UserProfileService);\n\n    userProfileService_$log.set(this, $log);\n\n    userProfileService_$rootScope.set(this, $rootScope);\n\n    userProfileService_contactService.set(this, contactService);\n\n    userProfileService_xmppService.set(this, xmppService);\n\n    userProfileService_profileService.set(this, profileService);\n\n    userProfileService_adminUserService.set(this, adminUserService);\n\n    userProfileService_SDK.set(this, SDK);\n\n    this.logService = 'UserProfileService | ';\n    /**\n     * @public\n     * @method getProfile\n     * @instance\n     * @description\n     *    Get user profile\n     *    Return a promise.\n     * @return {Object} a JSON Object {name: \"Name\", firstName: \"FirstName\", phoneNumbers : <list>} or an error object depending on the result\n     */\n\n    this.getProfile = this.getProfile.bind(this);\n    /**\n     * @public\n     * @method updateFirstName\n     * @instance\n     * @description\n     *    Change my firstname\n     *    Return a promise.\n     * @param {String} strFirstname The first name\n     * @return {Object} a JSON Object {name: \"Name\", firstName: \"FirstName\", phoneNumbers : <list>} or an error object depending on the result\n     */\n\n    this.updateFirstName = this.updateFirstName.bind(this);\n    /**\n     * @public\n     * @method updateLastName\n     * @instance\n     * @description\n     *    Change my last name\n     *    Return a promise.\n     * @param {String} strName The  name\n     * @return {Object} a JSON Object {name: \"Name\", firstName: \"FirstName\", phoneNumbers : <list>} or an error object depending on the result\n     */\n\n    this.updateLastName = this.updateLastName.bind(this);\n    /**\n     * @public\n     * @method updatePhoneNumber\n     * @instance\n     * @description\n     *    Change a Number.  You will have to give the number type and device type.\n     *    Return a promise.\n     * @param {String} type The number type.  One of the folowwing \"home\", \"work\", \"other\"\n     * @param {String} deviceType The number device type.  One of the folowwing \"landline\", \"mobile\", \"fax\", \"other\"\n     * @param {String} strPhoneNumber The number to change.  To delete it use an empty string\n     * @param {String} country [optional] The number's country in ISO 3166-1 alpha-3 format.  See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3\n     * @return {Object} a JSON Object {name: \"Name\", firstName: \"FirstName\", phoneNumbers : <list>} or an error object depending on the result\n     */\n\n    this.updatePhoneNumber = this.updatePhoneNumber.bind(this);\n    /**\n     * @public\n     * @method updatePhotoFromUrl\n     * @instance\n     * @description\n     *    Change my avatar/photo\n     *    Only jpg/jpeg and png images are accepted. Default max size is 4Mo (may be different for some organisations)\n     *    Note: for the moment images are cropped/resized to 512 x 512\n     *    Return a promise.\n     * @param {String} imgUrl The url to the photo\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.updatePhotoFromUrl = this.updatePhotoFromUrl.bind(this);\n  }\n\n  userProfileService_createClass(UserProfileService, [{\n    key: \"getProfile\",\n    value: function getProfile() {\n      var _this = this;\n\n      var $log = userProfileService_$log.get(this);\n\n      var profileService = userProfileService_profileService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        profileService.getUserData().then(function (userData) {\n          $log.sdk(_this.logService + '[getProfile] :: done');\n          var obj = {\n            name: userData.lastName,\n            firstName: userData.firstName,\n            phoneNumbers: userData.phoneNumbers\n          };\n          return resolve(obj);\n        })[\"catch\"](function (err) {\n          $log.sdk(_this.logService + '[getProfile] :: Error when trying to get Profile - ' + err);\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"updateFirstName\",\n    value: function updateFirstName(strFirstname) {\n      var _this2 = this;\n\n      var SDK = userProfileService_SDK.get(this);\n\n      var profileService = userProfileService_profileService.get(this);\n\n      var $log = userProfileService_$log.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strFirstname || typeof strFirstname !== 'string' || strFirstname.length < 1) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strFirstname' is missing, empty or null\"\n          });\n        } else {\n          var param = {\n            firstName: strFirstname\n          };\n          profileService.setUserData(param).then(function (result) {\n            $log.sdk(_this2.logService + '[updateFirstName] :: First name updated');\n            var obj = {\n              lastName: result.data.lastName,\n              firstName: result.data.firstName,\n              phoneNumbers: result.data.phoneNumbers\n            };\n            return resolve(obj);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this2.logService + '[updateFirstName] :: Error when updating first name - ' + err);\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateLastName\",\n    value: function updateLastName(strLastName) {\n      var _this3 = this;\n\n      var SDK = userProfileService_SDK.get(this);\n\n      var profileService = userProfileService_profileService.get(this);\n\n      var $log = userProfileService_$log.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strLastName || typeof strLastName !== 'string' || strLastName.length < 1) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strName' is missing, empty or null\"\n          });\n        } else {\n          var param = {\n            lastName: strLastName\n          };\n          profileService.setUserData(param).then(function (result) {\n            $log.sdk(_this3.logService + '[updateName] :: Name updated');\n            var obj = {\n              lastName: result.data.lastName,\n              firstName: result.data.firstName,\n              phoneNumbers: result.data.phoneNumbers\n            };\n            return resolve(obj);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this3.logService + '[updateName] :: Error when updating name - ' + err);\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updatePhoneNumber\",\n    value: function updatePhoneNumber(type, deviceType, strPhoneNumber, country) {\n      var _this4 = this;\n\n      var SDK = userProfileService_SDK.get(this);\n\n      var profileService = userProfileService_profileService.get(this);\n\n      var $log = userProfileService_$log.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!type || typeof type !== 'string' || ['home', 'work', 'other'].indexOf(type) < 0) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'type' is missing or not in 'home', 'work', 'other'\"\n          });\n        }\n\n        if (!deviceType || typeof deviceType !== 'string' || ['landline', 'mobile', 'fax', 'other'].indexOf(deviceType) < 0) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'deviceType' is missing or not in 'landline', 'mobile', 'fax', 'other'\"\n          });\n        } else if (!strPhoneNumber || typeof strPhoneNumber !== 'string') {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strPhoneNumber' is missing, empty or null\"\n          });\n        } else {\n          var param = {\n            phoneNumbers: [{\n              type: type,\n              deviceType: deviceType,\n              number: strPhoneNumber\n            }]\n          };\n\n          if (country && typeof country === 'string') {\n            param.country = country;\n          } // Check if user has already a number of type and deviceType\n          // If yes, change it\n\n\n          profileService.getUserData().then(function (userData) {\n            if (userData.phoneNumbers.length) {\n              var bFound = false;\n              bFound = userData.phoneNumbers.some(function (number) {\n                if (number.type === type && number.deviceType === deviceType) {\n                  // Update existing numbers\n                  number.number = strPhoneNumber;\n                  return true;\n                }\n\n                return false;\n              });\n\n              if (!bFound) {\n                // Add number to existing list\n                var newNumber = {\n                  type: type,\n                  deviceType: deviceType,\n                  number: strPhoneNumber\n                };\n                userData.phoneNumbers.push(newNumber);\n              }\n\n              return profileService.setUserData(userData);\n            } else {\n              // No number before, create it\n              return profileService.setUserData(param);\n            }\n          }).then(function (result) {\n            $log.sdk(_this4.logService + '[updatePhoneNumber] :: Phone number updated');\n            var obj = {\n              lastName: result.data.lastName,\n              firstName: result.data.firstName,\n              phoneNumbers: result.data.phoneNumbers\n            };\n            return resolve(obj);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this4.logService + '[updatePhoneNumber] :: Error when updating phone number - ' + err);\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updatePhotoFromUrl\",\n    value: function updatePhotoFromUrl(imgUrl) {\n      var _this5 = this;\n\n      var SDK = userProfileService_SDK.get(this);\n\n      var $log = userProfileService_$log.get(this);\n\n      var contactService = userProfileService_contactService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!imgUrl || typeof imgUrl !== 'string' || imgUrl.length < 1) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'imgUrl' is missing, empty or null\"\n          });\n        } else {\n          contactService.pushAvatarImage(imgUrl).then(function () {\n            $log.sdk(_this5.logService + '[updatePhotoFromUrl] :: Photo updated');\n            return resolve();\n          })[\"catch\"](function (err) {\n            $log.sdk(_this5.logService + '[updatePhotoFromUrl] :: Error when updating Photo: ' + err);\n            return reject(err);\n          });\n        }\n      });\n    }\n  }]);\n\n  return UserProfileService;\n}();\n// CONCATENATED MODULE: ./src/contactsService.js\nfunction contactsService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction contactsService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction contactsService_createClass(Constructor, protoProps, staticProps) { if (protoProps) contactsService_defineProperties(Constructor.prototype, protoProps); if (staticProps) contactsService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Contacts\n * @description\n *      This service gives access to the information of the connected user and to all of his contacts. <br/>\n *      In addition, this service manages the network of the connected user through invitations<br/><br/>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Retrieve the user connected information including his associated PBX phone if registered, <br/>\n *      - Retrieve the contacts information, <br/>\n *      - Search for contacts on the server, <br/>\n *      - Invite contacts, manage invitations, <br/>\n *      - Manage own contactlist (roster), <br/>\n *      - Listen to the contacts information changes to be able to update your application if needed, <br>\n *      - Listen to invitations coming from contacts <br/>\n * @fires RAINBOW_ONCONTACTINFORMATIONCHANGED\n * @fires RAINBOW_ONINFORMATIONCHANGED\n * @fires RAINBOW_ONCONTACTINVITATIONRECEIVED\n * @fires RAINBOW_ONCONTACTINVITATIONNUMBERCHANGED\n */\nvar contactsService_$log = new WeakMap();\n\nvar contactsService_$rootScope = new WeakMap();\n\nvar contactsService_contactService = new WeakMap();\n\nvar _directoryService = new WeakMap();\n\nvar contactsService_invitationService = new WeakMap();\n\nvar contactsService_SDK = new WeakMap();\n\nvar ContactsService =\n/*#__PURE__*/\nfunction () {\n  contactsService_createClass(ContactsService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'contactService', 'directoryService', 'invitationService', 'SDK'];\n    }\n  }]);\n\n  function ContactsService($log, $rootScope, contactService, directoryService, invitationService, SDK) {\n    var _this = this;\n\n    contactsService_classCallCheck(this, ContactsService);\n\n    this.logService = 'ContactService | ';\n\n    contactsService_$log.set(this, $log);\n\n    contactsService_$rootScope.set(this, $rootScope);\n\n    contactsService_contactService.set(this, contactService);\n\n    _directoryService.set(this, directoryService);\n\n    contactsService_invitationService.set(this, invitationService);\n\n    contactsService_SDK.set(this, SDK);\n    /**\n     * @public\n     * @event RAINBOW_ONCONTACTINFORMATIONCHANGED\n     * @param {Contact} contact The contact updated\n     * @description\n     *      This event is fired when the information of a contact in roster have changed\n     *      If roster is at \"false\", the contact was removed from your roster/contact list\n     */\n\n\n    this.RAINBOW_ONCONTACTINFORMATIONCHANGED = 'rainbowcontactinformationchanged';\n    /**\n     * @public\n     * @event RAINBOW_ONINFORMATIONCHANGED\n     * @param {Contact} contact The connected user information updated\n     * @description\n     *      This event is fired when the information of the connected user (yourself) have changed\n     */\n\n    this.RAINBOW_ONINFORMATIONCHANGED = 'rainbowinformationchanged';\n    /**\n     * @public\n     * @event RAINBOW_ONCONTACTINVITATIONNUMBERCHANGED\n     * @since 1.20\n     * @description\n     *      This event is fired when the number of existing invites changed\n     */\n\n    this.RAINBOW_ONCONTACTINVITATIONNUMBERCHANGED = 'rainbowsubscriptionnumberchanged';\n    /**\n     * @public\n     * @event RAINBOW_ONCONTACTINVITATIONRECEIVED\n     * @param {Invitation} invitation The invitation received\n     * @since 1.20\n     * @description\n     *      This event is fired each time an invite is received\n     */\n\n    this.RAINBOW_ONCONTACTINVITATIONRECEIVED = 'rainbowinvitationreceived';\n    /**\n     * @public\n     * @method getContactByJID\n     * @instance\n     * @description\n     *    Get a contact by his JID locally from the network or from opened conversations. <br>\n     *    If the contact is not found, you can call the searchByJID() method to try to find him on server side.\n     * @param {String} strJID The JID of the contact to get\n     * @return {Contact} Return a Contact object representing the contact information or null if no contact has been found\n     */\n\n    this.getContactByJID = this.getContactByJID.bind(this);\n    /**\n     * @public\n     * @method getContactById\n     * @since 1.26\n     * @instance\n     * @description\n     *    Get a contact by his ID locally from the network or from opened conversations. <br>\n     *    If the contact is not found, you can call the searchByID() method to try to find him on server side.\n     * @param {String} strId The Id of the contact to get\n     * @return {Contact} Return a Contact object representing the contact information or null if no contact has been found\n     */\n\n    this.getContactById = this.getContactById.bind(this);\n    /**\n     * @public\n     * @method getNetworkContacts\n     * @since 1.49\n     * @instance\n     * @description\n     *    Return the list of contacts that are in the network of the connected user\n     * @return {Contact[]} Return an array of Contact\n     */\n\n    this.getNetworkContacts = this.getNetworkContacts.bind(this);\n    /**\n     * @public\n     * @method getAll\n     * @instance\n     * @description\n     *    Return a list of users containing the contacts that are in the network and the recipients of opened conversations\n     * @return {Contact[]} Return an array of Contact object\n     */\n\n    this.getAll = this.getAll.bind(this);\n    /**\n     * @public\n     * @method getConnectedUser\n     * @instance\n     * @description\n     *    Get the connected user information\n     * @return {Contact} Return a Contact object representing the connected user information or null if not connected\n     */\n\n    this.getConnectedUser = this.getConnectedUser.bind(this);\n    /**\n     * @public\n     * @method getConnectedUserPhone\n     * @instance\n     * @description\n     *    Get the connected user phone information or null if not exists\n     */\n\n    this.getConnectedUserPhone = this.getConnectedUserPhone.bind(this);\n    /**\n     * @public\n     * @method searchByName\n     * @since 1.17\n     * @instance\n     * @description\n     *    Search for a contact by name or firstname on the server. <br>\n     *    Depending the privacy rules, you can receive more or less information for each contact. <br>\n     *    Please refer to [HUB privacy](https://hub.openrainbow.com/#/documentation/doc/hub/users-visibility-and-privacy \"HUB privacy page\") <br>\n     *    Return a Promise.\n     * @param {string} strName  The beginning of the name or the first name to search\n     * @param {Number} [limit=20] optional, allow to specify the maximum number of contacts to retrieve. 20 by default. A maximum of 1000 results can be retrieved.\n     * @return {Promise[]} Returns a promise with an array of contacts found or an empty array if no contact has been found\n     */\n\n    this.searchByName = this.searchByName.bind(this);\n    /**\n     * @public\n     * @method searchByLogin\n     * @since 1.18\n     * @instance\n     * @description\n     *    Search a contact by his login on the server. <br>\n     *    Depending the privacy rules, you can receive more or less information for each contact. <br>\n     *    Please refer to [HUB privacy](https://hub.openrainbow.com/#/documentation/doc/hub/users-visibility-and-privacy \"HUB privacy page\") <br>\n     *    Return a Promise\n     * @param {string} strLogin  The login to search for\n     * @return {Promise} Return a promise with a contact if found or an object describing the error\n     */\n\n    this.searchByLogin = this.searchByLogin.bind(this);\n    /**\n     * @public\n     * @method searchByJid\n     * @since 1.25\n     * @instance\n     * @description\n     *    Search a contact by his jid on the server. <br>\n     *    Depending the privacy rules, you can receive more or less information for each contact. <br>\n     *    Please refer to [HUB privacy](https://hub.openrainbow.com/#/documentation/doc/hub/users-visibility-and-privacy \"HUB privacy page\") <br>\n     *    Return a Promise\n     * @param {string} strJid  The jid to search for\n     * @return {Promise} Return a promise with a contact if found or an object describing the error\n     */\n\n    this.searchByJid = this.searchByJid.bind(this);\n    /**\n     * @public\n     * @method searchById\n     * @since 1.26\n     * @instance\n     * @description\n     *    Search a contact by his Id (DBId) on the server. <br>\n     *    Depending the privacy rules, you can receive more or less information for each contact. <br>\n     *    Please refer to [HUB privacy](https://hub.openrainbow.com/#/documentation/doc/hub/users-visibility-and-privacy \"HUB privacy page\") <br>\n     *    Return a Promise\n     * @param {string} strId  The id to search for\n     * @return {Promise} Return a promise with a contact if found or an object describing the error\n     */\n\n    this.searchById = this.searchById.bind(this);\n    /**\n     * @public\n     * @method acceptInvitation\n     * @since 1.17\n     * @instance\n     * @description\n     *    Accept a an invitation from an other Rainbow user to mutually join the network <br>\n     *    Once accepted, the user will be part of your network. <br>\n     *    Return a promise\n     * @param {Invitation} invitation The invitation to accept\n     * @return {Object} A promise that contains SDK.OK if success or an object that describes the error\n     */\n\n    this.acceptInvitation = this.acceptInvitation.bind(this);\n    /**\n     * @public\n     * @method declineInvitation\n     * @since 1.17\n     * @instance\n     * @description\n     *    Decline an invitation from an other Rainbow user to mutually join the network <br>\n     *    Once declined, the user will not be part of your network. <br>\n     *    Return a promise\n     * @param {Invitation} invitation The invitation to decline\n     * @return {Object} A promise that contains SDK.OK in case of success or an object that describes the error\n     */\n\n    this.declineInvitation = this.declineInvitation.bind(this);\n    /**\n     * @public\n     * @method addToNetwork\n     * @since 1.17\n     * @instance\n     * @description\n     *    Send an invitation to a Rainbow user for joining his network. <br>\n     *    The user will receive an invitation that can be accepted or declined <br>\n     *    In return, when accepted, he will be part of your network <br>\n     *    When in the same company, invitation is automatically accepted (ie: can't be declined)\n     * @param {Contact} contact The contact object to subscribe\n     * @return {Object} A promise that contains the contact added or an object describing an error\n     */\n\n    this.addToNetwork = this.addToNetwork.bind(this);\n    /**\n     * @private\n     * @method sendInvitationByEmail\n     * @since 1.43\n     * @instance\n     * @description\n     *    Send an invitation email as UCaaS\n     * @param {string} email The email\n     * @param {string} [customMessage] The email text (optional)\n     * @return {Object} A promise that contains the contact added or an object describing an error\n     */\n\n    this.sendInvitationByEmail = this.sendInvitationByEmail.bind(this);\n    /**\n     * @public\n     * @method removeFromNetwork\n     * @since 1.17\n     * @instance\n     * @description\n     *    Remove a contact from the list of contacts and unsubscribe to the contact's presence\n     * @param {Contact} contact The contact object to subscribe\n     * @return {Object} A promise that contains nothing if removed or an object describing an error\n     */\n\n    this.removeFromNetwork = this.removeFromNetwork.bind(this);\n    /**\n     * @public\n     * @method getInvitationById\n     * @since 1.20\n     * @instance\n     * @description\n     *    Get an invite by its id\n     * @param {String} strInvitationId the id of the invite to retrieve\n     * @return {Invitation} The invite if found\n     */\n\n    this.getInvitationById = this.getInvitationById.bind(this);\n    /**\n     * @public\n     * @method getInvitationsReceived\n     * @since 1.20\n     * @instance\n     * @description\n     *    Get the invite received coming from Rainbow users\n     * @return {Invitation[]} The list of invitations received\n     */\n\n    this.getInvitationsReceived = this.getInvitationsReceived.bind(this);\n    /**\n     * @public\n     * @method cancelInvitation\n     * @since 1.49\n     * @instance\n     * @param {Invitation} invitation The invitation to cancel\n     * @description\n     *    Cancel an invitation sent\n     * @return {Object} The SDK Ok object or an error\n     */\n\n    this.cancelInvitation = this.cancelInvitation.bind(this);\n    /**\n     * @public\n     * @method getInvitationsSent\n     * @since 1.20\n     * @instance\n     * @description\n     *    Get the invites sent to others Rainbow users\n     * @return {Invitation[]} The list of invite sent\n     */\n\n    this.getInvitationsSent = this.getInvitationsSent.bind(this);\n    /* EVENT HANDLERS */\n\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONTACT_UPDATED_EVENT', function (event, contact) {\n      return _this.onContactInformationUpdated(event, contact);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_USER_CONTACT_UPDATED_EVENT', function (event, contact) {\n      return _this.onInformationUpdated(event, contact);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_INVITATIONS_NUMBER_UPDATED', function () {\n      return _this.onInvitationNumberChanged();\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_INVITATION_CHANGED', function (event, contact) {\n      return _this.onInvitationReceived(event, contact);\n    }));\n  }\n\n  contactsService_createClass(ContactsService, [{\n    key: \"onContactInformationUpdated\",\n    value: function onContactInformationUpdated(__event, contact) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCONTACTINFORMATIONCHANGED, {\n        detail: contact\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onInformationUpdated\",\n    value: function onInformationUpdated(__event, contact) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONINFORMATIONCHANGED, {\n        detail: contact\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onInvitationNumberChanged\",\n    value: function onInvitationNumberChanged() {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCONTACTINVITATIONNUMBERCHANGED);\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onInvitationReceived\",\n    value: function onInvitationReceived(__event, invitation) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCONTACTINVITATIONRECEIVED, {\n        detail: invitation\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n    /* SERVICE METHODS */\n\n  }, {\n    key: \"getContactByJID\",\n    value: function getContactByJID(strJID) {\n      var contactService = contactsService_contactService.get(this);\n\n      var SDK = contactsService_SDK.get(this);\n\n      if (!strJID) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strJID' is missing or empty\"\n        };\n      }\n\n      return contactService.getContactByJid(strJID);\n    }\n  }, {\n    key: \"getContactById\",\n    value: function getContactById(strId) {\n      var contactService = contactsService_contactService.get(this);\n\n      var SDK = contactsService_SDK.get(this);\n\n      if (!strId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strId' is missing or empty\"\n        };\n      }\n\n      return contactService.getContactById(strId);\n    }\n  }, {\n    key: \"getNetworkContacts\",\n    value: function getNetworkContacts() {\n      var contactService = contactsService_contactService.get(this);\n\n      return contactService.getContacts().filter(function (contact) {\n        return contact.id !== contactService.userContact.id && !contact.isBot && contact.roster;\n      });\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var contactService = contactsService_contactService.get(this);\n\n      return contactService.getContacts().filter(function (contact) {\n        return contact.id !== contactService.userContact.id && !contact.isBot;\n      });\n    }\n  }, {\n    key: \"getConnectedUser\",\n    value: function getConnectedUser() {\n      var contactService = contactsService_contactService.get(this);\n\n      return contactService.userContact || null;\n    }\n  }, {\n    key: \"getConnectedUserPhone\",\n    value: function getConnectedUserPhone() {\n      var contactService = contactsService_contactService.get(this);\n\n      if (!contactService.userContact) {\n        return null;\n      }\n\n      if (contactService.userContact.pbxId.length === 0) {\n        return null;\n      }\n\n      return {\n        phoneNumber: contactService.userContact.phonePbx,\n        pbxId: contactService.userContact.pbxId\n      };\n    }\n  }, {\n    key: \"searchByName\",\n    value: function searchByName(strName, limit) {\n      var SDK = contactsService_SDK.get(this);\n\n      var directoryService = _directoryService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strName) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strName' is missing or empty\"\n          });\n        } else {\n          if (!limit) {\n            limit = 20;\n          }\n\n          directoryService.search(strName, true, Math.min(limit, 1000)).then(function (contacts) {\n            return resolve(contacts);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"searchByLogin\",\n    value: function searchByLogin(strLogin) {\n      var SDK = contactsService_SDK.get(this);\n\n      var directoryService = _directoryService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strLogin) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strLogin' is missing or empty\"\n          });\n        } else {\n          directoryService.searchUserByLogin(strLogin).then(function (contact) {\n            return resolve(contact);\n          })[\"catch\"](function (err) {\n            if (err.status === 404 || err.status === 400) {\n              return resolve(null);\n            } else {\n              return reject(err);\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"searchByJid\",\n    value: function searchByJid(strJid) {\n      var SDK = contactsService_SDK.get(this);\n\n      var directoryService = _directoryService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strJid) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strJid' is missing or empty\"\n          });\n        } else {\n          directoryService.searchUserByJid(strJid).then(function (contact) {\n            return resolve(contact);\n          })[\"catch\"](function (err) {\n            if (err.status === 404 || err.status === 400) {\n              return resolve(null);\n            } else {\n              return reject(err);\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"searchById\",\n    value: function searchById(strId) {\n      var SDK = contactsService_SDK.get(this);\n\n      var contactService = contactsService_contactService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strId) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strId' is missing or empty\"\n          });\n        } else {\n          contactService.getContactByDBId(strId, true).then(function (contact) {\n            return resolve(contact);\n          })[\"catch\"](function (err) {\n            if (err.status === 404 || err.status === 400) {\n              return resolve(null);\n            } else {\n              return reject(err);\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"acceptInvitation\",\n    value: function acceptInvitation(invitation) {\n      var SDK = contactsService_SDK.get(this);\n\n      var invitationService = contactsService_invitationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!invitation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'invitation' is missing or null\"\n          });\n        } else {\n          invitationService.acceptInvitation(invitation).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"declineInvitation\",\n    value: function declineInvitation(invitation) {\n      var SDK = contactsService_SDK.get(this);\n\n      var invitationService = contactsService_invitationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!invitation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'invitation' is missing or null\"\n          });\n        } else {\n          invitationService.declineInvitation(invitation).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"addToNetwork\",\n    value: function addToNetwork(contact) {\n      var SDK = contactsService_SDK.get(this);\n\n      var invitationService = contactsService_invitationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return {\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          };\n        } else {\n          invitationService.joinContactInvitation(contact).then(function () {\n            return resolve(contact);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"sendInvitationByEmail\",\n    value: function sendInvitationByEmail(email, customMessage) {\n      var SDK = contactsService_SDK.get(this);\n\n      var invitationService = contactsService_invitationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!email) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'email' is missing or null\"\n          });\n        } else {\n          invitationService.sendInvitationByEmail(email, customMessage).then(function (contact) {\n            return resolve(contact);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"removeFromNetwork\",\n    value: function removeFromNetwork(contact) {\n      var SDK = contactsService_SDK.get(this);\n\n      var contactService = contactsService_contactService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        }\n\n        contactService.removeContact(contact).then(function () {\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        })[\"catch\"](function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"getInvitationById\",\n    value: function getInvitationById(strInvitationId) {\n      var invitationService = contactsService_invitationService.get(this);\n\n      var SDK = contactsService_SDK.get(this);\n\n      if (!strInvitationId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strInvitationId' is missing or null\"\n        };\n      }\n\n      return invitationService.getInvitation(strInvitationId);\n    }\n  }, {\n    key: \"getInvitationsReceived\",\n    value: function getInvitationsReceived() {\n      var invitationService = contactsService_invitationService.get(this);\n\n      return invitationService.getReceivedInvitations();\n    }\n  }, {\n    key: \"cancelInvitation\",\n    value: function cancelInvitation(invitation) {\n      var invitationService = contactsService_invitationService.get(this);\n\n      var SDK = contactsService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!invitation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'invitation' is missing or null\"\n          });\n        } else {\n          invitationService.cancelOneSendInvitation(invitation).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getInvitationsSent\",\n    value: function getInvitationsSent() {\n      var invitationService = contactsService_invitationService.get(this);\n\n      return invitationService.getSentInvitations();\n    }\n  }]);\n\n  return ContactsService;\n}();\n// CONCATENATED MODULE: ./src/pbxService.js\nfunction pbxService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction pbxService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction pbxService_createClass(Constructor, protoProps, staticProps) { if (protoProps) pbxService_defineProperties(Constructor.prototype, protoProps); if (staticProps) pbxService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Telephony\n * @description\n *      This services manages PBX phone calls in a conversation. so it manages PBX calls between your PABX associated phone and a recipient's phone. If you don't have this service activated for your Rainbow user, all these methods will return an error when called. <br/><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Know if this service is activated or not for the connected user, <br/>\n *      - Know the version of the agent (deployed on the PBX) that monitors your line, <br>\n *      - Handle the basic telephony services: Make a call, take a call, hold a call, retrieve a call and release a call,<br/>\n *      - Listen to the call state change <br><br>\n *      Depending the agent version deployed, some services can return an error (unavailable service) when called\n * @fires RAINBOW_ONTELEPHONYSTARTED\n * @fires RAINBOW_ONTELEPHONYSTOPPED\n * @fires RAINBOW_ONTELEPHONYCALLSTATECHANGED\n * @fires RAINBOW_ONTELEPHONYFORWARDSTATECHANGED\n * @fires RAINBOW_ONCALLNOMADICEVENT\n */\nvar pbxService_$log = new WeakMap();\n\nvar pbxService_$rootScope = new WeakMap();\n\nvar pbxService_telephonyService = new WeakMap();\n\nvar pbxService_webrtcGatewayService = new WeakMap();\n\nvar _Call = new WeakMap();\n\nvar pbxService_SDK = new WeakMap();\n\nvar PbxService =\n/*#__PURE__*/\nfunction () {\n  pbxService_createClass(PbxService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'telephonyService', 'webrtcGatewayService', 'Call', 'SDK'];\n    }\n  }]);\n\n  function PbxService($log, $rootScope, telephonyService, webrtcGatewayService, Call, SDK) {\n    var _this = this;\n\n    pbxService_classCallCheck(this, PbxService);\n\n    this.logService = 'TelphonyService | ';\n\n    pbxService_$log.set(this, $log);\n\n    pbxService_$rootScope.set(this, $rootScope);\n\n    pbxService_telephonyService.set(this, telephonyService);\n\n    pbxService_webrtcGatewayService.set(this, webrtcGatewayService);\n\n    _Call.set(this, Call);\n\n    pbxService_SDK.set(this, SDK);\n    /**\n     * @public\n     * @event RAINBOW_ONTELEPHONYCALLSTATECHANGED\n     * @param {Call} call The call updated\n     * @description\n     *      This event is fired when the telephony state changes\n     */\n\n\n    this.RAINBOW_ONTELEPHONYCALLSTATECHANGED = 'rainbowontelephonycallstatechanged';\n    /**\n     * @public\n     * @event RAINBOW_ONTELEPHONYSTARTED\n     * @description\n     *      This event is fired when the PBX service is ready to be used\n     */\n\n    this.RAINBOW_ONTELEPHONYSTARTED = 'rainbowontelephonystarted';\n    /**\n     * @public\n     * @event RAINBOW_ONTELEPHONYSTOPPED\n     * @description\n     *      This event is fired when the PBX service is no more usable\n     */\n\n    this.RAINBOW_ONTELEPHONYSTOPPED = 'rainbowontelephonystopped';\n    /**\n     * @public\n     * @event RAINBOW_ONTELEPHONYFORWARDSTATECHANGED\n     * @param {Object} forwardState The forward status. Object looks like {\n     *\t\t\"forwardType\": \"Activation\" or \"Deactivation\"/undefined,\n     *\t\t\"forwardTo\": number if any, or \"VOICEMAILBOX\" or undefined if no forward\n     *\t}\n     * @description\n     *      This event is fired when the forward state changes or by request (getForwardStatus)\n     */\n\n    this.RAINBOW_ONTELEPHONYFORWARDSTATECHANGED = 'rainbowontelephonyforwardstatechanged';\n    /**\n     * @public\n     * @event RAINBOW_ONCALLNOMADICEVENT\n     * @description\n     *      This event is fired when a Nomadic Event is fired\n     */\n\n    this.RAINBOW_ONCALLNOMADICEVENT = 'rainbowoncallnomadicevent';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      This event is fired when the associated phone is dialing\n     */\n\n    this.RAINBOW_TELEPHONYDIALING = 'dialing';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      This event is fired when the recipient phone is ringing\n     */\n\n    this.RAINBOW_TELEPHONYRINGINGOUTGOING = 'ringingOutgoing';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      This event is fired when the associated phone is called\n     */\n\n    this.RAINBOW_TELEPHONYINCOMING = 'incomingCall';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      This event is fired when the associated phone is engaged in a call\n     */\n\n    this.RAINBOW_TELEPHONYACTIVE = 'active';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      This event is fired when the associated phone is releasing the call\n     */\n\n    this.RAINBOW_TELEPHONYRELEASING = 'releasing';\n    /**\n     * @public\n     * @constant\n     * @type {string}\n     * @description\n     *      This event is fired when the associated phone state is not known\n     */\n\n    this.RAINBOW_TELEPHONYUNKNOW = 'Unknown';\n    /**\n     * @public\n     * @method isTelephonyAvailable\n     * @instance\n     * @description\n     *    Check if the telephony service can be used or not (if the connected user has a phone monitored by a PBX)\n     * @return {boolean} Return true if the telephony service is configured\n     */\n\n    this.isTelephonyAvailable = this.isTelephonyAvailable.bind(this);\n    /**\n     * @public\n     * @method getAgentVersion\n     * @instance\n     * @description\n     *    Get the associated PBX agent version\n     * @return {string} Return the version of the agent or \"unknown\"\n     */\n\n    this.getAgentVersion = this.getAgentVersion.bind(this);\n    /**\n     * @public\n     * @method getXMPPAgentStatus\n     * @instance\n     * @description\n     *    Get the status of the XMPP connection to the PBX Agent\n     * @return {string} Return the status of the connections to the agent or \"unknown\"\n     */\n\n    this.getXMPPAgentStatus = this.getXMPPAgentStatus.bind(this);\n    /**\n     * @public\n     * @method getPhoneAPIStatus\n     * @instance\n     * @description\n     *    Get the status of the Phone API status for the PBX Agent\n     * @return {string} Return the Phone API status for to this Agent or \"unknown\"\n     */\n\n    this.getPhoneAPIStatus = this.getPhoneAPIStatus.bind(this);\n    /**\n     * @public\n     * @method callByNumber\n     * @instance\n     * @description\n     *    Call a number <br/>\n     *    Only canonical number or internal number are allowed\n     *    Return a promise\n     * @param {String} strPhoneNumber The number to call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.callByNumber = this.callByNumber.bind(this);\n    /**\n     * @public\n     * @method callWithMessage\n     * @instance\n     * @description\n     *    Call a number and include a message that will appear for the receiver of the call <br/>\n     *    Only canonical number or internal number are allowed\n     *    Return a promise\n     * @param {Contact} contact The contact to call\n     * @param {String} strPhoneNumber The number to call\n     * @param {String} callSubject The subject of the call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.callWithMessage = this.callWithMessage.bind(this);\n    /**\n     * @public\n     * @method callWithSubject\n     * @since 1.55\n     * @instance\n     * @description\n     *    Call with Subject <br/>\n     *    Allows to add a message to the call (i.e. to explain the reason of the call)\n     *    Returns a promise\n     * @param {Contact} contact - Contact to call (object)\n     * @param {String} strPhoneNumber The number to call\n     * @param {String} callSubject Message to add to the call (subject)\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.callWithSubject = this.callWithSubject.bind(this);\n    /**\n     * @public\n     * @method calls\n     * @instance\n     * @description\n     *    Retrieve the list of active calls <br/>\n     * @return {Call[]} Return an array of Call object\n     */\n\n    this.calls = this.calls.bind(this);\n    /**\n     * @public\n     * @method release\n     * @instance\n     * @description\n     *    Release a call <br/>\n     *    Return a promise\n     * @param {Call} call The call to release\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.release = this.release.bind(this);\n    /**\n     * @public\n     * @method deflectToVM\n     * @instance\n     * @description\n     *    Deflect a call to the voice mail <br/>\n     *    Return a promise\n     * @param {Call} call The call to deflect\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.deflectToVM = this.deflectToVM.bind(this);\n    /**\n     * @public\n     * @method forwardToDevice\n     * @instance\n     * @description\n     *    Activate the forward to a number <br/>\n     *    Return a promise\n     * @param {String} strPhoneNumber The number to call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.forwardToDevice = this.forwardToDevice.bind(this);\n    /**\n     * @public\n     * @method forwardToVoicemail\n     * @instance\n     * @description\n     *    Activate the forward to VM <br/>\n     *    Return a promise\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.forwardToVoicemail = this.forwardToVoicemail.bind(this);\n    /**\n     * @public\n     * @method cancelForward\n     * @instance\n     * @description\n     *    Cancel the forward <br/>\n     *    Return a promise\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.cancelForward = this.cancelForward.bind(this);\n    /**\n     * @public\n     * @method getForwardStatusFromServer\n     * @instance\n     * @description\n     *    Ask for Forward status <br/>\n     *    Return a promise\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object <br/>\n     *                  Forward status will arrive by event (see RAINBOW_ONTELEPHONYFORWARDSTATECHANGED)\n     */\n\n    this.getForwardStatusFromServer = this.getForwardStatusFromServer.bind(this);\n    /**\n     * @public\n     * @method getForwardStatus\n     * @instance\n     * @description\n     *    Get the Forward status <br/>\n     * @return {Object} Return the known forwardState.  See RAINBOW_ONTELEPHONYFORWARDSTATECHANGED event for format.\n     */\n\n    this.getForwardStatus = this.getForwardStatus.bind(this);\n    /**\n     * @public\n     * @method answer\n     * @instance\n     * @description\n     *    Answer a call <br/>\n     *    Return a promise\n     * @param {Call} call The call to answer\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.answer = this.answer.bind(this);\n    /**\n     * @public\n     * @method hold\n     * @instance\n     * @description\n     *    Hold a call <br/>\n     *    Return a promise\n     * @param {Call} call The call to hold\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.hold = this.hold.bind(this);\n    /**\n     * @public\n     * @method retrieve\n     * @instance\n     * @description\n     *    Retrieve a call <br/>\n     *    Return a promise\n     * @param {Call} call The call to retrieve\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.retrieve = this.retrieve.bind(this);\n    /**\n     * @public\n     * @method transfertCall\n     * @instance\n     * @description\n     *    Transfer a held call to the active call <br/>\n     *    User should have transfer rights <br/>\n     *    Return a promise\n     * @param {Call} activeCall The active call\n     * @param {Call} heldCall The held call to transfer to the activeCall\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.transfertCall = this.transfertCall.bind(this);\n    /**\n     * @public\n     * @method conferenceCall\n     * @instance\n     * @description\n     *    Create a conference with a held call and the active call <br/>\n     *    User should have conference rights <br/>\n     *    Return a promise\n     * @param {Call} activeCall The active call\n     * @param {Call} heldCall The held call to transfer to the activeCall\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.conferenceCall = this.conferenceCall.bind(this);\n    /**\n     * @public\n     * @method getNomadicState\n     * @instance\n     * @description\n     *    Returns the current Nomadic state\n     * @return {Promise} Return the current nomadic state\n     */\n\n    this.getNomadicState = this.getNomadicState.bind(this);\n    /**\n     * @public\n     * @method setExternalNomadicNumber\n     * @instance\n     * @description\n     *    Set external Nomadic Number\n     * @param {String} phoneNumber Phone number to be set\n     * @return {Promise} Return the promise\n     */\n\n    this.setExternalNomadicNumber = this.setExternalNomadicNumber.bind(this);\n    /**\n     * @public\n     * @method setNomadicOfficePhone\n     * @instance\n     * @description\n     *    Set Nomadic status to Office Phone\n     * @return {Promise} Return the promise\n     */\n\n    this.setNomadicOfficePhone = this.setNomadicOfficePhone.bind(this);\n    /**\n     * @public\n     * @method setNomadicWebRtc\n     * @instance\n     * @description\n     *    Set Nomadic status to WebRTC\n     * @return {Promise} Return the promise\n     */\n\n    this.setNomadicWebRtc = this.setNomadicWebRtc.bind(this);\n    /*\n     * EVENTS\n     * $rootScope.$on to be replaced with window.addEventListener in the future\n     */\n\n    $rootScope.$on('$destroy', $rootScope.$on('ON_TELEPHONY_STATUS_CHANGED_EVENT', function (event, state) {\n      return _this.onTelephonyStateChanged(event, state);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CALL_NOMADIC_EVENT', function (event, nomadicObject) {\n      return _this.onCallNomadicEvent(event, nomadicObject);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CALL_UPDATED_EVENT', function (event, call) {\n      return _this.onTelephonyCallChanged(event, call);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CALL_FORWARDED_EVENT', function (event, forwardStatus) {\n      return _this.onCallForwardChanged(event, forwardStatus);\n    }));\n  }\n  /* EVENT HANDLERS */\n\n\n  pbxService_createClass(PbxService, [{\n    key: \"onTelephonyStateChanged\",\n    value: function onTelephonyStateChanged(event, state) {\n      var $log = pbxService_$log.get(this);\n\n      $log.sdk(this.logService + '[onTelephonyStateChanged] :: PBX state changed to ' + state);\n\n      if (state === 'started') {\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONTELEPHONYSTARTED, {\n          detail: null\n        });\n        document.dispatchEvent(sdkEvent);\n      } else {\n        var _sdkEvent = new CustomEvent(this.RAINBOW_ONTELEPHONYSTOPPED, {\n          detail: null\n        });\n\n        document.dispatchEvent(_sdkEvent);\n      }\n    }\n  }, {\n    key: \"onCallNomadicEvent\",\n    value: function onCallNomadicEvent(event, nomadicObject) {\n      var $log = pbxService_$log.get(this); // Only deals with event of type call\n\n\n      $log.sdk(this.logService + '[onCallNomadicEvent] :: Nomadic event received');\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCALLNOMADICEVENT, {\n        detail: nomadicObject\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onTelephonyCallChanged\",\n    value: function onTelephonyCallChanged(event, call) {\n      var $log = pbxService_$log.get(this);\n\n      var Call = _Call.get(this); // Only deals with event of type call\n\n\n      if (call.type.value === Call.Type.PHONE.value) {\n        $log.sdk(this.logService + '[onTelephonyCallChanged] :: Telephony state changed to ' + call);\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONTELEPHONYCALLSTATECHANGED, {\n          detail: call\n        });\n        document.dispatchEvent(sdkEvent);\n      }\n    }\n  }, {\n    key: \"onCallForwardChanged\",\n    value: function onCallForwardChanged(event, forwardStatus) {\n      var $log = pbxService_$log.get(this);\n\n      $log.sdk(this.logService + '[onCallForwardChanged] :: Forward state changed to ' + forwardStatus);\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONTELEPHONYFORWARDSTATECHANGED, {\n        detail: forwardStatus\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"isTelephonyAvailable\",\n    value: function isTelephonyAvailable() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return telephonyService.started;\n    }\n  }, {\n    key: \"getAgentVersion\",\n    value: function getAgentVersion() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return telephonyService.agentStatus.agentVersion || 'unknown';\n    }\n  }, {\n    key: \"getXMPPAgentStatus\",\n    value: function getXMPPAgentStatus() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return telephonyService.agentStatus.xmppAgent || 'unknown';\n    }\n  }, {\n    key: \"getPhoneAPIStatus\",\n    value: function getPhoneAPIStatus() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return telephonyService.agentStatus.phoneApi || 'unknown';\n    }\n  }, {\n    key: \"callByNumber\",\n    value: function callByNumber(strPhoneNumber) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strPhoneNumber) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strPhoneNumber' is missing or empty\"\n          });\n        } else {\n          telephonyService.makeCallByPhoneNumber(strPhoneNumber).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"callWithMessage\",\n    value: function callWithMessage(contact, phoneNumber, callSubject) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or empty\"\n          });\n        } else if (!phoneNumber) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'phoneNumber' is missing or empty\"\n          });\n        } else if (!callSubject) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'callSubject' is missing or empty\"\n          });\n        } else {\n          telephonyService.makeCall(contact, phoneNumber, callSubject).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            })[\"catch\"](function (err) {\n              return reject({\n                code: SDK.ERROR,\n                label: err\n              });\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"callWithSubject\",\n    value: function callWithSubject(contact, phoneNumber, callSubject) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or empty\"\n          });\n        } else if (!phoneNumber) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'phoneNumber' is missing or empty\"\n          });\n        } else if (!callSubject) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'callSubject' is missing or empty\"\n          });\n        } else {\n          telephonyService.makeCall(contact, phoneNumber, callSubject).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"calls\",\n    value: function calls() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return telephonyService.calls;\n    }\n  }, {\n    key: \"release\",\n    value: function release(call) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!call) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'call' is missing or null\"\n          });\n        } else {\n          telephonyService.releaseCall(call).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deflectToVM\",\n    value: function deflectToVM(call) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!call) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'call' is missing or null\"\n          });\n        } else {\n          telephonyService.deflectCallToVM(call).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"forwardToDevice\",\n    value: function forwardToDevice(strPhoneNumber) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!strPhoneNumber || typeof strPhoneNumber !== 'string' || strPhoneNumber.length === 0) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strPhoneNumber' is missing or empty\"\n          });\n        } else {\n          telephonyService.forwardToDevice(strPhoneNumber).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"forwardToVoicemail\",\n    value: function forwardToVoicemail() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      var SDK = pbxService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        telephonyService.forwardToVoicemail().then(function () {\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        })[\"catch\"](function (err) {\n          return reject({\n            code: SDK.ERROR,\n            label: err\n          });\n        });\n      });\n    }\n  }, {\n    key: \"cancelForward\",\n    value: function cancelForward() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      var SDK = pbxService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        telephonyService.cancelForward().then(function () {\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        })[\"catch\"](function (err) {\n          return reject({\n            code: SDK.ERROR,\n            label: err\n          });\n        });\n      });\n    }\n  }, {\n    key: \"getForwardStatusFromServer\",\n    value: function getForwardStatusFromServer() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      var SDK = pbxService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        telephonyService.getForwardStatus().then(function () {\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        })[\"catch\"](function (err) {\n          return reject({\n            code: SDK.ERROR,\n            label: err\n          });\n        });\n      });\n    }\n  }, {\n    key: \"getForwardStatus\",\n    value: function getForwardStatus() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return telephonyService.getForwardObject();\n    }\n  }, {\n    key: \"answer\",\n    value: function answer(call) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!call) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'call' is missing or null\"\n          });\n        } else {\n          telephonyService.answerCall(call).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"hold\",\n    value: function hold(call) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!call) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'call' is missing or null\"\n          });\n        } else {\n          telephonyService.holdCall(call).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(call) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!call) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'call' is missing or null\"\n          });\n        } else {\n          telephonyService.retrieveCall(call).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"transfertCall\",\n    value: function transfertCall(activeCall, heldCall) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!activeCall) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'activeCall' is missing or null\"\n          });\n        } else if (!heldCall) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'heldCall' is missing or null\"\n          });\n        } else {\n          telephonyService.transfertCall(activeCall, heldCall).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"conferenceCall\",\n    value: function conferenceCall(activeCall, heldCall) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!activeCall) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'activeCall' is missing or null\"\n          });\n        } else if (!heldCall) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'heldCall' is missing or null\"\n          });\n        } else {\n          telephonyService.conferenceCall(activeCall, heldCall).then(function () {\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject({\n              code: SDK.ERROR,\n              label: err\n            });\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getNomadicState\",\n    value: function getNomadicState() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        telephonyService.getNomadicStatus().then(function () {\n          return resolve();\n        })[\"catch\"](function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"setExternalNomadicNumber\",\n    value: function setExternalNomadicNumber(phoneNumber) {\n      var SDK = pbxService_SDK.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!phoneNumber) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'phoneNumber' is missing or null\"\n          });\n        } else if (typeof phoneNumber !== 'string') {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'phoneNumber' is not a string\"\n          });\n        } else {\n          telephonyService.nomadicLogin(phoneNumber).then(function () {\n            return resolve();\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"setNomadicOfficePhone\",\n    value: function setNomadicOfficePhone() {\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        telephonyService.nomadicLoginOnOfficePhone().then(function () {\n          return resolve();\n        })[\"catch\"](function () {\n          return reject();\n        });\n      });\n    }\n  }, {\n    key: \"setNomadicWebRtc\",\n    value: function setNomadicWebRtc() {\n      var webrtcGatewayService = pbxService_webrtcGatewayService.get(this);\n\n      var telephonyService = pbxService_telephonyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var mediapillar = webrtcGatewayService.getMyMediaPillarRemoteExtension();\n        telephonyService.nomadicLogin(mediapillar).then(function () {\n          return resolve();\n        })[\"catch\"](function () {\n          return reject();\n        });\n      });\n    }\n  }]);\n\n  return PbxService;\n}();\n// CONCATENATED MODULE: ./src/conversationsService.js\nfunction conversationsService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction conversationsService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction conversationsService_createClass(Constructor, protoProps, staticProps) { if (protoProps) conversationsService_defineProperties(Constructor.prototype, protoProps); if (staticProps) conversationsService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Conversations\n * @description\n *      This module is the basic module for handling conversations in Rainbow. In Rainbow, conversations are the way to get in touch with someone or something (i.e. a Rainbow contact, a external phone number, a connected thing, ...) so a conversation is the \"long tail\" of communication between you and someone or something else like a bubble. <br><br>\n *      A Rainbow conversation by default supports sending and receiving Instant Messages with a single recipient (one-to-one conversation) or with several persons (bubble). A conversation can be escaladed to audio and video or by adding a PBX phone call (for p2p conversation only). Using the FileStorage service, you can share files in conversations. <br><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Create or close a Rainbow conversation (one-to-one of bubble), <br/>\n *      - Retrieve all information linked to that conversation, <br>\n *      - Listen to the conversation change <br>\n * @fires RAINBOW_ONCONVERSATIONCHANGED\n * @fires RAINBOW_ONCONVERSATIONREMOVED\n * @fires RAINBOW_ONCONVERSATIONSCHANGED\n */\nvar conversationsService_$log = new WeakMap();\n\nvar conversationsService_$rootScope = new WeakMap();\n\nvar _Conversation = new WeakMap();\n\nvar conversationsService_conversationService = new WeakMap();\n\nvar conversationsService_SDK = new WeakMap();\n\nvar ConversationsService =\n/*#__PURE__*/\nfunction () {\n  conversationsService_createClass(ConversationsService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'Conversation', 'conversationService', 'SDK'];\n    }\n  }]);\n\n  function ConversationsService($log, $rootScope, Conversation, conversationService, SDK) {\n    var _this = this;\n\n    conversationsService_classCallCheck(this, ConversationsService);\n\n    this.logService = 'ConversationsService | ';\n\n    conversationsService_$log.set(this, $log);\n\n    conversationsService_$rootScope.set(this, $log);\n\n    _Conversation.set(this, Conversation);\n\n    conversationsService_conversationService.set(this, conversationService);\n\n    conversationsService_SDK.set(this, SDK);\n    /**\n     * @public\n     * @event RAINBOW_ONCONVERSATIONREMOVED\n     * @param {Conversation} conversation The conversation removed\n     * @description\n     *      This event is fired when a conversation has been removed\n     */\n\n\n    this.RAINBOW_ONCONVERSATIONREMOVED = 'rainbowconversationremoved';\n    /**\n     * @public\n     * @event RAINBOW_ONCONVERSATIONCHANGED\n     * @since 1.16.0\n     * @param {String} conversationId The id of the conversation updated\n     * @description\n     *      This event is fired when a new message has been added to a conversation\n     */\n\n    this.RAINBOW_ONCONVERSATIONCHANGED = 'rainbowconversationchanged';\n    /**\n     * @public\n     * @event RAINBOW_ONCONVERSATIONSCHANGED\n     * @param {Conversation} conversation The conversation added\n     * @description\n     *      This event is fired when the list of the conversations has changed (conversation added)\n     */\n\n    this.RAINBOW_ONCONVERSATIONSCHANGED = 'rainbowconversationschanged';\n    /**\n     * @public\n     * @event RAINBOW_ONCONVERSATIONSMISSEDCOUNTERCHANGED\n     * @since 1.22\n     * @param {Object} counter The counter\n     * @description\n     *      This event is fired when the total number of missed IM associated to all conversations change\n     */\n\n    this.RAINBOW_ONCONVERSATIONSMISSEDCOUNTERCHANGED = 'rainbowconversationsmissedcounterchanged';\n    /**\n     * @public\n     * @method getAllConversations\n     * @instance\n     * @description\n     *    Allow to get the list of existing conversations (p2p and bubbles)\n     * @return {Conversation[]} An array of Conversation object\n     */\n\n    this.getAllConversations = this.getAllConversations.bind(this);\n    /**\n     * @public\n     * @method getCallById\n     * @since 1.19.0\n     * @instance\n     * @description\n     *    Get a call by its Id by searching on all user's conversations\n     * @param {String} strCallId ID of the call\n     * @return {Call} The call if found or an error\n     */\n\n    this.getCallById = this.getCallById.bind(this);\n    /**\n     * @public\n     * @method getConversationById\n     * @since 1.16.0\n     * @instance\n     * @description\n     *    Get a conversation by its id\n     * @param {String} strId ID of the conversation\n     * @return {Conversation} A conversation object or null if not found\n     */\n\n    this.getConversationById = this.getConversationById.bind(this);\n    /**\n     * @public\n     * @method getConversationByBubbleId\n     * @since 1.19.0\n     * @instance\n     * @description\n     *    Get a conversation associated to a bubble (using the bubble ID to retrieve it)\n     * @param {String} strBubbleId ID of the bubble (dbId field)\n     * @return {Conversation} A conversation object or null if not found\n     */\n\n    this.getConversationByBubbleId = this.getConversationByBubbleId.bind(this);\n    /**\n     * @public\n     * @method openConversationForContact\n     * @instance\n     * @description\n     *    Open a conversation to a contact <br/>\n     *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>\n     *    This method returns a promise\n     * @param {Contact} contact The contact involved in the conversation\n     * @return {Conversation} The conversation (created or retrieved) or null in case of error\n     */\n\n    this.openConversationForContact = this.openConversationForContact.bind(this);\n    /**\n     * @public\n     * @method openConversationForBubble\n     * @since 1.22\n     * @instance\n     * @description\n     *    Open a conversation to a bubble <br/>\n     *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>\n     *    This method returns a promise\n     * @param {Bubble} bubble The bubble involved in this conversation\n     * @return {Conversation} The conversation (created or retrieved) or null in case of error\n     */\n\n    this.openConversationForBubble = this.openConversationForBubble.bind(this);\n    /**\n     * @public\n     * @method closeConversation\n     * @instance\n     * @description\n     *    Close a conversation <br/>\n     *    This method returns a promise\n     * @param {Conversation} conversation The conversation to close\n     */\n\n    this.closeConversation = this.closeConversation.bind(this);\n    /* EVENTS */\n\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONVERSATIONS_UPDATED_EVENT', function (event, conversation) {\n      return _this.onConversationsChanged(event, conversation);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONVERSATION_REMOVE_EVENT', function (event, conversation) {\n      return _this.onConversationsRemoved(event, conversation);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONVERSATION_UPDATED_EVENT', function (event, conversation) {\n      return _this.onConversationChanged(event, conversation);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_MISSED_COUNTER_CHANGED_EVENT', function (event, json) {\n      return _this.onConversationsCounterChanged(event, json);\n    }));\n  }\n  /* EVENT HANDLERS */\n\n\n  conversationsService_createClass(ConversationsService, [{\n    key: \"onConversationsChanged\",\n    value: function onConversationsChanged(event, conversation) {\n      if (!conversation) {\n        return;\n      } else {\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONCONVERSATIONSCHANGED, {\n          detail: conversation\n        });\n        document.dispatchEvent(sdkEvent);\n      }\n    }\n  }, {\n    key: \"onConversationsRemoved\",\n    value: function onConversationsRemoved(event, conversation) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCONVERSATIONREMOVED, {\n        detail: conversation\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onConversationChanged\",\n    value: function onConversationChanged(event, conversation) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCONVERSATIONSCHANGED, {\n        detail: conversation\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onConversationsCounterChanged\",\n    value: function onConversationsCounterChanged(event, json) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCONVERSATIONSMISSEDCOUNTERCHANGED, {\n        detail: json\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n    /* SERVICE METHODS */\n\n  }, {\n    key: \"getAllConversations\",\n    value: function getAllConversations() {\n      var conversationService = conversationsService_conversationService.get(this);\n\n      var allConversations = conversationService.getConversations();\n      var oneToOneConversationsOnly = [];\n      allConversations.forEach(function (conversation) {\n        oneToOneConversationsOnly.push(conversation);\n      });\n      return oneToOneConversationsOnly;\n    }\n  }, {\n    key: \"getCallById\",\n    value: function getCallById(strCallId) {\n      var SDK = conversationsService_SDK.get(this);\n\n      var conversationService = conversationsService_conversationService.get(this);\n\n      if (!strCallId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strCallId' is missing or empty\"\n        };\n      }\n\n      var allConversations = conversationService.getConversations();\n      var call = null;\n      allConversations.forEach(function (conversation) {\n        if (conversation.videoCall && conversation.videoCall.id === strCallId) {\n          call = conversation.videoCall;\n        } else if (conversation.audioCall && conversation.audioCall.id === strCallId) {\n          call = conversation.audioCall;\n        }\n      });\n      return call;\n    }\n  }, {\n    key: \"getConversationById\",\n    value: function getConversationById(strId) {\n      var SDK = conversationsService_SDK.get(this);\n\n      var conversationService = conversationsService_conversationService.get(this);\n\n      if (!strId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'callId' is missing or empty\"\n        };\n      }\n\n      return conversationService.getConversationById(strId);\n    }\n  }, {\n    key: \"getConversationByBubbleId\",\n    value: function getConversationByBubbleId(strBubbleId) {\n      var SDK = conversationsService_SDK.get(this);\n\n      var conversationService = conversationsService_conversationService.get(this);\n\n      if (!strBubbleId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strBubbleId' is missing or empty\"\n        };\n      }\n\n      return conversationService.getConversationByRoomDbId(strBubbleId);\n    }\n  }, {\n    key: \"openConversationForContact\",\n    value: function openConversationForContact(contact) {\n      var _this2 = this;\n\n      var SDK = conversationsService_SDK.get(this);\n\n      var $log = conversationsService_$log.get(this);\n\n      var conversationService = conversationsService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else {\n          $log.sdk(_this2.logService + '[openConversationForContact] :: Trying to open a conversation for a contact');\n          conversationService.getOrCreateOneToOneConversation(contact.jid).then(function (conversation) {\n            $log.sdk(_this2.logService + '[openConversationForContact] :: Conversation retrieved or created ' + conversation.id);\n            return resolve(conversation);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this2.logService + '[openConversationForContact] :: Error');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"openConversationForBubble\",\n    value: function openConversationForBubble(bubble) {\n      var _this3 = this;\n\n      var SDK = conversationsService_SDK.get(this);\n\n      var $log = conversationsService_$log.get(this);\n\n      var conversationService = conversationsService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          $log.sdk(_this3.logService + '[openConversationForBubble] :: Try to create or get a conversation for a bubble ');\n          conversationService.getRoomConversation(bubble.jid).then(function (conversation) {\n            $log.sdk(_this3.logService + '[openConversationForBubble] :: Conversation retrieved or created ' + conversation.id);\n            return resolve(conversation);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this3.logService + '[openConversationForBubble] :: Error');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"closeConversation\",\n    value: function closeConversation(conversation) {\n      var SDK = conversationsService_SDK.get(this);\n\n      var conversationService = conversationsService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else {\n          conversationService.closeConversation(conversation).then(function () {\n            return resolve();\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }]);\n\n  return ConversationsService;\n}();\n// CONCATENATED MODULE: ./src/imService.js\nfunction imService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction imService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction imService_createClass(Constructor, protoProps, staticProps) { if (protoProps) imService_defineProperties(Constructor.prototype, protoProps); if (staticProps) imService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name IM\n * @description\n *      This service sends and receives Instant Messages in one-to-one conversations or bubble conversations. <br><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Retrieve the messages already exchanged in a conversation, <br>\n *      - Send a new message in a conversation  (one-to-one conversation or bubble)<br>\n *      - Listen when new messages are received in a conversation<br>\n * @fires RAINBOW_ONNEWIMMESSAGERECEIVED\n * @fires RAINBOW_ONNEWIMRECEIPTRECEIVED\n * @fires RAINBOW_ONNEWPARTICIPANTSTATUS\n */\nvar imService_$rootScope = new WeakMap();\n\nvar imService_$log = new WeakMap();\n\nvar imService_roomService = new WeakMap();\n\nvar imService_fileStorageService = new WeakMap();\n\nvar imService_conversationService = new WeakMap();\n\nvar imService_Conversation = new WeakMap();\n\nvar _Message = new WeakMap();\n\nvar imService_SDK = new WeakMap();\n\nvar ImService =\n/*#__PURE__*/\nfunction () {\n  imService_createClass(ImService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$rootScope', '$log', 'roomService', 'fileStorageService', 'conversationService', 'Conversation', 'Message', 'SDK'];\n    }\n  }]);\n\n  function ImService($rootScope, $log, roomService, fileStorageService, conversationService, Conversation, Message, SDK) {\n    var _this = this;\n\n    imService_classCallCheck(this, ImService);\n\n    imService_$rootScope.set(this, $rootScope);\n\n    imService_$log.set(this, $log);\n\n    imService_roomService.set(this, roomService);\n\n    imService_fileStorageService.set(this, fileStorageService);\n\n    imService_conversationService.set(this, conversationService);\n\n    imService_Conversation.set(this, Conversation);\n\n    _Message.set(this, Message);\n\n    imService_SDK.set(this, SDK);\n\n    this.logService = 'IMService | ';\n    /**\n     * @public\n     * @since 1.21\n     * @event RAINBOW_ONNEWIMMESSAGERECEIVED\n     * @param {Message} message The message\n     * @param {Conversation} conversation The associated conversation\n     * @param {boolean} cc  True if it is a carbon copie message (message sent by the connected user from an other resource)\n     * @description\n     *      This event is fired when a new message is received in a conversation\n     *      Contains 3 parameters:\n     */\n\n    this.RAINBOW_ONNEWIMMESSAGERECEIVED = 'rainbownewimmessagereceived';\n    /**\n     * @public\n     * @since 1.25\n     * @event RAINBOW_ONNEWIMRECEIPTRECEIVED\n     * @param {Message} message The message\n     * @param {Conversation} conversation The associated conversation\n     * @param {string} evt  Type of receipt. Can be \"server\", \"received\" or \"read\"\n     * @description\n     *      This event is fired when a receipt is received (i.e. \"server\", \"received\", \"read\")\n     */\n\n    this.RAINBOW_ONNEWIMRECEIPTRECEIVED = 'rainbownewimreceiptreceived';\n    /**\n     * @public\n     * @since 1.38\n     * @event RAINBOW_ONNEWPARTICIPANTSTATUS\n     * @param {Contact} participant The participant with status changed\n     * @param {Conversation} conversation The associated conversation\n     * @param {string} status the status, \"active\", \"composing\", \"paused\"\n     * @description\n     *      This event is fired when a participant is typing (\"composing\") or stopped typing (\"active\") or paused the IM (switched to another)\n     */\n\n    this.RAINBOW_ONNEWPARTICIPANTSTATUS = 'rainbownewparticipantstatus';\n    /**\n     * @public\n     * @method getMessagesFromConversation\n     * @instance\n     * @description\n     *    Retrieve the list of messages from a conversation <br/>\n     *    Calling several times this method will load older message from the history (pagination) <br/>\n     *    Return a promise\n     * @param {Conversation} conversation The conversation\n     * @param {Number} intNbMessage The number of messages to retrieve. Optional. Default value is 30. Maximum value is 100\n     * @return {Conversation} Return the conversation updated with the list of messages requested or an error (reject) if there is no more messages to retrieve\n     */\n\n    this.getMessagesFromConversation = this.getMessagesFromConversation.bind(this);\n    /**\n     * @public\n     * @method getMessageFromConversationById\n     * @since 1.24\n     * @instance\n     * @description\n     *    Retrieve a specific message in a conversation using its id <br/>\n     * @param {Conversation} conversation The conversation where to search for the message\n     * @param {String} strMessageId The message id\n     * @return {Message} The message if found or null\n     */\n\n    this.getMessageFromConversationById = this.getMessageFromConversationById.bind(this);\n    /**\n     * @public\n     * @method getMessageFromBubbleById\n     * @since 1.24\n     * @instance\n     * @description\n     *    Retrieve a specific message in a bubble using its id <br/>\n     * @param {Bubble} bubble The bubble where to search for the message\n     * @param {String} strMessageId The message id\n     * @return {Message} The message if found or null\n     */\n\n    this.getMessageFromBubbleById = this.getMessageFromBubbleById.bind(this);\n    /**\n     * @public\n     * @method sendMessageToConversation\n     * @instance\n     * @description\n     *    Send a instant message to a conversation<br>\n     *    This method works for sending messages to a one-to-one conversation or to a bubble conversation\n     * @param {Conversation} conversation The conversation object\n     * @param {string} strMessage The text message to send (limited to 1024 characters per message)\n     * @param {String} alternativeContentType [optional] A string matching one of the two values: \"text\" or \"markdown\"\n     * @param {String} alternativeContentMessage [optional] A string containing Alternative Content message (maximum 1024 characters)\n     * @return {Message} The message object created and sent or null in case of error\n     */\n\n    this.sendMessageToConversation = this.sendMessageToConversation.bind(this);\n    /**\n     * @public\n     * @method sendCorrectedChatMessage\n     * @since 1.53\n     * @instance\n     * @description\n     *    Send a corrected chat message to a conversation\n     *    This method allows the user to modify the given message and update its content\n     * @param {Conversation} conversation The conversation object\n     * @param {String} strMessage The text message to send (limited to 1024 characters per message)\n     * @param {String} messageId -id of the message that is supposed to be corrected\n     * @return {Message} - message object with updated replaceMsgs property\n     */\n\n    this.sendCorrectedChatMessage = this.sendCorrectedChatMessage.bind(this);\n    /**\n     * @public\n     * @method replyToMessage\n     * @since 1.55\n     * @instance\n     * @description\n     *    Reply to a specific message in a conversation\n     * @param {Conversation} conversation The conversation object\n     * @param {string} strMessage The text of the message to be sent (limited to 1024 characters per message)\n     * @param {Message} message -id of the message that is supposed to be corrected\n     * @return {Promise} - message object with updated replaceMsgs property\n     */\n\n    this.replyToMessage = this.replyToMessage.bind(this);\n    /**\n     * @public\n     * @method deleteMessage\n     * @since 1.53\n     * @instance\n     * @description\n     *    Delete a message by sending an empty string in a correctedMessage\n     * @param {Conversation} conversation The conversation object\n     * @param {messageId} message ID - id string of the message that needs to be deleted\n     * @return {Message} - message object with updated replaceMsgs property\n     */\n\n    this.deleteMessage = this.deleteMessage.bind(this);\n    /**\n     * @public\n     * @method sendIsTypingStateInConversation\n     * @instance\n     * @description\n     *    Switch the \"is typing\" state in a conversation<br>\n     * @param {Conversation} conversation The conversation recipient\n     * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.sendIsTypingStateInConversation = this.sendIsTypingStateInConversation.bind(this);\n    /**\n     * @public\n     * @method sendMessageToBubble\n     * @instance\n     * @description\n     *    Send a message to a bubble <br/>\n     *    This is a shortcut method for sending messages to a bubble (to avoid having to retrieve the associated conversation)\n     *    Return a promise\n     * @param {Bubble} bubble       The destination bubble\n     * @param {string} strMessage The text message to send (limited to 1024 characters per message)\n     * @return {Message} The message\n     */\n\n    this.sendMessageToBubble = this.sendMessageToBubble.bind(this);\n    /**\n     * @public\n     * @method sendIsTypingStateInBubble\n     * @instance\n     * @description\n     *    Switch the \"is typing\" state in a bubble/room<br>\n     * @param {Bubble} bubble The destination bubble\n     * @param {boolean} status The status, true for setting \"is Typing\", false to remove it\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.sendIsTypingStateInBubble = this.sendIsTypingStateInBubble.bind(this);\n    /**\n     * @public\n     * @method removeAllMessagesFromConversation\n     * @since 1.19.0\n     * @instance\n     * @description\n     *    Remove all messages from a one-to-one conversation. Messages are only removed for the connected user. <br/>\n     *    Return a promise\n     * @param {Conversation} conversation The conversation.  Have to be a one-to-one conversation.\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.removeAllMessagesFromConversation = this.removeAllMessagesFromConversation.bind(this);\n    /**\n     * @public\n     * @method markMessageFromConversationAsRead\n     * @since 1.19.0\n     * @instance\n     * @description\n     *    Mark a message as read\n     * @param {Conversation} conversation The conversation containing the message\n     * @param {Message} message The message to mark as read\n     * @return {Object} {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.markMessageFromConversationAsRead = this.markMessageFromConversationAsRead.bind(this);\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONVERSATION_MESSAGE_RECEIVED', function (event, message, conversation, cc) {\n      return _this.onNewImMessageReceived(event, message, conversation, cc);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONVERSATION_RECEIPT_RECEIVED', function (event, message, conversation, evt) {\n      return _this.onNewImReceiptReceived(event, message, conversation, evt);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CONVERSATIONS_STATUS_MESSAGE_EVENT', function (event, conversation, participant, status) {\n      return _this.onNewParticipantStatus(event, conversation, participant, status);\n    }));\n  } // EVENT HANDLERS\n\n\n  imService_createClass(ImService, [{\n    key: \"onNewImMessageReceived\",\n    value: function onNewImMessageReceived(event, message, conversation, cc) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONNEWIMMESSAGERECEIVED, {\n        detail: {\n          message: message,\n          conversation: conversation,\n          cc: cc\n        }\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onNewImReceiptReceived\",\n    value: function onNewImReceiptReceived(event, message, conversation, evt) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONNEWIMRECEIPTRECEIVED, {\n        detail: {\n          message: message,\n          conversation: conversation,\n          evt: evt\n        }\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onNewParticipantStatus\",\n    value: function onNewParticipantStatus(event, participant, conversation, status) {\n      if (!status || !status.value) {\n        return;\n      }\n\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONNEWPARTICIPANTSTATUS, {\n        detail: {\n          participant: participant,\n          conversation: conversation,\n          status: status.value\n        }\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"getMessagesFromConversation\",\n    value: function getMessagesFromConversation(conversation, intNbMessage) {\n      var conversationService = imService_conversationService.get(this);\n\n      var SDK = imService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else {\n          intNbMessage = intNbMessage ? Math.min(intNbMessage, 100) : 30;\n          var conversationHistory = conversationService.getHistoryPage(conversation, intNbMessage);\n          return resolve(conversationHistory);\n        }\n      });\n    }\n  }, {\n    key: \"getMessageFromConversationById\",\n    value: function getMessageFromConversationById(conversation, strMessageId) {\n      var SDK = imService_SDK.get(this);\n\n      var fileStorageService = imService_fileStorageService.get(this);\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!strMessageId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMessageId' is missing or empty\"\n        };\n      }\n\n      var message = conversation.getMessageById(strMessageId); // Add FileDescriptor if needed\n\n      if (message && message.fileId) {\n        message.shortFileDescriptor = fileStorageService.getFileDescriptorById(message.fileId);\n      }\n\n      return message;\n    }\n  }, {\n    key: \"getMessageFromBubbleById\",\n    value: function getMessageFromBubbleById(bubble, strMessageId) {\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      var Conversation = imService_Conversation.get(this);\n\n      var fileStorageService = imService_fileStorageService.get(this);\n\n      if (!bubble) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'bubble' is missing or null\"\n        };\n      }\n\n      if (!strMessageId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMessageId' is missing or empty\"\n        };\n      }\n\n      var conversation = conversationService.getConversationByRoomDbId(bubble.dbId);\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'bubble' don't have a conversation\"\n        };\n      }\n\n      if (conversation.type !== Conversation.Type.ROOM) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is not a bubble conversation\"\n        };\n      }\n\n      var message = conversation.getMessageById(strMessageId); // Add FileDescriptor if needed\n\n      if (message && message.fileId) {\n        message.shortFileDescriptor = fileStorageService.getFileDescriptorById(message.fileId);\n      }\n\n      return message;\n    }\n  }, {\n    key: \"sendMessageToConversation\",\n    value: function sendMessageToConversation(conversation, strMessage, alternativeContentType, alternativeContentMessage) {\n      var $log = imService_$log.get(this);\n\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      var that = this;\n      $log.sdk(that.logService + '[sendMessageToConversation] :: Trying to send a message');\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!strMessage) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMessage' is missing or empty\"\n        };\n      }\n\n      if (typeof strMessage !== 'string') {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMessage' must be a string\"\n        };\n      }\n\n      if (strMessage.length > 1024) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMessage' should be shorter than 1024 characters\"\n        };\n      }\n\n      var alternativeContent = null;\n\n      if (alternativeContentMessage) {\n        if (alternativeContentMessage.length > 1024) {\n          return {\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'alternativeContent.message' should be shorter than 1024 characters\"\n          };\n        } else if (!alternativeContentType || alternativeContentType !== 'text' && alternativeContentType !== 'markdown') {\n          return {\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'alternativeContent.type' should be set to either 'text' or 'markdown'\"\n          };\n        } else {\n          alternativeContent = {\n            type: alternativeContentType,\n            message: alternativeContentMessage\n          };\n        }\n      }\n\n      return conversationService.sendChatMessage(conversation, strMessage, alternativeContent);\n    }\n  }, {\n    key: \"sendCorrectedChatMessage\",\n    value: function sendCorrectedChatMessage(conversation, strMessage, messageId) {\n      var $log = imService_$log.get(this);\n\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      var that = this;\n      $log.sdk(that.logService + '[sendCorrectedChatMessage] :: Trying to send a corrected message');\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!strMessage) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMessage' is missing or empty\"\n        };\n      }\n\n      if (strMessage.length > 1024) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMessage' should be shorter than 1024 characters\"\n        };\n      }\n\n      if (!messageId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'messageId' is missing or empty\"\n        };\n      }\n\n      conversationService.sendCorrectedChatMessage(conversation, strMessage, messageId);\n      var message = conversation.getMessageById(messageId);\n      return message;\n    }\n  }, {\n    key: \"replyToMessage\",\n    value: function replyToMessage(conversation, strMessage, message) {\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else if (!strMessage) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strMessage' is missing or null\"\n          });\n        } else if (!message) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'message' is missing or null\"\n          });\n        } else {\n          conversationService.sendAnswerChatMessage(conversation, strMessage, message);\n          resolve(message);\n        }\n      });\n    }\n  }, {\n    key: \"deleteMessage\",\n    value: function deleteMessage(conversation, messageId) {\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!messageId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'messageId' is missing or empty\"\n        };\n      }\n\n      conversationService.sendCorrectedChatMessage(conversation, '', messageId);\n      var message = conversation.getMessageById(messageId);\n      return message;\n    }\n  }, {\n    key: \"sendIsTypingStateInConversation\",\n    value: function sendIsTypingStateInConversation(conversation, status) {\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else if (typeof status !== 'boolean') {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'status' is missing or null\"\n          });\n        } else {\n          conversation = conversation.id ? conversationService.getConversationById(conversation.id) : null;\n\n          if (!conversation) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"Parameter 'conversation': this conversation doesn't exist\"\n            });\n          } else {\n            conversationService.sendIsTypingState(conversation, status);\n            return resolve();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"sendMessageToBubble\",\n    value: function sendMessageToBubble(bubble, strMessage) {\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      var roomService = imService_roomService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else if (!strMessage) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strMessage' is missing or empty\"\n          });\n        } else if (strMessage.length > 1024) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strMessage' should be shorter than 1024 characters\"\n          });\n        } else {\n          conversationService.getRoomConversation(bubble.jid).then(function (conversation) {\n            if (!conversation) {\n              return reject({\n                code: SDK.ERRORNOTFOUND,\n                label: \"No 'conversation' found\"\n              });\n            } else {\n              if (!bubble.isActive) {\n                roomService.sendInitialRoomPresenceSync(bubble).then(function () {\n                  var message = conversationService.sendChatMessage(conversation, strMessage);\n                  return resolve(message);\n                })[\"catch\"](function (err) {\n                  console.log(err);\n                });\n              } else {\n                var message = conversationService.sendChatMessage(conversation, strMessage);\n                return resolve(message);\n              }\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"sendIsTypingStateInBubble\",\n    value: function sendIsTypingStateInBubble(bubble, status) {\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else if (typeof status !== 'boolean') {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'status' is missing or null\"\n          });\n        } else {\n          if (!bubble.jid) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"Parameter 'bubble': this bubble is not a valid one\"\n            });\n          } else {\n            conversationService.getRoomConversation(bubble.jid).then(function (conversation) {\n              if (!conversation) {\n                return reject({\n                  code: SDK.ERRORNOTFOUND,\n                  label: \"No 'conversation' found for this bubble\"\n                });\n              } else {\n                conversationService.sendIsTypingState(conversation, status);\n                return resolve();\n              }\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"removeAllMessagesFromConversation\",\n    value: function removeAllMessagesFromConversation(conversation) {\n      var conversationService = imService_conversationService.get(this);\n\n      var Conversation = imService_Conversation.get(this);\n\n      var SDK = imService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else if (conversation.type !== Conversation.Type.ONE_TO_ONE) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is not a one-to-one conversation\"\n          });\n        } else {\n          conversationService.removeAllMessages(conversation).then(function () {\n            resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"markMessageFromConversationAsRead\",\n    value: function markMessageFromConversationAsRead(conversation, message) {\n      var SDK = imService_SDK.get(this);\n\n      var conversationService = imService_conversationService.get(this);\n\n      var Message = _Message.get(this);\n\n      if (!message) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'message' is missing or empty\"\n        };\n      }\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (message.receiptStatus === Message.ReceiptStatus.READ) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'message' is aldready marked as read\"\n        };\n      }\n\n      conversation.sendAckReadMessage(message);\n\n      if (message.receiptStatus === Message.ReceiptStatus.READ) {\n        conversationService.decreaseMissedIMCounterForConversation(conversation);\n      }\n\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }]);\n\n  return ImService;\n}();\n// CONCATENATED MODULE: ./src/webRTCService.js\nfunction webRTCService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction webRTCService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction webRTCService_createClass(Constructor, protoProps, staticProps) { if (protoProps) webRTCService_defineProperties(Constructor.prototype, protoProps); if (staticProps) webRTCService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name WebRTC\n * @description\n *      This module manages WebRTC audio and video communication in a conversation. At this time of writing, only Chrome and Firefox browsers support these services in Rainbow.<br><br/>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Know if your application (in fact your browser) can use these services, <br/>\n *      - Detect if a webcam or at least a microphone is available, <br>\n *      - Handle the basic audio video services: Call a contact in audio or in audio and video and release the call, <br/>\n *      - Allow to show and hide the local and remote video, <br>\n *      - Mute and unmute audio and video stream, <br>\n *      - Listen to the call state change, <br>\n *      - Record a call <br>\n *      - Enumerate the available devices and allow to select the ones to use <br><br>\n *      You have to use the media device selector proposed by your browser in order to select the device to use when in communication (firefox) or you will use the default configured device (Chrome)<br>\n *      <br/>\n *      Note: for Desktop Sharing (rights and specific Chrome extension) please have a look at [Making audio and video calls]{@link https://hub.openrainbow.com/#/documentation/doc/sdk/web/guides/Initiating_audio_and_video_calls}<br/>\n * @fires RAINBOW_ONWEBRTCCALLSTATECHANGED\n * @fires RAINBOW_ONWEBRTCERRORHANDLED\n * @fires RAINBOW_ONWEBRTCSTREAMADDED\n * @fires RAINBOW_ONWEBRTCTRACKCHANGED\n * @fires RAINBOW_ONWEBRTCTMEDIAERROROCCURED\n * @fires RAINBOW_ONWEBRTCTRECORDDONE\n * @fires RAINBOW_ONWEBRTCTRECORDERROR\n * @fires RAINBOW_ONWEBRTCTRECORDSTARTED\n * @fires RAINBOW_ONWEBRTCTRECORDSTOPPED\n * @fires RAINBOW_ONWEBRTCTRECORDREMOTESTARTED\n * @fires RAINBOW_ONWEBRTCTRECORDREMOTESTOPPED\n */\nvar webRTCService_$log = new WeakMap();\n\nvar webRTCService_$rootScope = new WeakMap();\n\nvar webRTCService_videoService = new WeakMap();\n\nvar webRTCService_platformService = new WeakMap();\n\nvar _settingsService = new WeakMap();\n\nvar _XMPPService = new WeakMap();\n\nvar _extensionSharingService = new WeakMap();\n\nvar webRTCService_Call = new WeakMap();\n\nvar webRTCService_webrtcGatewayService = new WeakMap();\n\nvar webRTCService_recordsService = new WeakMap();\n\nvar webRTCService_conversationService = new WeakMap();\n\nvar webRTCService_SDK = new WeakMap();\n\nvar WebRTCService =\n/*#__PURE__*/\nfunction () {\n  webRTCService_createClass(WebRTCService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'videoService', 'platformService', 'settingsService', 'xmppService', 'extensionSharingService', 'Call', 'webrtcGatewayService', 'recordsService', 'conversationService', 'SDK'];\n    }\n  }]);\n\n  function WebRTCService($log, $rootScope, videoService, platformService, settingsService, XMPPService, extensionSharingService, Call, webrtcGatewayService, recordsService, conversationService, SDK) {\n    var _this = this;\n\n    webRTCService_classCallCheck(this, WebRTCService);\n\n    this.logService = 'WebRTCService | ';\n\n    webRTCService_$log.set(this, $log);\n\n    webRTCService_$rootScope.set(this, $rootScope);\n\n    webRTCService_videoService.set(this, videoService);\n\n    webRTCService_platformService.set(this, platformService);\n\n    _settingsService.set(this, settingsService);\n\n    _XMPPService.set(this, XMPPService);\n\n    _extensionSharingService.set(this, extensionSharingService);\n\n    webRTCService_Call.set(this, Call);\n\n    webRTCService_webrtcGatewayService.set(this, webrtcGatewayService);\n\n    webRTCService_recordsService.set(this, recordsService);\n\n    webRTCService_conversationService.set(this, conversationService);\n\n    webRTCService_SDK.set(this, SDK);\n\n    this.isChromeExtensionInstalled = false;\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCCALLSTATECHANGED\n     * @param {Call} call The call updated\n     * @description\n     *      This event is fired when the state of a webrtc call changes\n     */\n\n    this.RAINBOW_ONWEBRTCCALLSTATECHANGED = 'rainbowonwebrtccallstatechanged';\n    /**\n     * @private\n     * @event RAINBOW_ONWEBRTCMEDIADEVICECHANGED\n     * @description\n     *      This event is fired when the list of available media devices changes\n     */\n\n    this.RAINBOW_ONWEBRTCMEDIADEVICECHANGED = 'rainbowonwebrtcmediadevicechanged';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCERRORHANDLED\n     * @param {Object} error A JSON object containing a description of the error\n     * @description\n     *      This event is fired when a webrtc error is catched\n     */\n\n    this.RAINBOW_ONWEBRTCERRORHANDLED = 'rainbowonwebrtcerrorhandled';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCSTREAMADDED\n     * @param {Streams} streams The WebRTC streams added\n     * @description\n     *      This event is fired when a remote stream is added to the peer connection. Generally speaking, this event is fired only once at the beginning of the call when the peer connection received the remote stream.\n     */\n\n    this.RAINBOW_ONWEBRTCSTREAMADDED = 'rainbowonwebrtcstreamadded';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTRACKCHANGED\n     * @param {Track}\n     * @description\n     *      This event is fired when the tracks changed (eg. escalade from audio to audio and video)\n     */\n\n    this.RAINBOW_ONWEBRTCTRACKCHANGED = 'rainbowonwebrtctrackchanged';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTMEDIAERROROCCURED\n     * @param {Object} error A JSON object containing a description of the error\n     * @description\n     *      This event is fired when there is an error accessing the media device (eg. can't access to the camera...)\n     */\n\n    this.RAINBOW_ONWEBRTCTMEDIAERROROCCURED = 'rainbowonwebrtcmediaerroroccured';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTRECORDSTARTED\n     * @since 1.48\n     * @description\n     *      This event is fired when the recordind of the call has been started\n     */\n\n    this.RAINBOW_ONWEBRTCTRECORDSTARTED = 'rainbowonwebrtcrecordstarted';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTRECORDSTOPPED\n     * @since 1.48\n     * @description\n     *      This event is fired when the recording of the call has been stopped\n     */\n\n    this.RAINBOW_ONWEBRTCTRECORDSTOPPED = 'rainbowonwebrtcrecordstopped';\n    /**\n     * @private\n     * @event RAINBOW_ONWEBRTCTRECORDPAUSED\n     * @since 1.48\n     * @description\n     *      This event is fired when the recording of the call has been paused\n     */\n\n    this.RAINBOW_ONWEBRTCTRECORDPAUSED = 'rainbowonwebrtcrecordpaused';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTRECORDREMOTESTARTED\n     * @since 1.48\n     * @description\n     *      This event is fired when the recordind of the call has been started by the recipient\n     */\n\n    this.RAINBOW_ONWEBRTCTRECORDREMOTESTARTED = 'rainbowonwebrtcrecordremotestarted';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTRECORDREMOTESTOPPED\n     * @since 1.48\n     * @description\n     *      This event is fired when the recordind of the call has been stopped by the recipient\n     */\n\n    this.RAINBOW_ONWEBRTCTRECORDREMOTESTOPPED = 'rainbowonwebrtcrecordremotestopped';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTRECORDDONE\n     * @since 1.48\n     * @param {Object} description A JSON object containing a description of the file\n     * @param {Blob} data The record\n     * @param {String} source 'LOCAL' for a local recording or 'REMOTE' for a recording of the recipient\n     * @description\n     *      This event is fired when the recording of the call has been successfully saved\n     */\n\n    this.RAINBOW_ONWEBRTCTRECORDDONE = 'rainbowonwebrtcrecorddone';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCTRECORDERROR\n     * @since 1.48\n     * @description\n     *      This event is fired when there is an error during the recording of the call\n     */\n\n    this.RAINBOW_ONWEBRTCTRECORDERROR = 'rainbowonwebrtcrecorderror';\n    /**\n     * @public\n     * @method canMakeAudioVideoCall\n     * @instance\n     * @description\n     *    Return true if the browser can use WebRTC to make audio and video call AND the page uses HTTPS protocol\n     * @return {boolean} True if audio and video calls are supported\n     */\n\n    this.canMakeAudioVideoCall = this.canMakeAudioVideoCall.bind(this);\n    /**\n     * @public\n     * @method hasAMicrophone\n     * @instance\n     * @description\n     *    Return true if at least one microphone is detected and can be used\n     * @return {boolean} True if a microphone has been detected\n     */\n\n    this.hasAMicrophone = this.hasAMicrophone.bind(this);\n    /**\n     * @method hasACamera\n     * @instance\n     * @description\n     *    Return true if at least one camera is detected and can be used\n     * @return {boolean} True if a camera has been detected\n     */\n\n    this.hasACamera = this.hasACamera.bind(this);\n    /**\n     * @public\n     * @method useMicrophone\n     * @since 1.17\n     * @instance\n     * @description\n     *    Set the microphone to use\n     * @param {string} strMicrophoneId     The id of the microphone to use\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.useMicrophone = this.useMicrophone.bind(this);\n    /**\n     * @public\n     * @method useSpeaker\n     * @since 1.17\n     * @instance\n     * @description\n     *    Set the speaker to use\n     * @param {String} strSpeakerId     The id of the speaker to use\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.useSpeaker = this.useSpeaker.bind(this);\n    /**\n     * @public\n     * @method useCamera\n     * @since 1.17.0\n     * @instance\n     * @description\n     *    set the camera to use\n     * @param {String} strCameraId     The id of the camera to use\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.useCamera = this.useCamera.bind(this);\n    /**\n     * @public\n     * @method callInAudio\n     * @instance\n     * @description\n     *    Call a contact in audio only using WebRTC <br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Contact} contact     The contact to call in audio\n     * @param {String} [subject=\"\"]     [optional] add a subject/correlator to the call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.callInAudio = this.callInAudio.bind(this);\n    /**\n     * @public\n     * @method callInVideo\n     * @instance\n     * @description\n     *    Call a contact in audio & video using WebRTC<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Contact} contact     The contact to call in video\n     * @param {String} [subject=\"\"]     [optional] add a subject/correlator to the call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.callInVideo = this.callInVideo.bind(this);\n    /**\n     * @public\n     * @method callInSharing\n     * @instance\n     * @description\n     *    Call a contact in sharing without audio using WebRTC<br>\n     *    Use setChromeExtensionIdForSharing prior this method<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Contact} contact     The contact to call in sharing\n     * @param {String} [subject=\"\"]     [optional] add a subject/correlator to the call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.callInSharing = this.callInSharing.bind(this);\n    /**\n     * @public\n     * @method callinAudioWithSharing\n     * @instance\n     * @description\n     *    Call a contact in sharing with audio using WebRTC<br>\n     *    Use setChromeExtensionIdForSharing prior this method<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Contact} contact     The contact to call in sharing\n     * @param {String} [subject]     [optional] add a subject/correlator to the call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.callinAudioWithSharing = this.callinAudioWithSharing.bind(this);\n    /**\n     * @public\n     * @method answerInAudio\n     * @instance\n     * @description\n     *    Answer a call in audio only using WebRTC<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Call} call   The call to answer\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.answerInAudio = this.answerInAudio.bind(this);\n    /**\n     * @public\n     * @method answerInVideo\n     * @instance\n     * @description\n     *    Answer a call in audio & video using WebRTC<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Call} call   The call to answer\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.answerInVideo = this.answerInVideo.bind(this);\n    /**\n     * @public\n     * @method getPeerConnectionForCall\n     * @since 1.52\n     * @instance\n     * @description get the call's peerconnection object containing the statistics\n     * @param {Call} call   The call object\n     * @return {Object} return the peerconnection object\n     */\n\n    this.getPeerConnectionForCall = this.getPeerConnectionForCall.bind(this);\n    /**\n     * @public\n     * @method showLocalVideo\n     * @instance\n     * @description\n     *    Display the local video (Picture in picture)<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.showLocalVideo = this.showLocalVideo.bind(this);\n    /**\n     * @public\n     * @method hideLocalVideo\n     * @instance\n     * @description\n     *    Hide the local video (Picture in picture)<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.hideLocalVideo = this.hideLocalVideo.bind(this);\n    /**\n     * @public\n     * @method showRemoteVideo\n     * @instance\n     * @description\n     *    Show the remote video associated to the call<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Call} call   The call to show\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.showRemoteVideo = this.showRemoteVideo.bind(this);\n    /**\n     * @public\n     * @method hideRemoteVideo\n     * @instance\n     * @description\n     *    Hide the remote video associated to the call<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Call} call   The call to show\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.hideRemoteVideo = this.hideRemoteVideo.bind(this);\n    /**\n     * @public\n     * @method addVideoToCall\n     * @instance\n     * @description\n     *    Add the video to an existing call<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Call} call   The call to escalade to video\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.addVideoToCall = this.addVideoToCall.bind(this);\n    /**\n     * @public\n     * @method addSharingToCall\n     * @instance\n     * @description\n     *    Add the sharing to an existing call<br>\n     *    Use setChromeExtensionIdForSharing prior this method<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Call} call   The call to escalade to sharing\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.addSharingToCall = this.addSharingToCall.bind(this);\n    /**\n     * @public\n     * @method removeVideoFromCall\n     * @instance\n     * @description\n     *    Remove the video from the call<br>\n     *    Not supported on IE 11\n     *    canMakeAudioVideoCall() must be true<br>\n     * @param {Call} call   The call to remove the video\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.removeVideoFromCall = this.removeVideoFromCall.bind(this);\n    /**\n     * @public\n     * @method removeSharingFromCall\n     * @instance\n     * @description\n     *    Remove the sharing to an existing call<br>\n     *    Use setChromeExtensionIdForSharing prior this method<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @param {Call} call   The call where sharing should be removed\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.removeSharingFromCall = this.removeSharingFromCall.bind(this);\n    /**\n     * @public\n     * @method release\n     * @instance\n     * @description\n     *    Release a call\n     *    canMakeAudioVideoCall() may be false to allow to reject an incoming all as if WebRTC is not supported.<br>\n     * @param {Call} call   The call to release\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.release = this.release.bind(this);\n    /**\n     * @public\n     * @method muteAudioCall\n     * @instance\n     * @description\n     *    Mute an audio only call\n     *    canMakeAudioVideoCall() must be true<br>\n     * @param {Conversation} conversation   The conversation to mute\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.muteAudioCall = this.muteAudioCall.bind(this);\n    /**\n     * @public\n     * @method muteVideoCall\n     * @instance\n     * @description\n     *    Mute an audio/video call\n     *    canMakeAudioVideoCall() must be true<br>\n     * @param {Conversation} conversation   The conversation to mute\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.muteVideoCall = this.muteVideoCall.bind(this);\n    /**\n     * @public\n     * @method unmuteAudioCall\n     * @instance\n     * @description\n     *    Unmute an audio only call\n     *    canMakeAudioVideoCall() must be true<br>\n     * @param {Conversation} conversation   The conversation to unmute\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.unmuteAudioCall = this.unmuteAudioCall.bind(this);\n    /**\n     * @public\n     * @method unmuteVideoCall\n     * @instance\n     * @description\n     *    Unmute an audio/video call\n     *    canMakeAudioVideoCall() must be true<br>\n     * @param {Conversation} conversation   The conversation to unmute\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.unmuteVideoCall = this.unmuteVideoCall.bind(this);\n    /**\n     * @public\n     * @method getLocalStreamsFromCall\n     * @since 1.22.0\n     * @instance\n     * @description\n     *    Get the local streams associated to this call (for advanced webRTC developers)\n     * @param {Call} call     The call to get the streams\n     * @return {MediaStream[]} Return an array of local streams (MediaStream)\n     */\n\n    this.getLocalStreamsFromCall = this.getLocalStreamsFromCall.bind(this);\n    /**\n     * @public\n     * @method getRemoteStreamsFromCall\n     * @since 1.22.0\n     * @instance\n     * @description\n     *    Get the remote streams associated to this call (for advanced WebRTC developers)\n     * @param {Call} call     The call to get the streams\n     * @return {MediaStream[]} Return an array of remote streams (MediaStream)\n     */\n\n    this.getRemoteStreamsFromCall = this.getRemoteStreamsFromCall.bind(this);\n    /**\n     * @public\n     * @method setChromeExtensionIdForSharing\n     * @instance\n     * @description\n     *    Set Chrome extension Id for desktop sharing<br>\n     *    Only supported on Chrome<br>\n     *    /!\\ Must be used before any other request\n     * @param {String} strExtensionId    Chrome Extension ID for desktop sharing\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.setChromeExtensionIdForSharing = this.setChromeExtensionIdForSharing.bind(this);\n    /**\n     * @public\n     * @method canMakeDesktopSharingCall\n     * @since 1.29.0\n     * @instance\n     * @description\n     *    Check if the desktop sharing extension is installed or not (Chrome only)<br>\n     *    Call setChromeExtensionIdForSharing prior this method\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.canMakeDesktopSharingCall = this.canMakeDesktopSharingCall.bind(this);\n    /**\n     * @public\n     * @method startRecording\n     * @since 1.48.0\n     * @instance\n     * @description\n     *  Start to record a WebRTC call. <br/>\n     *  Only works for call with a single recipient (not when in conferencing)\n     * @param {Call} call   The call to record\n     * @param {String} fileName     The name of the file\n     * @param {Boolean} [recordRemote = true]   True to record the remote stream, false to record the local stream\n     * @param {Boolean} [toUpload = true] True to upload the record to Rainbow cloud storage, false to save the file locally\n     * @param {Boolean} [onlyAudio = false] True to record only the audio leg, false to record audio and video leg\n     * @param {String} [mimeType = \"video/webm;codecs=vp9\"] Mimetype of the recorded file. Other supported formats are 'video/webm;codecs=vp8', 'video/webm;codecs=h264', 'video/mpeg', 'video/webm' and `audio/webm`\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.startRecording = this.startRecording.bind(this);\n    /**\n     * @public\n     * @method stopRecording\n     * @since 1.48.0\n     * @instance\n     * @description\n     *  Start to record a conversation.\n     * @param {Call} call   The recorded call\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.stopRecording = this.stopRecording.bind(this);\n    /* WEBRTC SERVICE EVENT LISTENERS */\n\n    $rootScope.$on('$destroy', $rootScope.$on('ON_CALL_UPDATED_EVENT', function (event, call) {\n      return _this.onWebRTCCallChanged(event, call);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_WEBRTC_CALL_ERROR_EVENT', function (event, error) {\n      return _this.onWebRTCErrorHandled(event, error);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_WEBRTC_REMOTE_STREAM_ADDED', function (event, streams) {\n      return _this.onWebRTCRemoteStreamAdded(event, streams);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_WEBRTC_CALL_ESCALATION_SUCCESS', function (event, call) {\n      return _this.onWebRTCEscalation(event, call);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_WEBRTC_GETUSERMEDIA_ERROR', function (event, error) {\n      return _this.onWebRTCGetUserMediaError(event, error);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_WEBRTC_RECORD_SAVED', function (event, description, data, source) {\n      return _this.onWebRTCRecordingData(event, description, data, source);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_WEBRTC_RECORD_ERROR', function () {\n      return _this.onWebRTCRecordingError();\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_RECORDING_START_MSG_RECEIVED', function () {\n      return _this.onWebRTCRecordingStartedByRemote();\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_RECORDING_STOP_MSG_RECEIVED', function () {\n      return _this.onWebRTCRecordingStoppedByRemote();\n    }));\n  }\n\n  webRTCService_createClass(WebRTCService, [{\n    key: \"onWebRTCCallChanged\",\n    value: function onWebRTCCallChanged(event, call) {\n      var Call = webRTCService_Call.get(this); // Only deals with event of type call\n\n\n      if (call.type.value === Call.Type.WEBRTC.value) {\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCCALLSTATECHANGED, {\n          detail: call\n        });\n        document.dispatchEvent(sdkEvent);\n      }\n    }\n  }, {\n    key: \"onWebRTCErrorHandled\",\n    value: function onWebRTCErrorHandled(event, error) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCERRORHANDLED, {\n        detail: error\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onWebRTCRemoteStreamAdded\",\n    value: function onWebRTCRemoteStreamAdded(event, streams) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCSTREAMADDED, {\n        detail: streams\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onWebRTCEscalation\",\n    value: function onWebRTCEscalation(event, call) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCTRACKCHANGED, {\n        detail: call\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onWebRTCGetUserMediaError\",\n    value: function onWebRTCGetUserMediaError(event, error) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCMEDIAERROROCCURED, {\n        detail: error\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onWebRTCRecordingData\",\n    value: function onWebRTCRecordingData(event, description, data, source) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCTRECORDDONE, {\n        detail: [description, data, source]\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onWebRTCRecordingError\",\n    value: function onWebRTCRecordingError() {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCTRECORDERROR, {\n        detail: null\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onWebRTCRecordingStartedByRemote\",\n    value: function onWebRTCRecordingStartedByRemote() {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCTRECORDREMOTESTARTED, {\n        detail: null\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onWebRTCRecordingStoppedByRemote\",\n    value: function onWebRTCRecordingStoppedByRemote() {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCTRECORDREMOTESTOPPED, {\n        detail: null\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n    /* WEBRTC SERVICE METHODS */\n\n  }, {\n    key: \"canMakeAudioVideoCall\",\n    value: function canMakeAudioVideoCall() {\n      return (location.protocol === 'https:' || location.protocol === 'chrome-extension:') && DetectRTC.isWebRTCSupported && DetectRTC.isGetUserMediaSupported;\n    }\n  }, {\n    key: \"hasAMicrophone\",\n    value: function hasAMicrophone() {\n      return DetectRTC.hasMicrophone;\n    }\n  }, {\n    key: \"hasACamera\",\n    value: function hasACamera() {\n      return DetectRTC.hasWebcam;\n    }\n  }, {\n    key: \"useMicrophone\",\n    value: function useMicrophone(strMicrophoneId) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var settingsService = _settingsService.get(this);\n\n      if (!strMicrophoneId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strMicrophoneId' is missing or empty\"\n        };\n      }\n\n      settingsService.setSetting('microphone', strMicrophoneId);\n      settingsService.setSetting('headsetMicrophone', strMicrophoneId);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"useSpeaker\",\n    value: function useSpeaker(strSpeakerId) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var settingsService = _settingsService.get(this);\n\n      var platformService = webRTCService_platformService.get(this);\n\n      if (!strSpeakerId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strSpeakerId' is missing or empty\"\n        };\n      }\n\n      settingsService.setSetting('speaker', strSpeakerId);\n      settingsService.setSetting('headsetSpeaker', strSpeakerId);\n      settingsService.setSetting('ringingSpeaker', strSpeakerId);\n      platformService.setSpeakerForElement(document.getElementById('largevideo'), strSpeakerId);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"useCamera\",\n    value: function useCamera(strCameraId) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var settingsService = _settingsService.get(this);\n\n      if (!strCameraId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strCameraId' is missing or empty\"\n        };\n      }\n\n      settingsService.setSetting('camera', strCameraId);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"callInAudio\",\n    value: function callInAudio(contact, subject) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!contact) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'contact' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.makeCall(contact, 'audio', subject);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"callInVideo\",\n    value: function callInVideo(contact, subject) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!contact) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'contact' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.makeCall(contact, 'video', subject);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"callInSharing\",\n    value: function callInSharing(contact, subject) {\n      var _this2 = this;\n\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      var userAgent = navigator.userAgent;\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (userAgent.indexOf('Chrome') > -1) {\n          // check Chrome Version (starting version 73 there's no need for having an extension set)\n          var raw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n\n          if (parseInt(raw[2], 10) > 72) {\n            videoService.makeDesktopSharingCall(contact, 'sharingOnly', subject);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          } else {\n            _this2.canMakeDesktopSharingCall().then(function () {\n              videoService.makeDesktopSharingCall(contact, 'sharingOnly', subject);\n              return resolve({\n                code: SDK.OK,\n                label: 'OK'\n              });\n            })[\"catch\"](function (err) {\n              return reject(err);\n            });\n          }\n        } else {\n          videoService.makeDesktopSharingCall(contact, 'sharingOnly', subject);\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        }\n      });\n    }\n  }, {\n    key: \"callinAudioWithSharing\",\n    value: function callinAudioWithSharing(contact, subject) {\n      var _this3 = this;\n\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      var userAgent = navigator.userAgent;\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (userAgent.indexOf('Chrome') > -1) {\n          // check Chrome Version (starting version 73 there's no need for having an extension set)\n          var raw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n\n          if (parseInt(raw[2], 10) > 72) {\n            videoService.makeDesktopSharingCall(contact, subject);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          } else {\n            _this3.canMakeDesktopSharingCall().then(function () {\n              videoService.makeDesktopSharingCall(contact, subject);\n              return resolve({\n                code: SDK.OK,\n                label: 'OK'\n              });\n            })[\"catch\"](function (err) {\n              return reject(err);\n            });\n          }\n        } else {\n          videoService.makeDesktopSharingCall(contact, subject);\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        }\n      });\n    }\n  }, {\n    key: \"answerInAudio\",\n    value: function answerInAudio(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!call) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.answerCall(call, 'audio');\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"answerInVideo\",\n    value: function answerInVideo(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!call) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.answerCall(call, 'video');\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"getPeerConnectionForCall\",\n    value: function getPeerConnectionForCall(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var XMPPService = _XMPPService.get(this);\n\n      if (!call) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or null\"\n        };\n      } else if (!call.id) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: 'Can not get the call ID'\n        };\n      }\n\n      var sess = XMPPService.connection.jingle.sessions[call.id];\n      return sess.peerconnection;\n    }\n  }, {\n    key: \"showLocalVideo\",\n    value: function showLocalVideo() {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.attachLocalMediaStreams(true);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"hideLocalVideo\",\n    value: function hideLocalVideo() {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.attachLocalMediaStreams(false);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"showRemoteVideo\",\n    value: function showRemoteVideo(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!call) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.attachDistantMediaStreams(true, call);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"hideRemoteVideo\",\n    value: function hideRemoteVideo(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!call) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.attachDistantMediaStreams(false, call);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"addVideoToCall\",\n    value: function addVideoToCall(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.addVideoToCall(call, false);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"addSharingToCall\",\n    value: function addSharingToCall(call) {\n      var _this4 = this;\n\n      var videoService = webRTCService_videoService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var userAgent = navigator.userAgent;\n\n        if (!call) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'call' is missing or null\"\n          });\n        }\n\n        if (userAgent.indexOf('Chrome') > -1) {\n          var raw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n\n          if (parseInt(raw[2], 10) > 72) {\n            videoService.addSharingToCall(call);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          } else {\n            _this4.canMakeDesktopSharingCall().then(function () {\n              videoService.addSharingToCall(call);\n              return resolve({\n                code: SDK.OK,\n                label: 'OK'\n              });\n            })[\"catch\"](function (err) {\n              return reject(err);\n            });\n          }\n        } else {\n          videoService.addSharingToCall(call);\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        }\n      });\n    }\n  }, {\n    key: \"removeVideoFromCall\",\n    value: function removeVideoFromCall(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var videoService = webRTCService_videoService.get(this);\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.removeVideoFromCall(call);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"removeSharingFromCall\",\n    value: function removeSharingFromCall(call) {\n      var videoService = webRTCService_videoService.get(this);\n\n      var SDK = webRTCService_SDK.get(this); // if (!this.canMakeAudioVideoCall() && !this.isChromeExtensionInstalled) {\n      // return {\n      // code: SDK.ERRORUNSUPPORTED,\n      // label: 'WebRTC or Sharing is not supported by your browser'\n      // };\n      // }\n\n\n      videoService.removeSharingFromCall(call);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"release\",\n    value: function release(call) {\n      var videoService = webRTCService_videoService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      var $log = webRTCService_$log.get(this);\n\n      if (!call) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        $log.warn('[webRTCService] release called but WebRTC is not supported by your browser');\n      }\n\n      videoService.rejectCall(call);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"muteAudioCall\",\n    value: function muteAudioCall(conversation) {\n      var videoService = webRTCService_videoService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.muteAudio(conversation, true);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"muteVideoCall\",\n    value: function muteVideoCall(conversation) {\n      var videoService = webRTCService_videoService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.muteVideo(conversation, true);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"unmuteAudioCall\",\n    value: function unmuteAudioCall(conversation) {\n      var videoService = webRTCService_videoService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.muteAudio(conversation, false);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"unmuteVideoCall\",\n    value: function unmuteVideoCall(conversation) {\n      var videoService = webRTCService_videoService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      if (!conversation) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'conversation' is missing or null\"\n        };\n      }\n\n      if (!this.canMakeAudioVideoCall()) {\n        return {\n          code: SDK.ERRORUNSUPPORTED,\n          label: 'WebRTC is not supported by your browser'\n        };\n      }\n\n      videoService.muteVideo(conversation, false);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"getLocalStreamsFromCall\",\n    value: function getLocalStreamsFromCall(call) {\n      var XMPPService = _XMPPService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      var Call = webRTCService_Call.get(this);\n\n      if (!call || !('id' in call)) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or empty\"\n        };\n      }\n\n      if (call.type !== Call.Type.WEBRTC) {\n        return {\n          code: SDK.ERRORNOTFOUND,\n          label: 'This call is not an audio or audio/video call'\n        };\n      }\n\n      var session = XMPPService.connection.jingle.sessions[call.id];\n\n      if (session) {\n        return session.localStreams;\n      }\n\n      return [];\n    }\n  }, {\n    key: \"getRemoteStreamsFromCall\",\n    value: function getRemoteStreamsFromCall(call) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var Call = webRTCService_Call.get(this);\n\n      var XMPPService = _XMPPService.get(this);\n\n      if (!call || !('id' in call)) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or empty\"\n        };\n      }\n\n      if (call.type !== Call.Type.WEBRTC) {\n        return {\n          code: SDK.ERRORNOTFOUND,\n          label: 'This call is not an audio or audio/video call'\n        };\n      }\n\n      var session = XMPPService.connection.jingle.sessions[call.id];\n\n      if (session) {\n        return session.remoteStreams;\n      }\n\n      return [];\n    }\n  }, {\n    key: \"setChromeExtensionIdForSharing\",\n    value: function setChromeExtensionIdForSharing(strExtensionId) {\n      var SDK = webRTCService_SDK.get(this);\n\n      var extensionSharingService = _extensionSharingService.get(this);\n\n      if (!strExtensionId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strExtensionId' is missing or empty\"\n        };\n      }\n\n      extensionSharingService.setExtensionId(strExtensionId);\n      extensionSharingService.start();\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"canMakeDesktopSharingCall\",\n    value: function canMakeDesktopSharingCall() {\n      var _this5 = this;\n\n      var extensionSharingService = _extensionSharingService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        extensionSharingService.isExtensionInstalled().then(function (isInstalled) {\n          if (isInstalled) {\n            _this5.isChromeExtensionInstalled = true;\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          } else {\n            _this5.isChromeExtensionInstalled = false;\n            return reject({\n              code: SDK.ERRORUNSUPPORTED,\n              label: 'Not Chrome Extension installed for desktop sharing'\n            });\n          }\n        })[\"catch\"](function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"startRecording\",\n    value: function startRecording(call, fileName, recordRemote, toUpload, onlyAudio, mimeType) {\n      var _this6 = this;\n\n      var $log = webRTCService_$log.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      var recordsService = webRTCService_recordsService.get(this);\n\n      var conversationService = webRTCService_conversationService.get(this);\n\n      $log.sdk(this.logService + '[startRecording] :: Enter');\n\n      if (!call) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'call' is missing or null\"\n        };\n      }\n\n      if (!fileName) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'fileName' is missing or null\"\n        };\n      }\n\n      recordRemote = recordRemote === undefined || recordRemote === null ? true : recordRemote;\n      toUpload = toUpload === undefined || toUpload === null ? true : toUpload;\n      onlyAudio = onlyAudio === undefined || onlyAudio === null ? false : onlyAudio;\n      mimeType = mimeType === undefined || mimeType === null ? 'video/webm;codecs=vp9' : mimeType;\n      $log.sdk(this.logService + '[startRecording] :: Prepare recording...');\n      var res = recordsService.createRecord(call.id, recordRemote ? 'REMOTE' : 'LOCAL', toUpload, fileName, onlyAudio, mimeType);\n\n      if (res) {\n        recordsService.setOnPauseCallback(function () {\n          $log.sdk(_this6.logService + '[onRTCChange] :: WebRTC recording paused');\n          $(document).trigger(_this6.RAINBOW_ONWEBRTCTRECORDPAUSED, null);\n        });\n        $log.sdk(this.logService + '[startRecording] :: Start recording');\n        recordsService.startRecording();\n        var conversation = conversationService.getConversationById(call.conversationId);\n\n        if (conversation) {\n          $log.sdk(this.logService + '[startRecording] :: Notify remote peer', conversation);\n          conversationService.sendRecordingMessage(conversation, 'start');\n        } else {\n          $log.sdk(this.logService + \"[startRecording] :: No conversation found - can't notify remote peer\");\n        }\n\n        $log.sdk(this.logService + '[startRecording] :: WebRTC recording started');\n        $(document).trigger(this.RAINBOW_ONWEBRTCTRECORDSTARTED, null);\n        return {\n          code: SDK.OK,\n          label: 'OK'\n        };\n      } else {\n        $log.sdk(this.logService + \"[startRecording] :: can't start a webRTC recording\");\n        $(document).trigger(this.RAINBOW_ONWEBRTCTRECORDERROR, null);\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Can't record the conversation\"\n        };\n      }\n    }\n  }, {\n    key: \"stopRecording\",\n    value: function stopRecording(call) {\n      var $log = webRTCService_$log.get(this);\n\n      var recordsService = webRTCService_recordsService.get(this);\n\n      var conversationService = webRTCService_conversationService.get(this);\n\n      var SDK = webRTCService_SDK.get(this);\n\n      $log.sdk(this.logService + '[stopRecording] :: Stop current WebRTC recording');\n      recordsService.setOnPauseCallback(null);\n      recordsService.stopRecording();\n      var conversation = conversationService.getConversationById(call.conversationId);\n\n      if (conversation) {\n        $log.sdk(this.logService + '[stopRecording] :: Notify remote peer', conversation);\n        conversationService.sendRecordingMessage(conversation, 'stop');\n      } else {\n        $log.sdk(this.logService + \"[stopRecording] :: No conversation found - can't notify remote peer\");\n      }\n\n      $(document).trigger(this.RAINBOW_ONWEBRTCTRECORDSTOPPED, null);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }]);\n\n  return WebRTCService;\n}();\n// CONCATENATED MODULE: ./src/bubblesService.js\nfunction bubblesService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction bubblesService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction bubblesService_createClass(Constructor, protoProps, staticProps) { if (protoProps) bubblesService_defineProperties(Constructor.prototype, protoProps); if (staticProps) bubblesService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Bubbles\n * @public\n * @description\n *      This service manages multi-party communications in Rainbow (aka bubbles). Bubbles allow to chat and to share files with several participants.<br><br>\n *      Each user can create bubbles and invite other Rainbow users to be part of it. Without being invited, users can join a bubble.<br><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Create new bubbles, <br/>\n *      - Invite and manage participants in your bubbles, <br/>\n *      - Accept or decline invites received from bubbles, <br/>\n *      - Leave, close or remove your bubbles <br/>\n *      <br/>\n *      Note: for WebRtc Conference and Desktop Sharing (rights and specific Chrome extension) please have a look at [Making audio and video calls]{@link https://hub.openrainbow.com/#/documentation/doc/sdk/web/guides/Initiating_audio_and_video_calls}<br/>\n * @fires RAINBOW_ONBUBBLEUPDATED\n * @fires RAINBOW_ONBUBBLEAVATARUPDATED\n * @fires RAINBOW_ONBUBBLEINVITATIONTOJOINRECEIVED\n * @fires RAINBOW_ONBUBBLECONFERENCESTARTEDINVITATIONRECEIVED\n * @fires RAINBOW_ONBUBBLECONFERENCETALKERACTIVE\n * @fires RAINBOW_ONBUBBLESHARINGCONFERENCESTARTEDINVITATIONRECEIVED\n * @fires RAINBOW_ONWEBCONFERENCEUPDATED\n * @fires RAINBOW_ONWEBRTCMEDIAERROROCCURED\n * @fires RAINBOW_ONBUBBLEDEACTIVATED\n */\nvar bubblesService_$log = new WeakMap();\n\nvar bubblesService_roomService = new WeakMap();\n\nvar bubblesService_videoService = new WeakMap();\n\nvar bubblesService_conversationService = new WeakMap();\n\nvar bubblesService_contactService = new WeakMap();\n\nvar bubblesService_conferenceService = new WeakMap();\n\nvar bubblesService_profileService = new WeakMap();\n\nvar bubblesService_webConferenceService = new WeakMap();\n\nvar _PromiseQueue = new WeakMap();\n\nvar bubblesService_SDK = new WeakMap();\n\nvar _Room = new WeakMap();\n\nvar bubblesService_$rootScope = new WeakMap();\n\nvar BubblesService =\n/*#__PURE__*/\nfunction () {\n  bubblesService_createClass(BubblesService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', 'roomService', 'videoService', 'conversationService', 'contactService', 'conferenceService', 'profileService', 'webConferenceService', 'PromiseQueue', 'SDK', 'Room', '$rootScope'];\n    }\n  }]);\n\n  function BubblesService($log, roomService, videoService, conversationService, contactService, conferenceService, profileService, webConferenceService, PromiseQueue, SDK, Room, $rootScope) {\n    var _this = this;\n\n    bubblesService_classCallCheck(this, BubblesService);\n\n    this.logService = 'BubblesService | ';\n\n    bubblesService_$log.set(this, $log);\n\n    bubblesService_roomService.set(this, roomService);\n\n    bubblesService_videoService.set(this, videoService);\n\n    bubblesService_conversationService.set(this, conversationService);\n\n    bubblesService_contactService.set(this, contactService);\n\n    bubblesService_conferenceService.set(this, conferenceService);\n\n    bubblesService_profileService.set(this, profileService);\n\n    bubblesService_webConferenceService.set(this, webConferenceService);\n\n    _PromiseQueue.set(this, PromiseQueue);\n\n    bubblesService_SDK.set(this, SDK);\n\n    _Room.set(this, Room);\n\n    bubblesService_$rootScope.set(this, $rootScope);\n\n    this.confBubble = null;\n    this.confBubbleType = null;\n    /**\n     * @public\n     * @event RAINBOW_ONBUBBLEINVITATIONTOJOINRECEIVED\n     * @param {Room} bubble The bubble to join\n     * @description\n     *      This event is fired when an invitation to join a bubble is received<br>\n     *      The event contains a **Bubble** object.\n     */\n\n    this.RAINBOW_ONBUBBLEINVITATIONTOJOINRECEIVED = 'rainbowbubblerequesttojoin';\n    /**\n     * @public\n     * @event RAINBOW_ONBUBBLEUPDATED\n     * @param {Room} bubble The bubble updated\n     * @description\n     *      This event is fired when a bubble is updated (e.g. user has accepted to join the bubble, bubble information changed...)\n     *      The event contains a **Bubble** object.\n     */\n\n    this.RAINBOW_ONBUBBLEUPDATED = 'rainbowbubbleupdated';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBCONFERENCEUPDATED\n     * @param {conferenceSession} conferenceSession The conferenceSession updated\n     * @description\n     *      This event is fired when a conference session is updated (e.g. user has started web conference etc.)\n     *      The event contains a **conferenceSession** object.\n     */\n\n    this.RAINBOW_ONWEBCONFERENCEUPDATED = 'rainbowwebconferenceupdated';\n    /**\n     * @public\n     * @event RAINBOW_ONWEBRTCMEDIAERROROCCURED\n     * @param {conferenceSession} conferenceSession The conferenceSession updated\n     * @description\n     *      This event is fired when a there is a problem with any of the media sources used in the Web RTC Conference.\n     *      The event contains a **conferenceSession** object.\n     */\n\n    this.RAINBOW_ONWEBRTCMEDIAERROROCCURED = 'rainbowwebrtcmediaerroroccured';\n    /**\n     * @public\n     * @event RAINBOW_ONBUBBLEAVATARUPDATED\n     * @param {Room} bubble The bubble whara there was an avatar update\n     * @description\n     *      This event is fired when a bubble avatar is updated or deleted\n     *      The event contains a **Bubble** object.\n     */\n\n    this.RAINBOW_ONBUBBLEAVATARUPDATED = 'rainbowbubbleavatarupdated';\n    /**\n     * @public\n     * @event RAINBOW_ONBUBBLECONFERENCESTARTEDINVITATIONRECEIVED\n     * @param {Room} bubble The bubble where the WebRTC conference started\n     * @description\n     *      This event is fired when a WebRTC conference was started in the given bubble.\n     *      You can then (or not) launch a [startOrJoinWebRtcConference] {@link https://hub.openrainbow.com/#/documentation/doc/sdk/web/api/bubbles#module_Bubbles.startOrJoinWebRtcConference}\n     *      The event contains a **Bubble** object.\n     */\n\n    this.RAINBOW_ONBUBBLECONFERENCESTARTEDINVITATIONRECEIVED = 'rainbowbubbleconferencestartinvitation';\n    /**\n     * @public\n     * @event RAINBOW_ONBUBBLECONFERENCETALKERACTIVE\n     * @param {Object} conferenceSession ConferenceSession object\n     * @description\n     *      This event is fired when a person starts or stops talking in a Conference (via audio input)\n     */\n\n    this.RAINBOW_ONBUBBLECONFERENCETALKERACTIVE = 'rainbowonbubbleconferencetalkeractive';\n    /**\n     * @public\n     * @event RAINBOW_ONBUBBLESHARINGCONFERENCESTARTEDINVITATIONRECEIVED\n     * @param {Room} bubble The bubble where the Sharing conference started\n     * @description\n     *      This event is fired when a Sharing conference was started in the given bubble.\n     *      You can then (or not) launch a [startOrJoinSharingWebRtcConference] {@link https://hub.openrainbow.com/#/documentation/doc/sdk/web/api/bubbles#module_Bubbles.startOrJoinSharingWebRtcConference}\n     *      The event contains a **Bubble** object.\n     */\n\n    this.RAINBOW_ONBUBBLESHARINGCONFERENCESTARTEDINVITATIONRECEIVED = 'rainbowbubblesharingconferencestartinvitation';\n    /**\n     * @public\n     * @event RAINBOW_ONBUBBLEDEACTIVATED\n     * @param {Room} bubble The bubble which has been deactivated\n     * @description\n     *      This event is fired when a Bubble's status has changed to inActive\n     *      The event contains a **Bubble** object.\n     */\n\n    this.RAINBOW_ONBUBBLEDEACTIVATED = 'rainbowonbubbledeactivated';\n    /**\n     * @public\n     * @method createBubble\n     * @instance\n     * @description\n     *    Create a new bubble <br/>\n     *    Return a promise.\n     * @param {string} strName The name of the bubble\n     * @param {string} strDescription The description of the bubble\n     * @param {boolean} [boolWithHistory=false] True to have full messages history for newcomers\n     * @param {boolean} [disableNotifications=false] When set to true, there is no more notifications to be sent by a room in all cases with text body (user join/leave, conference start/end)\n     * @param {string} [urlAvatar=null]  The avatar Url or null (in case of invalid url or image it mai fail)\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.createBubble = this.createBubble.bind(this);\n    /**\n     * @public\n     * @method deleteBubble\n     * @instance\n     * @description\n     *    Delete an existing owned bubble <br/>\n     *    Return a promise.\n     * @param {Room} bubble The bubble to remove\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.deleteBubble = this.deleteBubble.bind(this);\n    /**\n     * @public\n     * @method deleteAllBubbles\n     * @instance\n     * @description\n     *    Delete all existing owned bubbles <br/>\n     *    Return a promise\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.deleteAllBubbles = this.deleteAllBubbles.bind(this);\n    /**\n     * @public\n     * @method inviteContactToBubble\n     * @instance\n     * @description\n     *    Invite a contact to a bubble <br/>\n     *    Return a promise.\n     * @param {Contact} contact The contact to invite\n     * @param {Bubble} bubble   The destination bubble\n     * @param {Boolean} [boolAsModerator=false]   True to invite a contact as a moderator (false by default)\n     * @param {Boolean} [boolWithInvitation=true]  True to send an invitation or false to add someone directly in a bubble (true by default)\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.inviteContactToBubble = this.inviteContactToBubble.bind(this);\n    /**\n     * @public\n     * @method removeContactFromBubble\n     * @instance\n     * @description\n     *    Remove a contact from a bubble <br/>\n     *    Return a promise.\n     * @param {Contact} contact The contact to remove\n     * @param {Bubble} bubble   The destination bubble\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.removeContactFromBubble = this.removeContactFromBubble.bind(this);\n    /**\n     * @public\n     * @method promoteContactToModerator\n     * @instance\n     * @description\n     *    Promote a contact to moderator in a bubble <br/>\n     *    Return a promise.\n     * @param {Contact} contact The contact to promote\n     * @param {Bubble} bubble   The destination bubble\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.promoteContactToModerator = this.promoteContactToModerator.bind(this);\n    /**\n     * @public\n     * @method demoteContactFromModerator\n     * @instance\n     * @description\n     *    Demote a contact to moderator in a bubble <br/>\n     *    Return a promise.\n     * @param {Contact} contact The contact to promote\n     * @param {Bubble} bubble   The destination bubble\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.demoteContactFromModerator = this.demoteContactFromModerator.bind(this);\n    /**\n     * @public\n     * @method changeOwner\n     * @instance\n     * @description\n     *    Change the bubble owner<br/>\n     *    Warning: the caller MUST be the current owner and will lose his previous owner state.\n     *    Return a promise.\n     * @param {Contact} contact The contact to promote as owner\n     * @param {Bubble} bubble   The destination bubble\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.changeOwner = this.changeOwner.bind(this);\n    /**\n     * @public\n     * @method acceptInvitationToJoinBubble\n     * @instance\n     * @description\n     *    Accept an invitation to join a bubble <br/>\n     *    Return a promise.\n     * @param {Bubble} bubble   The destination bubble\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.acceptInvitationToJoinBubble = this.acceptInvitationToJoinBubble.bind(this);\n    /**\n     * @public\n     * @method declineInvitationToJoinBubble\n     * @instance\n     * @description\n     *    Decline an invitation to join a bubble <br/>\n     *    Return a promise.\n     * @param {Bubble} bubble   The destination bubble\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.declineInvitationToJoinBubble = this.declineInvitationToJoinBubble.bind(this);\n    /**\n     * @public\n     * @method leaveBubble\n     * @instance\n     * @description\n     *    Leave a joined or invited bubble <br/>\n     *    Return a promise.\n     * @param {Bubble} bubble   The bubble to leave\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.leaveBubble = this.leaveBubble.bind(this);\n    /**\n     * @public\n     * @method closeBubble\n     * @instance\n     * @description\n     *    Close a bubble <br/>\n     *    Return a promise\n     * @param {Bubble} bubble   The bubble to leave\n     * @return {Object|null} The bubble object or an error object depending on the result\n     */\n\n    this.closeBubble = this.closeBubble.bind(this);\n    /**\n     * @public\n     * @method isBubbleArchived\n     * @instance\n     * @description\n     *    Check if the Bubble is un Archive state (everybody unsubscribed) <br/>\n     * @return {Boolean} True if the Bubble is in archive state\n     */\n\n    this.isBubbleArchived = this.isBubbleArchived.bind(this);\n    /**\n     * @public\n     * @method getAllBubbles\n     * @instance\n     * @description\n     *    Get the list of bubbles where the user is <br/>\n     * @return {Bubble[]} An array containing the list of bubbles\n     */\n\n    this.getAllBubbles = this.getAllBubbles.bind(this);\n    /**\n     * @public\n     * @method getAllOwnedBubbles\n     * @instance\n     * @description\n     *    Get the list of bubbles created by the user <br/>\n     * @return {Bubble[]} An array of bubbles restricted to the ones owned by the user\n     */\n\n    this.getAllOwnedBubbles = this.getAllOwnedBubbles.bind(this);\n    /**\n     * @public\n     * @method getAllPendingBubbles\n     * @instance\n     * @description\n     *  Get the list of pending bubbles<br/>\n     *  This is the list of bubbles where the connected user has been invited and has not yet answered (accepted or declined)\n     * @return {Bubble[]} An array of pending bubbles to accept or decline\n     */\n\n    this.getAllPendingBubbles = this.getAllPendingBubbles.bind(this);\n    /**\n     * @public\n     * @method getAllInactiveBubbles\n     * @instance\n     * @description\n     *  Get the list of the inactive bubbles <br />\n     *  It is the list of bubbles with no activity since at least 60 days\n     *  @return {Bubble[]} An array of inactive bubbles\n     */\n\n    this.getAllInactiveBubbles = this.getAllInactiveBubbles.bind(this);\n    /**\n     * @public\n     * @method getBubbleById\n     * @instance\n     * @description\n     *    Get a bubble by its id\n     * @param {string} strBubbleId   The ID of the bubble to retrieve\n     * @return {Bubble} A bubble object of null if not found\n     */\n\n    this.getBubbleById = this.getBubbleById.bind(this);\n    /**\n     * @public\n     * @method updateDescriptionForBubble\n     * @since 1.21\n     * @instance\n     * @description\n     *    Update the description of the bubble  <br/>\n     *    Return a promise.\n     * @param {string} strDescription   The description of the bubble\n     * @param {Bubble} bubble   The bubble to update\n     * @return {Bubble} A bubble object of null if not found\n     */\n\n    this.updateDescriptionForBubble = this.updateDescriptionForBubble.bind(this);\n    /**\n     * @public\n     * @method updateAvatarForBubble\n     * @since 1.43\n     * @instance\n     * @description\n     *    Update the bubble avatar (from given URL) <br/>\n     *    The image will be automaticalle resized <br/>\n     *    /!\\ if URL isn't valid or given image isn't loadable, it'll fail <br/>\n     *    Return a promise.\n     * @param {string} urlAvatar  The avatarUrl\n     * @param {Bubble} bubble  The bubble to update\n     * @return {Bubble} A bubble object of null if not found\n     */\n\n    this.updateAvatarForBubble = this.updateAvatarForBubble.bind(this);\n    /**\n     * @public\n     * @method deleteAvatarFromBubble\n     * @since 1.43\n     * @instance\n     * @description\n     *    Delete the bubble avatar <br/>\n     *    Return a promise.\n     * @param {Bubble} bubble  The bubble to update\n     * @return {Bubble} A bubble object of null if not found deleteAvatarFromBubble\n     */\n\n    this.deleteAvatarFromBubble = this.deleteAvatarFromBubble.bind(this);\n    /**\n     * @public\n     * @method updateCustomDataForBubble\n     * @since 1.29\n     * @instance\n     * @description\n     *    Update the customData of the bubble  <br/>\n     *    Return a promise.\n     * @param {Object} customData\n     *    The customData to put to the bubble <br />\n     *    Example: { \"key1\" : 123, \"key2\" : \"a string\" }\n     * @param {Bubble} bubble   The bubble to update\n     * @return {Bubble} The updated Bubble\n     */\n\n    this.updateCustomDataForBubble = this.updateCustomDataForBubble.bind(this);\n    /**\n     * @public\n     * @method deleteCustomDataForBubble\n     * @since 1.29\n     * @instance\n     * @description\n     *    Delete the customData of the bubble  <br/>\n     *    Return a promise.\n     * @param {Bubble} bubble   The bubble to update\n     * @return {Bubble} The updated Bubble\n     */\n\n    this.deleteCustomDataForBubble = this.deleteCustomDataForBubble.bind(this); /////////////////////////////////////////////////////////\n    // SFU Part\n    // (Selective Forwarding Unit)\n    /////////////////////////////////////////////////////////\n\n    /**\n     * @public\n     * @method isWebRtcConferenceAllowed\n     * @since 1.40\n     * @instance\n     * @description\n     *    Return true if WebRTC conference is allowed for your user<br/>\n     *    Return a boolean.\n     * @return {Boolean} True if allowed\n     */\n\n    this.isWebRtcConferenceAllowed = this.isWebRtcConferenceAllowed.bind(this);\n    /**\n     * @public\n     * @method hasActiveConferenceSession\n     * @since 1.41\n     * @instance\n     * @description\n     *    Return true if you are already in a WebRTC Conference<br/>\n     *    Return a boolean.\n     * @return {Boolean} True if already un a WebRTC Conference\n     */\n\n    this.hasActiveConferenceSession = this.hasActiveConferenceSession.bind(this);\n    /**\n     * @public\n     * @method getWebRtcConferenceBubble\n     * @since 1.41\n     * @instance\n     * @description\n     *    Return if any, the Bubble in which the WebRTC Conference is active<br/>\n     * @return {Bubble} The Bubble\n     */\n\n    this.getWebRtcConferenceBubble = this.getWebRtcConferenceBubble.bind(this);\n    /**\n     * @public\n     * @method startOrJoinWebRtcConference\n     * @since 1.41\n     * @instance\n     * @description\n     *    Join or start a WebRTC Conference<br/>\n     *    /!\\ you can't be in a call or in another WebRTC conference<br/>\n     *    Return a Promise.\n     * @param {Bubble} bubble   The bubble where do you want to launch the WebRTC Conference\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.startOrJoinWebRtcConference = this.startOrJoinWebRtcConference.bind(this);\n    /**\n     * @public\n     * @method addMediaToConferenceSession\n     * @since 1.50\n     * @instance\n     * @description Adding video leg to the conference\n     * @param conferenceSession - conference session retrieved from the event listener\n     * @return {conferenceSession} conferenceSession with updated information if everything went well\n     */\n\n    this.addMediaToConferenceSession = this.addMediaToConferenceSession.bind(this);\n    /**\n     * @public\n     * @method addSharingToConferenceSession\n     * @since 1.55\n     * @instance\n     * @description Adding screen sharing leg to the conference\n     * @param conferenceSession - conference session retrieved from the event listener\n     * @return {conferenceSession} conferenceSession with updated information if everything went well\n     */\n\n    this.addSharingToConferenceSession = this.addSharingToConferenceSession.bind(this);\n    /**\n     * @public\n     * @method removeMediaFromConferenceSession\n     * @since 1.50\n     * @instance\n     * @description Removing local video leg from the conference\n     * @param conferenceSession - conference session retrieved from the event listener\n     * @return {conferenceSession} conferenceSession with updated information if everything went well\n     */\n\n    this.removeMediaFromConferenceSession = this.removeMediaFromConferenceSession.bind(this);\n    /**\n     * @public\n     * @method removeSharingFromConferenceSession\n     * @since 1.55\n     * @instance\n     * @description Removing local sharing leg from the conference\n     * @param conferenceSession - conference session retrieved from the event listener\n     * @return {conferenceSession} conferenceSession with updated information if everything went well\n     */\n\n    this.removeSharingFromConferenceSession = this.removeSharingFromConferenceSession.bind(this);\n    /**\n     * @public\n     * @method addLocalVideoStreamToConference\n     * @since 1.50\n     * @instance\n     * @description Adding video leg to the conference\n     * @param conferenceSession - conference session retrieved from the event listener\n     * @return {Promise} - return promise if everything went well\n     */\n\n    this.addLocalVideoStreamToConference = this.addLocalVideoStreamToConference.bind(this);\n    /**\n     * @public\n     * @method showLocalVideo\n     * @instance\n     * @description\n     *    Display the local video (Picture in picture)<br>\n     *    canMakeAudioVideoCall() must be true<br>\n     *    Not supported on IE 11\n     * @return {Object} Return the SDK OK object in case of success or an SDK error object\n     */\n\n    this.showLocalVideo = this.showLocalVideo.bind(this);\n    /**\n     * @public\n     * @method getConferenceSessionById\n     * @since 1.50\n     * @instance\n     * @description Retrieving a conference object by passing the conference ID\n     * @param conferenceId - conference ID\n     * @return {ConferenceSession} - conferenceSession object\n     */\n\n    this.getConferenceSessionById = this.getConferenceSessionById.bind(this);\n    /**\n     * @public\n     * @method addDistantVideoStreamToConference\n     * @since 1.50\n     * @instance\n     * @description Adding video leg to the conference\n     * @param conferenceSession - conference session retrieved from the event listener\n     * @return {Promise} - return promise if everything went well\n     */\n\n    this.addDistantVideoStreamToConference = this.addDistantVideoStreamToConference.bind(this);\n    /**\n     * @public\n     * @method updateMainVideoSession\n     * @since 1.52\n     * @instance\n     * @description Changing the main video stream on demand\n     * @param conferenceId - conferenceId\n     * @param sessionid - Id number of the video session that is supposed to be set as main\n     * @return {Conference} - updated Conference.sessions object\n     */\n\n    this.updateMainVideoSession = this.updateMainVideoSession.bind(this);\n    /**\n     * @public\n     * @method startOrJoinSharingWebRtcConference\n     * @since 1.41\n     * @instance\n     * @description\n     *    Join or start a Sharing **only** WebRTC Conference<br/>\n     *    /!\\ you can't be in a call or in another WebRTC conference<br/>\n     *    /!\\ For Chrome, needs you to set before webrtcService.setChromeExtensionIdForSharing(strExtensionId)<br/>\n     *    Return a Promise.\n     * @param {Bubble} bubble   The bubble where do you want to launch the Sharing WebRTC Conference\n     * @return {Bubble} The bubble object or an error object depending on the result\n     */\n\n    this.startOrJoinSharingWebRtcConference = this.startOrJoinSharingWebRtcConference.bind(this);\n    /**\n     * @public\n     * @method stopWebRtcConference\n     * @since 1.41\n     * @instance\n     * @description\n     *    Try to stop the WebRTC or Sharing Conference<br/>\n     *    /!\\ One of your Bubble should be in a conference<br/>\n     *    Return a Promise.\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.stopWebRtcConference = this.stopWebRtcConference.bind(this);\n    /*\n     * EVENTS\n     * $rootScope.$on to be replaced with window.addEventListener in the future\n     */\n\n    $rootScope.$on('ON_CONFERENCE_UPDATED_EVENT', function (event, conferenceSession) {\n      return _this.onConferenceUpdated(event, conferenceSession);\n    });\n    $rootScope.$on('ON_WEBRTC_GETUSERMEDIA_ERROR', function (event, conferenceSession) {\n      return _this.onWebRtcGetUserMediaError(event, conferenceSession);\n    });\n    $rootScope.$on('ON_CONFERENCE_PARTICIPANT_EVENT', function (event, conferenceSession) {\n      return _this.onConferenceParticipantEvent(event, conferenceSession);\n    });\n    $rootScope.$on(roomService.ROOM_UPDATE_EVENT, function (event, room) {\n      return _this.onBubbleUpdatedEvent(event, room);\n    });\n    $rootScope.$on(roomService.ROOM_AVATAR_UPDATE_EVENT, function (event) {\n      return _this.onAvatarUpdatedEvent(event);\n    });\n    $rootScope.$on('ROOM_INVITATION', function (event, room) {\n      return _this.onRoomInvitationEvent(event, room);\n    });\n    $rootScope.$on('ON_CONFERENCE_STARTED_INVITATION', function (event, room) {\n      return _this.onConferenceStartedInvitation(event, room);\n    });\n    $rootScope.$on('ON_CONFERENCE_TALKER_EVENT', function (event, conferenceSession) {\n      return _this.onConferenceTalkerEvent(event, conferenceSession);\n    });\n  }\n  /* EVENT HANDLERS */\n\n\n  bubblesService_createClass(BubblesService, [{\n    key: \"onConferenceUpdated\",\n    value: function onConferenceUpdated(event, conferenceSession) {\n      if (conferenceSession) {\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBCONFERENCEUPDATED, {\n          detail: conferenceSession\n        });\n        document.dispatchEvent(sdkEvent);\n      }\n    }\n  }, {\n    key: \"onWebRtcGetUserMediaError\",\n    value: function onWebRtcGetUserMediaError(event, conferenceSession) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBRTCMEDIAERROROCCURED, {\n        detail: conferenceSession\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onConferenceParticipantEvent\",\n    value: function onConferenceParticipantEvent(event, conferenceSession) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONWEBCONFERENCEUPDATED, {\n        detail: conferenceSession\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onBubbleUpdatedEvent\",\n    value: function onBubbleUpdatedEvent(event, room) {\n      if (room.isActive === false) {\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONBUBBLEDEACTIVATED, {\n          detail: room\n        });\n        document.dispatchEvent(sdkEvent);\n      } else {\n        var _sdkEvent = new CustomEvent(this.RAINBOW_ONBUBBLEUPDATED, {\n          detail: room\n        });\n\n        document.dispatchEvent(_sdkEvent);\n      }\n    }\n  }, {\n    key: \"onAvatarUpdatedEvent\",\n    value: function onAvatarUpdatedEvent() {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONBUBBLEAVATARUPDATED, {\n        detail: null\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onRoomInvitationEvent\",\n    value: function onRoomInvitationEvent(event, room) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONBUBBLEINVITATIONTOJOINRECEIVED, {\n        detail: room\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onConferenceStartedInvitation\",\n    value: function onConferenceStartedInvitation(event, room) {\n      var _this2 = this;\n\n      var confEndpoints = room.confEndpoints;\n\n      if (confEndpoints) {\n        confEndpoints.forEach(function (confEndpoint) {\n          if (confEndpoint.mediaType === 'webrtc') {\n            var sdkEvent = new CustomEvent(_this2.RAINBOW_ONBUBBLECONFERENCESTARTEDINVITATIONRECEIVED, {\n              detail: room\n            });\n            document.dispatchEvent(sdkEvent);\n          }\n\n          if (confEndpoint.mediaType === 'webrtcSharingOnly') {\n            var _sdkEvent2 = new CustomEvent(_this2.RAINBOW_ONBUBBLESHARINGCONFERENCESTARTEDINVITATIONRECEIVED, {\n              detail: room\n            });\n\n            document.dispatchEvent(_sdkEvent2);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"onConferenceTalkerEvent\",\n    value: function onConferenceTalkerEvent(event, conferenceSession) {\n      if (conferenceSession) {\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONBUBBLECONFERENCETALKERACTIVE, {\n          detail: conferenceSession\n        });\n        document.dispatchEvent(sdkEvent);\n      }\n    }\n    /* BUBBLE METHODS */\n\n  }, {\n    key: \"createBubble\",\n    value: function createBubble(strName, strDescription, boolWithHistory, disableNotifications, urlAvatar) {\n      var _this3 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var conversationService = bubblesService_conversationService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this);\n\n      var bubble = null;\n      var description = strDescription || '';\n      var history = false;\n\n      if (boolWithHistory) {\n        history = true;\n      }\n\n      if (!disableNotifications) disableNotifications = false;else disableNotifications = true;\n      return new Promise(function (resolve, reject) {\n        if (!strName) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strName' is missing or empty\"\n          });\n        } else {\n          roomService.createRoom(strName, description, history, urlAvatar, disableNotifications).then(function (newBubble) {\n            bubble = newBubble;\n            return conversationService.getRoomConversation(bubble.jid);\n          }).then(function (conversation) {\n            $log.sdk(_this3.logService + '[createBubble] :: New bubble ' + strName + ' created successfully');\n            roomService.sendInitialRoomPresence(conversation.room);\n            return resolve(bubble);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this3.logService + '[createBubble] :: Error when creating a bubble');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteBubble\",\n    value: function deleteBubble(bubble) {\n      var _this4 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          _this4.closeBubble(bubble).then(function (closedBubble) {\n            return roomService.ownerDeleteRoom(closedBubble);\n          }).then(function (deletedRoom) {\n            return resolve(deletedRoom);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteAllBubbles\",\n    value: function deleteAllBubbles() {\n      var _this5 = this;\n\n      var PromiseQueue = _PromiseQueue.get(this);\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var deleteallBubblePromiseQueue = PromiseQueue.create();\n      var bubbles = roomService.getMyRooms();\n      bubbles.forEach(function (bubble) {\n        var deleteBubblePromise = function deleteBubblePromise() {\n          return _this5.deleteBubble(bubble);\n        };\n\n        deleteallBubblePromiseQueue.add(deleteBubblePromise);\n      });\n      return deleteallBubblePromiseQueue.execute();\n    }\n  }, {\n    key: \"inviteContactToBubble\",\n    value: function inviteContactToBubble(contact, bubble, boolAsModerator, boolWithInvitation) {\n      var _this6 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this);\n\n      var Room = _Room.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          var privilege = Room.Privilege.USER;\n\n          if (boolAsModerator) {\n            privilege = Room.Privilege.MODERATOR;\n          }\n\n          var withoutInvitation = false;\n\n          if (typeof boolWithInvitation === 'boolean') {\n            withoutInvitation = !boolWithInvitation;\n          }\n\n          var isActive = false;\n          var isAway = false;\n          var isInvited = false;\n          var isRejected = false;\n          var isDeleted = false;\n          bubble.users.forEach(function (user) {\n            if (user.contact.id === contact.id) {\n              switch (user.status) {\n                case 'invited':\n                  isInvited = true;\n                  break;\n\n                case 'accepted':\n                  isActive = true;\n                  break;\n\n                case 'unsubscribed':\n                  isAway = true;\n                  break;\n\n                case 'rejected':\n                  isRejected = true;\n                  break;\n\n                case 'deleted':\n                  isDeleted = true;\n                  break;\n\n                default:\n                  break;\n              }\n            }\n          });\n\n          if (isActive || isInvited) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: 'Contact has been already invited or is already a member of the room'\n            });\n          } else {\n            if (isAway || isRejected) {\n              roomService.ownerReinviteRejectedUser(bubble, contact, null, privilege, withoutInvitation).then(function (updatedBubble) {\n                updatedBubble.updateAvatarInfo();\n                return resolve(updatedBubble);\n              })[\"catch\"](function (err) {\n                $log.sdk(_this6.logService + '[invite     ] :: Error when inviting a contact');\n                return reject(err);\n              });\n            } else if (isDeleted) {\n              roomService.ownerReinviteDeletedUser(bubble, contact, null, privilege).then(function (updatedBubble) {\n                updatedBubble.updateAvatarInfo();\n                return resolve(updatedBubble);\n              })[\"catch\"](function (err) {\n                $log.sdk(_this6.logService + '[invite     ] :: Error when inviting a contact');\n                return reject(err);\n              });\n            } else {\n              roomService.addRoomUser(bubble, contact, null, privilege, withoutInvitation).then(function (updatedBubble) {\n                updatedBubble.updateAvatarInfo();\n                return resolve(updatedBubble);\n              })[\"catch\"](function (err) {\n                $log.sdk(_this6.logService + '[invite     ] :: Error when inviting a contact');\n                return reject(err);\n              });\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"removeContactFromBubble\",\n    value: function removeContactFromBubble(contact, bubble) {\n      var _this7 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or is null\"\n          });\n        } else {\n          var contactStatus = '';\n          bubble.users.forEach(function (user) {\n            if (user.contact.id === contact.id) {\n              contactStatus = user.status;\n            }\n          });\n\n          switch (contactStatus) {\n            case roomService.RoomUserStatus.INVITED:\n              roomService.ownerDeletesUserFromRoom(bubble, contact).then(function (updatedBubble) {\n                updatedBubble.updateAvatarInfo();\n                return resolve(updatedBubble);\n              })[\"catch\"](function (err) {\n                $log.sdk(_this7.logService + '[removeContactFromBubble] :: Error when removing a contact');\n                return reject(err);\n              });\n              break;\n\n            case roomService.RoomUserStatus.ACCEPTED:\n              roomService.unsubscribeUserFromRoom(bubble, contact).then(function (updatedBubble) {\n                updatedBubble.updateAvatarInfo();\n                return resolve(updatedBubble);\n              })[\"catch\"](function (err) {\n                $log.sdk(_this7.logService + '[removeContactFromBubble] :: Error when removing a contact');\n                return reject(err);\n              });\n              break;\n\n            default:\n              return resolve(bubble);\n              break;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"promoteContactToModerator\",\n    value: function promoteContactToModerator(contact, bubble) {\n      var _this8 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or is null\"\n          });\n        } else {\n          roomService.updateRoomUser(bubble, contact, null, 'moderator').then(function (updatedBubble) {\n            updatedBubble.updateAvatarInfo();\n            return resolve(updatedBubble);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this8.logService + '[promoteContactToModerator] :: Error when promoting a contact to a moderator');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"demoteContactFromModerator\",\n    value: function demoteContactFromModerator(contact, bubble) {\n      var _this9 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or is null\"\n          });\n        } else {\n          roomService.updateRoomUser(bubble, contact, null, 'user').then(function (updatedBubble) {\n            updatedBubble.updateAvatarInfo();\n            return resolve(updatedBubble);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this9.logService + '[demoteContactFromModerator] :: Error when demoting a contact');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"changeOwner\",\n    value: function changeOwner(contact, bubble) {\n      var _this10 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or is null\"\n          });\n        } else {\n          roomService.changeRoomOwner(bubble, contact).then(function (updatedBubble) {\n            updatedBubble.updateAvatarInfo();\n            return resolve(updatedBubble);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this10.logService + '[changeOwner] :: Error when changing bubble owner');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"acceptInvitationToJoinBubble\",\n    value: function acceptInvitationToJoinBubble(bubble) {\n      var _this11 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          roomService.acceptRoomInvitation(bubble).then(function () {\n            return resolve(bubble);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this11.logService + '[acceptInvitationToJoinBubble] :: Error when joining a bubble');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"declineInvitationToJoinBubble\",\n    value: function declineInvitationToJoinBubble(bubble) {\n      var _this12 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          roomService.declineRoomInvitation(bubble).then(function (updatedBubble) {\n            return resolve(updatedBubble);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this12.logService + '[declineInvitationToJoinBubble] :: Error when joining a bubble');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"leaveBubble\",\n    value: function leaveBubble(bubble) {\n      var _this13 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this);\n\n      var contactService = bubblesService_contactService.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          var hasOtherModerator = false;\n          bubble.users.forEach(function (user) {\n            if (!contactService.isUserContact(user)) {\n              if (user.privilege === 'moderator' && user.status === 'accepted') {\n                hasOtherModerator = true;\n              }\n            }\n          });\n\n          if (hasOtherModerator) {\n            switch (bubble.status) {\n              case roomService.RoomUserStatus.UNSUBSCRIBED:\n                roomService.participantCloseRoom(bubble).then(function (updatedBubble) {\n                  return resolve(updatedBubble);\n                })[\"catch\"](function (err) {\n                  $log.sdk(_this13.logService + '[leaveBubble] :: Error when leaving a bubble');\n                  return reject(err);\n                });\n                break;\n\n              default:\n                roomService.unsubscribeMeFromRoom(bubble).then(function (updatedBubble) {\n                  return resolve(updatedBubble);\n                })[\"catch\"](function (err) {\n                  $log.sdk(_this13.logService + '[leaveBubble] :: Error when leaving a bubble');\n                  return reject(err);\n                });\n                break;\n            }\n          } else {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"Can't leave the bubble. No other moderator\"\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"closeBubble\",\n    value: function closeBubble(bubble) {\n      var _this14 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var $log = bubblesService_$log.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          if (_this14.isBubbleArchived(bubble)) {\n            return resolve(bubble);\n          } else {\n            // Archive room then close it\n            roomService.ownerArchiveRoom(bubble) //.then(roomService.participantCloseRoom(bubble))\n            .then(function (updatedBubble) {\n              return resolve(updatedBubble);\n            })[\"catch\"](function (err) {\n              $log.sdk(_this14.logService + '[closeBubble] :: Error when closing a bubble');\n              return reject(err);\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"isBubbleArchived\",\n    value: function isBubbleArchived(bubble) {\n      var isArchived = true;\n\n      var roomService = bubblesService_roomService.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n\n      if (!bubble) {\n        isArchived = false;\n      } else if (bubble.status !== roomService.RoomUserStatus.UNSUBSCRIBED) {\n        isArchived = false;\n      } else {\n        bubble.users.forEach(function (user) {\n          if (user.status !== roomService.RoomUserStatus.UNSUBSCRIBED && user.status !== roomService.RoomUserStatus.DELETED) {\n            isArchived = false;\n          }\n        });\n      }\n\n      return isArchived;\n    }\n  }, {\n    key: \"getAllBubbles\",\n    value: function getAllBubbles() {\n      var roomService = bubblesService_roomService.get(this);\n\n      return roomService.getRooms();\n    }\n  }, {\n    key: \"getAllOwnedBubbles\",\n    value: function getAllOwnedBubbles() {\n      var roomService = bubblesService_roomService.get(this);\n\n      return roomService.getMyRooms();\n    }\n  }, {\n    key: \"getAllPendingBubbles\",\n    value: function getAllPendingBubbles() {\n      var roomService = bubblesService_roomService.get(this);\n\n      var pendingRooms = roomService.getRooms().filter(function (bubble) {\n        return bubble.status === 'invited';\n      });\n      return pendingRooms;\n    }\n  }, {\n    key: \"getAllInactiveBubbles\",\n    value: function getAllInactiveBubbles() {\n      var roomService = bubblesService_roomService.get(this);\n\n      var inactiveBubbles = roomService.getRooms().filter(function (bubble) {\n        return bubble.isActive == false;\n      });\n      return inactiveBubbles;\n    }\n  }, {\n    key: \"getBubbleById\",\n    value: function getBubbleById(strBubbleId) {\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this);\n\n      if (!strBubbleId) {\n        return {\n          code: SDK.ERRORBADREQUEST,\n          label: \"Parameter 'strBubbleId' is missing or empty\"\n        };\n      }\n\n      return roomService.getRoomById(strBubbleId);\n    }\n  }, {\n    key: \"updateDescriptionForBubble\",\n    value: function updateDescriptionForBubble(strDescription, bubble) {\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!strDescription) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strDescription' is missing or empty\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or empty\"\n          });\n        } else {\n          bubble.desc = strDescription;\n          roomService.ownerUpdateRoom(bubble).then(function (updatedBubble) {\n            return resolve(updatedBubble);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateAvatarForBubble\",\n    value: function updateAvatarForBubble(urlAvatar, bubble) {\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!urlAvatar) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'urlAvatar' is missing or empty\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or empty\"\n          });\n        } else {\n          // fake roomData\n          bubble.id = bubble.dbId;\n          roomService.setAvatarRoom(bubble, urlAvatar).then(function (updatedBubble) {\n            return resolve(updatedBubble);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteAvatarFromBubble\",\n    value: function deleteAvatarFromBubble(bubble) {\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or empty\"\n          });\n        } else {\n          roomService.deleteAvatarRoom(bubble.dbId).then(function (updatedBubble) {\n            return resolve(updatedBubble);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateCustomDataForBubble\",\n    value: function updateCustomDataForBubble(customData, bubble) {\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!customData) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'customData' is missing or empty\"\n          });\n        } else if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or empty\"\n          });\n        } else {\n          bubble.customData = customData;\n          roomService.ownerUpdateRoomCustomData(bubble).then(function (updatedCustomData) {\n            bubble.customData = updatedCustomData;\n            return resolve(bubble);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteCustomDataForBubble\",\n    value: function deleteCustomDataForBubble(bubble) {\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or empty\"\n          });\n        } else {\n          bubble.customData = {};\n          roomService.ownerUpdateRoomCustomData(bubble).then(function (updatedCustomData) {\n            bubble.customData = updatedCustomData;\n            return resolve(bubble);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    } /////////////////////////////////////////////////////////\n    // SFU Part\n    // (Selective Forwarding Unit)\n    /////////////////////////////////////////////////////////\n\n  }, {\n    key: \"isWebRtcConferenceAllowed\",\n    value: function isWebRtcConferenceAllowed() {\n      var profileService = bubblesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled(profileService.FeaturesEnum.WEBRTC_CONFERENCE_ALLOWED);\n    }\n  }, {\n    key: \"hasActiveConferenceSession\",\n    value: function hasActiveConferenceSession() {\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (webConferenceService.hasActiveConferenceSession()) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"getWebRtcConferenceBubble\",\n    value: function getWebRtcConferenceBubble() {\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      return webConferenceService.getRelatedRoomToActiveConferenceSession();\n    }\n  }, {\n    key: \"startOrJoinWebRtcConference\",\n    value: function startOrJoinWebRtcConference(bubble) {\n      var _this15 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      var SDK = bubblesService_SDK.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or empty\"\n          });\n        } else if (_this15.hasActiveConferenceSession()) {\n          return reject({\n            code: SDK.ERROR,\n            label: 'Already in a conference'\n          });\n        } else {\n          webConferenceService.startOrJoinWebConference(bubble).then(function () {\n            _this15.confBubble = bubble;\n            _this15.confBubbleType = 'webrtc';\n            return resolve(roomService.getRoomById(bubble.dbId));\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"addMediaToConferenceSession\",\n    value: function addMediaToConferenceSession(conferenceSession) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (!conferenceSession) {\n        return {\n          code: SDK.ERROR,\n          label: \"Parameter 'conferenceSession' is missing or empty\"\n        };\n      } else {\n        return webConferenceService.addMediaToConferenceSession(conferenceSession, 'video');\n      }\n    }\n  }, {\n    key: \"addSharingToConferenceSession\",\n    value: function addSharingToConferenceSession(conferenceSession) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (!conferenceSession) {\n        return {\n          code: SDK.ERROR,\n          label: \"Parameter 'conferenceSession' is missing or empty\"\n        };\n      } else {\n        return webConferenceService.addMediaToConferenceSession(conferenceSession, 'sharing');\n      }\n    }\n  }, {\n    key: \"removeMediaFromConferenceSession\",\n    value: function removeMediaFromConferenceSession(conferenceSession) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (!conferenceSession) {\n        return {\n          code: SDK.ERROR,\n          label: \"Parameter 'conferenceSession' is missing or empty\"\n        };\n      } else {\n        webConferenceService.removeMediaFromConferenceSession(conferenceSession, 'video');\n        return conferenceSession;\n      }\n    }\n  }, {\n    key: \"removeSharingFromConferenceSession\",\n    value: function removeSharingFromConferenceSession(conferenceSession) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (!conferenceSession) {\n        return {\n          code: SDK.ERROR,\n          label: \"Parameter 'conferenceSession' is missing or empty\"\n        };\n      } else {\n        webConferenceService.removeMediaFromConferenceSession(conferenceSession, 'sharing');\n        return conferenceSession;\n      }\n    }\n  }, {\n    key: \"addLocalVideoStreamToConference\",\n    value: function addLocalVideoStreamToConference(conferenceSession) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (!conferenceSession) {\n        return {\n          code: SDK.ERROR,\n          label: \"Parameter 'conferenceSession' is missing or empty\"\n        };\n      } else {\n        webConferenceService.attachLocalMediaStream(true, conferenceSession);\n        return conferenceSession;\n      }\n    }\n  }, {\n    key: \"showLocalVideo\",\n    value: function showLocalVideo() {\n      var SDK = bubblesService_SDK.get(this);\n\n      var videoService = bubblesService_videoService.get(this);\n\n      if (false) {}\n\n      videoService.attachLocalMediaStream(true);\n      return {\n        code: SDK.OK,\n        label: 'OK'\n      };\n    }\n  }, {\n    key: \"getConferenceSessionById\",\n    value: function getConferenceSessionById(conferenceId) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (!conferenceId) {\n        return {\n          code: SDK.ERROR,\n          label: \"Parameter 'conferenceId' is missing or empty\"\n        };\n      } else {\n        return webConferenceService.getConferenceSessionById(conferenceId);\n      }\n    }\n  }, {\n    key: \"addDistantVideoStreamToConference\",\n    value: function addDistantVideoStreamToConference(conferenceSession) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      if (!conferenceSession) {\n        return {\n          code: SDK.ERROR,\n          label: \"Parameter 'conferenceSession' is missing or empty\"\n        };\n      } else {\n        webConferenceService.attachDistantMediaStream(true, conferenceSession);\n        return conferenceSession;\n      }\n    }\n  }, {\n    key: \"updateMainVideoSession\",\n    value: function updateMainVideoSession(conferenceId, sessionId) {\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conferenceId) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conferenceId' is missing or empty\"\n          });\n        } else if (!sessionId) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'sessionId' is missing or empty\"\n          });\n        } else {\n          webConferenceService.updateMainScreenSession(conferenceId, sessionId);\n          return webConferenceService.getConferenceSessionById(conferenceId);\n        }\n      });\n    }\n  }, {\n    key: \"startOrJoinSharingWebRtcConference\",\n    value: function startOrJoinSharingWebRtcConference(bubble) {\n      var _this16 = this;\n\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      var roomService = bubblesService_roomService.get(this); // update bubble with internal copy to avoid user/moderator/owner side effects\n\n\n      bubble = bubble && bubble.dbId ? roomService.getRoomById(bubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or empty\"\n          });\n        } else if (_this16.hasActiveConferenceSession()) {\n          return reject({\n            code: SDK.ERROR,\n            label: 'Already in a conference'\n          });\n        } else {\n          webConferenceService.startOrJoinSharingOnlyConference(bubble).then(function () {\n            _this16.confBubble = bubble;\n            _this16.confBubbleType = 'sharing';\n            return resolve(roomService.getRoomById(bubble.dbId));\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"stopWebRtcConference\",\n    value: function stopWebRtcConference() {\n      var _this17 = this;\n\n      var roomService = bubblesService_roomService.get(this);\n\n      var SDK = bubblesService_SDK.get(this);\n\n      var webConferenceService = bubblesService_webConferenceService.get(this);\n\n      var conferenceService = bubblesService_conferenceService.get(this);\n\n      var contactService = bubblesService_contactService.get(this);\n\n      this.confBubble = this.confBubble && this.confBubble.dbId ? roomService.getRoomById(this.confBubble.dbId) : null;\n      return new Promise(function (resolve, reject) {\n        if (!_this17.hasActiveConferenceSession() || !_this17.confBubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: 'No known conference in a Bubble'\n          });\n        } else {\n          var id = '';\n\n          if (_this17.confBubbleType === 'webrtc') {\n            id = _this17.confBubble.getSFUConfEndpointId();\n          } else {\n            id = _this17.confBubble.getSFUSharingConfEndpointId();\n          }\n\n          var sharingConfSession = webConferenceService.getConferenceSessionById(id);\n          var participant = sharingConfSession ? sharingConfSession.getParticipantByJid(contactService.userContact.jid) : null; //webConferenceService.leaveWebConference(sharingConfId);\n\n          if (participant.role !== 'moderator') {\n            conferenceService.disconnectsParticipant(id, participant.participantId, _this17.confBubbleType).then(function () {\n              _this17.confBubble = null;\n              _this17.confBubbleType = null;\n              return resolve();\n            })[\"catch\"](function (err) {\n              return reject(err);\n            });\n          } else {\n            conferenceService.stopConference(id, _this17.confBubbleType, _this17.confBubble.dbId).then(function () {\n              _this17.confBubble = null;\n              _this17.confBubbleType = null;\n              return resolve();\n            })[\"catch\"](function (err) {\n              return reject(err);\n            });\n          }\n        }\n      });\n    }\n  }]);\n\n  return BubblesService;\n}();\n// CONCATENATED MODULE: ./src/groupsService.js\nfunction groupsService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction groupsService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction groupsService_createClass(Constructor, protoProps, staticProps) { if (protoProps) groupsService_defineProperties(Constructor.prototype, protoProps); if (staticProps) groupsService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Groups\n * @public\n * @description\n *      This service manages user groups in Rainbow.<br><br>\n *      Each user can create groups and invite other Rainbow users to be part of it. Without being invited, users can join a bubble.<br><br>\n *\t\tThe main methods proposed in that module allow to: <br>\n *\t\t- Get all groups of the user\n *\t\t- Create a new group\n *\t\t- Add a contact in a group\n *\t\t- Remove a contact from a group\n *\t\t- Delete an existing group\n * @fires RAINBOW_ONGROUPCREATED\n * @fires RAINBOW_ONGROUPUPDATED\n * @fires RAINBOW_ONGROUPDELETED\n * @fires RAINBOW_ONGROUPUSERADDED\n * @fires RAINBOW_ONGROUPUSERREMOVED\n */\nvar groupsService_$rootScope = new WeakMap();\n\nvar groupsService_$log = new WeakMap();\n\nvar groupsService_groupService = new WeakMap();\n\nvar _Group = new WeakMap();\n\nvar groupsService_contactService = new WeakMap();\n\nvar groupsService_PromiseQueue = new WeakMap();\n\nvar groupsService_SDK = new WeakMap();\n\nvar GroupsService =\n/*#__PURE__*/\nfunction () {\n  groupsService_createClass(GroupsService, null, [{\n    key: \"inject\",\n    get: function get() {\n      return ['$rootScope', '$log', 'groupService', 'Group', 'contactService', 'PromiseQueue', 'SDK'];\n    }\n  }]);\n\n  function GroupsService($rootScope, $log, groupService, Group, contactService, PromiseQueue, SDK) {\n    var _this = this;\n\n    groupsService_classCallCheck(this, GroupsService);\n\n    groupsService_$rootScope.set(this, $rootScope);\n\n    groupsService_$log.set(this, $log);\n\n    groupsService_groupService.set(this, groupService);\n\n    _Group.set(this, Group);\n\n    groupsService_contactService.set(this, contactService);\n\n    groupsService_PromiseQueue.set(this, PromiseQueue);\n\n    groupsService_SDK.set(this, SDK);\n\n    this.logService = 'GroupService  | ';\n    /**\n     * @public\n     * @event RAINBOW_ONGROUPCREATED\n     * @param {string} group_id The group id created\n     * @description\n     *      This event is fired when a group is created\n     *      The event contains a **Group** object.\n     */\n\n    this.RAINBOW_ONGROUPCREATED = 'rainbowgroupcreated';\n    /**\n     * @public\n     * @event RAINBOW_ONGROUPUPDATED\n     * @param {string} group_id The group id\n     * @param {string} name The group name\n     * @param {string} comment The group comment\n     * @param {Boolean} isFavorite The group favorite 'state\"\n     * @description\n     *      This event is fired when a group is updated\n     *      The event contains a **Group** object.\n     */\n\n    this.RAINBOW_ONGROUPUPDATED = 'rainbowgroupupdated';\n    /**\n     * @public\n     * @event RAINBOW_ONGROUPDELETED\n     * @param {string} group_id The group id deleted\n     * @description\n     *      This event is fired when a group is deleted\n     *      The event contains a **Group** object.\n     */\n\n    this.RAINBOW_ONGROUPDELETED = 'rainbowgroupdeleted';\n    /**\n     * @public\n     * @event RAINBOW_ONGROUPUSERADDED\n     * @param {string} group_id The group id\n     * @param {string} contact_id The contact id added to the group\n     * @description\n     *      This event is fired when a user is added in a group.\n     *      The event contains a **Group** object and a **Contact* object.\n     */\n\n    this.RAINBOW_ONGROUPUSERADDED = 'rainbowgroupuseradded';\n    /**\n     * @public\n     * @event RAINBOW_ONGROUPUSERREMOVED\n     * @param {string} group_id The group id\n     * @param {string} contact_id The contact id removed from the group\n     * @description\n     *      This event is fired when a user is removed from a group.\n     *      The event contains a **Group** object and a **Contact* object.\n     */\n\n    this.RAINBOW_ONGROUPUSERREMOVED = 'rainbowgroupuserdeleted';\n    /**\n     * @public\n     * @method createGroup\n     * @instance\n     * @description\n     *    Create a new group <br/>\n     *    Return a promise.\n     * @param {string} strName The name of the group\n     * @param {string} strDescription The description of the group\n     * @param {boolean} isFavorite True to flag the group as favorite\n     * @return {Group} The group object or an error object depending on the result\n     */\n\n    this.createGroup = this.createGroup.bind(this);\n    /**\n     * @public\n     * @method deleteGroup\n     * @instance\n     * @description\n     *    Delete a group <br/>\n     *    Return a promise.\n     * @param {Group} group group object\n     * @return {Promise<SDK.OK|Object>} SDK OK  or an error object depending on the result\n     */\n\n    this.deleteGroup = this.deleteGroup.bind(this);\n    /**\n     * @public\n     * @method deleteAllGroups\n     * @instance\n     * @description\n     *    Delete all existing owned groups <br/>\n     *    Return a promise\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.deleteAllGroups = this.deleteAllGroups.bind(this);\n    /**\n     * @public\n     * @method getAll\n     * @instance\n     * @description\n     *    Return the list of all existing groups\n     * @return {Group[]} The groups or an error object depending on the result\n     */\n\n    this.getAll = this.getAll.bind(this);\n    /**\n     * @public\n     * @method getFavoritesGroup\n     * @instance\n     * @since 1.49\n     * @description\n     *  Return the list of favorite groups\n     * @return {Group[]} The favorited groups or an error object depending on the result\n     */\n\n    this.getFavoritesGroups = this.getFavoritesGroups.bind(this);\n    /**\n     * @public\n     * @method setGroupAsFavorite\n     * @since 1.49\n     * @instance\n     * @param {Group} group The group to set as favorite\n     * @description\n     *  Set a group as favorite\n     *  Return a Promise\n     * @return {Group} The group updated\n     */\n\n    this.setGroupAsFavorite = this.setGroupAsFavorite.bind(this);\n    /**\n     * @public\n     * @method unsetGroupAsFavorite\n     * @since 1.49\n     * @param {Group} group The group to remove from favorite\n     * @description\n     *  Unset a group as favorite\n     *  Return a Promise\n     * @return {Group} The group updated\n     */\n\n    this.unsetGroupAsFavorite = this.unsetGroupAsFavorite.bind(this);\n    /**\n     * @public\n     * @method getGroupById\n     * @instance\n     * @description\n     *    Get user's group by id <br/>\n     *    Return user's group if found or null.\n     * @param {string} id the group id\n     * @return {Group} The group found or null if not found\n     */\n\n    this.getGroupById = this.getGroupById.bind(this);\n    /**\n     * @public\n     * @method getDetailedGroupById\n     * @instance\n     * @since 1.49\n     * @param {string} id The group id\n     * @description\n     *    Get the group with detailed information on users\n     *    Return a Promise\n     * @return {Group} The group updated\n     */\n\n    this.getDetailedGroupById = this.getDetailedGroupById.bind(this);\n    /**\n     * @public\n     * @method addContactInGroup\n     * @instance\n     * @description\n     *    Add a contact to a group <br/>\n     *    Return a promise.\n     * @param {Contact} contact The contact to add\n     * @param {Group} group The group\n     * @return {Group} The group updated\n     */\n\n    this.addContactInGroup = this.addContactInGroup.bind(this);\n    /**\n     * @public\n     * @method removeContactFromGroup\n     * @instance\n     * @description\n     *    Remove a contact from a group <br/>\n     *    Return a promise.\n     * @param {Contact} contact The contact to remove\n     * @param {Group} group The group\n     * @return {Object} group_id or an error object depending on the result\n     */\n\n    this.removeContactFromGroup = this.removeContactFromGroup.bind(this);\n    /* EVENT HANDLERS */\n\n    $rootScope.$on('$destroy', $rootScope.$on(groupService.ON_UPDATE_GROUP_EVENT, function (event, group_id) {\n      return _this.onGroupUpdated(event, group_id);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on(groupService.ON_CREATED_GROUP_EVENT, function (event, group_id) {\n      return _this.onGroupCreated(event, group_id);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on(groupService.ON_REMOVED_GROUP_EVENT, function (event, group_id) {\n      return _this.onGroupDeleted(event, group_id);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on(groupService.ON_ADD_GROUP_USER_EVENT, function (event, group_id, user_id) {\n      return _this.onGroupUserAdded(event, group_id, user_id);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on(groupService.ON_REMOVE_GROUP_USER_EVENT, function (event, group_id, user_id) {\n      return _this.onGroupUserRemoved(event, group_id, user_id);\n    }));\n  }\n  /* EVENT METHODS */\n\n\n  groupsService_createClass(GroupsService, [{\n    key: \"onGroupUpdated\",\n    value: function onGroupUpdated(event, group_id) {\n      var _this2 = this;\n\n      var groupService = groupsService_groupService.get(this);\n\n      groupService.getGroup(group_id).then(function (group) {\n        var sdkEvent = new CustomEvent(_this2.RAINBOW_ONGROUPUPDATED, {\n          detail: group\n        });\n        document.dispatchEvent(sdkEvent);\n      })[\"catch\"](function (err) {\n        return console.log(err);\n      });\n    }\n  }, {\n    key: \"onGroupCreated\",\n    value: function onGroupCreated(event, group_id) {\n      var _this3 = this;\n\n      var groupService = groupsService_groupService.get(this);\n\n      groupService.getGroup(group_id).then(function (group) {\n        var sdkEvent = new CustomEvent(_this3.RAINBOW_ONGROUPCREATED, {\n          detail: group\n        });\n        document.dispatchEvent(sdkEvent);\n      })[\"catch\"](function (err) {\n        console.log(err);\n      });\n    }\n  }, {\n    key: \"onGroupDeleted\",\n    value: function onGroupDeleted(event, group_id) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONGROUPDELETED, {\n        detail: group_id\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onGroupUserAdded\",\n    value: function onGroupUserAdded(event, group_id, user_id) {\n      var _this4 = this;\n\n      var groupService = groupsService_groupService.get(this);\n\n      groupService.getGroup(group_id).then(function (group) {\n        var sdkEvent = new CustomEvent(_this4.RAINBOW_ONGROUPUSERADDED, {\n          detail: {\n            group: group,\n            user_id: user_id\n          }\n        });\n        document.dispatchEvent(sdkEvent);\n      })[\"catch\"](function (err) {\n        console.log(err);\n      });\n    }\n  }, {\n    key: \"onGroupUserRemoved\",\n    value: function onGroupUserRemoved(event, group_id, user_id) {\n      var _this5 = this;\n\n      var groupService = groupsService_groupService.get(this);\n\n      groupService.getGroup(group_id).then(function (group) {\n        var sdkEvent = new CustomEvent(_this5.RAINBOW_ONGROUPUSERREMOVED, {\n          detail: {\n            group: group,\n            user_id: user_id\n          }\n        });\n        document.dispatchEvent(sdkEvent);\n      })[\"catch\"](function (err) {\n        console.log(err);\n      });\n    }\n    /* GROUP SERVICE METHODS */\n\n  }, {\n    key: \"createGroup\",\n    value: function createGroup(strName, strDescription, isFavorite) {\n      var _this6 = this;\n\n      var Group = _Group.get(this);\n\n      var $log = groupsService_$log.get(this);\n\n      var groupService = groupsService_groupService.get(this);\n\n      var SDK = groupsService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var group = null;\n        var comment = strDescription || '';\n        var boolFavorite = false;\n\n        if (typeof isFavorite === 'boolean') {\n          boolFavorite = isFavorite;\n        }\n\n        if (!strName) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'strName' is missing or empty\"\n          });\n        } else {\n          group = new Group(null, strName, comment, boolFavorite);\n          groupService.addGroup(group).then(function (newGroup) {\n            $log.sdk(_this6.logService + '[createGroup] :: New group created successfully');\n            return resolve(newGroup);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this6.logService + '[createGroup] :: Error when creating a group');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteGroup\",\n    value: function deleteGroup(group) {\n      var _this7 = this;\n\n      var $log = groupsService_$log.get(this);\n\n      var groupService = groupsService_groupService.get(this);\n\n      var SDK = groupsService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!group) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'group' is missing or empty\"\n          });\n        } else {\n          groupService.removeGroup(group.id).then(function () {\n            $log.sdk(_this7.logService + '[deleteGroup] :: Group deleted successfully');\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            $log.sdk(_this7.logService + '[deleteGroup] :: Error when deleting a group');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteAllGroups\",\n    value: function deleteAllGroups() {\n      var _this8 = this;\n\n      var $log = groupsService_$log.get(this);\n\n      var groupService = groupsService_groupService.get(this);\n\n      var SDK = groupsService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var promiseQueue = [];\n        var groups = groupService.getGroupsAsArray();\n\n        var deleteGroupPromise = function deleteGroupPromise(group) {\n          return groupService.removeGroup(group.id);\n        };\n\n        groups.forEach(function (group) {\n          promiseQueue.push(deleteGroupPromise(group));\n        });\n        Promise.all(promiseQueue).then(function () {\n          $log.sdk(_this8.logService + '[deleteAllGroups] :: All groups deleted successfully');\n          return resolve({\n            code: SDK.OK,\n            label: 'OK'\n          });\n        })[\"catch\"](function (err) {\n          $log.sdk(_this8.logService + '[deleteAllGroups] :: Error when deleting all groups');\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var groupService = groupsService_groupService.get(this);\n\n      return groupService.getGroupsAsArray();\n    }\n  }, {\n    key: \"getFavoritesGroups\",\n    value: function getFavoritesGroups() {\n      var groupService = groupsService_groupService.get(this);\n\n      return groupService.getGroupsAsArray().filter(function (group) {\n        return group.isFavorite;\n      });\n    }\n  }, {\n    key: \"setGroupAsFavorite\",\n    value: function setGroupAsFavorite(group) {\n      var groupService = groupsService_groupService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        group.isFavorite = true;\n        groupService.updateGroup(group).then(function () {\n          return resolve(group);\n        })[\"catch\"](function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"unsetGroupAsFavorite\",\n    value: function unsetGroupAsFavorite(group) {\n      var groupService = groupsService_groupService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        group.isFavorite = false;\n        groupService.updateGroup(group).then(function () {\n          return resolve(group);\n        })[\"catch\"](function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"getGroupById\",\n    value: function getGroupById(group_id) {\n      var groupService = groupsService_groupService.get(this);\n\n      var theGroup = null;\n      groupService.getGroupsAsArray().some(function (group) {\n        if (group_id === group.id) {\n          theGroup = group;\n          return true;\n        }\n\n        return false;\n      });\n      return theGroup;\n    }\n  }, {\n    key: \"getDetailedGroupById\",\n    value: function getDetailedGroupById(id) {\n      var groupService = groupsService_groupService.get(this);\n\n      var SDK = groupsService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          groupService.getGroup(id).then(function (updatedGroup) {\n            return resolve(updatedGroup);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"addContactInGroup\",\n    value: function addContactInGroup(contact, group) {\n      var _this9 = this;\n\n      var SDK = groupsService_SDK.get(this);\n\n      var groupService = groupsService_groupService.get(this);\n\n      var $log = groupsService_$log.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (!group) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'group' is missing or null\"\n          });\n        } else {\n          groupService.addGroupUser(group, contact).then(function (updatedGroup) {\n            $log.sdk(_this9.logService + '[addContactInGroup] :: Contact added successfully');\n            return resolve(updatedGroup);\n          })[\"catch\"](function (err) {\n            $log.sdk(_this9.logService + '[addContactInGroup] :: Error when adding a contact in a group');\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"removeContactFromGroup\",\n    value: function removeContactFromGroup(contact, group) {\n      var SDK = groupsService_SDK.get(this);\n\n      var groupService = groupsService_groupService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!contact) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'contact' is missing or null\"\n          });\n        } else if (!group) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'group' is missing or null\"\n          });\n        } else {\n          return resolve(groupService.removeGroupUser(group.id, contact));\n        }\n      });\n    }\n  }]);\n\n  return GroupsService;\n}();\n// CONCATENATED MODULE: ./src/callsLogService.js\nfunction callsLogService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction callsLogService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction callsLogService_createClass(Constructor, protoProps, staticProps) { if (protoProps) callsLogService_defineProperties(Constructor.prototype, protoProps); if (staticProps) callsLogService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name CallsLog\n * @public\n * @description\n *      This service allow to get the call log and manage it. <br><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Get all calls log <br/>\n *      - Delete one or all calls log <br/>\n *      - Mark calls as read / unread <br/>\n * @fires RAINBOW_ONCALLLOGUPDATED\n * @fires RAINBOW_ONCALLLOGACKUPDATED\n */\nvar callsLogService_callLogService = new WeakMap();\n\nvar CallsLogService =\n/*#__PURE__*/\nfunction () {\n  callsLogService_createClass(CallsLogService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$rootScope', 'callLogService'];\n    }\n  }]);\n\n  function CallsLogService($rootScope, callLogService) {\n    var _this = this;\n\n    callsLogService_classCallCheck(this, CallsLogService);\n\n    this.logService = 'CallsLogService | ';\n    this.initialized = false;\n\n    callsLogService_callLogService.set(this, callLogService);\n    /**\n     * @public\n     * @event RAINBOW_ONCALLLOGUPDATED\n     * @description\n     *      This event is fired each time the call log history is updated<br>\n     *      The event contains no data. use the API getAll() to retrieve them\n     */\n\n\n    this.RAINBOW_ONCALLLOGUPDATED = 'rainbowcalllogupdated';\n    /**\n     * @public\n     * @event RAINBOW_ONCALLLOGACKUPDATED\n     * @description\n     *      This event is fired each time a call entry item missed is read<br>\n     *      The event contains no data. use the API getAll() to retrieve them\n     */\n\n    this.RAINBOW_ONCALLLOGACKUPDATED = 'rainbowcalllogackupdated';\n    /**\n     * @public\n     * @method getAll\n     * @instance\n     * @description\n     *    Get all calls log history for the connected user\n     * @return {CallLog[]} An array of call log entry\n     */\n\n    this.getAll = this.getAll.bind(this);\n    /**\n     * @public\n     * @method getMissedCallLogCounter\n     * @instance\n     * @description\n     *    Get the number of call missed (state === \"missed\" && direction === \"incoming\")\n     * @return {Number} The number of call missed\n     */\n\n    this.getMissedCallLogCounter = this.getMissedCallLogCounter.bind(this);\n    /**\n     * @public\n     * @method deleteOneCallLog\n     * @instance\n     * @description\n     *    Delete a call log from it's id<br/>\n     *    You have to listen to event `RAINBOW_ONCALLLOGUPDATED` to know when the action is finished\n     * @param {String} id The call log id to remove\n     * @return Nothing\n     */\n\n    this.deleteOneCallLog = this.deleteOneCallLog.bind(this);\n    /**\n     * @public\n     * @method deleteCallLogsForContact\n     * @instance\n     * @description\n     *    Delete all calls log items associated to a contact's given jid<br/>\n     *    You have to listen to event `RAINBOW_ONCALLLOGUPDATED` to know when the action is finished\n     * @param {String} jid The call log id to remove\n     * @return Nothing\n     */\n\n    this.deleteCallLogsForContact = this.deleteCallLogsForContact.bind(this);\n    /**\n     * @public\n     * @method deleteAllCallLogs\n     * @instance\n     * @description\n     *    Delete all call logs history<br/>\n     *    You have to listen to event `RAINBOW_ONCALLLOGUPDATED` to know when the action is finished\n     * @return Nothing\n     */\n\n    this.deleteAllCallLogs = this.deleteAllCallLogs.bind(this);\n    /**\n     * @public\n     * @method markCallLogAsRead\n     * @instance\n     * @description\n     *    Mark a call log item as read<br/>\n     *    You have to listen to event `RAINBOW_ONCALLLOGACKUPDATED` to know when the action is finished\n     * @param {String} id The call log id\n     * @return Nothing\n     */\n\n    this.markCallLogAsRead = this.markCallLogAsRead.bind(this);\n    /**\n     * @public\n     * @method markAllCallsLogsAsRead\n     * @instance\n     * @description\n     *    Mark all call log items as read<br/>\n     *    You have to listen to event `RAINBOW_ONCALLLOGACKUPDATED` to know when the action is finished\n     * @return Nothing\n     */\n\n    this.markAllCallsLogsAsRead = this.markAllCallsLogsAsRead.bind(this);\n    /**\n     * @public\n     * @method isInitialized\n     * @instance\n     * @description\n     *    Check if the call log history has been received from Rainbow\n     *    A false answer means that the call logs have not yet been retrieved from the server.\n     * @return {Boolean} True if the call logs have been retrieved. False elsewhere.\n     */\n\n    this.isInitialized = this.isInitialized.bind(this);\n    /* EVENTS PART */\n\n    $rootScope.$on('ON_CALL_LOG_UPDATED', function (event, data) {\n      return _this.onCallLogUpdated(event, data);\n    });\n    $rootScope.$on('ON_CALL_LOG_ACK_UPDATED', function (event, data) {\n      return _this.onCallLogAckUpdated(event, data);\n    });\n  }\n\n  callsLogService_createClass(CallsLogService, [{\n    key: \"onCallLogUpdated\",\n    value: function onCallLogUpdated(event, data) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCALLLOGUPDATED, {\n        detail: data\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onCallLogAckUpdated\",\n    value: function onCallLogAckUpdated(event, data) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONCALLLOGACKUPDATED, {\n        detail: data\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var callLogService = callsLogService_callLogService.get(this);\n\n      callLogService.orderCallLogsFunction();\n      var callLogs = callLogService.getSimplifiedCallLogs(); // as dureation is \"h[H] mm[m] ss[s]\" in rb, switch it back to ms ...\n\n      for (var i = 0; i < callLogs.length; i++) {\n        var durationMs = 0;\n        var hmmss = callLogs[i].duration;\n\n        if (hmmss && typeof hmmss === 'string' && hmmss.match(/^(?:(?:([01]?\\d|2[0-3])h )?([0-5]?\\d)m )?([0-5]?\\ds)$/)) {\n          // Remove h, m and s\n          hmmss = hmmss.replace(/[hms]/g, ''); // split it at the \"space\", also reverse it to get seconds then minutes then hours\n\n          var parts = hmmss.split(' ').reverse();\n\n          for (var j = 0; j < parts.length; j++) {\n            durationMs += parts[j] * Math.pow(60, j);\n          }\n\n          callLogs[i].duration = durationMs * 1000;\n        }\n      }\n\n      return callLogs;\n    }\n  }, {\n    key: \"getMissedCallLogCounter\",\n    value: function getMissedCallLogCounter() {\n      var callLogService = callsLogService_callLogService.get(this);\n\n      return callLogService.getMissedCallLogCounter();\n    }\n  }, {\n    key: \"deleteOneCallLog\",\n    value: function deleteOneCallLog(id) {\n      var callLogService = callsLogService_callLogService.get(this);\n\n      return callLogService.deleteOneCallLog(id);\n    }\n  }, {\n    key: \"deleteCallLogsForContact\",\n    value: function deleteCallLogsForContact(jid) {\n      var callLogService = callsLogService_callLogService.get(this);\n\n      return callLogService.deleteCallLogsForContact(jid);\n    }\n  }, {\n    key: \"deleteAllCallLogs\",\n    value: function deleteAllCallLogs() {\n      var callLogService = callsLogService_callLogService.get(this);\n\n      return callLogService.deleteAllCallLogs();\n    }\n  }, {\n    key: \"markCallLogAsRead\",\n    value: function markCallLogAsRead(id) {\n      var callLogService = callsLogService_callLogService.get(this);\n\n      return callLogService.markCallLogAsRead(id);\n    }\n  }, {\n    key: \"markAllCallsLogsAsRead\",\n    value: function markAllCallsLogsAsRead() {\n      var callLogService = callsLogService_callLogService.get(this);\n\n      return callLogService.markAllCallsLogsAsRead();\n    }\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return this.initialized;\n    }\n  }]);\n\n  return CallsLogService;\n}();\n// CONCATENATED MODULE: ./src/favoritesService.js\nfunction favoritesService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction favoritesService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction favoritesService_createClass(Constructor, protoProps, staticProps) { if (protoProps) favoritesService_defineProperties(Constructor.prototype, protoProps); if (staticProps) favoritesService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Favorites\n * @description\n *      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.\n *      The main methods and events proposed in that service allow to: <br>\n *      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>\n *      - Retrieve all information linked to that Favorite, <br>\n * @fires RAINBOW_ONFAVORITECREATED\n * @fires RAINBOW_ONFAVORITEDELETED\n */\nvar favoritesService_favoriteService = new WeakMap();\n\nvar favoritesService_$log = new WeakMap();\n\nvar FavoritesService =\n/*#__PURE__*/\nfunction () {\n  favoritesService_createClass(FavoritesService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', 'favoriteService'];\n    }\n  }]);\n\n  function FavoritesService($log, favoriteService) {\n    var _this = this;\n\n    favoritesService_classCallCheck(this, FavoritesService);\n\n    favoritesService_favoriteService.set(this, favoriteService);\n\n    favoritesService_$log.set(this, $log);\n\n    this.logService = 'FavoritesService | ';\n    /**\n     * @public\n     * @since 1.56\n     * @event RAINBOW_ONFAVORITECREATED\n     * @param {Favorite} Favorite The created Favorite object\n     * @description\n     *      This event is fired when a Favorite is created\n     *      The event contains a **Favorite** object.\n     */\n\n    this.RAINBOW_ONFAVORITECREATED = 'rainbowonfavoritecreated';\n    /**\n     * @public\n     * @since 1.56\n     * @event RAINBOW_ONFAVORITEDELETED\n     * @param {Favorite} Favorite The created Favorite object\n     * @description\n     *      This event is fired when a Favorite is deleted\n     *      The event contains a **Favorite** object.\n     */\n\n    this.RAINBOW_ONFAVORITEDELETED = 'rainbowonfavoritedeleted';\n    /**\n     * @public\n     * @since 1.56\n     * @method fetchAllFavorites\n     * @instance\n     * @description\n     *   Fetch all the Favorites from the server in a form of an Array\n     * @return {Conversation[]} An array of Favorite objects\n     */\n\n    this.fetchAllFavorites = this.fetchAllFavorites.bind(this);\n    /**\n     * @public\n     * @since 1.56\n     * @method createFavorite\n     * @instance\n     * @description\n     *   Add conversation/bubble/bot to Favorites Array\n     * @param {String} id ID of the conversation/bubble\n     * @param {String} type Type of Favorite (can be 'conversation' or 'bubble')\n     * @return {Promise} Promise\n     */\n\n    this.createFavorite = this.createFavorite.bind(this);\n    /**\n     * @public\n     * @since 1.56\n     * @method deleteFavorite\n     * @instance\n     * @description\n     *   Delete conversation/bubble/bot from Favorites Array\n     * @param {String} id ID of the Favorite item\n     * @return {Favorite[]} A Favorite object\n     */\n\n    this.deleteFavorite = this.deleteFavorite.bind(this);\n    window.addEventListener('ON_FAVORITE_CREATED', function (event) {\n      return _this.onFavoriteCreated(event);\n    });\n    window.addEventListener('ON_FAVORITE_DELETED', function (event) {\n      return _this.onFavoriteDeleted(event);\n    });\n  }\n\n  favoritesService_createClass(FavoritesService, [{\n    key: \"onFavoriteCreated\",\n    value: function onFavoriteCreated(event) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONFAVORITECREATED, {\n        detail: event.detail\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"onFavoriteDeleted\",\n    value: function onFavoriteDeleted(event) {\n      var sdkEvent = new CustomEvent(this.RAINBOW_ONFAVORITEDELETED, {\n        detail: event.detail\n      });\n      document.dispatchEvent(sdkEvent);\n    }\n  }, {\n    key: \"fetchAllFavorites\",\n    value: function fetchAllFavorites() {\n      var _this2 = this;\n\n      var $log = favoritesService_$log.get(this);\n\n      var favoriteService = favoritesService_favoriteService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var that = _this2;\n        favoriteService.getServerFavorites().then(function (favorites) {\n          $log.sdk(that.logService + \"[fetchAllFavorites] :: Successfully fetched the Favorites\");\n          return resolve(favorites);\n        })[\"catch\"](function (err) {\n          $log.sdk(that.logService + \"[fetchAllFavorites] :: ERROR:\", err);\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"createFavorite\",\n    value: function createFavorite(id, type) {\n      var _this3 = this;\n\n      var favoriteService = favoritesService_favoriteService.get(this);\n\n      var $log = favoritesService_$log.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          $log.sdk(_this3.logService + \"[createFavorite] :: Error: parameter 'id' is missing or null\");\n          return reject(_this3.logService + \"[createFavorite] :: Error: parameter 'id' is missing or null\");\n        }\n\n        if (!type) {\n          $log.sdk(_this3.logService + \"[createFavorite] :: Error: parameter 'type' is missing or null\");\n          return reject(_this3.logService + \"[createFavorite] :: Error: parameter 'type' is missing or null\");\n        }\n\n        if (type !== 'bubble' && type !== 'user') {\n          $log.sdk(_this3.logService + '[createFavorite] :: Error: type should be set to \"user\" or \"bubble\"');\n          return reject(_this3.logService + '[createFavorite] :: Error: type should be set to \"user\" or \"bubble\"');\n        }\n\n        if (type === 'bubble') {\n          type = 'room';\n        }\n\n        favoriteService.addServerFavorite(id, type).then(function (favorite) {\n          $log.sdk(_this3.logService + \"[createFavorite] :: Successfully added \".concat(type, \" to favorites\"));\n          return resolve();\n        })[\"catch\"](function (err) {\n          $log.sdk(_this3.logService + '[createFavorite] :: Error: ' + err);\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"deleteFavorite\",\n    value: function deleteFavorite(id) {\n      var _this4 = this;\n\n      var favoriteService = favoritesService_favoriteService.get(this);\n\n      var $log = favoritesService_$log.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          $log.sdk(_this4.logService + \"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n          return reject(_this4.logService + \"[deleteFavorite] :: Error: parameter 'id' is missing or null\");\n        }\n\n        favoriteService.removeServerFavorite(id).then(function () {\n          return resolve();\n        })[\"catch\"](function (err) {\n          $log.sdk(_this4.logService + '[deleteFavorite] :: Error: ' + err);\n          return reject(err);\n        });\n      });\n    }\n  }]);\n\n  return FavoritesService;\n}();\n// CONCATENATED MODULE: ./src/filesStorageService.js\nfunction filesStorageService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction filesStorageService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction filesStorageService_createClass(Constructor, protoProps, staticProps) { if (protoProps) filesStorageService_defineProperties(Constructor.prototype, protoProps); if (staticProps) filesStorageService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name FileStorage\n * @public\n * @description\n *      This service shares files bwith a single user (one-to-one conversation) or with several persons (bubble conversation). <br><br>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Upload a file in a one-to-one conversation or bubble conversation, <br/>\n *      - Download a file from a conversation or bubble, <br/>\n *      - To be notified when a file has been successfully uploaded or downloaded by the connected user or when there is an error when uploading or downloading a file in a conversation or a bubble<br/>\n *      - Get the list of files send or received in a one-to-one conversation <br/>\n *      - Get the list of files send or received in a bubble conversation <br/>\n *      - Get the connected user quota and consumption\n * @fires RAINBOW_ONCHUNKLOADMESSAGE\n * @fires RAINBOW_ONFILEUPLOADED\n * @fires RAINBOW_ONFILEUPLOADED_ERROR\n * @fires RAINBOW_ONFILEDOWNLOADED\n * @fires RAINBOW_ONFILEDOWNLOADED_ERROR\n */\nvar filesStorageService_$rootScope = new WeakMap();\n\nvar filesStorageService_$log = new WeakMap();\n\nvar filesStorageService_Conversation = new WeakMap();\n\nvar filesStorageService_fileStorageService = new WeakMap();\n\nvar filesStorageService_fileServerService = new WeakMap();\n\nvar filesStorageService_conversationService = new WeakMap();\n\nvar filesStorageService_contactService = new WeakMap();\n\nvar filesStorageService_SDK = new WeakMap();\n\nvar FilesStorageService =\n/*#__PURE__*/\nfunction () {\n  filesStorageService_createClass(FilesStorageService, null, [{\n    key: \"inject\",\n    get: function get() {\n      return ['$rootScope', '$log', 'Conversation', 'fileStorageService', 'fileServerService', 'conversationService', 'contactService', 'SDK'];\n    }\n  }]);\n\n  function FilesStorageService($rootScope, $log, Conversation, fileStorageService, fileServerService, conversationService, contactService, SDK) {\n    var _this = this;\n\n    filesStorageService_classCallCheck(this, FilesStorageService);\n\n    filesStorageService_$rootScope.set(this, $rootScope);\n\n    filesStorageService_$log.set(this, $log);\n\n    filesStorageService_Conversation.set(this, Conversation);\n\n    filesStorageService_fileStorageService.set(this, fileStorageService);\n\n    filesStorageService_fileServerService.set(this, fileServerService);\n\n    filesStorageService_conversationService.set(this, conversationService);\n\n    filesStorageService_contactService.set(this, contactService);\n\n    filesStorageService_SDK.set(this, SDK);\n\n    this.logService = 'FilesStorageService | ';\n    /**\n     * @public\n     * @event RAINBOW_ONFILEUPLOADED\n     * @since 1.24\n     * @param {FileDescriptor} fileDescriptor   The descriptor of the file\n     * @description\n     *      This event is fired when a new file has been uploaded successfully to a conversation by the connected user (conversation with a contact or in a bubble)\n     */\n\n    this.RAINBOW_ONFILEUPLOADED = 'rainbowfileuploaded';\n    /**\n     * @public\n     * @event RAINBOW_ONFILEUPLOADED_ERROR\n     * @since 1.24\n     * @param {FileDescriptor} fileDescriptor   The descriptor of the file\n     * @description\n     *      This event is fired when the connected user fails to upload a file to a conversation (conversation with a contact or in a bubble)\n     */\n\n    this.RAINBOW_ONFILEUPLOADED_ERROR = 'rainbowfileuploadederror';\n    /**\n     * @public\n     * @event RAINBOW_ONFILEDOWNLOADED\n     * @since 1.24\n     * @param {string} fileId   The fileId of the file\n     * @param {boolean} cancelable Is the download cancelable\n     * @description\n     *      This event is fired when a file has been downloaded successfully from a conversation by the connected user (conversation with a contact or in a bubble)\n     */\n\n    this.RAINBOW_ONFILEDOWNLOADED = 'rainbowonfiledownloaded';\n    /**\n     * @public\n     * @event RAINBOW_ONFILEDOWNLOADED_ERROR\n     * @since 1.24\n     * @param {FileDescriptor} fileDescriptor   The descriptor of the file\n     * @description\n     *      This event is fired when the connected user fails to download a file from a conversation (conversation with a contact or in a bubble)\n     */\n\n    this.RAINBOW_ONFILEDOWNLOADED_ERROR = 'rainbowfiledownloadederror';\n    /**\n     * @public\n     * @event RAINBOW_ONCHUNKLOADMESSAGE\n     * @since 1.51\n     * @param { data } data The data object containing fileDescriptor of the file\n     * @description\n     *      This event is fired when the connected user tries to download or upload a file bigger than 1MB and the file is divided into chunks\n     */\n\n    this.RAINBOW_ONCHUNKLOADMESSAGE = 'rainbowonchunkloadmessage';\n    this.eventsMap = {\n      success: {\n        download: this.RAINBOW_ONFILEDOWNLOADED,\n        upload: this.RAINBOW_ONFILEUPLOADED\n      },\n      error: {\n        download: this.RAINBOW_ONFILEDOWNLOADED_ERROR,\n        upload: this.RAINBOW_ONFILEUPLOADED_ERROR\n      }\n    };\n    /**\n     * @private\n     * @method addFileToConversation\n     * @since 1.24\n     * @instance\n     * @description\n     *    Allow to add a file to an existing Peer 2 Peer or Bubble conversation\n     *    Return a promise\n     * @return {Message} Return the message sent\n     */\n\n    this.addFileToConversation = this.addFileToConversation.bind(this);\n    /**\n     * @public\n     * @method uploadFileToConversation\n     * @since 1.24\n     * @instance\n     * @param {Conversation} conversation   The conversation where the message will be added\n     * @param {File|String} file The file to add. It could be a JavaScript File object or a path to a local file.\n     * @param {String} message   An optional message to add with the file\n     * @description\n     *    Allow to add a file to an existing conversation (ie: conversation with a contact)\n     *    Return the promise\n     * @return {Message} Return the message sent\n     */\n\n    this.uploadFileToConversation = this.uploadFileToConversation.bind(this);\n    /**\n     * @public\n     * @method uploadFileToBubble\n     * @since 1.24\n     * @instance\n     * @param {Bubble} bubble   The bubble where the message will be added\n     * @param {File|String} file The file to add. It could be a JavaScript File object or a path to a local file.\n     * @param {String} message  An optional message to add with the file\n     * @description\n     *    Allow to add a file to an existing Bubble conversation\n     *    Return a promise\n     * @return {Message} Return the message sent\n     */\n\n    this.uploadFileToBubble = this.uploadFileToBubble.bind(this);\n    /**\n     * @public\n     * @method downloadFile\n     * @since 1.24\n     * @instance\n     * @param {FileDescriptor} fileDescriptor   The description of the file to download (short file descriptor)\n     * @description\n     *    Allow to download a file from the server\n     *    Return a promise\n     * @return {Blob} Return the file received\n     */\n\n    this.downloadFile = this.downloadFile.bind(this);\n    /**\n     * @public\n     * @method removeFile\n     * @since 1.24\n     * @instance\n     * @param {FileDescriptor} fileDescriptor   The description of the file to remove (short file descriptor)\n     * @description\n     *    Remove an uploaded file\n     *    Return a promise\n     * @return {Object} Return a SDK OK Object or a SDK error object depending the result\n     */\n\n    this.removeFile = this.removeFile.bind(this);\n    /**\n     * @public\n     * @method getFileDescriptorFromId\n     * @since 1.24\n     * @instance\n     * @param {String} id   The file id\n     * @description\n     *    Get the file descriptor the user own by it's id\n     * @return {FileDescriptor} Return a file descriptors found or null if no file descriptor has been found\n     */\n\n    this.getFileDescriptorFromId = this.getFileDescriptorFromId.bind(this);\n    /**\n     * @public\n     * @method getFilesReceivedInConversation\n     * @since 1.24\n     * @instance\n     * @param {Conversation} conversation   The conversation where to get the files\n     * @description\n     *    Get the list of all files received in a conversation with a contact\n     *    Return a promise\n     * @return {FileDescriptor[]} Return an array of file descriptors found or an empty array if no file descriptor has been found\n     */\n\n    this.getFilesReceivedInConversation = this.getFilesReceivedInConversation.bind(this);\n    /**\n     * @public\n     * @method getFilesReceivedInBubble\n     * @since 1.24\n     * @instance\n     * @param {Bubble} bubble   The bubble where to get the files\n     * @description\n     *    Get the list of all files received in a bubble\n     *    Return a promise\n     * @return {FileDescriptor[]} Return an array of file descriptors found or an empty array if no file descriptor has been found\n     */\n\n    this.getFilesReceivedInBubble = this.getFilesReceivedInBubble.bind(this);\n    /**\n     * @public\n     * @method getFilesSentInConversation\n     * @since 1.24\n     * @instance\n     * @param {Conversation} conversation   The conversation where to get the files\n     * @description\n     *    Get the list of all files sent in a conversation with a contact\n     *    Return a promise\n     * @return {FileDescriptor[]} Return an array of file descriptors found or an empty array if no file descriptor has been found\n     */\n\n    this.getFilesSentInConversation = this.getFilesSentInConversation.bind(this);\n    /**\n     * @public\n     * @method getFilesSentInBubble\n     * @since 1.24\n     * @instance\n     * @param {Bubble} bubble   The bubble where to get the files\n     * @description\n     *    Get the list of all files sent in a bubble\n     *    Return a promise\n     * @return {FileDescriptor[]} Return an array of file descriptors found or an empty array if no file descriptor has been found\n     */\n\n    this.getFilesSentInBubble = this.getFilesSentInBubble.bind(this);\n    /**\n     * @public\n     * @method getUserQuotaConsumption\n     * @since 1.24\n     * @instance\n     * @description\n     *    Get the current file storage quota and consumption for the connected user\n     *    Return a promise\n     * @return {Object} Return an object containing the user quota and consumption\n     */\n\n    this.getUserQuotaConsumption = this.getUserQuotaConsumption.bind(this);\n    /**\n     * @public\n     * @method getAllFilesSent\n     * @since 1.24\n     * @instance\n     * @description\n     *    Get the list of files (represented using an array of File|string Descriptor objects) created and owned by the connected which is the list of file sent to all of his conversations and bubbles.\n     * @return {FileDescriptor[]} Return an array containing the list of FileDescriptor objects representing the files sent\n     */\n\n    this.getAllFilesSent = this.getAllFilesSent.bind(this);\n    /**\n     * @public\n     * @method getAllFilesReceived\n     * @since 1.24\n     * @instance\n     * @description\n     *    Get the list of files (represented using an array of File|string Descriptor objects) received by the connected user from all of his conversations and bubbles.\n     * @return {FileDescriptor[]} Return an array containing a list of FileDescriptor objects representing the files received\n     */\n\n    this.getAllFilesReceived = this.getAllFilesReceived.bind(this);\n    /**\n     * @public\n     * @method cancelCurrentFileTransfer\n     * @since 1.52\n     * @instance\n     * @description\n     *  Cancel the ongoing file transfer based on the file ID.\n     * @param {id} id id of the file that is being transfered [string]\n     * @return {promise} returns promise with the updated fileDescriptor object\n     */\n\n    this.cancelCurrentFileTransfer = this.cancelCurrentFileTransfer.bind(this); //Listen for the general-purpose event sent by the webclient service\n\n    $rootScope.$on('$destroy', $rootScope.$on('ON_FILE_TRANSFER_EVENT', function (event, data) {\n      return _this.onFileTransferChanged(event, data);\n    }));\n  }\n  /* FILE TRANSFER EVENTS */\n\n  /**\n   * @private\n   * @since 1.52\n   * @method\n   * @description Method is in charge of sending the right events concerning the file transfer depeneding on the load data\n   * @param {} __event\n   * @param {object} data - data passed by the event\n   */\n\n\n  filesStorageService_createClass(FilesStorageService, [{\n    key: \"onFileTransferChanged\",\n    value: function onFileTransferChanged(event, data) {\n      var $log = filesStorageService_$log.get(this);\n\n      if (data.result && data.type) {\n        $log.sdk(this.logService + '[onFileTransferChanged] ::  File transfered');\n        var sdkEvent = new CustomEvent(this.eventsMap[data.result][data.type], {\n          detail: data\n        });\n        document.dispatchEvent(sdkEvent);\n      } else {\n        // Send an event only when the file is being uploaded or downloaded.\n        // Prevents sending an event when the transfer has been already cancelled\n        data = data.fileDesc;\n\n        if (data.state === 'uploading' || data.state === 'downloading') {\n          var _sdkEvent = new CustomEvent(this.RAINBOW_ONCHUNKLOADMESSAGE, {\n            detail: data\n          });\n\n          document.dispatchEvent(_sdkEvent);\n        }\n      }\n    }\n  }, {\n    key: \"addFileToConversation\",\n    value: function addFileToConversation(conversation, file, data) {\n      var SDK = filesStorageService_SDK.get(this);\n\n      var conversationService = filesStorageService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        return new Promise(function (resolve) {\n          if (typeof file === 'string') {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', file, true);\n\n            xhr.onreadystatechange = function () {\n              if (xhr.readyState === XMLHttpRequest.DONE) {\n                var blob = xhr.response;\n\n                var _file = new File([blob], file.replace(/^.*[\\\\\\/]/, ''));\n\n                return resolve(_file);\n              }\n            };\n\n            xhr.responseType = 'blob';\n            xhr.send();\n          } else {\n            return resolve(file);\n          } // Allow to pass a file path (for test purpose)\n\n        }).then(function (_file) {\n          if (_file.size > 100000000) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: 'The file is too large (limited to 100MB)'\n            });\n          } else {\n            conversationService.sendFSMessage(conversation, _file, data).then(function (message) {\n              return resolve(message);\n            });\n          }\n        });\n      });\n    }\n  }, {\n    key: \"uploadFileToConversation\",\n    value: function uploadFileToConversation(conversation, file, message) {\n      var _this2 = this;\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      var $log = filesStorageService_$log.get(this);\n\n      var Conversation = filesStorageService_Conversation.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else if (!file) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'file' is missing or null\"\n          });\n        } else if (conversation.type !== Conversation.Type.ONE_TO_ONE) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is not a one-to-one conversation\"\n          });\n        } else {\n          $log.sdk(_this2.logService + '[uploadFileToConversation] ::  Add file to the conversation ' + conversation.id);\n\n          _this2.addFileToConversation(conversation, file, message).then(function (msg) {\n            $log.sdk(_this2.logService + '[uploadFileToConversation] ::  file added');\n            return resolve(msg);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"uploadFileToBubble\",\n    value: function uploadFileToBubble(bubble, file, message) {\n      var _this3 = this;\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      var $log = filesStorageService_$log.get(this);\n\n      var Conversation = filesStorageService_Conversation.get(this);\n\n      var conversationService = filesStorageService_conversationService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else if (!file) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'file' is missing or null\"\n          });\n        } else {\n          var conversation = conversationService.getConversationByRoomDbId(bubble.dbId);\n\n          if (!conversation) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"Parameter 'bubble' don't have a conversation\"\n            });\n          } else if (conversation.type !== Conversation.Type.ROOM) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"Parameter 'conversation' is not a bubble conversation\"\n            });\n          } else {\n            $log.sdk(_this3.logService + '[uploadFileToBubble] ::  Trying to add a file to the bubble ' + bubble.dbId);\n\n            _this3.addFileToConversation(conversation, file, message).then(function (msg) {\n              $log.sdk(_this3.logService + '[uploadFileToBubble] ::  File added');\n              return resolve(msg);\n            })[\"catch\"](function (err) {\n              return reject(err);\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"downloadFile\",\n    value: function downloadFile(fileDescriptor) {\n      var _this4 = this;\n\n      var $log = filesStorageService_$log.get(this);\n\n      var fileServerService = filesStorageService_fileServerService.get(this);\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!fileDescriptor) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'fileDescriptor' is missing or null\"\n          });\n        } else {\n          $log.sdk(_this4.logService + '[downloadFile] ::  Trying to get a file'); // const fileToDownload = {\n          // url: fileDescriptor.url || config.restServerUrl + '/api/rainbow/fileserver/v1.0/files/' + fileDescriptor.id,\n          // mime: fileDescriptor.mime || fileDescriptor.typeMIME,\n          // filesize: fileDescriptor.filesize || fileDescriptor.size,\n          // filename: fileDescriptor.filename || fileDescriptor.fileName\n          // };\n\n          fileServerService.getBlobFromFileDescriptor(fileDescriptor, true).then(function (blob) {\n            $log.sdk(_this4.logService + '[downloadFile] ::  File downloaded');\n            return resolve(blob);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"removeFile\",\n    value: function removeFile(fileDescriptor) {\n      var _this5 = this;\n\n      var $log = filesStorageService_$log.get(this);\n\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!fileDescriptor) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'fileDescriptor' is missing or null\"\n          });\n        }\n\n        if (!fileDescriptor.id && !fileDescriptor.url) {\n          reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'fileDescriptor' don't contain information to remove the file\"\n          });\n        } else {\n          $log.sdk(_this5.logService + '[removeFile] ::  Trying to remove a file');\n          var fileDescriptorId = fileDescriptor.id;\n\n          if (!fileDescriptorId) {\n            var parts = fileDescriptor.url.split('/');\n            fileDescriptorId = parts.pop() || parts.pop();\n          }\n\n          fileStorageService.deleteFileDescriptor(fileDescriptorId).then(function () {\n            $log.sdk(_this5.logService + '[removeFile] ::  File removed');\n            resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getFileDescriptorFromId\",\n    value: function getFileDescriptorFromId(id) {\n      var $log = filesStorageService_$log.get(this);\n\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      $log.sdk(this.logService + '[getFileDescriptorFromId] ::  Get file descriptor ' + id);\n      return fileStorageService.getFileDescriptorById(id);\n    }\n  }, {\n    key: \"getFilesReceivedInConversation\",\n    value: function getFilesReceivedInConversation(conversation) {\n      var _this6 = this;\n\n      var $log = filesStorageService_$log.get(this);\n\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      var Conversation = filesStorageService_Conversation.get(this);\n\n      var contactService = filesStorageService_contactService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else if (conversation.type !== Conversation.Type.ONE_TO_ONE) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is not a one-to-one conversation\"\n          });\n        } else {\n          $log.sdk(_this6.logService + '[getFilesReceivedInConversation] ::  Get files received in conversation ' + conversation.id + '...');\n          fileStorageService.retrieveFilesReceivedFromPeer(contactService.userContact.dbId, conversation.contact.dbId).then(function (files) {\n            $log.sdk(_this6.logService + '[getFilesReceivedInConversation] ::  Shared ' + files.length);\n            return resolve(files);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getFilesReceivedInBubble\",\n    value: function getFilesReceivedInBubble(bubble) {\n      var _this7 = this;\n\n      var $log = filesStorageService_$log.get(this);\n\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          $log.sdk(_this7.logService + '[getFilesReceivedInBubble] ::  Get files received in bubble ' + bubble.dbId);\n          fileStorageService.retrieveReceivedFilesForRoom(bubble.dbId).then(function (files) {\n            $log.sdk(_this7.logService + '[getFilesReceivedInBubble] ::  Shared ' + files.length);\n            return resolve(files);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getFilesSentInConversation\",\n    value: function getFilesSentInConversation(conversation) {\n      var _this8 = this;\n\n      var $log = filesStorageService_$log.get(this);\n\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      var Conversation = filesStorageService_Conversation.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!conversation) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is missing or null\"\n          });\n        } else if (conversation.type !== Conversation.Type.ONE_TO_ONE) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'conversation' is not a one-to-one conversation\"\n          });\n        } else {\n          $log.sdk(_this8.logService + '[getFilesSentInConversation] :: Get files sent in conversation ' + conversation.id);\n          fileStorageService.retrieveSentFiles(conversation.contact.dbId).then(function (files) {\n            $log.sdk(_this8.logService + '[getFilesSentInConversation] :: Shared ' + files.length);\n            return resolve(files);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getFilesSentInBubble\",\n    value: function getFilesSentInBubble(bubble) {\n      var _this9 = this;\n\n      var $log = filesStorageService_$log.get(this);\n\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      var SDK = filesStorageService_SDK.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!bubble) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'bubble' is missing or null\"\n          });\n        } else {\n          $log.sdk(_this9.logService + '[getFilesSentInBubble] :: Get files sent in bubble ' + bubble.dbId);\n          fileStorageService.retrieveSentFiles(bubble.dbId).then(function (files) {\n            $log.sdk(_this9.logService + '[getFilesSentInBubble] :: Shared ' + files.length);\n            return resolve(files);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getUserQuotaConsumption\",\n    value: function getUserQuotaConsumption() {\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        fileStorageService.retrieveUserConsumption().then(function (consumptionData) {\n          return resolve(consumptionData);\n        })[\"catch\"](function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"getAllFilesSent\",\n    value: function getAllFilesSent() {\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      return fileStorageService.getDocuments();\n    }\n  }, {\n    key: \"getAllFilesReceived\",\n    value: function getAllFilesReceived() {\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      return fileStorageService.getReceivedDocuments();\n    }\n  }, {\n    key: \"cancelCurrentFileTransfer\",\n    value: function cancelCurrentFileTransfer(id) {\n      var SDK = filesStorageService_SDK.get(this);\n\n      var fileStorageService = filesStorageService_fileStorageService.get(this);\n\n      var fileServerService = filesStorageService_fileServerService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or null\"\n          });\n        } else {\n          // If the id parameter is provided, check if getFileDescriptorById() finds the right file\n          var fileDescriptor = fileStorageService.getFileDescriptorById(id);\n\n          if (fileDescriptor == null) {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: 'Could not find a file with the id ' + id\n            });\n          } else if (fileDescriptor.state !== 'downloading' && fileDescriptor.state !== 'uploading') {\n            return reject({\n              code: SDK.ERRORBADREQUEST,\n              label: \"File Status is not set to 'downloading' or 'uploading'\"\n            });\n          } else {\n            fileServerService.cancelCurrentFiletransfer(id);\n\n            if (fileDescriptor.state !== 'not_uploaded' && fileDescriptor.state !== 'uploading') {\n              fileDescriptor.state = 'uploaded';\n              return resolve(fileDescriptor);\n            } else if (fileDescriptor.state !== 'not_uploaded' && fileDescriptor.state === 'uploading') {\n              fileDescriptor.state = 'not_uploaded';\n              return resolve(fileDescriptor);\n            }\n          }\n        }\n      });\n    }\n  }]);\n\n  return FilesStorageService;\n}();\n// CONCATENATED MODULE: ./src/capabilitiesService.js\nfunction capabilitiesService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction capabilitiesService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction capabilitiesService_createClass(Constructor, protoProps, staticProps) { if (protoProps) capabilitiesService_defineProperties(Constructor.prototype, protoProps); if (staticProps) capabilitiesService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Capabilities\n * @public\n * @description\n *      This service manages the capabilities of the connected user.<br><br>\n *      The capabilities allow to use the Rainbow features depending on the user subscription profile. <br><br>\n *      The main methods proposed in that service allow to: <br>\n *      - Get all capabilities <br/>\n *      - Check each capability individually <br/>\n */\nvar capabilitiesService_profileService = new WeakMap();\n\nvar CapabilitiesService =\n/*#__PURE__*/\nfunction () {\n  capabilitiesService_createClass(CapabilitiesService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['profileService'];\n    }\n  }]);\n\n  function CapabilitiesService(profileService) {\n    capabilitiesService_classCallCheck(this, CapabilitiesService);\n\n    capabilitiesService_profileService.set(this, profileService);\n    /**\n     * @public\n     * @method getAll\n     * @instance\n     * @description\n     *    Get all capabilities for the connected user\n     * @return {Object[]} An array of Objects representing the capabilities supported\n     */\n\n\n    this.getAll = this.getAll.bind(this);\n    /**\n     * @public\n     * @method hasS4BExtensionEnabled\n     * @instance\n     * @description\n     *    Check the right to use the Skype for Business extension\n     * @return {boolean} Return true if the user can use the S4B extension\n     */\n\n    this.hasS4BExtensionEnabled = this.hasS4BExtensionEnabled.bind(this);\n    /**\n     * @public\n     * @method hasOutlookExtensionEnabled\n     * @instance\n     * @description\n     *    Check the right to use the Outlook extension\n     * @return {boolean} Return true if the user can use the Microsoft Outlook extension\n     */\n\n    this.hasOutlookExtensionEnabled = this.hasOutlookExtensionEnabled.bind(this);\n    /**\n     * @public\n     * @method hasCalendarPresenceEnabled\n     * @instance\n     * @description\n     *    Check the right to take into account the Microsoft Office 365 Presence information\n     * @return {boolean} Return true if the user can take into account is O365 Presence information\n     */\n\n    this.hasCalendarPresenceEnabled = this.hasCalendarPresenceEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonyBasicCallEnabled\n     * @instance\n     * @description\n     *    Check the right to use the Basic Telephony feature (make call, take call and clear call)\n     * @return {boolean} Return true if the user can use the Telephony basic call feature\n     */\n\n    this.hasTelephonyBasicCallEnabled = this.hasTelephonyBasicCallEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonySecondCallEnabled\n     * @instance\n     * @description\n     *    Check the right to make a second call when an other one is active\n     * @return {boolean} Return true if the user can make a second call\n     */\n\n    this.hasTelephonySecondCallEnabled = this.hasTelephonySecondCallEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonyTransferCallEnabled\n     * @instance\n     * @description\n     *    Check the right to transfer a call\n     * @return {boolean} Return true if the user can transfer the call\n     */\n\n    this.hasTelephonyTransferCallEnabled = this.hasTelephonyTransferCallEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonyConferenceCallEnabled\n     * @instance\n     * @description\n     *    Check the right to initiate a conference call\n     * @return {boolean} Return true if the user can initiate a conference call\n     */\n\n    this.hasTelephonyConferenceCallEnabled = this.hasTelephonyConferenceCallEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonyDeflectCallEnabled\n     * @instance\n     * @description\n     *    Check the right to deflect a  call\n     * @return {boolean} Return true if the user can deflect a call\n     */\n\n    this.hasTelephonyDeflectCallEnabled = this.hasTelephonyDeflectCallEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonyForwardCallEnabled\n     * @instance\n     * @description\n     *    Check the right to forward a call\n     * @return {boolean} Return true if the user can forward a call\n     */\n\n    this.hasTelephonyForwardCallEnabled = this.hasTelephonyForwardCallEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonyPhoneBookEnabled\n     * @instance\n     * @description\n     *    Check the right to access the phone book\n     * @return {boolean} Return true if the user can access to the phone book\n     */\n\n    this.hasTelephonyPhoneBookEnabled = this.hasTelephonyPhoneBookEnabled.bind(this);\n    /**\n     * @public\n     * @method hasTelephonyVoiceMailEnabled\n     * @instance\n     * @description\n     *    Check the right to access the voice mail\n     * @return {boolean} Return true if the user can access to the voice mail\n     */\n\n    this.hasTelephonyVoiceMailEnabled = this.hasTelephonyVoiceMailEnabled.bind(this);\n    /**\n     * @public\n     * @method hasWebRTCAudioMobileEnabled\n     * @instance\n     * @description\n     *    Check the right to make a WebRTC audio call using a mobile device\n     * @return {boolean} Return true if the user can make a WebRTC audio call using his mobile device\n     */\n\n    this.hasWebRTCAudioMobileEnabled = this.hasWebRTCAudioMobileEnabled.bind(this);\n    /**\n     * @public\n     * @method hasWebRTCVideoMobileEnabled\n     * @instance\n     * @description\n     *    Check the right to make a WebRTC video call using a mobile device\n     * @return {boolean} Return true if the user can make a WebRTC video call using his mobile device\n     */\n\n    this.hasWebRTCVideoMobileEnabled = this.hasWebRTCVideoMobileEnabled.bind(this);\n    /**\n     * @public\n     * @method hasBridgeConferenceEnabled\n     * @instance\n     * @description\n     *    Check the right to have a conference audio bridge\n     * @return {boolean} Return true if the user has an associated conference audio bridge\n     */\n\n    this.hasBridgeConferenceEnabled = this.hasBridgeConferenceEnabled.bind(this);\n    /**\n     * @public\n     * @method hasBridgeConferenceRecordEnabled\n     * @instance\n     * @description\n     *    Check the right to record a conference\n     * @return {boolean} Return true if the user can record the conference\n     */\n\n    this.hasBridgeConferenceRecordEnabled = this.hasBridgeConferenceRecordEnabled.bind(this);\n    /**\n     * @public\n     * @method hasBridgeConferenceDialOutEnabled\n     * @instance\n     * @description\n     *    Check the right to be called back by the conference bridge\n     * @return {boolean} Return true if the user can be called back by the conference bridge\n     */\n\n    this.hasBridgeConferenceDialOutEnabled = this.hasBridgeConferenceDialOutEnabled.bind(this);\n    /**\n     * @public\n     * @method maxParticipantsPerBubbleAllowed\n     * @instance\n     * @description\n     *    Get the maximum number of participants that can join a bubble\n     * @return {Number} The maximum number of participants per bubble\n     */\n\n    this.maxParticipantsPerBubbleAllowed = this.maxParticipantsPerBubbleAllowed.bind(this);\n    /**\n     * @public\n     * @method maxParticipantsPerBridgeConferenceAllowed\n     * @instance\n     * @description\n     *    Get the maximum number of participants that can join a conference bridge\n     * @return {Number} The maximum number of participants per conference bridge\n     */\n\n    this.maxParticipantsPerBridgeConferenceAllowed = this.maxParticipantsPerBridgeConferenceAllowed.bind(this);\n    /**\n     * @public\n     * @method maxFileStorageQuotaAllowed\n     * @instance\n     * @description\n     *    Get the quota allowed for the file storage\n     * @return {Number} The quota (in GB) allowed for the File Storage\n     */\n\n    this.maxFileStorageQuotaAllowed = this.maxFileStorageQuotaAllowed.bind(this);\n  }\n\n  capabilitiesService_createClass(CapabilitiesService, [{\n    key: \"getAll\",\n    value: function getAll() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.getMyProfileFeatures();\n    }\n  }, {\n    key: \"hasS4BExtensionEnabled\",\n    value: function hasS4BExtensionEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('MS_SKYPE_PLUGIN');\n    }\n  }, {\n    key: \"hasOutlookExtensionEnabled\",\n    value: function hasOutlookExtensionEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('MS_OUTLOOK_PLUGIN');\n    }\n  }, {\n    key: \"hasCalendarPresenceEnabled\",\n    value: function hasCalendarPresenceEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('MSO365_CALENDAR_PRESENCE');\n    }\n  }, {\n    key: \"hasTelephonyBasicCallEnabled\",\n    value: function hasTelephonyBasicCallEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_BASIC_CALL');\n    }\n  }, {\n    key: \"hasTelephonySecondCallEnabled\",\n    value: function hasTelephonySecondCallEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_SECOND_CALL');\n    }\n  }, {\n    key: \"hasTelephonyTransferCallEnabled\",\n    value: function hasTelephonyTransferCallEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_TRANSFER_CALL');\n    }\n  }, {\n    key: \"hasTelephonyConferenceCallEnabled\",\n    value: function hasTelephonyConferenceCallEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_CONFERENCE_CALL');\n    }\n  }, {\n    key: \"hasTelephonyDeflectCallEnabled\",\n    value: function hasTelephonyDeflectCallEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_DEFLECT_CALL');\n    }\n  }, {\n    key: \"hasTelephonyForwardCallEnabled\",\n    value: function hasTelephonyForwardCallEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_FORWARD_CALL');\n    }\n  }, {\n    key: \"hasTelephonyPhoneBookEnabled\",\n    value: function hasTelephonyPhoneBookEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_PHONE_BOOK');\n    }\n  }, {\n    key: \"hasTelephonyVoiceMailEnabled\",\n    value: function hasTelephonyVoiceMailEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('TELEPHONY_VOICE_MAIL');\n    }\n  }, {\n    key: \"hasWebRTCAudioMobileEnabled\",\n    value: function hasWebRTCAudioMobileEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('WEBRTC_FOR_MOBILE');\n    }\n  }, {\n    key: \"hasWebRTCVideoMobileEnabled\",\n    value: function hasWebRTCVideoMobileEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('WEBRTC_FOR_MOBILE_VIDEO');\n    }\n  }, {\n    key: \"hasBridgeConferenceEnabled\",\n    value: function hasBridgeConferenceEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('CONFERENCE_ALLOWED');\n    }\n  }, {\n    key: \"hasBridgeConferenceRecordEnabled\",\n    value: function hasBridgeConferenceRecordEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('CONFERENCE_RECORDING');\n    }\n  }, {\n    key: \"hasBridgeConferenceDialOutEnabled\",\n    value: function hasBridgeConferenceDialOutEnabled() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.isFeatureEnabled('CONFERENCE_DIAL_OUT');\n    }\n  }, {\n    key: \"maxParticipantsPerBubbleAllowed\",\n    value: function maxParticipantsPerBubbleAllowed() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.getFeatureLimitMax('BUBBLE_PARTICIPANT_COUNT');\n    }\n  }, {\n    key: \"maxParticipantsPerBridgeConferenceAllowed\",\n    value: function maxParticipantsPerBridgeConferenceAllowed() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.getFeatureLimitMax('CONFERENCE_PARTICIPANT_COUNT');\n    }\n  }, {\n    key: \"maxFileStorageQuotaAllowed\",\n    value: function maxFileStorageQuotaAllowed() {\n      var profileService = capabilitiesService_profileService.get(this);\n\n      return profileService.getFeatureLimitMax('FILE_SHARING_QUOTA_GB');\n    }\n  }]);\n\n  return CapabilitiesService;\n}();\n// CONCATENATED MODULE: ./src/adminService.js\nfunction adminService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction adminService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction adminService_createClass(Constructor, protoProps, staticProps) { if (protoProps) adminService_defineProperties(Constructor.prototype, protoProps); if (staticProps) adminService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Admin\n * @public\n * @description\n *      This module allows to manage a company and the invited users. <br><br>\n *      The main methods and events proposed in that module allow to: <br>\n *      - Create and manage your company, <br/>\n *      - Invite and manage participants <br/>\n */\nvar _Company = new WeakMap();\n\nvar _User = new WeakMap();\n\nvar adminService_adminCompanyService = new WeakMap();\n\nvar adminService_adminUserService = new WeakMap();\n\nvar AdminService =\n/*#__PURE__*/\nfunction () {\n  adminService_createClass(AdminService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['Company', 'User', 'adminCompanyService', 'adminUserService'];\n    }\n  }]);\n\n  function AdminService(Company, User, adminCompanyService, adminUserService) {\n    adminService_classCallCheck(this, AdminService);\n\n    this.logService = 'AdminService | ';\n\n    _Company.set(this, Company);\n\n    _User.set(this, User);\n\n    adminService_adminCompanyService.set(this, adminCompanyService);\n\n    adminService_adminUserService.set(this, adminUserService);\n    /**\n     * Create essential company\n     * @private\n     */\n\n\n    this.createEssentialCompany = this.createEssentialCompany.bind(this);\n    /**\n     * Create a company\n     * @private\n     */\n\n    this.createCompany = this.createCompany.bind(this);\n    /**\n     * Remove a company\n     * @private\n     */\n\n    this.removeCompany = this.removeCompany.bind(this);\n    /**\n     * @public\n     * @method createUserForCompany\n     * @instance\n     * @description\n     *\tCreate a new user for a given company\n     * @param {String} strLogin User login\n     * @param {String} strFirstName User first name\n     * @param {String} strLastName User last name\n     * @param {String} strPassword User password\n     * @param {Object} company Object of Company for which the user is supposed to be created\n     * @param {Tags[]} tags Array of tags for the user (optional)\n     */\n\n    this.createUserForCompany = this.createUserForCompany.bind(this);\n    /**\n     * Remove a user from a company\n     * @private\n     */\n\n    this.removeUserFromCompany = this.removeUserFromCompany.bind(this);\n    /**\n     * @public\n     * @method fetchUsersByTag\n     * @since 1.60\n     * @instance\n     * @description\n     *   Perform a complex search for users\n     * @param {String} searchPattern String representing a tag to search\n     * @param {Integer} page Page number (optional; defaults to 1)\n     * @param {Integer} page Page size - number of results per page (optional; defaults to 10)\n     * @return {Users[]} Array of users found\n     */\n\n    this.fetchUsersByTag = this.fetchUsersByTag.bind(this);\n    /**\n     * @public\n     * @method updateUserTags\n     * @since 1.60\n     * @instance\n     * @description\n     *   Update user tags\n     * @param {Object} user User to update (object)\n     * @param {Array} tags Tags to update (array of min 1, max 5 elements)\n     * @return {Promise}\n     */\n\n    this.updateUserTags = this.updateUserTags.bind(this);\n    /**\n     * Set the visibility for a company\n     * @private\n     */\n\n    this.setVisibilityForCompany = this.setVisibilityForCompany.bind(this);\n    /**\n     * Promote a company to BP\n     * @private\n     */\n\n    this.promoteCompanyToBP = this.promoteCompanyToBP.bind(this);\n  }\n\n  adminService_createClass(AdminService, [{\n    key: \"createEssentialCompany\",\n    value: function createEssentialCompany(strName, strCountry) {\n      var Company = _Company.get(this);\n\n      var adminCompanyService = adminService_adminCompanyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var company = Company.create(null, '');\n        company.name = strName;\n        company.country = strCountry;\n        adminCompanyService.createCompanyEndUser(company).then(function (companyCreated) {\n          resolve(companyCreated);\n        })[\"catch\"](function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"createCompany\",\n    value: function createCompany(strName, strCountry, strState) {\n      var Company = _Company.get(this);\n\n      var adminCompanyService = adminService_adminCompanyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var company = Company.create(null, '');\n        company.name = strName;\n        company.country = strCountry;\n\n        if (strState) {\n          company.state = strState;\n        }\n\n        company.economicActivityClassification = '';\n        adminCompanyService.createCompany(company).then(function (companyCreated) {\n          resolve(companyCreated);\n        })[\"catch\"](function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"removeCompany\",\n    value: function removeCompany(company) {\n      var adminCompanyService = adminService_adminCompanyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        adminCompanyService.deleteCompany(company.id).then(function () {\n          resolve(company);\n        })[\"catch\"](function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"createUserForCompany\",\n    value: function createUserForCompany(strLogin, strFirstName, strLastName, strPassword, company, tags) {\n      var User = _User.get(this);\n\n      var adminUserService = adminService_adminUserService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var user = User.create();\n        user.loginEmail = strLogin;\n        user.firstName = strFirstName;\n        user.lastName = strLastName;\n        user.password = strPassword;\n        user.language = 'en';\n        user.companyId = company.id;\n        user.adminType = 'undefined';\n        user.isActive = true;\n        user.isInitialized = true; // Check if the tags parameter exists and if it is an array\n\n        if (tags) {\n          user.tags = tags && Array.isArray(tags) ? tags : [tags];\n        }\n\n        adminUserService.createUser(user).then(function (userCreated) {\n          resolve(userCreated);\n        })[\"catch\"](function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"removeUserFromCompany\",\n    value: function removeUserFromCompany(user) {\n      var adminUserService = adminService_adminUserService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        adminUserService.deleteUser(user).then(function () {\n          resolve(user);\n        })[\"catch\"](function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"fetchUsersByTag\",\n    value: function fetchUsersByTag(searchPattern, page, pageSize) {\n      var adminUserService = adminService_adminUserService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        var source = null,\n            isTerminated = false,\n            isAdministrator = null,\n            noDefaultValues = false,\n            tags = true;\n        page = page ? page : 1;\n        pageSize = pageSize ? pageSize : 10;\n        adminUserService.getUsers(source, page, pageSize, searchPattern, isTerminated, isAdministrator, noDefaultValues, tags).then(function (users) {\n          return resolve(users);\n        })[\"catch\"](function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"updateUserTags\",\n    value: function updateUserTags(user, tags) {\n      var _this = this;\n\n      var adminUserService = adminService_adminUserService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        if (!user) {\n          return reject(_this.logService + \"[updateUserTags] :: Error: parameter 'user' is missing or null\");\n        } else if (!user.id) {\n          return reject(_this.logService + \"[updateUserTags] :: Error: parameter 'user.id' is missing or null\");\n        } else if (tags instanceof Array !== true) {\n          return reject(_this.logService + \"[updateUserTags] :: Error: parameter 'tags' must be an array\");\n        } else if (tags instanceof Array && (tags.length < 1 || tags.length > 5)) {\n          return reject(_this.logService + \"[updateUserTags] :: Error: parameter 'tags' must be an array with at least 1 and maximum 5 elements\");\n        } else {\n          user.tags = tags;\n          adminUserService.updateUser(user).then(function () {\n            return resolve;\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"setVisibilityForCompany\",\n    value: function setVisibilityForCompany(company, visibleByCompany) {\n      var adminCompanyService = adminService_adminCompanyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        adminCompanyService.addVisibility(company.id, visibleByCompany.id).then(function () {\n          resolve(company);\n        })[\"catch\"](function (err) {\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"promoteCompanyToBP\",\n    value: function promoteCompanyToBP(company, bpType, applicantNumber) {\n      var adminCompanyService = adminService_adminCompanyService.get(this);\n\n      return new Promise(function (resolve, reject) {\n        company.isBP = true;\n        company.bpType = bpType;\n        company.bpBusinessModel = 'resell';\n        company.bpApplicantNumber = applicantNumber;\n        company.bpCRDid = applicantNumber;\n        company.supportEmail = 'rford@sandbox.westworld.com';\n        adminCompanyService.updateCompany(company).then(function (updatedCompany) {\n          resolve(updatedCompany);\n        })[\"catch\"](function (error) {\n          reject(error);\n        });\n      });\n    }\n  }]);\n\n  return AdminService;\n}();\n// CONCATENATED MODULE: ./src/channelsService.js\nfunction channelsService_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction channelsService_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction channelsService_createClass(Constructor, protoProps, staticProps) { if (protoProps) channelsService_defineProperties(Constructor.prototype, protoProps); if (staticProps) channelsService_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @module\n * @name Channels\n * @description\n *      This service gives access to channels in Rainbow.<br/>\n *      It is a Publish–subscribe pattern implementation<br/><br/>\n *      Rainbow users can create channels. Currently, there is a configuration limit for max_items=100 and a source code limit for max_payload_size=60000 bytes<br/><br/>\n *      The main methods and events proposed in that service allow to: <br>\n *      - Get all channels owned by an user, <br/>\n *      - Find a channel, get a channel, if owned modify it,<br/>\n *      - Subscribe/Unsubscribe to a channel (you are not automatically subscried to a channel you own),<br/>\n *      - Publish a message to a channel,<br/>\n *      - Manage users in a channel you own,<br/>\n *      - Soon get previous messages in a channel<br/>\n * @fires RAINBOW_ONCHANNELMESSAGERECEIVED\n * @fires RAINBOW_ONCHANNELUPDATED\n * @fires RAINBOW_ONCHANNELDELETED\n * @fires RAINBOW_ONCHANNELUSERSUPDATED\n * @fires RAINBOW_ONCHANNELRETRACTMESSAGERECEIVED\n * @fires RAINBOW_ONCHANNELAVATARUPDATED\n * @fires RAINBOW_ONCHANNELUSERSUBSCRIBED\n * @fires RAINBOW_ONCHANNELUSERUNSUBSCRIBED\n */\nvar channelsService_$log = new WeakMap();\n\nvar channelsService_$rootScope = new WeakMap();\n\nvar channelsService_channelService = new WeakMap();\n\nvar channelsService_contactService = new WeakMap();\n\nvar channelsService_SDK = new WeakMap();\n\nvar ChannelsService =\n/*#__PURE__*/\nfunction () {\n  channelsService_createClass(ChannelsService, null, [{\n    key: \"$inject\",\n    get: function get() {\n      return ['$log', '$rootScope', 'channelService', 'contactService', 'SDK'];\n    }\n  }]);\n\n  function ChannelsService($log, $rootScope, channelService, contactService, SDK) {\n    var _this = this;\n\n    channelsService_classCallCheck(this, ChannelsService);\n\n    this.logService = 'ChannelsService | ';\n\n    channelsService_$log.set(this, $log);\n\n    channelsService_$rootScope.set(this, $rootScope);\n\n    channelsService_channelService.set(this, channelService);\n\n    channelsService_contactService.set(this, contactService);\n\n    channelsService_SDK.set(this, SDK);\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELMESSAGERECEIVED\n     * @since 1.38\n     * @param {Channel} channel The channel updated\n     * @param {Object} message The message with<br/>\n     *        {String} id: the id of the message,<br/>\n     *        {String} channelId: the channel's id,<br/>\n     *        {String} from: the sender,<br/>\n     *        {String} message: message if any,<br/>\n     *        {String} title: title if any,<br/>\n     *        {String} url: url if any,<br/>\n     *        {Number} timestamp: the timestamp\n     * @description\n     *      This event is fired when a message has been received from a channel\n     */\n\n\n    this.RAINBOW_ONCHANNELMESSAGERECEIVED = 'rainbowchannelmessagereceived';\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELUPDATED\n     * @since 1.38\n     * @param {Channel} channel The channel updated\n     * @param {Number} kind The kind of change (ADD: 0, UPDATE: 1, REMOVE: 2, SUBSCRIBE: 4, UNSUBSCRIBE: 5)\n     * @description\n     *      This event is fired when a parameter of the channel was updated\n     */\n\n    this.RAINBOW_ONCHANNELUPDATED = 'rainbowchannelupdate';\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELDELETED\n     * @since 1.47\n     * @param {String} id The id of the channel deleted\n     * @description\n     *      This event is fired when a parameter of the channel was updated\n     */\n\n    this.RAINBOW_ONCHANNELDELETED = 'rainbowchanneldeleted';\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELUSERSUPDATED\n     * @since 1.38\n     * @param {Channel} channel The channel updated\n     * @param {Object} users Arrays of user removed, updated and added with:<br/>\n     *   removed \t{String}[] removed users ids<br/>\n     *   updated \t{String}[] updated users ids<br/>\n     *   added \t    {String}[] added users ids<br/>\n     * @description\n     *      This event is fired when a channel users are changed (closed channels only)\n     */\n\n    this.RAINBOW_ONCHANNELUSERSUPDATED = 'rainbowchannelusersupdate';\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELRETRACTMESSAGERECEIVED\n     * @since 1.38\n     * @param {Channel} channel The channel updated\n     * @description\n     *      This event is fired when the persistence history limit is reached for the given channel<br/>\n     *      (oldest message will be deleted to keep the max limit)\n     */\n\n    this.RAINBOW_ONCHANNELRETRACTMESSAGERECEIVED = 'rainbowchannelretractmessage';\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELAVATARUPDATED\n     * @since 1.38\n     * @param {Channel} channel The channel updated\n     * @description\n     *      This event is fired when the avatar changed for the given channel\n     */\n\n    this.RAINBOW_ONCHANNELAVATARUPDATED = 'rainbowchannelavatarupdate';\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELUSERSUBSCRIBED\n     * @since 1.47\n     * @param {Channel} channel The channel updated\n     * @param {Contact} user The user who subscribes to the channel\n     * @description\n     *      This event is fired when a user has subscribed to the channel\n     */\n\n    this.RAINBOW_ONCHANNELUSERSUBSCRIBED = 'rainbowchannelusersubscribed';\n    /**\n     * @public\n     * @event RAINBOW_ONCHANNELUSERUNSUBSCRIBED\n     * @since 1.47\n     * @param {Channel} channel The channel updated\n     * @param {Contact} user The user who unsubscribes from the channel\n     * @description\n     *      This event is fired when a user has unsubscribed to the channel\n     */\n\n    this.RAINBOW_ONCHANNELUSERUNSUBSCRIBED = 'rainbowchanneluserunsubscribed';\n    /**\n     * @public\n     * @method fetchMyChannels\n     * @since 1.38\n     * @instance\n     * @description\n     *    Get the channels you own, are subscribed to, are publisher<br/>\n     *    Return a promise.\n     * @return {Channel[]} Return a list of channels or an empty array if no channel has been found\n     */\n\n    this.fetchMyChannels = this.fetchMyChannels.bind(this);\n    /**\n     * @public\n     * @method createPublicChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Create a public channel<br/>\n     *    Return a promise.\n     * @param {String} channelName The name of the channel\n     * @param {String} [channelTopic=\"\"] The topic of the channel\n     * @param {String} [category=\"\"] The category of the channel\n     * @return {Channel} Return the channel created or an error\n     */\n\n    this.createPublicChannel = this.createPublicChannel.bind(this);\n    /**\n     * @public\n     * @method createClosedChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Create a closed channel<br/>\n     *    Return a promise.\n     * @param {String} channelName The name of the channel\n     * @param {String} [channelTopic=\"\"] The topic of the channel\n     * @param {Number} [max_items=100] The maximum number of items to persist in the channel\n     * @param {String} [category=\"\"] The category of the channel\n     * @return {Channel} Return the channel created or an error\n     */\n\n    this.createClosedChannel = this.createClosedChannel.bind(this);\n    /**\n     * @public\n     * @method deleteChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Delete a channel<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.deleteChannel = this.deleteChannel.bind(this);\n    /**\n     * @public\n     * @method fetchChannelsByName\n     * @since 1.56\n     * @instance\n     * @description\n     *    Find channels by name  </br>\n     *    Return a promise.\n     * @param  {String} [name] search by channel names (case insensitive substring).\n     * @return {Object} Result of the find with\n     *      {Array}   found channels information\n     */\n\n    this.fetchChannelsByName = this.fetchChannelsByName.bind(this);\n    /**\n     * @public\n     * @method fetchChannelsByTopic\n     * @since 1.56\n     * @instance\n     * @description\n     *    Find channels by topic </br>\n     *    Return a promise.\n     * @param  {String} [topic] search by channel topics (case insensitive substring).\n     * @return {Object} Result of the find with\n     *      {Array}   found channels information\n     */\n\n    this.fetchChannelsByTopic = this.fetchChannelsByTopic.bind(this);\n    /**\n     * @public\n     * @method fetchChannelsByCategory\n     * @since 1.56\n     * @instance\n     * @description\n     *    Find channels by category </br>\n     *    Return a promise.\n     * @param  {String} [category] search by channel category (case insensitive substring).\n     * @return {Object} Result of the find with\n     *      {Array}   found channels information\n     */\n\n    this.fetchChannelsByCategory = this.fetchChannelsByCategory.bind(this);\n    /**\n     * @public\n     * @method fetchChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Get a channel<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.fetchChannel = this.fetchChannel.bind(this);\n    /**\n     * @public\n     * @method createItem\n     * @since 1.38\n     * @instance\n     * @description\n     *    Publish to a channel<br/>\n     *    Return a promise.\n     * @param {Channel} channel The channel to publish\n     * @param {String} message The message to send\n     * @param {String} [title=\"\"] An optional title\n     * @param {String} [url=\"\"] An optional link\n     * @param {String} [type=\"basic\"] An optional message content type (could be basic, markdown, html or data)\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.createItem = this.createItem.bind(this);\n    /**\n     * @public\n     * @method subscribeToChannelById\n     * @since 1.47\n     * @instance\n     * @description\n     *    Subscribe to a channel using its id<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.subscribeToChannelById = this.subscribeToChannelById.bind(this);\n    /**\n     * @public\n     * @method subscribeToChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Subscribe to a channel<br/>\n     *    Return a promise.\n     * @param {Channel} channel The channel object\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.subscribeToChannel = this.subscribeToChannel.bind(this);\n    /**\n     * @public\n     * @method unsubscribeFromChannelById\n     * @since 1.47\n     * @instance\n     * @description\n     *    UnsubscribeFromChannel by its id<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.unsubscribeFromChannelById = this.unsubscribeFromChannelById.bind(this);\n    /**\n     * @public\n     * @method unsubscribeFromChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Unsubscribe to a channel<br/>\n     *    Return a promise.\n     * @param {Channel} channel The channel object\n     * @return {Object} Nothing or an error object depending on the result\n     */\n\n    this.unsubscribeFromChannel = this.unsubscribeFromChannel.bind(this);\n    /**\n     * @public\n     * @method updateChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Update a channel<br/>\n     *      May be updated: name, topic, visibility, max_items and max_payload<br/>\n     *      Please put null to not update a property.<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {String} [channelTopic=\"\"] The topic of the channel\n     * @param {String} [visibility=public] public/company/closed group visibility for search\n     * @param {Number} [max_items=30] max # of items to persist in the channel\n     * @param {Number} [max_payload_size=60000] max # of items to persist in the channel\n     * @param {String} [channelName=\"\"] The name of the channel\n     * @param {String} [category=\"\"] The category of the channel\n     * @return {Channel} Return the channel created or an error\n     */\n\n    this.updateChannel = this.updateChannel.bind(this);\n    /**\n     * @public\n     * @method updateChannelVisibility\n     * @since 1.46\n     * @instance\n     * @description\n     *    Update a channel visibility<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {String} visibility  The new channel visibility (closed or company)\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.updateChannelVisibility = this.updateChannelVisibility.bind(this);\n    /**\n     * @public\n     * @method updateChannelVisibilityToPublic\n     * @since 1.47\n     * @instance\n     * @description\n     *    Set the channel visibility to company (visible for users in that company)<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.updateChannelVisibilityToPublic = this.updateChannelVisibilityToPublic.bind(this);\n    /**\n     * @public\n     * @method updateChannelVisibilityToClosed\n     * @since 1.47\n     * @instance\n     * @description\n     *    Set the channel visibility to closed (not visible by users)<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.updateChannelVisibilityToClosed = this.updateChannelVisibilityToClosed.bind(this);\n    /**\n     * @public\n     * @method updateChannelName\n     * @since 1.46\n     * @instance\n     * @description\n     *    Update a channel name<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {String} channelName The name of the channel\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.updateChannelName = this.updateChannelName.bind(this);\n    /**\n     * @public\n     * @method updateChannelTopic\n     * @since 1.46\n     * @instance\n     * @description\n     *    Update a channel topic<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {String} channelTopic The topic of the channel\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.updateChannelTopic = this.updateChannelTopic.bind(this);\n    /**\n     * @public\n     * @method updateChannelCategory\n     * @since 1.49\n     * @instance\n     * @description\n     *    Update a channel category<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {String} category The category of the channel\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.updateChannelCategory = this.updateChannelCategory.bind(this);\n    /**\n     * @public\n     * @method updateChannelAvatar\n     * @since 1.43\n     * @instance\n     * @description\n     *    Update a channel avatar<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {string} urlAvatar  The avatar Url.  It'll be resized to 512 pixels.\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.updateChannelAvatar = this.updateChannelAvatar.bind(this);\n    /**\n     * @public\n     * @method deleteChannelAvatar\n     * @since 1.43\n     * @instance\n     * @description\n     *    Delete a channel avatar<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Channel} Return the channel updated or an error\n     */\n\n    this.deleteChannelAvatar = this.deleteChannelAvatar.bind(this);\n    /**\n     * @public\n     * @method fetchUsers\n     * @since 1.38\n     * @instance\n     * @description\n     *    Get the users in a channel<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Object} [options={}] options (optionnal), with <br/>\n     *      {String=small, medium, full} [options.format=small] Allows to retrieve more or less user details in response.<br/>\n     *          <br/> - `small`: id type additionDate loginEmail displayName companyId companyName<br/>\n     *          <br/> - `medium`: id type additionDate loginEmail firstName lastName displayName country jid_im jid_tel companyId companyName<br/>\n     *          <br/> - `full`: all user fields + type<br/>\n     *      {String} [options.types] Allows to filter users list on the affiliation types provided in this option.<br/>\n     *      {Number} [options.limit=100] Allow to specify the number of users to retrieve.<br/>\n     *      {Number} [options.offset] Allow to specify the position of first user to retrieve (first user if not specified).<br/>\n     *          Warning: if offset > total, no results are returned.<br/>\n     *      {String} [options.sortField=displayName] Sort user list based on the given field.<br/>\n     *      {Number=-1,1} [options.sortOrder=1] Specify order when sorting user list.<br/>\n     * @return {Object[]} Return the users in an array or an error with<br/>\n     *       {String} data.id - user Rainbow Id<br/>\n     *       {type=owner,publisher,member} data.type - user channel affiliation<br/>\n     *       {Date} data.additionDate - user addition date<br/>\n     *       {String} data.loginEmail - user login<br/>\n     *       {String} data.displayName - user display name<br/>\n     *       {String} data.companyId - user rainbow company id<br/>\n     *       {String} data.companyName - user rainbow name\n     */\n\n    this.fetchUsers = this.fetchUsers.bind(this);\n    /**\n     * @public\n     * @method deleteAllUsersFromChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *    Remove all the users in a channel<br/>\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @return {Channel} The channel updated\n     */\n\n    this.deleteAllUsersFromChannel = this.deleteAllUsersFromChannel.bind(this);\n    /**\n     * @public\n     * @method updateChannelUsers\n     * @since 1.38\n     * @instance\n     * @description\n     *    Updates an array of users in a channel to userType<br/>You may add users by roles or remove them.\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Contact[]} users Array of users\n     * @param {String} [userType=member] Affiliation. Can be none (no more subscribed to the channel),owner,publisher or member}\n     * @return {Object[]} arrays or users added, removed and updated or an error object depending on the result<br/>\n     *      {String[]} removed - removed users ids\n     *      {String[]} updated - updated users ids\n     *      {String[]} added - added users\n     */\n\n    this.updateChannelUsers = this.updateChannelUsers.bind(this);\n    /**\n     * @public\n     * @method addMembersToChannel\n     * @since 1.47\n     * @instance\n     * @description\n     *   Add members to a channel\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Contact[]} users Array of users to add with a member affiliation\n     * @return {Object[]} arrays or users added\n     */\n\n    this.addMembersToChannel = this.addMembersToChannel.bind(this);\n    /**\n     * @public\n     * @method addPublishersToChannel\n     * @since 1.47\n     * @instance\n     * @description\n     *   Add publishers to a channel\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Contact[]} users Array of users to add with a publisher affiliation\n     * @return {Object[]} arrays or users added\n     */\n\n    this.addPublishersToChannel = this.addPublishersToChannel.bind(this);\n    /**\n     * @public\n     * @method addOwnersToChannel\n     * @since 1.38\n     * @instance\n     * @description\n     *   Add owners to a channel\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Contact[]} users Array of users to add with a owner affiliation\n     * @return {Object[]} arrays or users added\n     */\n\n    this.addOwnersToChannel = this.addOwnersToChannel.bind(this);\n    /**\n     * @public\n     * @method deleteUsersFromChannel\n     * @since 1.47\n     * @instance\n     * @description\n     *   Delete users from a channel\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Contact[]} users Array of users to remove\n     * @return {Object[]} arrays or users removed\n     */\n\n    this.deleteUsersFromChannel = this.deleteUsersFromChannel.bind(this);\n    /**\n     * @public\n     * @method fetchItems\n     * @since 1.38\n     * @instance\n     * @description\n     *    Updates an array of users in a channel to userType<br/>You may add users by roles or remove them.\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Number} [maxMessages=10] [optional] number of messages to get, 10 by default<br/>\n     * @param {Date} [before] [optional] - show items before a specific timestamp (ISO 8601 format)\n     * @param {Date} [after] [optional] - show items after a specific timestamp (ISO 8601 format)\n     * @return {Object[]} arrays of messages with for example for a message\n     *    \"id\": \"STRINGID\",\n     *    \"channelId\": \"CHANNELID\",\n     *    \"from\": \"EXAMPLECONTACT@opentouch.com\",\n     *    \"timestamp\": \"2019-02-08T01:43:53.353Z\",\n     *    \"type\": \"urn:xmpp:channels:basic\",\n     *    \"title\": \"title 7\", [optional]\n     *    \"message\": \"message 7\", [optional]\n     *    \"url\": \"http://google.com\" [optional]\n     */\n\n    this.fetchItems = this.fetchItems.bind(this);\n    /**\n     * @public\n     * @method deleteItem\n     * @since 1.38\n     * @instance\n     * @description\n     *    Updates an array of users in a channel to userType<br/>You may add users by roles or remove them.\n     *    Return a promise.\n     * @param {String} id The id of the channel\n     * @param {Number} [maxMessages=10] [optional] number of messages to get, 10 by default<br/>\n     * @param {Date} [before] [optional] - show items before a specific timestamp (ISO 8601 format)\n     * @param {Date} [after] [optional] - show items after a specific timestamp (ISO 8601 format)\n     * @return {Object[]} arrays of messages with for example for a message\n     *    \"id\": \"STRINGID\",\n     *    \"channelId\": \"CHANNELID\",\n     *    \"from\": \"EXAMPLECONTACT@opentouch.com\",\n     *    \"timestamp\": \"2019-02-08T01:43:53.353Z\",\n     *    \"type\": \"urn:xmpp:channels:basic\",\n     *    \"title\": \"title 7\", [optional]\n     *    \"message\": \"message 7\", [optional]\n     *    \"url\": \"http://google.com\" [optional]\n     */\n\n    this.deleteItem = this.deleteItem.bind(this);\n    /*\n     * EVENTS\n     * $rootScope.$on to be replaced with window.addEventListener in the future\n     */\n\n    $rootScope.$on('$destroy', $rootScope.$on('CHANNEL_MESSAGE_RECEIVED', function (event, messageType, message) {\n      return _this.onMessageReceived(event, messageType, message);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('CHANNEL_UPDATE_EVENT', function (event, updateType, id) {\n      return _this.onChannelUpdated(event, updateType, id);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('CHANNEL_USERS_UPDATE_EVENT', function (event, id, users) {\n      return _this.onChannelUsersUpdated(event, id, users);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('ON_UPDATE_CHANNEL_AVATAR', function (event, id) {\n      return _this.onChannelAvatarUpdated(event, id);\n    }));\n    $rootScope.$on('$destroy', $rootScope.$on('CHANNEL_USER_SUBSCRIPTION_EVENT', function (event, type, channelId, userId) {\n      return _this.onUserSubscriptionChange(event, type, channelId, userId);\n    }));\n  }\n  /* EVENT HANDLERS */\n\n\n  channelsService_createClass(ChannelsService, [{\n    key: \"onMessageReceived\",\n    value: function onMessageReceived(__event, messageType, message) {\n      var _this2 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var that = this;\n      $log.sdk(this.logService + '[ChannelsService] :: EVENT onMessageReceived');\n      that.fetchChannel(message.channelId).then(function (channel) {\n        if (messageType === 0) {\n          var sdkEvent = new CustomEvent(_this2.RAINBOW_ONCHANNELMESSAGERECEIVED, {\n            detail: {\n              channel: channel,\n              message: message\n            }\n          });\n          document.dispatchEvent(sdkEvent);\n        } else {\n          $log.sdk(_this2.logService + '[ChannelsService] :: EVENT onMessageReceived - retracted message');\n\n          var _sdkEvent = new CustomEvent(_this2.RAINBOW_ONCHANNELRETRACTMESSAGERECEIVED, {\n            detail: {\n              channel: channel,\n              message: message\n            }\n          });\n\n          document.dispatchEvent(_sdkEvent);\n        }\n      });\n    }\n  }, {\n    key: \"onChannelUpdated\",\n    value: function onChannelUpdated(event, updateType, id) {\n      var _this3 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var that = this;\n      $log.sdk(this.logService + '[ChannelsService] :: EVENT: onChannelUpdated(' + updateType + ') id:' + id);\n\n      if (updateType !== 3) {\n        that.fetchChannel(id).then(function (channel) {\n          var sdkEvent = new CustomEvent(_this3.RAINBOW_ONCHANNELUPDATED, {\n            detail: {\n              channel: channel,\n              updateType: updateType\n            }\n          });\n          document.dispatchEvent(sdkEvent);\n        });\n      } else {\n        var sdkEvent = new CustomEvent(this.RAINBOW_ONCHANNELDELETED, {\n          detail: id\n        });\n        document.dispatchEvent(sdkEvent);\n      }\n    }\n  }, {\n    key: \"onChannelUsersUpdated\",\n    value: function onChannelUsersUpdated(event, id, users) {\n      var _this4 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var that = this;\n      $log.sdk(this.logService + '[ChannelsService] :: EVENT onChannelUsersUpdated:' + id);\n      that.fetchChannel(id).then(function (channel) {\n        var sdkEvent = new CustomEvent(_this4.RAINBOW_ONCHANNELUSERSUPDATED, {\n          detail: {\n            channel: channel,\n            users: users\n          }\n        });\n        document.dispatchEvent(sdkEvent);\n      });\n    }\n  }, {\n    key: \"onChannelAvatarUpdated\",\n    value: function onChannelAvatarUpdated(event, id) {\n      var _this5 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var that = this;\n      that.fetchChannel(id).then(function (channel) {\n        $log.sdk(_this5.logService + '[ChannelsService] :: EVENT onChannelAvatarUpdated' + channel.id);\n        var sdkEvent = new CustomEvent(_this5.RAINBOW_ONCHANNELAVATARUPDATED, {\n          detail: channel\n        });\n        document.dispatchEvent(sdkEvent);\n      });\n    }\n  }, {\n    key: \"onUserSubscriptionChange\",\n    value: function onUserSubscriptionChange(__event, type, channelId, userId) {\n      var _this6 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var contactService = channelsService_contactService.get(this);\n\n      var that = this;\n      var channel = null;\n      that.fetchChannel(channelId).then(function (channelFound) {\n        channel = channelFound;\n        return contactService.getContactByDBId(userId, true);\n      }).then(function (user) {\n        user = user || userId;\n\n        if (type === 4) {\n          $log.sdk(_this6.logService + '[ChannelsService] :: EVENT onUserSubscriptionChange: user subscribed to a channel: ' + channelId);\n          var sdkEvent = new CustomEvent(_this6.RAINBOW_ONCHANNELUSERSUBSCRIBED, {\n            detail: {\n              channel: channel,\n              user: user\n            }\n          });\n          document.dispatchEvent(sdkEvent);\n        } else {\n          $log.sdk(_this6.logService + '[ChannelsService] :: EVENT onUserSubscriptionChange: user unsubscribed from a channel: ' + channelId);\n\n          var _sdkEvent2 = new CustomEvent(_this6.RAINBOW_ONCHANNELUSERUNSUBSCRIBED, {\n            detail: {\n              channel: channel,\n              user: user\n            }\n          });\n\n          document.dispatchEvent(_sdkEvent2);\n        }\n      });\n    }\n    /* CHANNELS SERVICE FUNCTIONS */\n\n  }, {\n    key: \"fetchMyChannels\",\n    value: function fetchMyChannels() {\n      var channelService = channelsService_channelService.get(this);\n\n      return channelService.getMyChannels();\n    }\n  }, {\n    key: \"createPublicChannel\",\n    value: function createPublicChannel(channelName) {\n      var _this7 = this;\n\n      var channelTopic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[createPublicChannel] :: Trying to create a new public channel');\n      return new Promise(function (resolve, reject) {\n        if (!channelName) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'channelName' is missing or empty\"\n          });\n        } else {\n          var mode = 'company_public';\n          channelService.createChannel(channelName, mode, channelTopic, category, false).then(function (channel) {\n            $log.sdk(_this7.logService + '[createPublicChannel] :: Public Channel created: ' + channel.id);\n            return resolve(channel);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"createClosedChannel\",\n    value: function createClosedChannel(channelName) {\n      var _this8 = this;\n\n      var channelTopic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var category = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[createClosedChannel] :: Trying to create a new closed channel');\n      return new Promise(function (resolve, reject) {\n        if (!channelName) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'channelName' is missing or empty\"\n          });\n        } else {\n          var mode = 'company_closed';\n          channelService.createChannel(channelName, mode, channelTopic, category, false).then(function (channel) {\n            $log.sdk(_this8.logService + '[createClosedChannel] :: created: ' + channel.id);\n            return resolve(channel);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteChannel\",\n    value: function deleteChannel(id) {\n      var _this9 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[deleteChannel] :: Trying to delete a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          channelService.deleteChannel(id).then(function () {\n            $log.sdk(_this9.logService + '[deleteChannel] :: deleted: ' + id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return err;\n          });\n        }\n      });\n    }\n  }, {\n    key: \"fetchChannelsByName\",\n    value: function fetchChannelsByName(name) {\n      var _this10 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      $log.sdk(this.logService + '[fetchChannelsByName] :: Trying to fetch channels by name');\n      return new Promise(function (resolve, reject) {\n        if (!name) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'name' is missing or empty\"\n          });\n        } else {\n          var filter = {};\n          filter.name = name;\n          channelService.findChannels(filter).then(function (channels) {\n            $log.sdk(_this10.logService + '[fetchChannelsByName] :: fetched: ' + channels.length);\n            return resolve(channels);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"fetchChannelsByTopic\",\n    value: function fetchChannelsByTopic(topic) {\n      var _this11 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      $log.sdk(this.logService + '[fetchChannelsByTopic] :: Trying to fetch channels by topic');\n      return new Promise(function (resolve, reject) {\n        if (!topic) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'topic' is missing or empty\"\n          });\n        } else {\n          var filter = {};\n          filter.topic = topic;\n          channelService.findChannels(filter).then(function (channels) {\n            $log.sdk(_this11.logService + '[fetchChannelsByTopic] :: fetched: ' + channels.length);\n            return resolve(channels);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"fetchChannelsByCategory\",\n    value: function fetchChannelsByCategory(category) {\n      var _this12 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      $log.sdk(this.logService + '[fetchChannelsByCategory] :: Trying to fetch channels by category');\n      return new Promise(function (resolve, reject) {\n        if (!category) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'category' is missing or empty\"\n          });\n        } else {\n          var filter = {};\n          filter.category = category;\n          channelService.findChannels(filter).then(function (channels) {\n            $log.sdk(_this12.logService + '[fetchChannelsByCategory] :: fetched: ' + channels.length);\n            return resolve(channels);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"fetchChannel\",\n    value: function fetchChannel(id) {\n      var _this13 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[fetchChannel] :: Trying to fetch a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          channelService.getChannel(id).then(function (channel) {\n            $log.sdk(_this13.logService + '[fetchChannel] :: fetched: ' + channel.id);\n            return resolve(channel);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"createItem\",\n    value: function createItem(channel, message, title, url, type) {\n      var _this14 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[createItem] :: Trying to create item');\n      return new Promise(function (resolve, reject) {\n        if (!channel) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'channel' is missing or empty\"\n          });\n        } else if (!message) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'message' is missing or empty\"\n          });\n        } else if (type && ['basic', 'markdown', 'html', 'data'].indexOf(type) === -1) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'type' could be 'basic', 'markdown', 'html' or 'data'\"\n          });\n        } else {\n          title = title || '';\n          url = url || '';\n          type = type ? 'urn:xmpp:channels:' + type : 'urn:xmpp:channels:basic';\n          channelService.publishToChannel(channel.id, null, type, message, title, url).then(function () {\n            $log.sdk(_this14.logService + '[createItem] :: created: ' + channel.id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"subscribeToChannelById\",\n    value: function subscribeToChannelById(id) {\n      var _this15 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[subscribeToChannelById] :: Trying to subscribe to a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or null\"\n          });\n        }\n\n        var channel = channelService.getChannelFromCache(id);\n\n        if (!channel) {\n          channelService.getChannel(id).then(function (channelFound) {\n            if (channelFound) {\n              channelService.subscribeToChannel(channelFound).then(function () {\n                $log.sdk(_this15.logService + '[subscribeToChannelById] :: subscribed: ' + id);\n                return resolve({\n                  code: SDK.OK,\n                  label: 'OK'\n                });\n              })[\"catch\"](function (err) {\n                return reject(err);\n              });\n            } else {\n              return reject({\n                code: SDK.ERRORBADREQUEST,\n                label: 'No channel found with id ' + id\n              });\n            }\n          });\n        } else {\n          channelService.subscribeToChannel(channel).then(function () {\n            $log.sdk(_this15.logService + '[subscribeToChannelById] :: subscribed: ' + id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"subscribeToChannel\",\n    value: function subscribeToChannel(channel) {\n      var _this16 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[subscribeToChannel] :: Trying to subscribe to a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!channel) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'channel' is missing or null\"\n          });\n        } else {\n          channelService.subscribeToChannel(channel).then(function () {\n            $log.sdk(_this16.logService + '[subscribeToChannel] :: subscribed: ' + channel.id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"unsubscribeFromChannelById\",\n    value: function unsubscribeFromChannelById(id) {\n      var _this17 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[unsubscribeFromChannelById] :: Trying to unsubscribe from a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {}\n\n        var channel = channelService.getChannelFromCache(id);\n\n        if (!channel) {\n          channelService.getChannel(id).then(function (channelFound) {\n            if (channelFound) {\n              channelService.unsubscribeToChannel(channelFound).then(function () {\n                $log.sdk(_this17.logService + '[unsubscribeFromChannelById] :: unsubscribed: ' + id);\n                return resolve({\n                  code: SDK.OK,\n                  label: 'OK'\n                });\n              })[\"catch\"](function (err) {\n                return reject(err);\n              });\n            } else {\n              return reject({\n                code: SDK.ERRORBADREQUEST,\n                label: 'No channel found with id ' + id\n              });\n            }\n          });\n        } else {\n          channelService.unsubscribeToChannel(channel).then(function () {\n            $log.sdk(_this17.logService + '[unsubscribeFromChannelById] :: unsubscribed: ' + id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"unsubscribeFromChannel\",\n    value: function unsubscribeFromChannel(channel) {\n      var _this18 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[unsubscribeFromChannel] :: Trying to unsubscribe from a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!channel) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'channel' is missing or null\"\n          });\n        } else {\n          channelService.unsubscribeToChannel(channel).then(function () {\n            $log.sdk(_this18.logService + '[unsubscribeFromChannel] :: unsubscribed: ' + channel.id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannel\",\n    value: function updateChannel(id, channelTopic, visibility, max_items, max_payload_size, channelName, category) {\n      var _this19 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannel] :: Trying to update a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var options = {};\n\n          if (channelTopic != null) {\n            options.topic = channelTopic;\n          }\n\n          if (visibility != null) {\n            options.mode = visibility === 'company' ? 'company_public' : 'company_closed';\n          }\n\n          if (max_items != null) {\n            options.max_items = max_items;\n          }\n\n          if (max_payload_size != null) {\n            options.max_payload_size = max_payload_size;\n          }\n\n          if (channelName != null) {\n            options.name = channelName;\n          }\n\n          if (category != null) {\n            options.cateogry = category;\n          }\n\n          channelService.updateChannel(id, options).then(function (channelUpdated) {\n            channelUpdated.visibility = options.visibility;\n            $log.sdk(_this19.logService + '[updateChannel] :: updated: ' + id);\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelVisibility\",\n    value: function updateChannelVisibility(id, visibility) {\n      var _this20 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelVisibility] :: Trying to update visibility of a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else if (!visibility) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'visibility' is missing or empty\"\n          });\n        } else {\n          var options = {};\n\n          if (visibility != null) {\n            options.mode = visibility === 'company' ? 'company_public' : 'company_closed';\n          }\n\n          channelService.updateChannel(id, options).then(function (channelUpdated) {\n            $log.sdk(_this20.logService + '[updateChannelVisibility] :: updated: ' + id); //channelUpdated.mode = options.mode; //hack expecting to be done in channelService\n\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelVisibilityToPublic\",\n    value: function updateChannelVisibilityToPublic(id) {\n      var _this21 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelVisibilityToPublic] :: Trying to update visibility to visible for a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var options = {\n            mode: 'company_public'\n          };\n          channelService.updateChannel(id, options).then(function (channelUpdated) {\n            $log.sdk(_this21.logService + '[updateChannelVisibilityToPublic] :: updated: ' + id); //channelUpdated.mode = options.mode; //hack expecting to be done in channelService\n\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelVisibilityToClosed\",\n    value: function updateChannelVisibilityToClosed(id) {\n      var _this22 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelVisibilityToClosed] :: Trying to update visibility to closed for a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var options = {\n            mode: 'company_closed'\n          };\n          channelService.updateChannel(id, options).then(function (channelUpdated) {\n            $log.sdk(_this22.logService + '[updateChannelVisibilityToClosed] :: updated: ' + id); //channelUpdated.mode = options.mode; //hack expecting to be done in channelService\n\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelName\",\n    value: function updateChannelName(id, channelName) {\n      var _this23 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelName] :: Trying to update the name of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var options = {};\n\n          if (channelName != null) {\n            options.name = channelName;\n          }\n\n          channelService.updateChannel(id, options).then(function (channelUpdated) {\n            $log.sdk(_this23.logService + '[updateChannelName] :: updated: ' + id);\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelTopic\",\n    value: function updateChannelTopic(id, channelTopic) {\n      var _this24 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelTopic] :: Try to update the topic of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var options = {};\n\n          if (channelTopic != null) {\n            options.topic = channelTopic;\n          }\n\n          channelService.updateChannel(id, options).then(function (channelUpdated) {\n            $log.sdk(_this24.logService + '[updateChannelTopic] :: updated: ' + id);\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelCategory\",\n    value: function updateChannelCategory(id, category) {\n      var _this25 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelCategory] :: Try to update the category of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var options = {};\n\n          if (category != null) {\n            options.category = category;\n          }\n\n          channelService.updateChannel(id, options).then(function (channelUpdated) {\n            $log.sdk(_this25.logService + '[updateChannelCategory] :: updated: ' + id);\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelAvatar\",\n    value: function updateChannelAvatar(id, urlAvatar) {\n      var _this26 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelAvatar] :: Try to update the avatar of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else if (!urlAvatar) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'urlAvatar' is missing or empty\"\n          });\n        } else {\n          channelService.uploadChannelAvatar(id, urlAvatar, 512).then(function () {\n            $log.sdk(_this26.logService + '[updateChannelAvatar] :: updated: ' + id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteChannelAvatar\",\n    value: function deleteChannelAvatar(id) {\n      var _this27 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[deleteChannelAvatar] :: Try to delete the avatar of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          channelService.deleteChannelAvatar(id).then(function () {\n            $log.sdk(_this27.logService + '[deleteChannelAvatar] :: updated: ' + id);\n            return resolve({\n              code: SDK.OK,\n              label: 'OK'\n            });\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"fetchUsers\",\n    value: function fetchUsers(id, options) {\n      var _this28 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[fetchUsers] :: Trying to fetch users of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          channelService.getChannelUsers(id, options).then(function (usersData) {\n            $log.sdk(_this28.logService + '[fetchUsers] :: got: ' + id);\n            return resolve(usersData.data);\n          })[\"catch\"](function (error) {\n            return reject(error);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteAllUsersFromChannel\",\n    value: function deleteAllUsersFromChannel(id) {\n      var _this29 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[deleteAllUsersFromChannel] :: Trying to get delete all users of a channel...');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          channelService.removeAllUsersFromChannel(id).then(function () {\n            return channelService.getChannel(id);\n          }).then(function (channelUpdated) {\n            $log.sdk(_this29.logService + '[deleteAllUsersFromChannel] :: deleted: ' + id);\n            return resolve(channelUpdated);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateChannelUsers\",\n    value: function updateChannelUsers(id, users, userType) {\n      var _this30 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[updateChannelUsers] :: Trying to update users of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          userType = userType || 'member';\n          channelService.updateChannelUsers(id, users, userType).then(function (usersData) {\n            $log.sdk(_this30.logService + '[updateChannelUsers] :: updated: ' + id);\n            return resolve(usersData);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"addMembersToChannel\",\n    value: function addMembersToChannel(id, users) {\n      var _this31 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[addMembersToChannel] :: Trying to add members to a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var userType = 'member';\n          channelService.updateChannelUsers(id, users, userType).then(function (usersData) {\n            $log.sdk(_this31.logService + '[addMembersToChannel] :: added: ' + id);\n            return resolve(usersData);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"addPublishersToChannel\",\n    value: function addPublishersToChannel(id, users) {\n      var _this32 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[addPublishersToChannel] :: Trying to add publishers to a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var userType = 'publisher';\n          channelService.updateChannelUsers(id, users, userType).then(function (usersData) {\n            $log.sdk(_this32.logService + '[addPublishersToChannel] :: added: ' + id);\n            return resolve(usersData);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"addOwnersToChannel\",\n    value: function addOwnersToChannel(id, users) {\n      var _this33 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[addOwnersToChannel] :: Trying to add owners to a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var userType = 'owner';\n          channelService.updateChannelUsers(id, users, userType).then(function (usersData) {\n            $log.sdk(_this33.logService + '[addOwnersToChannel] :: added: ' + id);\n            return resolve(usersData);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteUsersFromChannel\",\n    value: function deleteUsersFromChannel(id, users) {\n      var _this34 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[deleteUsersFromChannel] :: Trying to delete users from a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          var userType = 'none';\n          channelService.updateChannelUsers(id, users, userType).then(function (usersData) {\n            $log.sdk(_this34.logService + '[deleteUsersFromChannel] :: deleted: ' + id);\n            return resolve(usersData);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"fetchItems\",\n    value: function fetchItems(id, maxMessages, beforeDate, afterDate) {\n      var _this35 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[fetchItems] :: Try to fetch items of a channel');\n      return new Promise(function (resolve, reject) {\n        if (!id) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'id' is missing or empty\"\n          });\n        } else {\n          channelService.getChannelItems(id, maxMessages, beforeDate, afterDate).then(function (messages) {\n            $log.sdk(_this35.logService + '[fetchItems] :: fetched: ' + id);\n            return resolve(messages);\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"deleteItem\",\n    value: function deleteItem(channelId, itemId) {\n      var _this36 = this;\n\n      var $log = channelsService_$log.get(this);\n\n      var SDK = channelsService_SDK.get(this);\n\n      var channelService = channelsService_channelService.get(this);\n\n      $log.sdk(this.logService + '[deleteItem] :: Trying to delete an item.');\n      return new Promise(function (resolve, reject) {\n        if (!channelId) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'channelId' is missing or empty\"\n          });\n        } else if (!itemId) {\n          return reject({\n            code: SDK.ERRORBADREQUEST,\n            label: \"Parameter 'itemId' is missing or empty\"\n          });\n        } else {\n          channelService.deleteChannelItem(channelId, itemId).then(function () {\n            $log.sdk(_this36.logService + '[deleteItem] :: Item deleted: ' + itemId);\n            return resolve();\n          })[\"catch\"](function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n  }]);\n\n  return ChannelsService;\n}();\n// CONCATENATED MODULE: ./src/entrypoints/index.js\n//ORDERED VERSION\n// This file is a webpack entry point. Its job is to show webpack in which order to bundle the SDK files. The inspiration comes from gruntfile.js which was concatenating the minified version of SDK in this very order. Some files have been moved since, therefore the paths below can slightly differ.\n__webpack_require__(13);\n\n__webpack_require__(20);\n\n\nwindow['adapter'] = adapter_core_namespaceObject;\n\n__webpack_require__(21);\n\n__webpack_require__(22);\n\n__webpack_require__(151);\n\n__webpack_require__(152);\n\n__webpack_require__(153);\n\n__webpack_require__(154);\n\n\n\n\n\n\n\n\n\n\n\n // import { CpaasService } from '../cpaasService'; <<<<<< not sure if necessary\n\n\n\n\n\n\n\n__webpack_require__(155); // Add AngularJS Modules to the application\n\n\nangular.module('sdk').service('connectionService', ConnectionService);\nangular.module('sdk').service('presenceService', PresenceService);\nangular.module('sdk').service('userProfileService', UserProfileService);\nangular.module('sdk').service('contactsService', ContactsService);\nangular.module('sdk').service('pbxService', PbxService);\nangular.module('sdk').service('conversationsService', ConversationsService);\nangular.module('sdk').service('imService', ImService);\nangular.module('sdk').service('webRTCService', WebRTCService);\nangular.module('sdk').service('bubblesService', BubblesService);\nangular.module('sdk').service('groupsService', GroupsService);\nangular.module('sdk').service('callsLogService', CallsLogService); // angular.module('sdk').service('cpaasService', CpaasService);\n\nangular.module('sdk').service('favoritesService', FavoritesService);\nangular.module('sdk').service('filesStorageService', FilesStorageService);\nangular.module('sdk').service('capabilitiesService', CapabilitiesService);\nangular.module('sdk').service('adminService', AdminService);\nangular.module('sdk').service('channelsService', ChannelsService);\n\n//# sourceURL=webpack:///./src/entrypoints/index.js_+_31_modules?")}]);